From 6939d49bed0d994a785ff3ecbd385137f164a317 Mon Sep 17 00:00:00 2001
From: Khai Do <dovankhai@abc.com>
Date: Mon, 16 Dec 2024 14:48:25 +0700
Subject: [PATCH] Apply u-boot from TP-LINK to v1.1.4

---
 MAKEALL                                       |    5 +-
 Makefile                                      | 1588 +++++-
 board/ar7100/ap81/Makefile                    |   23 +
 board/ar7100/ap81/ap81.c                      |  150 +
 board/ar7100/ap81/config.mk                   |    5 +
 board/ar7100/ap81/flash.c                     |   29 +
 board/ar7100/ap81/u-boot.lds                  |   42 +
 board/ar7100/ap83/Makefile                    |   23 +
 board/ar7100/ap83/ap83.c                      |  153 +
 board/ar7100/ap83/config.mk                   |    6 +
 board/ar7100/ap83/flash.c                     |   29 +
 board/ar7100/ap83/u-boot.lds                  |   42 +
 board/ar7100/ap94/Makefile                    |   18 +
 board/ar7100/ap94/ap94.c                      |  106 +
 board/ar7100/ap94/ap94_pci.c                  |  432 ++
 board/ar7100/ap94/athrs26_phy.c               |  745 +++
 board/ar7100/ap94/athrs26_phy.h               |  116 +
 board/ar7100/ap94/config.mk                   |    5 +
 board/ar7100/ap94/lowlevel_init.S             |  217 +
 board/ar7100/ap94/u-boot.lds                  |   42 +
 board/ar7100/ap96/Makefile                    |   19 +
 board/ar7100/ap96/ap96.c                      |  201 +
 board/ar7100/ap96/config.mk                   |    5 +
 board/ar7100/ap96/u-boot.lds                  |   40 +
 board/ar7100/common/ar7100_flash.c            |  183 +
 board/ar7100/common/ar7100_flash.h            |   62 +
 board/ar7100/common/ar9100_pflash.c           |  325 ++
 board/ar7100/common/athr_phy.h                |   81 +
 board/ar7100/common/athrf1_phy.c              |  196 +
 board/ar7100/common/athrs16_phy.c             |  681 +++
 board/ar7100/common/athrs16_phy.h             |  105 +
 board/ar7100/common/athrs26_phy.c             |  828 +++
 board/ar7100/common/athrs26_phy.h             |  134 +
 .../g5_Plus1_2_29a_unmanaged_Atheros_v5.c     |  511 ++
 .../g5_Plus1_2_29b_unmanaged_Atheros_v5.c     |  511 ++
 .../g5_Plus1_2_31_unmanaged_Atheros_v3.c      |  521 ++
 .../g5_Plus1_2_31_unmanaged_Atheros_v4.c      |  509 ++
 .../g5e_Plus1_2_29a_unmanaged_Atheros_v3.c    |  513 ++
 board/ar7100/common/generic_i2c.c             |  461 ++
 board/ar7100/common/generic_i2c.h             |   84 +
 board/ar7100/common/generic_spi.c             |  355 ++
 board/ar7100/common/generic_spi.h             |   48 +
 board/ar7100/common/ipPhy.c                   |  843 +++
 board/ar7100/common/ipPhy.h                   |  172 +
 board/ar7100/common/lowlevel_init.S           |  246 +
 board/ar7100/common/lowlevel_init_ar9100.S    |  149 +
 board/ar7100/common/phy.h                     |   28 +
 board/ar7100/common/vsc73xx.c                 | 1208 +++++
 board/ar7100/common/vsc73xx.h                 |  168 +
 board/ar7100/common/vsc8601_phy.c             | 1226 +++++
 board/ar7100/common/vsc8601_phy.h             |   19 +
 board/ar7100/common/vsc_phy.c                 |   15 +
 board/ar7100/pb42/Makefile                    |   18 +
 board/ar7100/pb42/config.mk                   |    5 +
 board/ar7100/pb42/flash.c                     |   28 +
 board/ar7100/pb42/pb42.c                      |   72 +
 board/ar7100/pb42/u-boot.lds                  |   42 +
 board/ar7100/pb44/Makefile                    |   14 +
 board/ar7100/pb44/config.mk                   |   10 +
 board/ar7100/pb44/lowlevel_init.S             |  427 ++
 board/ar7100/pb44/pb44.c                      |  234 +
 board/ar7100/pb44/pb44_pci.c                  |  374 ++
 board/ar7100/pb44/u-boot-bootstrap.lds        |   61 +
 board/ar7100/pb44/u-boot.lds                  |   40 +
 board/ar7100/pb47/Makefile                    |   13 +
 board/ar7100/pb47/config.mk                   |    5 +
 board/ar7100/pb47/lowlevel_init.S             |  427 ++
 board/ar7100/pb47/pb47.c                      |  221 +
 board/ar7100/pb47/pb47_pci.c                  |  368 ++
 board/ar7100/pb47/u-boot.lds                  |   40 +
 board/ar7100/tb225/Makefile                   |   18 +
 board/ar7100/tb225/config.mk                  |    5 +
 board/ar7100/tb225/flash.c                    |   26 +
 board/ar7100/tb225/tb225.c                    |   55 +
 board/ar7100/tb225/u-boot.lds                 |   42 +
 board/ar7100/tb243/Makefile                   |   18 +
 board/ar7100/tb243/config.mk                  |    6 +
 board/ar7100/tb243/tb243.c                    |   83 +
 board/ar7100/tb243/u-boot.lds                 |   42 +
 board/ar7240/ap101-2.6.31/Makefile            |   18 +
 board/ar7240/ap101-2.6.31/ap101-2.6.31.c      |   71 +
 board/ar7240/ap101-2.6.31/config.mk           |    5 +
 board/ar7240/ap101-2.6.31/flash.c             |   35 +
 board/ar7240/ap101-2.6.31/u-boot.lds          |   42 +
 board/ar7240/ap101-small/Makefile             |   18 +
 board/ar7240/ap101-small/ap101-small.c        |   71 +
 board/ar7240/ap101-small/config.mk            |    5 +
 board/ar7240/ap101-small/flash.c              |   35 +
 board/ar7240/ap101-small/u-boot.lds           |   42 +
 board/ar7240/ap101/Makefile                   |   18 +
 board/ar7240/ap101/ap101.c                    |   71 +
 board/ar7240/ap101/config.mk                  |    5 +
 board/ar7240/ap101/flash.c                    |   35 +
 board/ar7240/ap101/u-boot.lds                 |   42 +
 board/ar7240/ap111-2.6.31/Makefile            |   18 +
 board/ar7240/ap111-2.6.31/ap111-2.6.31.c      |   71 +
 board/ar7240/ap111-2.6.31/config.mk           |    5 +
 board/ar7240/ap111-2.6.31/flash.c             |   35 +
 board/ar7240/ap111-2.6.31/u-boot.lds          |   42 +
 board/ar7240/ap111/Makefile                   |   18 +
 board/ar7240/ap111/ap111.c                    |   71 +
 board/ar7240/ap111/config.mk                  |    5 +
 board/ar7240/ap111/flash.c                    |   35 +
 board/ar7240/ap111/u-boot.lds                 |   42 +
 board/ar7240/ap120/Makefile                   |   68 +
 board/ar7240/ap120/ap120.c                    |  177 +
 board/ar7240/ap120/config.mk                  |   19 +
 board/ar7240/ap120/flash.c                    |   30 +
 board/ar7240/ap120/u-boot-bootstrap.lds       |   61 +
 board/ar7240/ap120/u-boot.lds                 |   42 +
 board/ar7240/ap121/Makefile                   |   22 +
 board/ar7240/ap121/ap121.c                    |  142 +
 board/ar7240/ap121/config.mk                  |   10 +
 board/ar7240/ap121/flash.c                    |   28 +
 board/ar7240/ap121/hornet_pll_init.S          |  375 ++
 board/ar7240/ap121/u-boot-bootstrap.lds       |   62 +
 board/ar7240/ap121/u-boot.lds                 |   42 +
 board/ar7240/ap123/Makefile                   |   68 +
 board/ar7240/ap123/ap123.c                    |  171 +
 board/ar7240/ap123/config.mk                  |   19 +
 board/ar7240/ap123/flash.c                    |   30 +
 board/ar7240/ap123/u-boot-bootstrap.lds       |   61 +
 board/ar7240/ap123/u-boot.lds                 |   42 +
 board/ar7240/ap91-2MB/Makefile                |   18 +
 board/ar7240/ap91-2MB/ap91-2MB.c              |   75 +
 board/ar7240/ap91-2MB/ar9285gpio.c            |  141 +
 board/ar7240/ap91-2MB/config.mk               |   10 +
 board/ar7240/ap91-2MB/flash.c                 |   28 +
 board/ar7240/ap91-2MB/u-boot-bootstrap.lds    |   62 +
 board/ar7240/ap91-2MB/u-boot.lds              |   42 +
 board/ar7240/ap91-2x8/Makefile                |   18 +
 board/ar7240/ap91-2x8/ap91-2x8.c              |   75 +
 board/ar7240/ap91-2x8/config.mk               |   10 +
 board/ar7240/ap91-2x8/flash.c                 |   28 +
 board/ar7240/ap91-2x8/u-boot-bootstrap.lds    |   62 +
 board/ar7240/ap91-2x8/u-boot.lds              |   42 +
 board/ar7240/ap91-router/Makefile             |   18 +
 board/ar7240/ap91-router/ap91-router.c        |   58 +
 board/ar7240/ap91-router/config.mk            |   13 +
 board/ar7240/ap91-router/flash.c              |   28 +
 board/ar7240/ap91-router/u-boot-bootstrap.lds |   62 +
 board/ar7240/ap91-router/u-boot.lds           |   42 +
 board/ar7240/ap91/Makefile                    |   18 +
 board/ar7240/ap91/ap91.c                      |   70 +
 board/ar7240/ap91/ar9285gpio.c                |  152 +
 board/ar7240/ap91/config.mk                   |    5 +
 board/ar7240/ap91/flash.c                     |   28 +
 board/ar7240/ap91/u-boot-bootstrap.lds        |   62 +
 board/ar7240/ap91/u-boot.lds                  |   42 +
 board/ar7240/ap93-hgw/Makefile                |   18 +
 board/ar7240/ap93-hgw/ap93-hgw.c              |   53 +
 board/ar7240/ap93-hgw/config.mk               |    5 +
 board/ar7240/ap93-hgw/flash.c                 |   28 +
 board/ar7240/ap93-hgw/u-boot.lds              |   42 +
 board/ar7240/ap93/Makefile                    |   18 +
 board/ar7240/ap93/ap93.c                      |   60 +
 board/ar7240/ap93/config.mk                   |    5 +
 board/ar7240/ap93/flash.c                     |   28 +
 board/ar7240/ap93/u-boot.lds                  |   42 +
 board/ar7240/ap98/Makefile                    |   18 +
 board/ar7240/ap98/ap98.c                      |   87 +
 board/ar7240/ap98/config.mk                   |   13 +
 board/ar7240/ap98/flash.c                     |   38 +
 board/ar7240/ap98/u-boot-bootstrap.lds        |   62 +
 board/ar7240/ap98/u-boot.lds                  |   42 +
 board/ar7240/ap99-2.6.31/Makefile             |   18 +
 board/ar7240/ap99-2.6.31/ap99-2.6.31.c        |   73 +
 board/ar7240/ap99-2.6.31/config.mk            |   11 +
 board/ar7240/ap99-2.6.31/flash.c              |   35 +
 board/ar7240/ap99-2.6.31/u-boot-bootstrap.lds |   62 +
 board/ar7240/ap99-2.6.31/u-boot.lds           |   42 +
 board/ar7240/ap99-hgw/Makefile                |   18 +
 board/ar7240/ap99-hgw/ap99-hgw.c              |   83 +
 board/ar7240/ap99-hgw/config.mk               |   13 +
 board/ar7240/ap99-hgw/flash.c                 |   38 +
 board/ar7240/ap99-hgw/u-boot-bootstrap.lds    |   62 +
 board/ar7240/ap99-hgw/u-boot.lds              |   42 +
 board/ar7240/ap99-ivi/Makefile                |   18 +
 board/ar7240/ap99-ivi/ap99-ivi.c              |   83 +
 board/ar7240/ap99-ivi/config.mk               |   13 +
 board/ar7240/ap99-ivi/flash.c                 |   38 +
 board/ar7240/ap99-ivi/u-boot-bootstrap.lds    |   61 +
 board/ar7240/ap99-ivi/u-boot.lds              |   42 +
 board/ar7240/ap99-small/Makefile              |   18 +
 board/ar7240/ap99-small/ap99-small.c          |   71 +
 board/ar7240/ap99-small/config.mk             |    5 +
 board/ar7240/ap99-small/flash.c               |   35 +
 board/ar7240/ap99-small/u-boot.lds            |   42 +
 board/ar7240/ap99-test/ap99-test.c            |   71 +
 board/ar7240/ap99/Makefile                    |   18 +
 board/ar7240/ap99/ap99.c                      |   86 +
 board/ar7240/ap99/config.mk                   |   13 +
 board/ar7240/ap99/flash.c                     |   38 +
 board/ar7240/ap99/u-boot-bootstrap.lds        |   62 +
 board/ar7240/ap99/u-boot.lds                  |   42 +
 board/ar7240/aph126/Makefile                  |   62 +
 board/ar7240/aph126/aph126.c                  |  163 +
 board/ar7240/aph126/config.mk                 |   19 +
 board/ar7240/aph126/flash.c                   |   28 +
 board/ar7240/aph126/u-boot-bootstrap.lds      |   61 +
 board/ar7240/aph126/u-boot.lds                |   42 +
 board/ar7240/aph128/Makefile                  |   62 +
 board/ar7240/aph128/aph128.c                  |  175 +
 board/ar7240/aph128/config.mk                 |   19 +
 board/ar7240/aph128/flash.c                   |   28 +
 board/ar7240/aph128/u-boot-bootstrap.lds      |   61 +
 board/ar7240/aph128/u-boot.lds                |   42 +
 board/ar7240/ar7240_emu/Makefile              |   18 +
 board/ar7240/ar7240_emu/ar7240_emu.c          |  144 +
 board/ar7240/ar7240_emu/config.mk             |    5 +
 board/ar7240/ar7240_emu/flash.c               |   28 +
 board/ar7240/ar7240_emu/u-boot.lds            |   42 +
 board/ar7240/common/ar7240_flash.c            |  249 +
 board/ar7240/common/ar7240_flash.h            |   64 +
 board/ar7240/common/ar7240_pci.c              |  584 ++
 board/ar7240/common/ar7240_s26_phy.c          |  916 ++++
 board/ar7240/common/ar7240_s26_phy.h          |  121 +
 board/ar7240/common/ath_nand.c                | 1597 ++++++
 board/ar7240/common/athr_s27_phy.c            |  878 +++
 board/ar7240/common/athr_s27_phy.h            |  208 +
 board/ar7240/common/athrs16_phy.c             |  687 +++
 board/ar7240/common/athrs16_phy.h             |  143 +
 board/ar7240/common/athrs17_phy.c             |  628 +++
 board/ar7240/common/athrs17_phy.h             |  109 +
 board/ar7240/common/athrs_vir_phy.c           |  123 +
 board/ar7240/common/athrsf1_phy.c             |  434 ++
 board/ar7240/common/athrsf1_phy.h             |   26 +
 board/ar7240/common/athrsf2_phy.c             |  377 ++
 board/ar7240/common/lowlevel_init.S           |  212 +
 board/ar7240/common/lowlevel_init_934x-1.1.S  |  405 ++
 board/ar7240/common/lowlevel_init_934x.S      |  180 +
 board/ar7240/common/phy.h                     |   19 +
 board/ar7240/cus136/Makefile                  |   18 +
 board/ar7240/cus136/config.mk                 |    5 +
 board/ar7240/cus136/cus136.c                  |   70 +
 board/ar7240/cus136/flash.c                   |   28 +
 board/ar7240/cus136/u-boot.lds                |   42 +
 board/ar7240/db12x-extender/Makefile          |   62 +
 board/ar7240/db12x-extender/config.mk         |   19 +
 board/ar7240/db12x-extender/db12x-extender.c  |  136 +
 board/ar7240/db12x-extender/flash.c           |   28 +
 .../db12x-extender/u-boot-bootstrap.lds       |   61 +
 board/ar7240/db12x-extender/u-boot.lds        |   42 +
 board/ar7240/db12x-hybrid/Makefile            |   68 +
 board/ar7240/db12x-hybrid/config.mk           |   19 +
 board/ar7240/db12x-hybrid/db12x-hybrid.c      |  170 +
 board/ar7240/db12x-hybrid/flash.c             |   30 +
 .../ar7240/db12x-hybrid/u-boot-bootstrap.lds  |   61 +
 board/ar7240/db12x-hybrid/u-boot.lds          |   42 +
 board/ar7240/db12x/Makefile                   |   78 +
 board/ar7240/db12x/config.mk                  |   35 +
 board/ar7240/db12x/db12x.c                    |  131 +
 board/ar7240/db12x/extra.c                    |   89 +
 board/ar7240/db12x/flash.c                    |   30 +
 board/ar7240/db12x/u-boot-bootstrap.lds       |   61 +
 board/ar7240/db12x/u-boot.lds                 |   42 +
 board/ar7240/dhp1565/Makefile                 |   62 +
 board/ar7240/dhp1565/config.mk                |   19 +
 board/ar7240/dhp1565/dhp1565.c                |  171 +
 board/ar7240/dhp1565/flash.c                  |   28 +
 board/ar7240/dhp1565/u-boot-bootstrap.lds     |   61 +
 board/ar7240/dhp1565/u-boot.lds               |   42 +
 board/ar7240/mi93/Makefile                    |   18 +
 board/ar7240/mi93/config.mk                   |    5 +
 board/ar7240/mi93/flash.c                     |   35 +
 board/ar7240/mi93/mi93.c                      |   67 +
 board/ar7240/mi93/u-boot.lds                  |   42 +
 board/ar7240/pb90/Makefile                    |   18 +
 board/ar7240/pb90/config.mk                   |    5 +
 board/ar7240/pb90/flash.c                     |   28 +
 board/ar7240/pb90/pb90.c                      |   59 +
 board/ar7240/pb90/u-boot.lds                  |   42 +
 board/ar7240/pb92/Makefile                    |   18 +
 board/ar7240/pb92/config.mk                   |   10 +
 board/ar7240/pb92/flash.c                     |   28 +
 board/ar7240/pb92/pb92.c                      |   75 +
 board/ar7240/pb92/u-boot-bootstrap.lds        |   62 +
 board/ar7240/pb92/u-boot.lds                  |   42 +
 board/ar7240/pb93/Makefile                    |   18 +
 board/ar7240/pb93/config.mk                   |    5 +
 board/ar7240/pb93/flash.c                     |   28 +
 board/ar7240/pb93/pb93.c                      |   72 +
 board/ar7240/pb93/u-boot.lds                  |   42 +
 board/ar7240/pb9x-2.6.31/Makefile             |   18 +
 board/ar7240/pb9x-2.6.31/config.mk            |   10 +
 board/ar7240/pb9x-2.6.31/flash.c              |   28 +
 board/ar7240/pb9x-2.6.31/pb9x-2.6.31.c        |   86 +
 board/ar7240/pb9x-2.6.31/u-boot-bootstrap.lds |   62 +
 board/ar7240/pb9x-2.6.31/u-boot.lds           |   42 +
 board/ar7240/pb9x-2x8/Makefile                |   18 +
 board/ar7240/pb9x-2x8/config.mk               |   10 +
 board/ar7240/pb9x-2x8/flash.c                 |   28 +
 board/ar7240/pb9x-2x8/pb9x-2x8.c              |   75 +
 board/ar7240/pb9x-2x8/u-boot-bootstrap.lds    |   62 +
 board/ar7240/pb9x-2x8/u-boot.lds              |   42 +
 board/ar7240/pb9x/Makefile                    |   18 +
 board/ar7240/pb9x/config.mk                   |   10 +
 board/ar7240/pb9x/flash.c                     |   28 +
 board/ar7240/pb9x/pb9x.c                      |   86 +
 board/ar7240/pb9x/u-boot-bootstrap.lds        |   62 +
 board/ar7240/pb9x/u-boot.lds                  |   42 +
 board/ar7240/reh132/Makefile                  |   62 +
 board/ar7240/reh132/config.mk                 |   19 +
 board/ar7240/reh132/flash.c                   |   28 +
 board/ar7240/reh132/reh132.c                  |  176 +
 board/ar7240/reh132/u-boot-bootstrap.lds      |   61 +
 board/ar7240/reh132/u-boot.lds                |   42 +
 board/ar7240/tb327/Makefile                   |   18 +
 board/ar7240/tb327/config.mk                  |    5 +
 board/ar7240/tb327/flash.c                    |   28 +
 board/ar7240/tb327/tb327.c                    |   52 +
 board/ar7240/tb327/u-boot.lds                 |   42 +
 board/ar7240/wasp_emu/Makefile                |   18 +
 board/ar7240/wasp_emu/config.mk               |    9 +
 board/ar7240/wasp_emu/flash.c                 |   28 +
 board/ar7240/wasp_emu/u-boot.lds              |   42 +
 board/ar7240/wasp_emu/wasp_emu.c              |   69 +
 board/ar7240/wrt54g/Makefile                  |   18 +
 board/ar7240/wrt54g/config.mk                 |    5 +
 board/ar7240/wrt54g/flash.c                   |   42 +
 board/ar7240/wrt54g/u-boot.lds                |   42 +
 board/ar7240/wrt54g/wrt54g.c                  |   73 +
 board/atheros/aph131/Makefile                 |   58 +
 board/atheros/aph131/aph131.c                 |  143 +
 board/atheros/aph131/config.mk                |   35 +
 board/atheros/aph131/extra.c                  |  103 +
 board/atheros/aph131/flash.c                  |   32 +
 board/atheros/aph131/u-boot-bootstrap.lds     |   61 +
 board/atheros/aph131/u-boot.lds               |   42 +
 board/atheros/board953x/Makefile              |   68 +
 board/atheros/board953x/board953x.c           |  145 +
 board/atheros/board953x/config.mk             |   23 +
 board/atheros/board953x/extra.c               |   55 +
 board/atheros/board953x/flash.c               |   30 +
 board/atheros/board953x/u-boot-bootstrap.lds  |   61 +
 board/atheros/board953x/u-boot.lds            |   42 +
 board/atheros/board955x/Makefile              |   97 +
 board/atheros/board955x/board955x.c           |  143 +
 board/atheros/board955x/config.mk             |   35 +
 board/atheros/board955x/extra.c               |  103 +
 board/atheros/board955x/flash.c               |   32 +
 board/atheros/board955x/u-boot-bootstrap.lds  |   61 +
 board/atheros/board955x/u-boot.lds            |   42 +
 board/atheros/common/953x.S                   |  151 +
 board/atheros/common/955x.S                   |  153 +
 board/atheros/common/ath_flash.c              |  323 ++
 board/atheros/common/ath_flash.h              |   53 +
 board/atheros/common/ath_nand.c               | 1593 ++++++
 board/atheros/common/ath_pci.c                |  421 ++
 board/atheros/common/athr_ar8033_phy.c        |  156 +
 board/atheros/common/athr_s27_phy.c           |  878 +++
 board/atheros/common/athr_s27_phy.h           |  208 +
 board/atheros/common/athrs17_lpbk.c           |  290 +
 board/atheros/common/athrs17_phy.c            |  713 +++
 board/atheros/common/athrs17_phy.h            |  555 ++
 board/atheros/common/athrs_ar8033_phy.h       |   87 +
 board/atheros/common/athrs_vir_phy.c          |  123 +
 board/atheros/common/athrsf1_phy.c            |  434 ++
 board/atheros/common/athrsf1_phy.h            |   26 +
 board/atheros/common/init-953x.c              |  381 ++
 board/atheros/common/init-955x.c              |  458 ++
 board/atheros/common/phy.h                    |   17 +
 board/atheros/common/qca-eth-953x.c           |  681 +++
 board/atheros/common/qca-eth-953x.h           |  349 ++
 board/atheros/common/qca-eth-953x_phy.h       |   73 +
 board/atheros/common/qca-eth-955x.c           |  977 ++++
 board/atheros/common/qca-eth-955x.h           |  407 ++
 board/atheros/common/qca-eth-955x_phy.h       |  102 +
 board/atheros/common/rgmii-cal-955x.c         |  600 +++
 board/atheros/common/serial.c                 |   88 +
 board/atheros/common/tap-953x.S               |  182 +
 board/atheros/common/tap-955x.S               |  184 +
 board/atheros/scoemu/Makefile                 |   73 +
 board/atheros/scoemu/config.mk                |   19 +
 board/atheros/scoemu/flash.c                  |   32 +
 board/atheros/scoemu/scoemu.c                 |  121 +
 board/atheros/scoemu/u-boot.lds               |   42 +
 board/atheros/tb6xx/Makefile                  |   73 +
 board/atheros/tb6xx/config.mk                 |   19 +
 board/atheros/tb6xx/flash.c                   |   32 +
 board/atheros/tb6xx/tb6xx.c                   |  126 +
 board/atheros/tb6xx/u-boot.lds                |   42 +
 board/mcc200/mcc200.c                         |   10 +
 common/Makefile                               |   42 +-
 common/cmd_bdr.c                              |  427 ++
 common/cmd_boot.c                             |   18 +-
 common/cmd_bootm.c                            |  189 +-
 common/cmd_ddr.c                              |  117 +
 common/cmd_elf.c                              |    6 +
 common/cmd_ethreg.c                           |  197 +
 common/cmd_flash.c                            |   55 +-
 common/cmd_load.c                             |    2 +
 common/cmd_mem.c                              |   94 +-
 common/cmd_mii.c                              |  273 +-
 common/cmd_nand.c                             |   42 +-
 common/cmd_net.c                              |   45 +-
 common/cmd_nvedit.c                           |    2 -
 common/cmd_pll.c                              |  309 ++
 common/command.c                              |    2 +
 common/env_common.c                           |    2 +-
 common/env_flash.c                            |    1 +
 common/main.c                                 |  195 +-
 config.mk                                     |   67 +-
 cpu/mips/Makefile                             |   10 +-
 cpu/mips/Makefile.orig                        |   45 +
 cpu/mips/ar7100/Makefile                      |   22 +
 cpu/mips/ar7100/ag7100.c                      |  823 +++
 cpu/mips/ar7100/ag7100.h                      |  239 +
 cpu/mips/ar7100/ag7100_phy.h                  |  257 +
 cpu/mips/ar7100/ar7100_serial.c               |  178 +
 cpu/mips/ar7100/meminit.c                     |  297 +
 cpu/mips/ar7240/Makefile                      |   61 +
 cpu/mips/ar7240/ag7240.c                      |  722 +++
 cpu/mips/ar7240/ag7240.h                      |  237 +
 cpu/mips/ar7240/ag7240_phy.h                  |   69 +
 cpu/mips/ar7240/ag934x.c                      |  877 +++
 cpu/mips/ar7240/ag934x.h                      |  242 +
 cpu/mips/ar7240/ag934x_phy.h                  |  117 +
 cpu/mips/ar7240/ar7240_serial.c               |  142 +
 cpu/mips/ar7240/hornet.h                      |   34 +
 cpu/mips/ar7240/hornet_ag7240.c               |  662 +++
 cpu/mips/ar7240/hornet_ddr_init.S             | 4690 ++++++++++++++++
 cpu/mips/ar7240/hornet_serial.c               |  216 +
 cpu/mips/ar7240/meminit.c                     |  558 ++
 cpu/mips/cache.S                              |  180 +-
 cpu/mips/config.mk                            |    8 +-
 cpu/mips/cpu.c                                |   61 +-
 cpu/mips/start.S                              | 4777 ++++++++++++++++-
 cpu/mips/start_bootstrap.S                    |  795 +++
 drivers/Makefile                              |    4 +-
 drivers/nand/nand_ids.c                       |    5 +-
 drivers/sk98lin/skge.c                        |    4 +-
 drivers/sk98lin/skgemib.c                     |    4 +-
 drivers/sk98lin/skproc.c                      |    4 +-
 examples/hello_world.s                        |  496 ++
 include/953x.h                                | 4472 +++++++++++++++
 include/955x.h                                | 3484 ++++++++++++
 include/LzmaWrapper.h                         |   36 +
 include/ar7100_soc.h                          |  603 +++
 include/ar7240_soc.h                          |  768 +++
 include/ar934x_soc.h                          | 3148 +++++++++++
 include/asm-mips/addrspace.h                  |    4 +-
 include/asm-mips/bitops.h                     |    3 +-
 include/atheros.h                             |  325 ++
 include/athversion.h                          |    8 +
 include/cmd_confdefs.h                        |   72 +-
 include/common.h                              |    9 +
 include/configs/ap101-2.6.31.h                |  243 +
 include/configs/ap101-small.h                 |  243 +
 include/configs/ap101.h                       |  243 +
 include/configs/ap111-2.6.31.h                |  244 +
 include/configs/ap111.h                       |  243 +
 include/configs/ap120.h                       |  476 ++
 include/configs/ap121.h                       |  335 ++
 include/configs/ap123.h                       |  474 ++
 include/configs/ap81.h                        |  191 +
 include/configs/ap83.h                        |  190 +
 include/configs/ap91-2MB.h                    |  214 +
 include/configs/ap91-2x8.h                    |  214 +
 include/configs/ap91-router.h                 |  195 +
 include/configs/ap91.h                        |  240 +
 include/configs/ap93-hgw.h                    |  172 +
 include/configs/ap93.h                        |  166 +
 include/configs/ap94.h                        |  182 +
 include/configs/ap94min.h                     |  167 +
 include/configs/ap96.h                        |  177 +
 include/configs/ap98.h                        |  278 +
 include/configs/ap99-2.6.31.h                 |  259 +
 include/configs/ap99-hgw.h                    |  274 +
 include/configs/ap99-ivi.h                    |  272 +
 include/configs/ap99-small.h                  |  247 +
 include/configs/ap99.h                        |  278 +
 include/configs/aph126.h                      |  421 ++
 include/configs/aph128.h                      |  421 ++
 include/configs/aph131.h                      |  321 ++
 include/configs/ar7100.h                      |  100 +
 include/configs/ar7240.h                      |  153 +
 include/configs/ar7240_emu.h                  |  177 +
 include/configs/board953x.h                   |  359 ++
 include/configs/board955x.h                   |  310 ++
 include/configs/cus136.h                      |  201 +
 include/configs/cus97.h                       |  147 +
 include/configs/db12x-extender.h              |  419 ++
 include/configs/db12x-hybrid.h                |  495 ++
 include/configs/db12x.h                       |  484 ++
 include/configs/dhp1565.h                     |  420 ++
 include/configs/hornet_emu.h                  |  255 +
 include/configs/mi93.h                        |  247 +
 include/configs/pb42.h                        |  115 +
 include/configs/pb44.h                        |  230 +
 include/configs/pb45.h                        |  162 +
 include/configs/pb47.h                        |  160 +
 include/configs/pb90.h                        |  167 +
 include/configs/pb92.h                        |  330 ++
 include/configs/pb93.h                        |  229 +
 include/configs/pb9x-2.6.31.h                 |  286 +
 include/configs/pb9x-2x8.h                    |  212 +
 include/configs/pb9x.h                        |  282 +
 include/configs/reh132.h                      |  424 ++
 include/configs/scoemu.h                      |  439 ++
 include/configs/tb225.h                       |   84 +
 include/configs/tb243.h                       |  124 +
 include/configs/tb327.h                       |  156 +
 include/configs/tb6xx.h                       |  342 ++
 include/configs/wah132.h                      |  422 ++
 include/configs/wasp_emu.h                    |  179 +
 include/configs/wrt54g.h                      |  173 +
 include/flash.h                               |    2 +
 include/hornet_soc.h                          |  293 +
 include/image.h                               |    1 +
 include/linux/mtd/mtd.h                       |    6 +-
 include/linux/mtd/nand.h                      |    6 +-
 include/nand.h                                |    6 +-
 include/net.h                                 |    8 +
 include/tpLinuxTag.h                          |   45 +
 include/version.h                             |    1 +
 lib_bootstrap/LzmaDecode.c                    |  622 +++
 lib_bootstrap/LzmaDecode.h                    |  113 +
 lib_bootstrap/LzmaTypes.h                     |   45 +
 lib_bootstrap/LzmaWrapper.c                   |  223 +
 lib_bootstrap/Makefile                        |   54 +
 lib_bootstrap/bootstrap_board.c               |  480 ++
 lib_bootstrap/console.c                       |  573 ++
 lib_bootstrap/crc32.c                         |  197 +
 lib_bootstrap/ctype.c                         |   56 +
 lib_bootstrap/devices.c                       |  216 +
 lib_bootstrap/display_options.c               |   67 +
 lib_bootstrap/lists.c                         |  734 +++
 lib_bootstrap/string.c                        |  578 ++
 lib_bootstrap/time.c                          |   99 +
 lib_bootstrap/vsprintf.c                      |  385 ++
 lib_generic/LzmaDecode.c                      |  600 +++
 lib_generic/LzmaDecode.h                      |  113 +
 lib_generic/LzmaTypes.h                       |   45 +
 lib_generic/LzmaWrapper.c                     |  197 +
 lib_generic/Makefile                          |   10 +-
 lib_generic/zlib.c                            |    2 +
 lib_mips/board.c                              |   48 +-
 lib_mips/mips_linux.c                         |   72 +
 mips_config.mk                                |    4 +
 net/Makefile                                  |    6 +-
 net/eth.c                                     |   14 +-
 net/net.c                                     |  103 +-
 net/tftp.c                                    |   19 +-
 tools/crc32.c                                 |    1 +
 tools/environment.c                           |    1 +
 tools/mkimage.c                               |    1 +
 547 files changed, 101276 insertions(+), 245 deletions(-)
 create mode 100644 board/ar7100/ap81/Makefile
 create mode 100644 board/ar7100/ap81/ap81.c
 create mode 100755 board/ar7100/ap81/config.mk
 create mode 100644 board/ar7100/ap81/flash.c
 create mode 100755 board/ar7100/ap81/u-boot.lds
 create mode 100644 board/ar7100/ap83/Makefile
 create mode 100644 board/ar7100/ap83/ap83.c
 create mode 100644 board/ar7100/ap83/config.mk
 create mode 100644 board/ar7100/ap83/flash.c
 create mode 100755 board/ar7100/ap83/u-boot.lds
 create mode 100644 board/ar7100/ap94/Makefile
 create mode 100644 board/ar7100/ap94/ap94.c
 create mode 100644 board/ar7100/ap94/ap94_pci.c
 create mode 100644 board/ar7100/ap94/athrs26_phy.c
 create mode 100644 board/ar7100/ap94/athrs26_phy.h
 create mode 100755 board/ar7100/ap94/config.mk
 create mode 100755 board/ar7100/ap94/lowlevel_init.S
 create mode 100755 board/ar7100/ap94/u-boot.lds
 create mode 100644 board/ar7100/ap96/Makefile
 create mode 100644 board/ar7100/ap96/ap96.c
 create mode 100644 board/ar7100/ap96/config.mk
 create mode 100755 board/ar7100/ap96/u-boot.lds
 create mode 100644 board/ar7100/common/ar7100_flash.c
 create mode 100644 board/ar7100/common/ar7100_flash.h
 create mode 100644 board/ar7100/common/ar9100_pflash.c
 create mode 100644 board/ar7100/common/athr_phy.h
 create mode 100644 board/ar7100/common/athrf1_phy.c
 create mode 100644 board/ar7100/common/athrs16_phy.c
 create mode 100644 board/ar7100/common/athrs16_phy.h
 create mode 100644 board/ar7100/common/athrs26_phy.c
 create mode 100644 board/ar7100/common/athrs26_phy.h
 create mode 100644 board/ar7100/common/g5_Plus1_2_29a_unmanaged_Atheros_v5.c
 create mode 100644 board/ar7100/common/g5_Plus1_2_29b_unmanaged_Atheros_v5.c
 create mode 100644 board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v3.c
 create mode 100644 board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v4.c
 create mode 100644 board/ar7100/common/g5e_Plus1_2_29a_unmanaged_Atheros_v3.c
 create mode 100644 board/ar7100/common/generic_i2c.c
 create mode 100644 board/ar7100/common/generic_i2c.h
 create mode 100644 board/ar7100/common/generic_spi.c
 create mode 100644 board/ar7100/common/generic_spi.h
 create mode 100644 board/ar7100/common/ipPhy.c
 create mode 100644 board/ar7100/common/ipPhy.h
 create mode 100644 board/ar7100/common/lowlevel_init.S
 create mode 100644 board/ar7100/common/lowlevel_init_ar9100.S
 create mode 100644 board/ar7100/common/phy.h
 create mode 100644 board/ar7100/common/vsc73xx.c
 create mode 100644 board/ar7100/common/vsc73xx.h
 create mode 100644 board/ar7100/common/vsc8601_phy.c
 create mode 100644 board/ar7100/common/vsc8601_phy.h
 create mode 100644 board/ar7100/common/vsc_phy.c
 create mode 100644 board/ar7100/pb42/Makefile
 create mode 100755 board/ar7100/pb42/config.mk
 create mode 100644 board/ar7100/pb42/flash.c
 create mode 100644 board/ar7100/pb42/pb42.c
 create mode 100755 board/ar7100/pb42/u-boot.lds
 create mode 100644 board/ar7100/pb44/Makefile
 create mode 100644 board/ar7100/pb44/config.mk
 create mode 100755 board/ar7100/pb44/lowlevel_init.S
 create mode 100644 board/ar7100/pb44/pb44.c
 create mode 100644 board/ar7100/pb44/pb44_pci.c
 create mode 100644 board/ar7100/pb44/u-boot-bootstrap.lds
 create mode 100644 board/ar7100/pb44/u-boot.lds
 create mode 100644 board/ar7100/pb47/Makefile
 create mode 100644 board/ar7100/pb47/config.mk
 create mode 100755 board/ar7100/pb47/lowlevel_init.S
 create mode 100644 board/ar7100/pb47/pb47.c
 create mode 100644 board/ar7100/pb47/pb47_pci.c
 create mode 100644 board/ar7100/pb47/u-boot.lds
 create mode 100644 board/ar7100/tb225/Makefile
 create mode 100644 board/ar7100/tb225/config.mk
 create mode 100644 board/ar7100/tb225/flash.c
 create mode 100644 board/ar7100/tb225/tb225.c
 create mode 100644 board/ar7100/tb225/u-boot.lds
 create mode 100644 board/ar7100/tb243/Makefile
 create mode 100755 board/ar7100/tb243/config.mk
 create mode 100644 board/ar7100/tb243/tb243.c
 create mode 100755 board/ar7100/tb243/u-boot.lds
 create mode 100644 board/ar7240/ap101-2.6.31/Makefile
 create mode 100644 board/ar7240/ap101-2.6.31/ap101-2.6.31.c
 create mode 100755 board/ar7240/ap101-2.6.31/config.mk
 create mode 100644 board/ar7240/ap101-2.6.31/flash.c
 create mode 100755 board/ar7240/ap101-2.6.31/u-boot.lds
 create mode 100644 board/ar7240/ap101-small/Makefile
 create mode 100644 board/ar7240/ap101-small/ap101-small.c
 create mode 100755 board/ar7240/ap101-small/config.mk
 create mode 100644 board/ar7240/ap101-small/flash.c
 create mode 100755 board/ar7240/ap101-small/u-boot.lds
 create mode 100644 board/ar7240/ap101/Makefile
 create mode 100644 board/ar7240/ap101/ap101.c
 create mode 100755 board/ar7240/ap101/config.mk
 create mode 100644 board/ar7240/ap101/flash.c
 create mode 100755 board/ar7240/ap101/u-boot.lds
 create mode 100644 board/ar7240/ap111-2.6.31/Makefile
 create mode 100644 board/ar7240/ap111-2.6.31/ap111-2.6.31.c
 create mode 100755 board/ar7240/ap111-2.6.31/config.mk
 create mode 100644 board/ar7240/ap111-2.6.31/flash.c
 create mode 100755 board/ar7240/ap111-2.6.31/u-boot.lds
 create mode 100644 board/ar7240/ap111/Makefile
 create mode 100644 board/ar7240/ap111/ap111.c
 create mode 100755 board/ar7240/ap111/config.mk
 create mode 100644 board/ar7240/ap111/flash.c
 create mode 100755 board/ar7240/ap111/u-boot.lds
 create mode 100644 board/ar7240/ap120/Makefile
 create mode 100644 board/ar7240/ap120/ap120.c
 create mode 100755 board/ar7240/ap120/config.mk
 create mode 100644 board/ar7240/ap120/flash.c
 create mode 100644 board/ar7240/ap120/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap120/u-boot.lds
 create mode 100644 board/ar7240/ap121/Makefile
 create mode 100644 board/ar7240/ap121/ap121.c
 create mode 100644 board/ar7240/ap121/config.mk
 create mode 100644 board/ar7240/ap121/flash.c
 create mode 100755 board/ar7240/ap121/hornet_pll_init.S
 create mode 100644 board/ar7240/ap121/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/ap121/u-boot.lds
 create mode 100644 board/ar7240/ap123/Makefile
 create mode 100644 board/ar7240/ap123/ap123.c
 create mode 100755 board/ar7240/ap123/config.mk
 create mode 100644 board/ar7240/ap123/flash.c
 create mode 100644 board/ar7240/ap123/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap123/u-boot.lds
 create mode 100644 board/ar7240/ap91-2MB/Makefile
 create mode 100644 board/ar7240/ap91-2MB/ap91-2MB.c
 create mode 100644 board/ar7240/ap91-2MB/ar9285gpio.c
 create mode 100755 board/ar7240/ap91-2MB/config.mk
 create mode 100644 board/ar7240/ap91-2MB/flash.c
 create mode 100644 board/ar7240/ap91-2MB/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap91-2MB/u-boot.lds
 create mode 100644 board/ar7240/ap91-2x8/Makefile
 create mode 100644 board/ar7240/ap91-2x8/ap91-2x8.c
 create mode 100755 board/ar7240/ap91-2x8/config.mk
 create mode 100644 board/ar7240/ap91-2x8/flash.c
 create mode 100644 board/ar7240/ap91-2x8/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap91-2x8/u-boot.lds
 create mode 100644 board/ar7240/ap91-router/Makefile
 create mode 100644 board/ar7240/ap91-router/ap91-router.c
 create mode 100755 board/ar7240/ap91-router/config.mk
 create mode 100644 board/ar7240/ap91-router/flash.c
 create mode 100644 board/ar7240/ap91-router/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap91-router/u-boot.lds
 create mode 100644 board/ar7240/ap91/Makefile
 create mode 100644 board/ar7240/ap91/ap91.c
 create mode 100644 board/ar7240/ap91/ar9285gpio.c
 create mode 100755 board/ar7240/ap91/config.mk
 create mode 100644 board/ar7240/ap91/flash.c
 create mode 100644 board/ar7240/ap91/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap91/u-boot.lds
 create mode 100644 board/ar7240/ap93-hgw/Makefile
 create mode 100644 board/ar7240/ap93-hgw/ap93-hgw.c
 create mode 100755 board/ar7240/ap93-hgw/config.mk
 create mode 100644 board/ar7240/ap93-hgw/flash.c
 create mode 100755 board/ar7240/ap93-hgw/u-boot.lds
 create mode 100644 board/ar7240/ap93/Makefile
 create mode 100644 board/ar7240/ap93/ap93.c
 create mode 100755 board/ar7240/ap93/config.mk
 create mode 100644 board/ar7240/ap93/flash.c
 create mode 100755 board/ar7240/ap93/u-boot.lds
 create mode 100644 board/ar7240/ap98/Makefile
 create mode 100644 board/ar7240/ap98/ap98.c
 create mode 100755 board/ar7240/ap98/config.mk
 create mode 100644 board/ar7240/ap98/flash.c
 create mode 100644 board/ar7240/ap98/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap98/u-boot.lds
 create mode 100644 board/ar7240/ap99-2.6.31/Makefile
 create mode 100644 board/ar7240/ap99-2.6.31/ap99-2.6.31.c
 create mode 100644 board/ar7240/ap99-2.6.31/config.mk
 create mode 100644 board/ar7240/ap99-2.6.31/flash.c
 create mode 100644 board/ar7240/ap99-2.6.31/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap99-2.6.31/u-boot.lds
 create mode 100644 board/ar7240/ap99-hgw/Makefile
 create mode 100644 board/ar7240/ap99-hgw/ap99-hgw.c
 create mode 100755 board/ar7240/ap99-hgw/config.mk
 create mode 100644 board/ar7240/ap99-hgw/flash.c
 create mode 100644 board/ar7240/ap99-hgw/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap99-hgw/u-boot.lds
 create mode 100644 board/ar7240/ap99-ivi/Makefile
 create mode 100644 board/ar7240/ap99-ivi/ap99-ivi.c
 create mode 100755 board/ar7240/ap99-ivi/config.mk
 create mode 100644 board/ar7240/ap99-ivi/flash.c
 create mode 100644 board/ar7240/ap99-ivi/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap99-ivi/u-boot.lds
 create mode 100644 board/ar7240/ap99-small/Makefile
 create mode 100644 board/ar7240/ap99-small/ap99-small.c
 create mode 100644 board/ar7240/ap99-small/config.mk
 create mode 100644 board/ar7240/ap99-small/flash.c
 create mode 100755 board/ar7240/ap99-small/u-boot.lds
 create mode 100644 board/ar7240/ap99-test/ap99-test.c
 create mode 100644 board/ar7240/ap99/Makefile
 create mode 100644 board/ar7240/ap99/ap99.c
 create mode 100755 board/ar7240/ap99/config.mk
 create mode 100644 board/ar7240/ap99/flash.c
 create mode 100644 board/ar7240/ap99/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap99/u-boot.lds
 create mode 100644 board/ar7240/aph126/Makefile
 create mode 100644 board/ar7240/aph126/aph126.c
 create mode 100644 board/ar7240/aph126/config.mk
 create mode 100644 board/ar7240/aph126/flash.c
 create mode 100644 board/ar7240/aph126/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/aph126/u-boot.lds
 create mode 100644 board/ar7240/aph128/Makefile
 create mode 100644 board/ar7240/aph128/aph128.c
 create mode 100644 board/ar7240/aph128/config.mk
 create mode 100644 board/ar7240/aph128/flash.c
 create mode 100644 board/ar7240/aph128/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/aph128/u-boot.lds
 create mode 100644 board/ar7240/ar7240_emu/Makefile
 create mode 100644 board/ar7240/ar7240_emu/ar7240_emu.c
 create mode 100755 board/ar7240/ar7240_emu/config.mk
 create mode 100644 board/ar7240/ar7240_emu/flash.c
 create mode 100755 board/ar7240/ar7240_emu/u-boot.lds
 create mode 100644 board/ar7240/common/ar7240_flash.c
 create mode 100644 board/ar7240/common/ar7240_flash.h
 create mode 100644 board/ar7240/common/ar7240_pci.c
 create mode 100644 board/ar7240/common/ar7240_s26_phy.c
 create mode 100644 board/ar7240/common/ar7240_s26_phy.h
 create mode 100644 board/ar7240/common/ath_nand.c
 create mode 100644 board/ar7240/common/athr_s27_phy.c
 create mode 100644 board/ar7240/common/athr_s27_phy.h
 create mode 100644 board/ar7240/common/athrs16_phy.c
 create mode 100644 board/ar7240/common/athrs16_phy.h
 create mode 100644 board/ar7240/common/athrs17_phy.c
 create mode 100644 board/ar7240/common/athrs17_phy.h
 create mode 100644 board/ar7240/common/athrs_vir_phy.c
 create mode 100644 board/ar7240/common/athrsf1_phy.c
 create mode 100644 board/ar7240/common/athrsf1_phy.h
 create mode 100644 board/ar7240/common/athrsf2_phy.c
 create mode 100644 board/ar7240/common/lowlevel_init.S
 create mode 100644 board/ar7240/common/lowlevel_init_934x-1.1.S
 create mode 100644 board/ar7240/common/lowlevel_init_934x.S
 create mode 100644 board/ar7240/common/phy.h
 create mode 100644 board/ar7240/cus136/Makefile
 create mode 100755 board/ar7240/cus136/config.mk
 create mode 100644 board/ar7240/cus136/cus136.c
 create mode 100644 board/ar7240/cus136/flash.c
 create mode 100755 board/ar7240/cus136/u-boot.lds
 create mode 100644 board/ar7240/db12x-extender/Makefile
 create mode 100644 board/ar7240/db12x-extender/config.mk
 create mode 100644 board/ar7240/db12x-extender/db12x-extender.c
 create mode 100644 board/ar7240/db12x-extender/flash.c
 create mode 100644 board/ar7240/db12x-extender/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/db12x-extender/u-boot.lds
 create mode 100644 board/ar7240/db12x-hybrid/Makefile
 create mode 100644 board/ar7240/db12x-hybrid/config.mk
 create mode 100644 board/ar7240/db12x-hybrid/db12x-hybrid.c
 create mode 100644 board/ar7240/db12x-hybrid/flash.c
 create mode 100644 board/ar7240/db12x-hybrid/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/db12x-hybrid/u-boot.lds
 create mode 100644 board/ar7240/db12x/Makefile
 create mode 100755 board/ar7240/db12x/config.mk
 create mode 100644 board/ar7240/db12x/db12x.c
 create mode 100644 board/ar7240/db12x/extra.c
 create mode 100644 board/ar7240/db12x/flash.c
 create mode 100644 board/ar7240/db12x/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/db12x/u-boot.lds
 create mode 100644 board/ar7240/dhp1565/Makefile
 create mode 100644 board/ar7240/dhp1565/config.mk
 create mode 100644 board/ar7240/dhp1565/dhp1565.c
 create mode 100644 board/ar7240/dhp1565/flash.c
 create mode 100644 board/ar7240/dhp1565/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/dhp1565/u-boot.lds
 create mode 100644 board/ar7240/mi93/Makefile
 create mode 100755 board/ar7240/mi93/config.mk
 create mode 100644 board/ar7240/mi93/flash.c
 create mode 100644 board/ar7240/mi93/mi93.c
 create mode 100755 board/ar7240/mi93/u-boot.lds
 create mode 100644 board/ar7240/pb90/Makefile
 create mode 100755 board/ar7240/pb90/config.mk
 create mode 100644 board/ar7240/pb90/flash.c
 create mode 100644 board/ar7240/pb90/pb90.c
 create mode 100755 board/ar7240/pb90/u-boot.lds
 create mode 100644 board/ar7240/pb92/Makefile
 create mode 100755 board/ar7240/pb92/config.mk
 create mode 100644 board/ar7240/pb92/flash.c
 create mode 100644 board/ar7240/pb92/pb92.c
 create mode 100644 board/ar7240/pb92/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/pb92/u-boot.lds
 create mode 100644 board/ar7240/pb93/Makefile
 create mode 100755 board/ar7240/pb93/config.mk
 create mode 100644 board/ar7240/pb93/flash.c
 create mode 100644 board/ar7240/pb93/pb93.c
 create mode 100755 board/ar7240/pb93/u-boot.lds
 create mode 100644 board/ar7240/pb9x-2.6.31/Makefile
 create mode 100644 board/ar7240/pb9x-2.6.31/config.mk
 create mode 100644 board/ar7240/pb9x-2.6.31/flash.c
 create mode 100644 board/ar7240/pb9x-2.6.31/pb9x-2.6.31.c
 create mode 100644 board/ar7240/pb9x-2.6.31/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/pb9x-2.6.31/u-boot.lds
 create mode 100644 board/ar7240/pb9x-2x8/Makefile
 create mode 100755 board/ar7240/pb9x-2x8/config.mk
 create mode 100644 board/ar7240/pb9x-2x8/flash.c
 create mode 100644 board/ar7240/pb9x-2x8/pb9x-2x8.c
 create mode 100644 board/ar7240/pb9x-2x8/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/pb9x-2x8/u-boot.lds
 create mode 100644 board/ar7240/pb9x/Makefile
 create mode 100644 board/ar7240/pb9x/config.mk
 create mode 100644 board/ar7240/pb9x/flash.c
 create mode 100644 board/ar7240/pb9x/pb9x.c
 create mode 100644 board/ar7240/pb9x/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/pb9x/u-boot.lds
 create mode 100644 board/ar7240/reh132/Makefile
 create mode 100644 board/ar7240/reh132/config.mk
 create mode 100644 board/ar7240/reh132/flash.c
 create mode 100644 board/ar7240/reh132/reh132.c
 create mode 100644 board/ar7240/reh132/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/reh132/u-boot.lds
 create mode 100644 board/ar7240/tb327/Makefile
 create mode 100755 board/ar7240/tb327/config.mk
 create mode 100644 board/ar7240/tb327/flash.c
 create mode 100644 board/ar7240/tb327/tb327.c
 create mode 100755 board/ar7240/tb327/u-boot.lds
 create mode 100644 board/ar7240/wasp_emu/Makefile
 create mode 100755 board/ar7240/wasp_emu/config.mk
 create mode 100644 board/ar7240/wasp_emu/flash.c
 create mode 100755 board/ar7240/wasp_emu/u-boot.lds
 create mode 100644 board/ar7240/wasp_emu/wasp_emu.c
 create mode 100644 board/ar7240/wrt54g/Makefile
 create mode 100755 board/ar7240/wrt54g/config.mk
 create mode 100644 board/ar7240/wrt54g/flash.c
 create mode 100755 board/ar7240/wrt54g/u-boot.lds
 create mode 100644 board/ar7240/wrt54g/wrt54g.c
 create mode 100644 board/atheros/aph131/Makefile
 create mode 100644 board/atheros/aph131/aph131.c
 create mode 100755 board/atheros/aph131/config.mk
 create mode 100644 board/atheros/aph131/extra.c
 create mode 100644 board/atheros/aph131/flash.c
 create mode 100644 board/atheros/aph131/u-boot-bootstrap.lds
 create mode 100755 board/atheros/aph131/u-boot.lds
 create mode 100755 board/atheros/board953x/Makefile
 create mode 100755 board/atheros/board953x/board953x.c
 create mode 100755 board/atheros/board953x/config.mk
 create mode 100755 board/atheros/board953x/extra.c
 create mode 100755 board/atheros/board953x/flash.c
 create mode 100755 board/atheros/board953x/u-boot-bootstrap.lds
 create mode 100755 board/atheros/board953x/u-boot.lds
 create mode 100644 board/atheros/board955x/Makefile
 create mode 100644 board/atheros/board955x/board955x.c
 create mode 100755 board/atheros/board955x/config.mk
 create mode 100644 board/atheros/board955x/extra.c
 create mode 100644 board/atheros/board955x/flash.c
 create mode 100644 board/atheros/board955x/u-boot-bootstrap.lds
 create mode 100755 board/atheros/board955x/u-boot.lds
 create mode 100755 board/atheros/common/953x.S
 create mode 100644 board/atheros/common/955x.S
 create mode 100644 board/atheros/common/ath_flash.c
 create mode 100644 board/atheros/common/ath_flash.h
 create mode 100644 board/atheros/common/ath_nand.c
 create mode 100644 board/atheros/common/ath_pci.c
 create mode 100644 board/atheros/common/athr_ar8033_phy.c
 create mode 100755 board/atheros/common/athr_s27_phy.c
 create mode 100755 board/atheros/common/athr_s27_phy.h
 create mode 100644 board/atheros/common/athrs17_lpbk.c
 create mode 100644 board/atheros/common/athrs17_phy.c
 create mode 100644 board/atheros/common/athrs17_phy.h
 create mode 100644 board/atheros/common/athrs_ar8033_phy.h
 create mode 100644 board/atheros/common/athrs_vir_phy.c
 create mode 100755 board/atheros/common/athrsf1_phy.c
 create mode 100755 board/atheros/common/athrsf1_phy.h
 create mode 100755 board/atheros/common/init-953x.c
 create mode 100644 board/atheros/common/init-955x.c
 create mode 100644 board/atheros/common/phy.h
 create mode 100755 board/atheros/common/qca-eth-953x.c
 create mode 100755 board/atheros/common/qca-eth-953x.h
 create mode 100755 board/atheros/common/qca-eth-953x_phy.h
 create mode 100644 board/atheros/common/qca-eth-955x.c
 create mode 100644 board/atheros/common/qca-eth-955x.h
 create mode 100644 board/atheros/common/qca-eth-955x_phy.h
 create mode 100644 board/atheros/common/rgmii-cal-955x.c
 create mode 100644 board/atheros/common/serial.c
 create mode 100755 board/atheros/common/tap-953x.S
 create mode 100644 board/atheros/common/tap-955x.S
 create mode 100644 board/atheros/scoemu/Makefile
 create mode 100755 board/atheros/scoemu/config.mk
 create mode 100644 board/atheros/scoemu/flash.c
 create mode 100644 board/atheros/scoemu/scoemu.c
 create mode 100755 board/atheros/scoemu/u-boot.lds
 create mode 100644 board/atheros/tb6xx/Makefile
 create mode 100755 board/atheros/tb6xx/config.mk
 create mode 100644 board/atheros/tb6xx/flash.c
 create mode 100644 board/atheros/tb6xx/tb6xx.c
 create mode 100755 board/atheros/tb6xx/u-boot.lds
 create mode 100644 common/cmd_bdr.c
 create mode 100644 common/cmd_ddr.c
 create mode 100644 common/cmd_ethreg.c
 create mode 100644 common/cmd_pll.c
 create mode 100644 cpu/mips/Makefile.orig
 create mode 100644 cpu/mips/ar7100/Makefile
 create mode 100644 cpu/mips/ar7100/ag7100.c
 create mode 100644 cpu/mips/ar7100/ag7100.h
 create mode 100644 cpu/mips/ar7100/ag7100_phy.h
 create mode 100644 cpu/mips/ar7100/ar7100_serial.c
 create mode 100644 cpu/mips/ar7100/meminit.c
 create mode 100644 cpu/mips/ar7240/Makefile
 create mode 100644 cpu/mips/ar7240/ag7240.c
 create mode 100644 cpu/mips/ar7240/ag7240.h
 create mode 100644 cpu/mips/ar7240/ag7240_phy.h
 create mode 100644 cpu/mips/ar7240/ag934x.c
 create mode 100644 cpu/mips/ar7240/ag934x.h
 create mode 100644 cpu/mips/ar7240/ag934x_phy.h
 create mode 100644 cpu/mips/ar7240/ar7240_serial.c
 create mode 100644 cpu/mips/ar7240/hornet.h
 create mode 100644 cpu/mips/ar7240/hornet_ag7240.c
 create mode 100755 cpu/mips/ar7240/hornet_ddr_init.S
 create mode 100644 cpu/mips/ar7240/hornet_serial.c
 create mode 100644 cpu/mips/ar7240/meminit.c
 create mode 100644 cpu/mips/start_bootstrap.S
 create mode 100644 examples/hello_world.s
 create mode 100755 include/953x.h
 create mode 100644 include/955x.h
 create mode 100644 include/LzmaWrapper.h
 create mode 100644 include/ar7100_soc.h
 create mode 100644 include/ar7240_soc.h
 create mode 100644 include/ar934x_soc.h
 create mode 100644 include/atheros.h
 create mode 100644 include/athversion.h
 create mode 100644 include/configs/ap101-2.6.31.h
 create mode 100644 include/configs/ap101-small.h
 create mode 100644 include/configs/ap101.h
 create mode 100644 include/configs/ap111-2.6.31.h
 create mode 100644 include/configs/ap111.h
 create mode 100644 include/configs/ap120.h
 create mode 100644 include/configs/ap121.h
 create mode 100644 include/configs/ap123.h
 create mode 100644 include/configs/ap81.h
 create mode 100644 include/configs/ap83.h
 create mode 100644 include/configs/ap91-2MB.h
 create mode 100644 include/configs/ap91-2x8.h
 create mode 100644 include/configs/ap91-router.h
 create mode 100644 include/configs/ap91.h
 create mode 100644 include/configs/ap93-hgw.h
 create mode 100644 include/configs/ap93.h
 create mode 100644 include/configs/ap94.h
 create mode 100644 include/configs/ap94min.h
 create mode 100644 include/configs/ap96.h
 create mode 100644 include/configs/ap98.h
 create mode 100644 include/configs/ap99-2.6.31.h
 create mode 100644 include/configs/ap99-hgw.h
 create mode 100644 include/configs/ap99-ivi.h
 create mode 100644 include/configs/ap99-small.h
 create mode 100644 include/configs/ap99.h
 create mode 100644 include/configs/aph126.h
 create mode 100644 include/configs/aph128.h
 create mode 100644 include/configs/aph131.h
 create mode 100644 include/configs/ar7100.h
 create mode 100644 include/configs/ar7240.h
 create mode 100644 include/configs/ar7240_emu.h
 create mode 100755 include/configs/board953x.h
 create mode 100644 include/configs/board955x.h
 create mode 100644 include/configs/cus136.h
 create mode 100644 include/configs/cus97.h
 create mode 100644 include/configs/db12x-extender.h
 create mode 100644 include/configs/db12x-hybrid.h
 create mode 100644 include/configs/db12x.h
 create mode 100644 include/configs/dhp1565.h
 create mode 100644 include/configs/hornet_emu.h
 create mode 100644 include/configs/mi93.h
 create mode 100644 include/configs/pb42.h
 create mode 100644 include/configs/pb44.h
 create mode 100644 include/configs/pb45.h
 create mode 100644 include/configs/pb47.h
 create mode 100644 include/configs/pb90.h
 create mode 100644 include/configs/pb92.h
 create mode 100644 include/configs/pb93.h
 create mode 100644 include/configs/pb9x-2.6.31.h
 create mode 100644 include/configs/pb9x-2x8.h
 create mode 100644 include/configs/pb9x.h
 create mode 100644 include/configs/reh132.h
 create mode 100644 include/configs/scoemu.h
 create mode 100644 include/configs/tb225.h
 create mode 100644 include/configs/tb243.h
 create mode 100644 include/configs/tb327.h
 create mode 100644 include/configs/tb6xx.h
 create mode 100644 include/configs/wah132.h
 create mode 100644 include/configs/wasp_emu.h
 create mode 100644 include/configs/wrt54g.h
 create mode 100644 include/hornet_soc.h
 create mode 100755 include/tpLinuxTag.h
 create mode 100644 lib_bootstrap/LzmaDecode.c
 create mode 100644 lib_bootstrap/LzmaDecode.h
 create mode 100644 lib_bootstrap/LzmaTypes.h
 create mode 100644 lib_bootstrap/LzmaWrapper.c
 create mode 100644 lib_bootstrap/Makefile
 create mode 100644 lib_bootstrap/bootstrap_board.c
 create mode 100644 lib_bootstrap/console.c
 create mode 100644 lib_bootstrap/crc32.c
 create mode 100644 lib_bootstrap/ctype.c
 create mode 100644 lib_bootstrap/devices.c
 create mode 100644 lib_bootstrap/display_options.c
 create mode 100644 lib_bootstrap/lists.c
 create mode 100644 lib_bootstrap/string.c
 create mode 100644 lib_bootstrap/time.c
 create mode 100644 lib_bootstrap/vsprintf.c
 create mode 100644 lib_generic/LzmaDecode.c
 create mode 100644 lib_generic/LzmaDecode.h
 create mode 100644 lib_generic/LzmaTypes.h
 create mode 100644 lib_generic/LzmaWrapper.c
 create mode 120000 tools/crc32.c
 create mode 120000 tools/environment.c

diff --git a/MAKEALL b/MAKEALL
index d388afa909..c3521e5021 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -228,7 +228,10 @@ LIST_mips5kc="purple"
 
 LIST_au1xx0="dbau1000 dbau1100 dbau1500 dbau1550 dbau1550_el"
 
-LIST_mips="${LIST_mips4kc} ${LIST_mips5kc} ${LIST_au1xx0}"
+LIST_mips24k="ar7100"
+
+LIST_mips="${LIST_mips4kc} ${LIST_mips5kc} ${LIST_au1xx0} ${LIST_MIPS24k}"
+
 
 #########################################################################
 ## MIPS Systems		(little endian)
diff --git a/Makefile b/Makefile
index beea5d2881..38dbb8abdf 100644
--- a/Makefile
+++ b/Makefile
@@ -49,6 +49,12 @@ VENDOR=
 TOPDIR	:= $(shell if [ "$$PWD" != "" ]; then echo $$PWD; else pwd; fi)
 export	TOPDIR
 
+BUILDVERSION=$(shell if test -e $(KERNELPATH)/ath_version.mk ; then cat $(KERNELPATH)/ath_version.mk | sed s/EXTRAVERSION=-LSDK-//g; fi)
+
+ifndef COMPRESSED_UBOOT
+COMPRESSED_UBOOT = 0
+endif 
+
 ifeq (include/config.mk,$(wildcard include/config.mk))
 # load ARCH, BOARD, and CPU configuration
 include include/config.mk
@@ -71,7 +77,7 @@ CROSS_COMPILE = i386-linux-
 endif
 endif
 ifeq ($(ARCH),mips)
-CROSS_COMPILE = mips_4KC-
+CROSS_COMPILE = mips-linux-
 endif
 ifeq ($(ARCH),nios)
 CROSS_COMPILE = nios-elf-
@@ -99,8 +105,12 @@ include $(TOPDIR)/config.mk
 
 #########################################################################
 # U-Boot objects....order is important (i.e. start must be first)
-
 OBJS  = cpu/$(CPU)/start.o
+
+ifeq ($(COMPRESSED_UBOOT),1)
+OBJS_BOOTSTRAP  = cpu/$(CPU)/start_bootstrap.o
+endif
+
 ifeq ($(CPU),i386)
 OBJS += cpu/$(CPU)/start16.o
 OBJS += cpu/$(CPU)/reset.o
@@ -120,25 +130,48 @@ OBJS += cpu/$(CPU)/cplbhdlr.o	cpu/$(CPU)/cplbmgr.o	cpu/$(CPU)/flush.o
 endif
 
 LIBS  = lib_generic/libgeneric.a
+LIBS += common/libcommon.a
 LIBS += board/$(BOARDDIR)/lib$(BOARD).a
 LIBS += cpu/$(CPU)/lib$(CPU).a
 ifdef SOC
 LIBS += cpu/$(CPU)/$(SOC)/lib$(SOC).a
 endif
 LIBS += lib_$(ARCH)/lib$(ARCH).a
-LIBS += fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a \
-	fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a
+
+#ifeq ($(KERNELVER),2.6.31)
+LIBS += drivers/libdrivers.a
+#endif
+#ifeq ($(COMPRESSED_UBOOT),0)
+#LIBS += fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a \
+#	fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a
+#LIBS += disk/libdisk.a
+#LIBS += dtt/libdtt.a
+#ifneq ($(KERNELVER),2.6.31)
+#LIBS += drivers/libdrivers.a
+#endif
+#LIBS += drivers/sk98lin/libsk98lin.a
+#endif
+
 LIBS += net/libnet.a
-LIBS += disk/libdisk.a
 LIBS += rtc/librtc.a
-LIBS += dtt/libdtt.a
-LIBS += drivers/libdrivers.a
-LIBS += drivers/sk98lin/libsk98lin.a
-LIBS += post/libpost.a post/cpu/libcpu.a
-LIBS += common/libcommon.a
+#LIBS += post/libpost.a post/cpu/libcpu.a
 LIBS += $(BOARDLIBS)
+
+ifeq ($(COMPRESSED_UBOOT),1)
+LIBS_BOOTSTRAP = lib_bootstrap/libbootstrap.a 
+#LIBS_BOOTSTRAP += lib_$(CPU)/lib$(CPU).a
+LIBS_BOOTSTRAP += board/$(BOARDDIR)/lib$(BOARD).a 
+LIBS_BOOTSTRAP += cpu/$(CPU)/lib$(CPU).a
+ifneq ($(SOC),)
+LIBS_BOOTSTRAP += cpu/$(CPU)/$(SOC)/lib$(SOC).a
+endif
+endif
 .PHONY : $(LIBS)
 
+ifeq ($(COMPRESSED_UBOOT),1)
+.PHONY : $(LIBS_BOOTSTRAP)
+endif
+
 # Add GCC lib
 PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc
 
@@ -146,7 +179,6 @@ PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -
 # The "tools" are needed early, so put this first
 # Don't include stuff already done in $(LIBS)
 SUBDIRS	= tools \
-	  examples \
 	  post \
 	  post/cpu
 .PHONY : $(SUBDIRS)
@@ -156,7 +188,11 @@ SUBDIRS	= tools \
 
 ALL = u-boot.srec u-boot.bin System.map
 
+ifeq ($(COMPRESSED_UBOOT),1)
+all:		$(ALL) tuboot.bin
+else
 all:		$(ALL)
+endif
 
 u-boot.hex:	u-boot
 		$(OBJCOPY) ${OBJCFLAGS} -O ihex $< $@
@@ -179,7 +215,7 @@ u-boot.dis:	u-boot
 
 u-boot:		depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)
 		UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) |sed  -n -e 's/.*\(__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
-		$(LD) $(LDFLAGS) $$UNDEF_SYM $(OBJS) \
+		$(LD) $(LDFLAGS) $$UNDEF_SYM $(OBJS) $(BOARD_EXTRA_OBJS) \
 			--start-group $(LIBS) --end-group $(PLATFORM_LIBS) \
 			-Map u-boot.map -o u-boot
 
@@ -189,6 +225,36 @@ $(LIBS):
 $(SUBDIRS):
 		$(MAKE) -C $@ all
 
+ifeq ($(COMPRESSED_UBOOT),1)
+
+#LZMA = $(BUILD_DIR)/util/lzma
+LZMA = $(TOPDIR)/../../../util/lzma/bin/lzma
+
+tuboot.bin:	System.map bootstrap.bin u-boot.lzimg	
+		@cat bootstrap.bin > $@
+		@cat u-boot.lzimg >> $@
+
+u-boot.lzimg: $(obj)u-boot.bin System.map 
+		@rm -rf u-boot.bin.lzma
+		@$(LZMA) --best --keep $(obj)u-boot.bin
+		@./tools/mkimage -A mips -T firmware -C lzma \
+		-a 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-n 'u-boot image' -d $(obj)u-boot.bin.lzma $@
+
+bootstrap.bin:	bootstrap
+		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+bootstrap:	depend version $(SUBDIRS) $(OBJS_BOOTSTRAP) $(LIBS_BOOTSTRAP) $(LDSCRIPT_BOOTSTRAP)
+		UNDEF_SYM=`$(OBJDUMP) -x $(LIBS_BOOTSTRAP) |sed  -n -e 's/.*\(__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
+		$(LD) $(LDFLAGS_BOOTSTRAP) $$UNDEF_SYM $(OBJS_BOOTSTRAP) \
+			--start-group $(LIBS_BOOTSTRAP) --end-group $(PLATFORM_LIBS) \
+			-Map bootstrap.map -o bootstrap
+
+$(LIBS_BOOTSTRAP):
+		$(MAKE) -C `dirname $@`
+endif
+
 version:
 		@echo -n "#define U_BOOT_VERSION \"U-Boot " > $(VERSION_FILE); \
 		echo -n "$(U_BOOT_VERSION)" >> $(VERSION_FILE); \
@@ -1799,6 +1865,1457 @@ pb1000_config		: 	unconfig
 purple_config :		unconfig
 	@./mkconfig $(@:_config=) mips mips purple
 
+#########################################################################
+## MIPS32 AR7100 (24K)
+#########################################################################
+tb225_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a tb225 mips mips tb225 ar7100 ar7100
+
+pb42_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a pb42 mips mips pb42 ar7100 ar7100
+
+tb243_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@echo "#define CONFIG_AR9100 1" >>include/config.h
+	@./mkconfig -a tb243 mips mips tb243 ar7100 ar7100
+
+ap83_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@echo "#define CONFIG_AR9100 1" >>include/config.h
+	@./mkconfig -a ap83 mips mips ap83 ar7100 ar7100
+
+ap81_config		: 	unconfig
+	@ >include/config.h
+	@echo '#ifndef _INCLUDE_CONFIG_H' >>include/config.h
+	@echo '#define _INCLUDE_CONFIG_H' >>include/config.h
+	@echo '#define CONFIG_AR7100 1' >>include/config.h
+	@echo '#define CONFIG_AR9100 1' >>include/config.h
+
+ifeq ($(CONFIG_AP81_CARRIER_CUS109), 1)
+	@echo '#define CONFIG_AP81_CUS109 1' >>include/config.h
+endif
+ifeq ($(BUILD_CONFIG), _4m)
+ifeq ($(CONFIG_CARRIER_4MB), 1)
+	@echo '#define BUILD_CONFIG_OVERRIDE 1' >>include/config.h
+	@echo '#define CFG_FLASH_SIZE 0x00400000' >>include/config.h
+	@echo '#define CONFIG_BOOTARGS "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7100-nor0:256k(u-boot),128k(u-boot-env),2112k(rootfs),384k(config),1024k(uImage),64k(nvram),64k(lang),64k(ART)"' >>include/config.h
+	@echo '#define MTDPARTS_DEFAULT "mtdparts=ar7100-nor0:256k(u-boot),128k(u-boot-env),2112k(rootfs),384k(config),1024k(uImage),64k(nvram),64k(lang),64k(ART)"' >>include/config.h
+	@echo '#define CONFIG_BOOTCOMMAND "bootm 0xbf300000"' >>include/config.h
+else
+	@echo '#define BUILD_CONFIG_OVERRIDE 1' >>include/config.h
+	@echo '#define CFG_FLASH_SIZE 0x00400000' >>include/config.h
+	@echo '#define CONFIG_BOOTARGS "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7100-nor0:256k(u-boot),64k(u-boot-env),2688k(rootfs),1024k(uImage),64k(ART)"' >>include/config.h
+	@echo '#define MTDPARTS_DEFAULT "mtdparts=ar7100-nor0:256k(u-boot),64k(u-boot-env),2688k(rootfs),1024k(uImage),64k(ART)"' >>include/config.h
+	@echo '#define CONFIG_BOOTCOMMAND "bootm 0xbf300000"' >>include/config.h
+endif
+endif
+	@echo '#endif /* _INCLUDE_CONFIG_H */' >>include/config.h
+	@./mkconfig -a ap81 mips mips ap81 ar7100 ar7100
+
+ap94_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a ap94 mips mips ap94 ar7100 ar7100
+
+ap94min_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a ap94min mips mips ap94 ar7100 ar7100
+
+pb44_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a pb44 mips mips pb44 ar7100 ar7100
+
+pb45_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a pb45 mips mips pb45 ar7100 ar7100
+
+pb47_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a pb47 mips mips pb47 ar7100 ar7100
+
+ap96_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@./mkconfig -a ap96 mips mips ap96 ar7100 ar7100
+
+cus97_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7100 1" >>include/config.h
+	@echo "#define CONFIG_AR9100 1" >>include/config.h
+	@./mkconfig -a cus97 mips mips cus97 ar7100 ar7100
+ar7240_emu_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ar7240_emu mips mips ar7240_emu ar7240 ar7240
+
+wasp_emu_config			: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+	@./mkconfig -a wasp_emu mips mips wasp_emu ar7240 ar7240
+
+db12x_config			: 	unconfig
+	@ >include/config.h
+
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f2e)
+	@echo '#define CONFIG_F2E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+ifneq ($(findstring cus227,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_CUS227 1' >>include/config.h
+endif
+	@echo "#define BUILD_VERSION "\"$(BUILDVERSION)\" >>include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1' >>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT  1' >>include/config.h
+endif
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+ifeq ($(DB12X_P2P_ENV), 1)
+        @echo "#define CONFIG_DB12X_P2P 1" >>include/config.h
+endif
+	@./mkconfig -a db12x mips mips db12x ar7240 ar7240
+
+#board953x_config		:	unconfig
+ap143_config	board953x_config	:	unconfig
+	@ >include/config.h
+	@echo '#define CONFIG_ATHEROS		1'	>include/config.h
+	@echo '#define CONFIG_MACH_QCA953x	1'	>>include/config.h
+	@echo '#define CFG_INIT_STACK_IN_SRAM	1'	>>include/config.h
+	@echo '#define CONFIG_'`echo $(CFG_BOARD_TYPE) | tr [a-z] [A-Z] | sed s/-/_/g`'	1' >>include/config.h
+	@echo '#define __CONFIG_BOARD_NAME $(CFG_BOARD_TYPE)' >>include/config.h
+	@echo '#define CONFIG_BOARD_NAME "$(CFG_BOARD_TYPE)"' >>include/config.h
+	@echo "#define BUILD_VERSION "\"$(BUILDVERSION)\" >>include/config.h
+
+ifdef pll
+	@echo '#define CFG_PLL_FREQ		$(pll)'	>>include/config.h
+else
+	@echo '#define CFG_PLL_FREQ		CFG_PLL_550_400_200'	>>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS 1' >>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS 2' >>include/config.h
+endif
+
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+
+ifeq ($(FW_RECOVERY), y)
+	@echo '#define FW_RECOVERY 1' >>include/config.h
+	@echo '#define FW_RECOVERY_DEV "$(FW_RECOVERY_DEV)"' >>include/config.h
+	@echo "#define FW_RECOVERY_INPUT_BUTTON_GPIO $(FW_INPUT_BUTTON_GPIO)" >>include/config.h
+	@echo "#define FW_RECOVERY_OUTPUT_LED_GPIO $(FW_OUTPUT_LED_GPIO)" >>include/config.h
+	@echo "#define FW_RECOVERY_OUTPUT_LED_ON $(FW_OUTPUT_LED_ON)" >>include/config.h
+endif
+	@./mkconfig -a board953x mips mips board953x atheros
+
+ap120_config			: 	unconfig
+	@ >include/config.h
+
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f2e)
+	@echo '#define CONFIG_F2E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1' >>include/config.h
+endif
+ifeq ($(or $(BOOT_FROM_NAND),$(ATH_DUAL_FLASH)),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+endif
+	@./mkconfig -a ap120 mips mips ap120 ar7240 ar7240
+
+db12x-lte_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f2e)
+	@echo '#define CONFIG_F2E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef BOOT_FROM_NAND
+	@echo "#define CONFIG_ATH_NAND_FL 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+#
+# U-Boot from spi flash. Kernel & FS in NAND
+#
+ifdef ATH_DUAL_FLASH
+	@echo "#define ATH_DUAL_FLASH 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+	@./mkconfig -a db12x mips mips db12x ar7240 ar7240
+
+db12x-hgw_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f2e)
+	@echo '#define CONFIG_F2E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+ifneq ($(findstring db12x-hgw,$(BOARD_TYPE)),)
+	@echo '#define CONFIG_DB12X-HGW 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1' >>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+endif
+#
+# U-Boot from spi flash. Kernel & FS in NAND
+#
+ifdef ATH_DUAL_FLASH
+	@echo "#define ATH_DUAL_FLASH 1" >>include/config.h
+endif
+
+	@./mkconfig -a db12x-hybrid mips mips db12x-hybrid ar7240 ar7240
+
+zte-mf28l_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f2e)
+	@echo '#define CONFIG_F2E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1' >>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+endif
+
+	@./mkconfig -a db12x mips mips db12x ar7240 ar7240
+
+
+reh132_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef BOOT_FROM_NAND
+	@echo "#define CONFIG_ATH_NAND_FL 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+	@./mkconfig -a reh132 mips mips reh132 ar7240 ar7240
+
+db12x-hybrid_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef BOOT_FROM_NAND
+	@echo "#define CONFIG_ATH_NAND_FL 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+	@./mkconfig -a db12x-hybrid mips mips db12x-hybrid ar7240 ar7240
+
+aph126_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef BOOT_FROM_NAND
+	@echo "#define CONFIG_ATH_NAND_FL 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+	@./mkconfig -a aph126 mips mips aph126 ar7240 ar7240
+
+aph128_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef BOOT_FROM_NAND
+	@echo "#define CONFIG_ATH_NAND_FL 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+	@./mkconfig -a aph128 mips mips aph128 ar7240 ar7240
+
+dhp1565_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef BOOT_FROM_NAND
+	@echo "#define CONFIG_ATH_NAND_FL 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+	@./mkconfig -a dhp1565 mips mips dhp1565 ar7240 ar7240
+
+
+db12x-extender_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+ifneq ($(findstring ap123,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+endif
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef BOOT_FROM_NAND
+	@echo "#define CONFIG_ATH_NAND_FL 1" >>include/config.h
+ifeq ($(BUILD_TYPE),jffs2)
+	@echo "#define CONFIG_ATH_NAND_JFFS2	1" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	0" >>include/config.h
+else
+	@echo "#define CONFIG_ATH_NAND_JFFS2	0" >>include/config.h
+	@echo "#define CONFIG_ATH_NAND_YAFFS	1" >>include/config.h
+endif
+endif
+	@./mkconfig -a db12x-extender mips mips db12x-extender ar7240 ar7240
+
+ap123_config			: 	unconfig
+	@ >include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT 1' >>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 1' >>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY 1' >>include/config.h
+	@echo '#define CFG_AG7240_NMACS 2' >>include/config.h
+endif
+
+ifneq ($(findstring mi124,$(BUILD_CONFIG)),)
+	@echo '#define CONFIG_MI124 1' >>include/config.h
+endif
+
+	@echo '#define CONFIG_AP123 1' >>include/config.h
+	@echo '#define CONFIG_ROOTFS_TYPE "rootfstype=squashfs"' >>include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_WASP 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+ifeq ($(DB12X_P2P_ENV), 1)
+	@echo "#define CONFIG_DB12X_P2P 1" >>include/config.h
+endif
+
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1' >>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1' >>include/config.h
+endif
+
+	@./mkconfig -a ap123 mips mips ap123 ar7240 ar7240
+
+
+ap91_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap91 mips mips ap91 ar7240 ar7240
+ap91-2MB_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap91-2MB mips mips ap91-2MB ar7240 ar7240
+ap91-2x8_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap91-2x8 mips mips ap91-2x8 ar7240 ar7240
+ap93_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap93 mips mips ap93 ar7240 ar7240
+ap91-router_config	: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap91-router mips mips ap91-router ar7240 ar7240
+ap93-hgw_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap93-hgw mips mips ap93-hgw ar7240 ar7240
+cus136_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a cus136 mips mips cus136 ar7240 ar7240
+wrt54g_config           :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a wrt54g mips mips wrt54g ar7240 ar7240
+pb90_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a pb90 mips mips pb90 ar7240 ar7240
+tb327_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a tb327 mips mips tb327 ar7240 ar7240
+pb93_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a pb93 mips mips pb93 ar7240 ar7240
+pb9x_config             :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a pb9x mips mips pb9x ar7240 ar7240
+
+pb9x-2x8_config             :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a pb9x-2x8 mips mips pb9x-2x8 ar7240 ar7240
+ap98_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a ap98 mips mips ap98 ar7240 ar7240
+
+pb9x-2.6.31_config             :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a pb9x-2.6.31 mips mips pb9x-2.6.31 ar7240 ar7240
+
+pb9x-offload_config             :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+ifdef ROOTFS
+	@echo "#define ROOTFS $(ROOTFS)" >>include/config.h
+endif
+	@./mkconfig -a pb9x-2.6.31 mips mips pb9x-2.6.31 ar7240 ar7240
+
+pb92_config             :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a pb92 mips mips pb92 ar7240 ar7240
+
+ap99_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a ap99 mips mips ap99 ar7240 ar7240
+
+ap99-small_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a ap99-small mips mips ap99-small ar7240 ar7240
+
+
+ap99-2.6.31_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a ap99-2.6.31 mips mips ap99-2.6.31 ar7240 ar7240
+
+ap99-hgw_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a ap99-hgw mips mips ap99-hgw ar7240 ar7240
+ap99-ivi_config     :   unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+ifdef FLASH_SIZE
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+endif
+	@./mkconfig -a ap99-ivi mips mips ap99-ivi ar7240 ar7240
+
+ap101_config             :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap101 mips mips ap101 ar7240 ar7240
+
+ap101-small_config       :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap101-small mips mips ap101-small ar7240 ar7240
+
+ap101-2.6.31_config      :       unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap101-2.6.31 mips mips ap101-2.6.31 ar7240 ar7240
+
+mi93_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a mi93 mips mips mi93 ar7240 ar7240
+
+ap111_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap111 mips mips ap111 ar7240 ar7240
+
+ap111-2.6.31_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@./mkconfig -a ap111-2.6.31 mips mips ap111-2.6.31 ar7240 ar7240
+
+hornet_common_config        :
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_MACH_HORNET 1" >>include/config.h
+ifdef BUILD_EMU
+	@echo "#define CONFIG_HORNET_EMU 1" >>include/config.h
+ifeq ($(BUILD_EMU), 24)
+	@echo "#define CONFIG_HORNET_EMU_HARDI 1" >>include/config.h
+	@echo "#define CONFIG_HORNET_EMU_HARDI_WLAN 1" >>include/config.h
+else
+
+ifeq ($(BUILD_EMU), 40)
+    #
+	# No need to include CONFIG_HORNET_EMU_HARDI_WLAN in 40Mhz, only for emulation and 24Mhz board
+	#	
+else
+    #
+	# Configure it as 24Mhz by default
+	#
+	@export BUILD_EMU=24
+	@echo "#define CONFIG_HORNET_EMU_HARDI_WLAN 1" >>include/config.h
+endif
+endif
+endif
+ifeq ($(CONFIG_HORNET_XTAL), 40)
+	@echo "#define CONFIG_40MHZ_XTAL_SUPPORT 1" >>include/config.h
+endif
+ifeq ($(CONFIG_HORNET_1_1_WAR), 1)
+	@echo "#define CONFIG_HORNET_1_1_WAR 1" >>include/config.h
+endif
+ifeq ($(AG7240_BROADCAST_ENABLE), 1)
+	@echo "#define AG7240_BROADCAST_ENABLE 1" >>include/config.h
+endif
+ifeq ($(NEW_DDR_TAP_CAL), 1)
+	@echo "#define NEW_DDR_TAP_CAL 1" >>include/config.h
+endif
+
+ap121_config		    : 	unconfig    hornet_common_config
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+ifdef BOARD_STRING
+	@echo "#define BOARD_STRING 1" >>include/config.h
+endif
+	@./mkconfig -a ap121 mips mips ap121 ar7240 ar7240
+ap121-2x16_config		    : 	unconfig    hornet_common_config
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+	@./mkconfig -a ap121 mips mips ap121 ar7240 ar7240
+
+ap121-2.6.31_config		    : 	unconfig    hornet_common_config
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+	@./mkconfig -a ap121 mips mips ap121 ar7240 ar7240
+
+ap121-2.6.31-2MB_config		: 	unconfig    hornet_common_config
+	@./mkconfig -a ap121 mips mips ap121 ar7240 ar7240
+ifeq ($(VXWORKS_UBOOT), 1)
+	@echo "#define VXWORKS_UBOOT 1" >>include/config.h
+endif
+
+ap121-2MB_config		: 	unconfig   hornet_common_config
+	@./mkconfig -a ap121 mips mips ap121 ar7240 ar7240
+
+ap121-hgw_config		    : 	unconfig    hornet_common_config
+	@echo "#define FLASH_SIZE $(FLASH_SIZE)" >>include/config.h
+	@./mkconfig -a ap121 mips mips ap121 ar7240 ar7240
+
+hornet_emu_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_AR7240 1" >>include/config.h
+	@echo "#define CONFIG_MACH_HORNET 1" >>include/config.h
+ifdef BUILD_EMU
+	@echo "#define CONFIG_HORNET_EMU 1" >>include/config.h
+ifeq ($(BUILD_EMU), 24)
+	@echo "#define CONFIG_HORNET_EMU_HARDI 1" >>include/config.h
+	@echo "#define CONFIG_HORNET_EMU_HARDI_WLAN 1" >>include/config.h
+else
+
+ifeq ($(BUILD_EMU), 40)
+    #
+	# No need to include CONFIG_HORNET_EMU_HARDI_WLAN in 40Mhz, only for emulation and 24Mhz board
+	#	
+else
+    #
+	# Configure it as 24Mhz by default
+	#
+	@export BUILD_EMU=24
+	@echo "#define CONFIG_HORNET_EMU_HARDI_WLAN 1" >>include/config.h
+endif
+endif
+endif
+	@./mkconfig -a hornet_emu mips mips hornet_emu ar7240 ar7240
+
+scoemu_config: 	unconfig
+	@echo '#define CONFIG_ATHEROS		1'	>include/config.h
+	@echo '#define CONFIG_MACH_QCA955x	1'	>>include/config.h
+	@echo '#define CFG_INIT_STACK_IN_SRAM	1'	>>include/config.h
+	@echo '#define CONFIG_ATH_EMULATION	1'	>>include/config.h
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f2e)
+	@echo '#define CONFIG_F2E_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	2'	>>include/config.h
+endif
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1'	>>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifdef FLASH_SIZE
+	@echo '#define FLASH_SIZE	$(FLASH_SIZE)'	>>include/config.h
+endif
+	@./mkconfig -a scoemu mips mips scoemu atheros
+
+
+ifneq ($(findstring $(BOARD_TYPE), board955x-offload-target),) #{
+ifneq ($(findstring $(BUILD_CONFIG), _ap136),)
+CFG_BOARD_TYPE=ap136
+endif
+ifneq ($(findstring $(BUILD_CONFIG), _ap132),)
+CFG_BOARD_TYPE=ap132
+endif
+endif #}
+
+ifneq ($(findstring $(BOARD_TYPE), board955x-offload-host),)
+ifneq ($(findstring $(BUILD_CONFIG), _ap135_bootrom_pcie),)
+CFG_BOARD_TYPE=ap135
+ETH_CONFIG=_s17
+ATH_GMAC_GE0_IS_CONNECTED=1
+ATH_GMAC_GE1_IS_CONNECTED=1
+ATH_GMAC0_MII=ATHR_RGMII
+ATH_GMAC1_MII=ATHR_SGMII
+#sgmii defines
+ATH_CFG_SGMII=1
+ATH_CONFIG_SWAP_SGMII=0
+AH_CAL_IN_FLASH_PCI=1
+ATH_S17_PHY0_WAN=1
+ATH_SGMII_FORCED=1
+ATH_S17_MAC0_SGMII=1
+FLASH_SIZE=16
+ATH_RGMII_CAL=1
+endif
+
+ifneq ($(findstring $(BUILD_CONFIG), _ap136 _ap136_bootrom),)
+CFG_BOARD_TYPE=ap136
+
+ifneq ($(findstring $(BUILD_CONFIG), _ap136_bootrom),) #{
+ETH_CONFIG=_s17
+ATH_GMAC_GE0_IS_CONNECTED=1
+ATH_GMAC_GE1_IS_CONNECTED=1
+ATH_GMAC0_MII=ATHR_RGMII
+ATH_GMAC1_MII=ATHR_SGMII
+#sgmii defines
+ATH_CFG_SGMII=1
+ATH_CONFIG_SWAP_SGMII=0
+AH_CAL_IN_FLASH_PCI=1
+ATH_S17_PHY0_WAN=1
+ATH_SGMII_FORCED=1
+#LED defines
+ATH_SUPPORT_LED=1
+GPIO_PIN_FUNC_0=7
+GPIO_PIN_FUNC_1=7
+GPIO_PIN_FUNC_2=7
+ATH_LED_CUSTOMER=CUSTOMER_ATHEROS_SCORPION
+endif #}
+
+endif
+endif
+board955x_config: 	unconfig
+	@echo '#define CONFIG_ATHEROS		1'	>include/config.h
+	@echo '#define CONFIG_MACH_QCA955x	1'	>>include/config.h
+	@echo '#define CFG_INIT_STACK_IN_SRAM	1'	>>include/config.h
+	@echo '#define CONFIG_'`echo $(CFG_BOARD_TYPE) | tr [a-z] [A-Z] | sed s/-/_/g`'	1' >>include/config.h
+	@echo '#define __CONFIG_BOARD_NAME $(CFG_BOARD_TYPE)' >>include/config.h
+	@echo '#define CONFIG_BOARD_NAME "$(CFG_BOARD_TYPE)"' >>include/config.h
+ifdef pll
+	@echo '#define CFG_PLL_FREQ		$(pll)'	>>include/config.h
+else
+	@echo '#define CFG_PLL_FREQ		CFG_PLL_720_600_200'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+endif
+
+ifeq ($(ATH_SGMII_FORCED),1)
+	@echo '#define ATH_SGMII_FORCED		1'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+
+ifneq (,$(findstring $(CFG_BOARD_TYPE),ap136 ap135)) #{
+	@echo '#define CFG_ATH_GMAC_NMACS	2'	>>include/config.h
+	@echo '#define CFG_ATH_GE1_IS_CONNECTED 1' 	>>include/config.h
+	@echo '#define CONFIG_ATHRS_GMAC_SGMII  1'      >>include/config.h
+
+ifeq ($(ATH_S17_PHY0_WAN),1)
+	@echo "#define CONFIG_ATH_S17_WAN 1" >> include/config.h
+endif
+
+endif #}
+ifeq ($(S17_SWMAC6_CONNECTED),1)
+	@echo "#define CONFIG_S17_SWMAC6_CONNECTED 1" >> include/config.h
+endif
+endif
+
+ifeq ($(CFG_BOARD_TYPE), ap132)
+	@echo '#define CFG_ATH_GMAC_NMACS       2'      >>include/config.h
+	@echo '#define CFG_ATH_GE1_IS_CONNECTED 1'      >>include/config.h
+	@echo '#define CONFIG_ATHRS_GMAC_SGMII  1'      >>include/config.h
+	@echo '#define CONFIG_MGMT_INIT         1'      >>include/config.h
+ifeq ($(ATH_SWITCH_ONLY_MODE),1)
+	@echo "#define CONFIG_ATHR_SWITCH_ONLY_MODE 1" >> include/config.h
+endif
+endif
+
+ifeq ($(ATH_S17_MAC0_SGMII),1)
+	@echo "#define ATH_S17_MAC0_SGMII 1" >> include/config.h
+endif
+
+
+#ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+#	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+#	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+#else
+#ifeq ($(ETH_CONFIG), _s17_hwaccel)
+#	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+#	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+#endif
+ifeq ($(ETH_CONFIG2), _ar8033) #{
+	@echo '#define CONFIG_ATHR_8033_PHY     1'      >>include/config.h
+	@echo '#define CONFIG_ATHRS_GMAC_SGMII  1'      >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	2'	>>include/config.h
+ifeq ($(ATH_MDC_GPIO),1)
+	@echo '#define ATH_MDC_GPIO       1'      >>include/config.h
+endif
+
+endif #}
+ifeq ($(ETH_CONFIG), _vir) #{
+
+ifneq ($(findstring ATHR_MII,$(ATH_GMAC0_MII)),)
+	@echo "#define GMAC0_MII 1" >> include/config.h
+
+else
+	@echo '#define CONFIG_VIR_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+
+ifeq ($(ATH_SLAVE_CONNECTED),1)
+	@echo "#define CONFIG_SCO_SLAVE_CONNECTED 1" >> include/config.h
+endif
+
+endif #}
+ifeq ($(ATH_SGMII_FORCED),1)
+	@echo "#define ATH_SGMII_FORCED_MODE 1" >> include/config.h
+endif
+
+ifeq ($(ATH_RGMII_CAL),1)
+	@echo "#define ATH_RGMII_CAL 1" >> include/config.h
+endif
+
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1'	>>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifdef FLASH_SIZE
+	@echo '#define FLASH_SIZE	$(FLASH_SIZE)'	>>include/config.h
+endif
+	@./mkconfig -a board955x mips mips board955x atheros
+
+
+aph131_config: 	unconfig
+	@echo '#define CONFIG_ATHEROS		1'	>include/config.h
+	@echo '#define CONFIG_MACH_QCA955x	1'	>>include/config.h
+	@echo '#define CFG_INIT_STACK_IN_SRAM	1'	>>include/config.h
+	@echo '#define CONFIG_'`echo $(BOARD_TYPE) | tr [a-z] [A-Z] | sed s/-/_/g`'	1' >>include/config.h
+	@echo '#define __CONFIG_BOARD_NAME $(BOARD_TYPE)' >>include/config.h
+	@echo '#define CONFIG_BOARD_NAME "$(BOARD_TYPE)"' >>include/config.h
+ifdef pll
+	@echo '#define CFG_PLL_FREQ		$(pll)'	>>include/config.h
+else
+	@echo '#define CFG_PLL_FREQ		CFG_PLL_720_600_240'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+endif
+
+ifeq ($(ATH_SGMII_FORCED),1)
+	@echo '#define ATH_SGMII_FORCED		1'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+
+ifneq (,$(findstring $(CFG_BOARD_TYPE),ap136 ap135)) #{
+	@echo '#define CFG_ATH_GMAC_NMACS	2'	>>include/config.h
+	@echo '#define CFG_ATH_GE1_IS_CONNECTED 1' 	>>include/config.h
+	@echo '#define CONFIG_ATHRS_GMAC_SGMII  1'      >>include/config.h
+
+ifeq ($(ATH_S17_PHY0_WAN),1)
+	@echo "#define CONFIG_ATH_S17_WAN 1" >> include/config.h
+endif
+
+endif #}
+ifeq ($(S17_SWMAC6_CONNECTED),1)
+	@echo "#define CONFIG_S17_SWMAC6_CONNECTED 1" >> include/config.h
+endif
+endif
+
+ifeq ($(CFG_BOARD_TYPE), ap132)
+	@echo '#define CFG_ATH_GMAC_NMACS       2'      >>include/config.h
+	@echo '#define CFG_ATH_GE1_IS_CONNECTED 1'      >>include/config.h
+	@echo '#define CONFIG_ATHRS_GMAC_SGMII  1'      >>include/config.h
+	@echo '#define CONFIG_MGMT_INIT         1'      >>include/config.h
+ifeq ($(ATH_SWITCH_ONLY_MODE),1)
+	@echo "#define CONFIG_ATHR_SWITCH_ONLY_MODE 1" >> include/config.h
+endif
+endif
+
+ifeq ($(ATH_S17_MAC0_SGMII),1)
+	@echo "#define ATH_S17_MAC0_SGMII 1" >> include/config.h
+endif
+
+
+#ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+#	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+#	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+#else
+#ifeq ($(ETH_CONFIG), _s17_hwaccel)
+#	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+#	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+#endif
+ifeq ($(ETH_CONFIG2), _ar8033) #{
+	@echo '#define CONFIG_ATHR_8033_PHY     1'      >>include/config.h
+	@echo '#define CONFIG_ATHRS_GMAC_SGMII  1'      >>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	2'	>>include/config.h
+ifeq ($(ATH_MDC_GPIO),1)
+	@echo '#define ATH_MDC_GPIO       1'      >>include/config.h
+endif
+
+endif #}
+ifeq ($(ETH_CONFIG), _vir) #{
+
+ifneq ($(findstring ATHR_MII,$(ATH_GMAC0_MII)),)
+	@echo "#define GMAC0_MII 1" >> include/config.h
+
+else
+	@echo '#define CONFIG_VIR_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+
+ifeq ($(ATH_SLAVE_CONNECTED),1)
+	@echo "#define CONFIG_SCO_SLAVE_CONNECTED 1" >> include/config.h
+endif
+
+endif #}
+ifeq ($(ATH_SGMII_FORCED),1)
+	@echo "#define ATH_SGMII_FORCED_MODE 1" >> include/config.h
+endif
+
+ifeq ($(ATH_RGMII_CAL),1)
+	@echo "#define ATH_RGMII_CAL 1" >> include/config.h
+endif
+
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1'	>>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifdef FLASH_SIZE
+	@echo '#define FLASH_SIZE	$(FLASH_SIZE)'	>>include/config.h
+endif
+	@./mkconfig -a aph131 mips mips aph131 atheros
+
+ap138_config: 	unconfig
+	@echo '#define CONFIG_ATHEROS		1'	>include/config.h
+	@echo '#define CONFIG_MACH_QCA955x	1'	>>include/config.h
+	@echo '#define CFG_INIT_STACK_IN_SRAM	1'	>>include/config.h
+ifdef pll
+	@echo '#define CFG_PLL_FREQ		$(pll)'	>>include/config.h
+else
+	@echo '#define CFG_PLL_FREQ		CFG_PLL_720_600_240'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG2), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_DUAL_PHY_SUPPORT	1'	>>include/config.h
+else
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+	@echo '#define CONFIG_ATHRS17_PHY	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+endif
+ifeq ($(ETH_CONFIG), _s16)
+	@echo '#define CONFIG_AR7242_S16_PHY	1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f1e)
+	@echo '#define CONFIG_F1E_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _f2e)
+	@echo '#define CONFIG_F2E_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+	@echo '#define CONFIG_VIR_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	1'	>>include/config.h
+endif
+ifeq ($(ETH_CONFIG), _s27)
+	@echo '#define CFG_ATHRS27_PHY		1'	>>include/config.h
+	@echo '#define CFG_ATH_GMAC_NMACS	2'	>>include/config.h
+endif
+ifeq ($(BOOT_FROM_NAND),1)
+	@echo '#define CONFIG_ATH_NAND_BR	1'	>>include/config.h
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifeq ($(ATH_DUAL_FLASH),1)
+	@echo '#define CONFIG_ATH_NAND_SUPPORT	1'	>>include/config.h
+	@echo "#define ATH_CAL_NAND_PARTITION "\"$(strip ${ATH_CAL_NAND_PARTITION})\" >>include/config.h
+	@echo '#define ATH_CAL_OFF_INVAL        0xbad0ff' >>include/config.h
+endif
+ifdef FLASH_SIZE
+	@echo '#define FLASH_SIZE	$(FLASH_SIZE)'	>>include/config.h
+endif
+	@./mkconfig -a board955x mips mips board955x atheros
+
+
 #========================================================================
 # Nios
 #========================================================================
@@ -1903,37 +3420,44 @@ dspstamp_config	:	unconfig
 #########################################################################
 
 clean:
-	find . -type f \
+	@echo Making $@
+	@find . -type f \
 		\( -name 'core' -o -name '*.bak' -o -name '*~' \
-		-o -name '*.o'  -o -name '*.a'  \) -print \
+		-o -name '*.o'  -o -name '*.a' -o -name .depend \) -print \
 		| xargs rm -f
-	rm -f examples/hello_world examples/timer \
+	@rm -f examples/hello_world examples/timer \
 	      examples/eepro100_eeprom examples/sched \
 	      examples/mem_to_mem_idma2intr examples/82559_eeprom \
 	      examples/smc91111_eeprom \
 	      examples/test_burst
-	rm -f tools/img2srec tools/mkimage tools/envcrc tools/gen_eth_addr
-	rm -f tools/mpc86x_clk tools/ncb
-	rm -f tools/easylogo/easylogo tools/bmp_logo
-	rm -f tools/gdb/astest tools/gdb/gdbcont tools/gdb/gdbsend
-	rm -f tools/env/fw_printenv tools/env/fw_setenv
-	rm -f board/cray/L1/bootscript.c board/cray/L1/bootscript.image
-	rm -f board/netstar/eeprom board/netstar/crcek
-	rm -f board/netstar/*.srec board/netstar/*.bin
-	rm -f board/trab/trab_fkt board/voiceblue/eeprom
-	rm -f board/integratorap/u-boot.lds board/integratorcp/u-boot.lds
+	@rm -f tools/img2srec tools/mkimage tools/envcrc tools/gen_eth_addr
+	@rm -f tools/mpc86x_clk tools/ncb
+	@rm -f tools/easylogo/easylogo tools/bmp_logo
+	@rm -f tools/gdb/astest tools/gdb/gdbcont tools/gdb/gdbsend
+	@rm -f tools/env/fw_printenv tools/env/fw_setenv
+	@rm -f board/cray/L1/bootscript.c board/cray/L1/bootscript.image
+	@rm -f board/netstar/eeprom board/netstar/crcek
+	@rm -f board/netstar/*.srec board/netstar/*.bin
+	@rm -f board/trab/trab_fkt board/voiceblue/eeprom
+	@rm -f board/integratorap/u-boot.lds board/integratorcp/u-boot.lds
+ifeq ($(COMPRESSED_UBOOT),1)
+	@rm -f lib_bootstrap/*.o
+	@rm -f lib_bootstrap/*.a
+	@rm -f bootstrap bootstrap.bin tuboot.bin u-boot.lzimg
+endif
 
 clobber:	clean
-	find . -type f \( -name .depend \
+	@echo Making $@
+	@find . -type f \( -name .depend \
 		-o -name '*.srec' -o -name '*.bin' -o -name u-boot.img \) \
 		-print0 \
 		| xargs -0 rm -f
-	rm -f $(OBJS) *.bak tags TAGS include/version_autogenerated.h
-	rm -fr *.*~
-	rm -f u-boot u-boot.map u-boot.hex $(ALL)
-	rm -f tools/crc32.c tools/environment.c tools/env/crc32.c
-	rm -f tools/inca-swap-bytes cpu/mpc824x/bedbug_603e.c
-	rm -f include/asm/proc include/asm/arch include/asm
+	@rm -f $(OBJS) *.bak tags TAGS include/version_autogenerated.h
+	@rm -fr *.*~
+	@rm -f u-boot u-boot.map u-boot.hex $(ALL)
+	@rm -f tools/crc32.c tools/environment.c tools/env/crc32.c
+	@rm -f tools/inca-swap-bytes cpu/mpc824x/bedbug_603e.c
+	@rm -f include/asm/proc include/asm/arch include/asm
 
 mrproper \
 distclean:	clobber unconfig
diff --git a/board/ar7100/ap81/Makefile b/board/ar7100/ap81/Makefile
new file mode 100644
index 0000000000..9057cbd772
--- /dev/null
+++ b/board/ar7100/ap81/Makefile
@@ -0,0 +1,23 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+ifeq ($(CONFIG_AP81_CARRIER_CUS109), 1)
+OBJS	= $(BOARD).o flash.o ../common/ar7100_flash.o ../common/athrf1_phy.o
+else
+OBJS	= $(BOARD).o flash.o ../common/ar7100_flash.o ../common/athrs26_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_ar9100.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7100/ap81/ap81.c b/board/ar7100/ap81/ap81.c
new file mode 100644
index 0000000000..8b0ac718f5
--- /dev/null
+++ b/board/ar7100/ap81/ap81.c
@@ -0,0 +1,150 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7100_soc.h"
+extern const char version_string[];
+
+void
+ar7100_usb_initial_config(void)
+{
+    ar7100_reg_wr_nf(AR7100_USB_PLL_CONFIG, 0x00001030);
+}
+
+int
+ar7100_mem_config()
+{
+    uint32_t  ddr_config, ddr_config2;
+    int i;
+#if 0
+    ar7100_ddr_width_t width;
+#endif
+
+    ar7100_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+#if 0
+    ar7100_ddr_tap_config();
+#else
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL0, 0x0);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL1, 0x0);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL2, 0x0);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL3, 0x0);
+#endif
+
+#if 0
+    ddr_config   = ar7100_reg_rd(AR7100_DDR_CONFIG);
+    ddr_config2  = ar7100_reg_rd(AR7100_DDR_CONFIG2);
+    width        = ar7100_ddr_get_width();
+
+    if (width != AR7100_DDR_32B)
+        ddr_config |= AR7100_DDR_CONFIG_16BIT;
+    if (width == AR7100_DDR_16B_HIGH)
+        ddr_config2 &= ~AR7100_DDR_CONFIG2_HALF_WIDTH_L;
+
+    ddr_config2 &= ~((0x1f << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                     (0x1f << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                      0xf);
+
+    ddr_config2 |= ((CFG_DDR_TRTW_VAL << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                    (CFG_DDR_TWTR_VAL << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                    AR7100_DDR_CONFIG2_BL2);
+    /*
+     * XXX These bits are reserved...
+     */
+    ddr_config2 |= (1 << 26)|(1 << 27)|(1 << 30);
+
+    printf("programming config1 %#x, config2 %#x\n", ddr_config, ddr_config2);
+
+    ar7100_reg_wr(AR7100_DDR_CONFIG, ddr_config);
+    ar7100_reg_wr(AR7100_DDR_CONFIG2, ddr_config2);
+#endif
+
+    /* XXX - these don't really belong here!
+    *(volatile unsigned int *)0xb8050004 = 0x00001032;
+    udelay(100);
+*/
+#ifndef AR9100
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+#endif
+#if 0
+    *(volatile unsigned int *)0xb805001c = 0x00000909;
+    udelay(100);
+
+    *(volatile unsigned int *)0xb8050014 = 0x14000044;
+    udelay(100);
+#endif
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(1 << 25));
+    *(volatile int *)0xb8050004 = i;
+    while ((*(volatile int *)0xb8050004) & (1 << 17));
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(1 << 16));
+    *(volatile int *)0xb8050004 = i;
+    while ((*(volatile int *)0xb8050004) & (1 << 17));
+
+    i = *(volatile int *)0xb8050004;
+    i = i | (0x3f << 19);
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    *(volatile int *)0xb8050014 = 0x13000a44;
+/*
+    *(volatile int *)0xb8050014 = 0x13000044;
+    *(volatile int *)0xb8050014 = 0x13111321;
+    *(volatile int *)0xb8050014 = 0x00111321;
+    *(volatile int *)0xb8050014 = 0x00001344;
+    *(volatile int *)0xb8050014 = 0x14000044;
+    *(volatile int *)0xb8050014 = 0x14000f44;
+    *(volatile int *)0xb8050014 = 0x00001044;
+    *(volatile int *)0xb8050014 = 0x14001044;
+    *(volatile int *)0xb8050014 = 0x14001f44;
+    *(volatile int *)0xb8050014 = 0x1f001044;
+    *(volatile int *)0xb8050014 = 0x1f001f44;
+*/
+
+    *(volatile int *)0xb805001c = 0x00000909;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(0x3b << 19));
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i | (0x3 << 20);
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(0x3 << 20));
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    /* Temp addition - check with Ravi */
+    *(volatile unsigned int *)0xb8080008 = 0x00000040;
+    udelay(100);
+
+    ar7100_usb_initial_config();
+
+    i = ar7100_ddr_find_size();
+
+    printf ("\n\n%s\n\n", version_string);
+    printf("AP81 (ar7100) U-boot\n");
+    printf("sri\n");
+
+    return i;
+}
+
+long int initdram(int board_type)
+{
+    return (ar7100_mem_config());
+}
+
+int checkboard (void)
+{
+	return 0;
+}
diff --git a/board/ar7100/ap81/config.mk b/board/ar7100/ap81/config.mk
new file mode 100755
index 0000000000..3c410579c0
--- /dev/null
+++ b/board/ar7100/ap81/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0xa1000000
diff --git a/board/ar7100/ap81/flash.c b/board/ar7100/ap81/flash.c
new file mode 100644
index 0000000000..c2d244f2a3
--- /dev/null
+++ b/board/ar7100/ap81/flash.c
@@ -0,0 +1,29 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %dMB, sector count = %d\n",
+                (CFG_FLASH_SIZE >> 20), flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7100/ap81/u-boot.lds b/board/ar7100/ap81/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7100/ap81/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/ap83/Makefile b/board/ar7100/ap83/Makefile
new file mode 100644
index 0000000000..0c8432990b
--- /dev/null
+++ b/board/ar7100/ap83/Makefile
@@ -0,0 +1,23 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+
+ifeq ($(SERIAL_FLASH),YES)
+OBJS	= $(BOARD).o ../common/ar7100_flash.o ../common/vsc8601_phy.o ../common/generic_spi.o ../common/vsc73xx.o ../ap83/flash.o
+else
+OBJS	= $(BOARD).o ../common/ar9100_pflash.o ../common/vsc8601_phy.o ../common/generic_spi.o ../common/vsc73xx.o
+endif
+SOBJS	= ../common/lowlevel_init_ar9100.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7100/ap83/ap83.c b/board/ar7100/ap83/ap83.c
new file mode 100644
index 0000000000..79a93eeb61
--- /dev/null
+++ b/board/ar7100/ap83/ap83.c
@@ -0,0 +1,153 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7100_soc.h"
+
+int ap83_board_version;
+
+void
+ar7100_usb_initial_config(void)
+{
+    ar7100_reg_wr_nf(AR7100_USB_PLL_CONFIG, 0x00001030);
+}
+
+int
+ar7100_mem_config()
+{
+    uint32_t  ddr_config, ddr_config2;
+    int i;
+#if 0
+    ar7100_ddr_width_t width;
+#endif
+
+    ar7100_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+#if 0
+    ar7100_ddr_tap_config();
+#else
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL0, 0x0);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL1, 0x0);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL2, 0x0);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL3, 0x0);
+#endif
+
+#if 0
+    ddr_config   = ar7100_reg_rd(AR7100_DDR_CONFIG);
+    ddr_config2  = ar7100_reg_rd(AR7100_DDR_CONFIG2);
+    width        = ar7100_ddr_get_width();
+
+    if (width != AR7100_DDR_32B)
+        ddr_config |= AR7100_DDR_CONFIG_16BIT;
+    if (width == AR7100_DDR_16B_HIGH)
+        ddr_config2 &= ~AR7100_DDR_CONFIG2_HALF_WIDTH_L;
+
+    ddr_config2 &= ~((0x1f << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                     (0x1f << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                      0xf);
+
+    ddr_config2 |= ((CFG_DDR_TRTW_VAL << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                    (CFG_DDR_TWTR_VAL << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                    AR7100_DDR_CONFIG2_BL2);
+    /*
+     * XXX These bits are reserved...
+     */
+    ddr_config2 |= (1 << 26)|(1 << 27)|(1 << 30);
+
+    printf("programming config1 %#x, config2 %#x\n", ddr_config, ddr_config2);
+
+    ar7100_reg_wr(AR7100_DDR_CONFIG, ddr_config);
+    ar7100_reg_wr(AR7100_DDR_CONFIG2, ddr_config2);
+#endif
+
+    /* XXX - these don't really belong here!
+    *(volatile unsigned int *)0xb8050004 = 0x00001032;
+    udelay(100);
+*/
+#ifndef AR9100
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+#endif
+#if 0
+    *(volatile unsigned int *)0xb805001c = 0x00000909;
+    udelay(100);
+
+    *(volatile unsigned int *)0xb8050014 = 0x14000044;
+    udelay(100);
+#endif
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(1 << 25));
+    *(volatile int *)0xb8050004 = i;
+    while ((*(volatile int *)0xb8050004) & (1 << 17));
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(1 << 16));
+    *(volatile int *)0xb8050004 = i;
+    while ((*(volatile int *)0xb8050004) & (1 << 17));
+
+    i = *(volatile int *)0xb8050004;
+    i = i | (0x3f << 19);
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    *(volatile int *)0xb8050014 = 0x13000a44;
+/*
+    *(volatile int *)0xb8050014 = 0x13000044;
+    *(volatile int *)0xb8050014 = 0x13111321;
+    *(volatile int *)0xb8050014 = 0x00111321;
+    *(volatile int *)0xb8050014 = 0x00001344;
+    *(volatile int *)0xb8050014 = 0x14000044;
+    *(volatile int *)0xb8050014 = 0x14000f44;
+    *(volatile int *)0xb8050014 = 0x00001044;
+    *(volatile int *)0xb8050014 = 0x14001044;
+    *(volatile int *)0xb8050014 = 0x14001f44;
+    *(volatile int *)0xb8050014 = 0x1f001044;
+    *(volatile int *)0xb8050014 = 0x1f001f44;
+*/
+
+    *(volatile int *)0xb805001c = 0x00000909;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(0x3b << 19));
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i | (0x3 << 20);
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(0x3 << 20));
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    /* Temp addition - check with Mani */
+    *(volatile unsigned int *)0xb8080008 = 0x00000060;
+    udelay(100);
+
+    ar7100_usb_initial_config();
+
+    return (ar7100_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7100_mem_config());
+}
+
+int checkboard (void)
+{
+#define AP83_BOARD_NUM_ADDR ((char *)0xbf7f1244)
+
+    ap83_board_version = (AP83_BOARD_NUM_ADDR[0] - '0') +
+                    ((AP83_BOARD_NUM_ADDR[1] - '0') * 10);
+
+    printf("AP83-%d (ar9100) U-boot " ATH_AP83_UBOOT_VERSION "\n",
+           ap83_board_version);
+
+    return 0;
+}
diff --git a/board/ar7100/ap83/config.mk b/board/ar7100/ap83/config.mk
new file mode 100644
index 0000000000..36591ccd48
--- /dev/null
+++ b/board/ar7100/ap83/config.mk
@@ -0,0 +1,6 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+SERIAL_FLASH = NO
+
+# SDRAM version
+#TEXT_BASE = 0xa1000000
diff --git a/board/ar7100/ap83/flash.c b/board/ar7100/ap83/flash.c
new file mode 100644
index 0000000000..c2d244f2a3
--- /dev/null
+++ b/board/ar7100/ap83/flash.c
@@ -0,0 +1,29 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %dMB, sector count = %d\n",
+                (CFG_FLASH_SIZE >> 20), flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7100/ap83/u-boot.lds b/board/ar7100/ap83/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7100/ap83/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/ap94/Makefile b/board/ar7100/ap94/Makefile
new file mode 100644
index 0000000000..5acded7db1
--- /dev/null
+++ b/board/ar7100/ap94/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o ../common/ar7100_flash.o athrs26_phy.o ap94_pci.o ../common/generic_spi.o
+SOBJS	= lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7100/ap94/ap94.c b/board/ar7100/ap94/ap94.c
new file mode 100644
index 0000000000..2f88824b32
--- /dev/null
+++ b/board/ar7100/ap94/ap94.c
@@ -0,0 +1,106 @@
+/*****************************************************************************/
+/*! file ap94.c
+** /brief Boot support for AP94 board
+**    
+**  This provides the support code required for the AP94 board in the U-Boot
+**  environment.  This board is a Hydra based system with two Merlin WLAN
+**  interfaces.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7100_soc.h"
+
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_mem_config
+**
+**  This is a "C" level implementation of the memory configuration interface
+**  for the AP94.  
+**
+**  \return RAM size in bytes
+*/
+
+int
+ar7100_mem_config(void)
+{
+
+    /* XXX - should be set based board configuration */
+    *(volatile unsigned int *)0xb8050004 = 0x50C0;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+    *(volatile unsigned int *)0xb805001c = 0x67;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050010 = 0x1099;
+    udelay(10);
+
+    return (ar7100_ddr_find_size());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+long int initdram(int board_type)
+{
+    printf("b8050000: 0x%x\n",* (unsigned long *)(0xb8050000));
+    return (ar7100_mem_config());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+int checkboard (void)
+{
+
+    printf("AP94 (ar7100) U-boot " ATH_AP83_UBOOT_VERSION "\n");
+    return 0;
+}
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = 8*1024*1024; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7100/ap94/ap94_pci.c b/board/ar7100/ap94/ap94_pci.c
new file mode 100644
index 0000000000..b7fcee292d
--- /dev/null
+++ b/board/ar7100/ap94/ap94_pci.c
@@ -0,0 +1,432 @@
+/*****************************************************************************/
+/*! file ap94_pci.c
+** /brief PCI support for AP94 board
+**    
+**  This provides the support code required for PCI support on the AP94
+**  board in the U-Boot environment.  This board is a Hydra based system
+**  with two Merlin WLAN interfaces.  This file also contains the support
+**  for initialization of the Merlin radios on the PCi bus, required for
+**  pre-configuration for use by Linux.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <pci.h>
+#include "ar7100_soc.h"
+
+/*
+** PCI controller "hose" value
+*/
+
+static struct pci_controller hose;
+
+/*
+ * Mask table, bits to mask for quantity of size 1, 2 or 4 bytes.
+ * 0 and 3 are not valid indexes...
+ */
+static uint32_t bytemask[] = {
+	/*0*/	0,
+	/*1*/	0xff,
+	/*2*/	0xffff,
+	/*3*/	0,
+	/*4*/	0xffffffff,
+};
+
+static void crp_read(uint32_t ad_cbe, uint32_t *data);
+static void crp_write(uint32_t ad_cbe, uint32_t data);
+static int  ar7100_check_error(int verbose);
+static int  ar7100_pci_read(uint32_t addr, uint32_t cmd, uint32_t* data);
+static int  ar7100_pci_write(uint32_t addr, uint32_t cmd, uint32_t data);
+static uint32_t ar7100_config_addr(uint8_t bus_num, uint16_t devfn, int where);
+static uint32_t local_byte_lane_enable_bits(uint32_t n, int size);
+static int  ar7100_local_read_config(int where, int size, uint32_t *value);
+static int  ar7100_local_write_config(int where, int size, uint32_t value);
+
+/*
+** This is where the merlin devices in slot 0 and 1 are initialized.
+** Note that for other boards derived from AP-94 this should be customized
+** for the board in question
+**
+** We will use the ART configuration information stored in flash to initialize
+** these devices as required.
+*/
+
+void plat_dev_init(void)
+{
+    u32     val;
+    u32     addr;
+    u32     BaseAddr[2] = {0x10000000, 0x10010000};
+    u32     CalAddr[2] = {MERLIN24CAL, MERLIN50CAL};
+    u16     *calData;
+    int     i;
+    
+    /*
+    ** For AP94, we have two Merlins that need to be initialized. Set the device ID for now
+    */
+    
+    for( i=0 ; i<2; i++ )
+    {
+        calData = (u16 *)CalAddr[i];
+    
+        if(calData[0] != 0xa55a)
+        {
+            /*
+            ** Board is not calibrated.
+            */
+        
+            printf("BOARD IS NOT CALIBRATED!!!\n");
+            return;
+        }
+        
+        /*
+        ** Need to setup the PCI device to access the internal registers
+        */
+
+        ar7100_pci_write_config(&hose,PCI_BDF(0,i,0),0x10,BaseAddr[i]);
+        ar7100_pci_write_config(&hose,PCI_BDF(0,i,0),0x04,0x6);
+        
+        /*
+        ** Set pointer to first reg address
+        */
+        
+        calData += 3;
+        
+        while(*calData != 0xffff)
+        {
+            addr = BaseAddr[i] + *calData++;
+            val  = *calData++;
+            val |= (*calData++) << 16;
+
+            ar7100_reg_wr(addr,val);
+        }
+    }
+
+    return;
+}
+
+/*
+ * Read from PCI config space (host ctrl)
+ */
+static void crp_read(uint32_t ad_cbe, uint32_t *data)
+{
+    ar7100_reg_wr(AR7100_PCI_CRP_AD_CBE, ad_cbe);
+	*data     =  ar7100_reg_rd(AR7100_PCI_CRP_RDDATA);
+}
+
+/*
+ * Write to PCI config space (host ctrl)
+ */
+static void crp_write(uint32_t ad_cbe, uint32_t data)
+{ 
+    ar7100_reg_wr(AR7100_PCI_CRP_AD_CBE, (AR7100_CRP_CMD_WRITE | ad_cbe));
+	ar7100_reg_wr(AR7100_PCI_CRP_WRDATA, data);
+}
+
+
+/*
+ * Check for PCI errors (aborts, parity etc.), for configuration cycles
+ * PCI error reg: 1:0
+ * AHB error reg: 0
+ * Both write-back-1 to clear.
+ */
+static int 
+ar7100_check_error(int verbose)
+{
+    uint32_t error = 0, trouble = 0, status;
+
+    error = ar7100_reg_rd(AR7100_PCI_ERROR) & 3;
+
+    if (error) {
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+
+        if (verbose) {
+            printf("PCI error %d at PCI addr 0x%x status %#x\n", 
+                    error, ar7100_reg_rd(AR7100_PCI_ERROR_ADDRESS),
+                    status);
+        }
+
+        ar7100_reg_wr(AR7100_PCI_ERROR, error);
+        ar7100_local_write_config(PCI_STATUS, 2, status);
+        /*
+         * flush
+         */
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+        trouble = 1;
+    }
+
+    error = 0;
+    error = ar7100_reg_rd(AR7100_PCI_AHB_ERROR) & 1;
+
+    if (error) {
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+
+        if (verbose) {
+            printf("AHB error %d at AHB address 0x%x status %#x\n", 
+                   ar7100_reg_rd(AR7100_PCI_AHB_ERROR_ADDRESS), status);
+        }
+
+        ar7100_reg_wr(AR7100_PCI_AHB_ERROR, error);
+        trouble = 1;
+    }
+
+    return trouble;
+}
+
+static int 
+ar7100_pci_read(uint32_t addr, uint32_t cmd, uint32_t* data)
+{
+	int retval = 0;
+
+    ar7100_reg_wr(AR7100_PCI_CFG_AD, addr);
+    ar7100_reg_wr(AR7100_PCI_CFG_CBE, cmd);
+
+	/* 
+     * the result of the read is now in CFG_RDATA 
+     */
+    if (!ar7100_check_error(0))
+        *data = ar7100_reg_rd(AR7100_PCI_CFG_RDDATA);
+    else {
+        *data = 0xffffffff;
+        retval = 1;
+    }
+
+	return retval;
+}
+
+static int 
+ar7100_pci_write(uint32_t addr, uint32_t cmd, uint32_t data)
+{    
+	int retval = 0;
+
+    ar7100_reg_wr(AR7100_PCI_CFG_AD, addr);
+    ar7100_reg_wr(AR7100_PCI_CFG_CBE, cmd);
+
+	/* 
+     * execute the write by writing to CFG_WDATA 
+     */ 
+    ar7100_reg_wr(AR7100_PCI_CFG_WRDATA, data);
+
+    if (ar7100_check_error(0))
+        retval = 1;
+
+	return retval;
+}
+
+/*
+ * This is assuming idsel of device 0 is connected to Address line 17
+ * Address for type 0 config is as follows:
+ * AD: 
+ *  1:0 00 indicates type zero transaction
+ *  7:2    indicates the target config dword
+ *  10:8   indicates the target function within the physical device
+ *  31:11  are reserved (and most probably used to connect idsels)
+ */
+static uint32_t 
+ar7100_config_addr(uint8_t bus_num, uint16_t devfn, int where)
+{
+	uint32_t addr;
+
+	if (!bus_num) {
+		/* type 0 */
+		addr = (1 << (AR7100_PCI_IDSEL_ADLINE_START + PCI_DEV(devfn))) |
+               ((PCI_FUNC(devfn)) << 8)                                 |
+		       (where & ~3);	
+	} else {
+		/* type 1 */
+		addr = (bus_num << 16) | ((PCI_DEV(devfn)) << 11) | 
+			((PCI_FUNC(devfn)) << 8) | (where & ~3) | 1;
+	}
+
+	return addr;
+}
+
+
+static uint32_t 
+local_byte_lane_enable_bits(uint32_t n, int size)
+{
+	if (size == 1)
+		return (0xf & ~BIT(n)) << 20;
+	if (size == 2)
+		return (0xf & ~(BIT(n) | BIT(n+1))) << 20;
+	if (size == 4)
+		return 0;
+	return 0xffffffff;
+}
+
+static int 
+ar7100_local_read_config(int where, int size, uint32_t *value)
+{ 
+	uint32_t n, data;
+
+	/*printk("ar7100_local_read_config from %d size %d\n", where, size);*/
+	n = where % 4;
+	crp_read(where & ~3, &data);
+	*value = (data >> (8*n)) & bytemask[size];
+	/*printk("ar7100_local_read_config read %#x\n", *value);*/
+
+	return 0;
+}
+
+static int 
+ar7100_local_write_config(int where, int size, uint32_t value)
+{
+	uint32_t n, byte_enables, data;
+
+	n = where % 4;
+	byte_enables = local_byte_lane_enable_bits(n, size);
+	if (byte_enables == 0xffffffff)
+		return -1;
+	data = value << (8*n);
+	crp_write((where & ~3) | byte_enables, data);
+
+	return 0;
+}
+
+
+static int ar7100_pci_read_config(struct pci_controller *hose,
+			      pci_dev_t dev, int offset, u32* value)
+{
+	uint32_t    addr;
+	uint8_t     bus_num = PCI_BUS(dev);
+    uint16_t    devfn = dev & 0xffff;
+    
+
+	addr = ar7100_config_addr(bus_num, devfn, offset);
+	ar7100_pci_read(addr, AR7100_CFG_CMD_READ, value);
+
+	return 0;
+}
+
+
+static int 
+ar7100_pci_write_config(struct pci_controller *hose, pci_dev_t dev, int offset, u32 value)
+{
+	uint32_t    addr;
+	uint8_t     bus_num = PCI_BUS(dev);
+    uint16_t    devfn = dev & 0xffff;
+
+	addr = ar7100_config_addr(bus_num, devfn, offset);
+	ar7100_pci_write(addr, AR7100_CFG_CMD_WRITE, value);
+	return 0;
+}
+
+/******************************************************************************/
+/*!
+**  \brief pci host initialization
+**
+**  Sets up the PCI controller on the host.  For AR7100 this may not be necessary,
+**  but this function is required for board support.
+**
+** We want a 1:1 mapping between PCI and DDR for inbound and outbound.
+** The PCI<---AHB decoding works as follows:
+**
+** 8 registers in the DDR unit provide software configurable 32 bit offsets
+** for each of the eight 16MB PCI windows in the 128MB. The offsets will be 
+** added to any address in the 16MB segment before being sent to the PCI unit.
+**
+** Essentially  for any AHB address generated by the CPU,
+** 1. the MSB  four bits are stripped off, [31:28],
+** 2. Bit 27 is used to decide between the lower 128Mb (PCI) or the rest of 
+**    the AHB space
+** 3. Bits 26:24 are used to access one of the 8 window registers and are 
+**    masked off.
+** 4. If it is a PCI address, then the WINDOW offset in the WINDOW register 
+**    corresponding to the next 3 bits (bit 26:24) is ADDED to the address, 
+**    to generate the address to PCI unit.
+**
+**     eg. CPU address = 0x100000ff
+**         window 0 offset = 0x10000000
+**         This points to lowermost 16MB window in PCI space.
+**         So the resulting address would be 0x000000ff+0x10000000
+**         = 0x100000ff
+**
+**         eg2. CPU address = 0x120000ff
+**         WINDOW 2 offset = 0x12000000
+**         resulting address would be 0x000000ff+0x12000000
+**                         = 0x120000ff 
+**
+** There is no translation for inbound access (PCI device as a master)
+**
+**  \return N/A
+*/
+
+void pci_init_board (void)
+{
+    uint32_t cmd, val;
+
+    ar7100_reg_rmw_set(AR7100_RESET, 
+                      (AR7100_RESET_PCI_BUS|AR7100_RESET_PCI_CORE));
+    udelay(2000);
+
+    ar7100_reg_rmw_clear(AR7100_RESET, 
+                      (AR7100_RESET_PCI_BUS|AR7100_RESET_PCI_CORE));
+    udelay(2000);
+
+    ar7100_write_pci_window(0);
+    ar7100_write_pci_window(1);
+    ar7100_write_pci_window(2);
+    ar7100_write_pci_window(3);
+    ar7100_write_pci_window(4);
+    ar7100_write_pci_window(5);
+    ar7100_write_pci_window(6);
+    ar7100_write_pci_window(7);
+
+    udelay(2000);
+
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+          PCI_COMMAND_PARITY|PCI_COMMAND_SERR|PCI_COMMAND_FAST_BACK;
+
+    ar7100_local_write_config(PCI_COMMAND, 4, cmd);
+
+    /*
+     * clear any lingering errors and register core error IRQ
+     */
+    ar7100_check_error(0);
+    
+    /*
+    ** Now, configure for u-boot tools
+    */
+    
+	hose.first_busno = 0;
+	hose.last_busno = 0xff;
+
+	/* System space */
+	pci_set_region( &hose.regions[0],
+		            0x80000000,
+		            0x00000000,
+		            32 * 1024 * 1024,
+		            PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region( &hose.regions[1],
+		            0x10000000,
+		            0x10000000,
+		            128 * 1024 * 1024,
+		            PCI_REGION_MEM);
+
+	hose.region_count = 2;
+
+	pci_register_hose(&hose);
+
+	pci_set_ops(&hose,
+		pci_hose_read_config_byte_via_dword,
+		pci_hose_read_config_word_via_dword,
+		ar7100_pci_read_config,
+		pci_hose_write_config_byte_via_dword,
+		pci_hose_write_config_word_via_dword,
+		ar7100_pci_write_config);
+
+    plat_dev_init();
+    
+    return 0;
+}
+
+
diff --git a/board/ar7100/ap94/athrs26_phy.c b/board/ar7100/ap94/athrs26_phy.c
new file mode 100644
index 0000000000..9b57dc54dc
--- /dev/null
+++ b/board/ar7100/ap94/athrs26_phy.c
@@ -0,0 +1,745 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <miiphy.h>
+#include "../cpu/mips/ar7100/ag7100.h"
+#include "ar7100_soc.h"
+#include "athrs26_phy.h"
+
+/* PHY selections and access functions */
+
+typedef enum {
+    PHY_SRCPORT_INFO, 
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG, 
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+#define ENET_UNIT_LAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+/*****************************Device ID***************************/
+#define DEVICE_ID_OFFSET 0x0
+#define LOAD_EEPROM_E_BOFFSET 16
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* phy port 0 -- LAN port 0 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+     FALSE,
+     1,
+     0,
+     ATHR_PHY4_ADDR, 
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00, 
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+static uint8_t athr26_init_flag = 0;
+static unsigned int old_ahb_div = 0;
+
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+            
+/* Forward references */
+BOOL athrs26_phy_is_link_alive(int phyUnit);
+static uint32_t athrs26_reg_read(uint16_t reg_addr);
+static void athrs26_reg_write(uint16_t reg_addr, uint32_t reg_val);
+
+#define get_field_val(_reg, _mask, _shift, _res_reg)     \
+    do { \
+        unsigned int temp;	\
+        temp = ar7100_reg_rd(_reg); \
+        temp &= (unsigned int)_mask;\
+        _res_reg  = temp >> _shift; \
+    } while (0)
+
+#define set_field_val(_reg, _mask, _shift, _val)                \
+    do { \
+        unsigned int temp; \
+        temp = ar7100_reg_rd(_reg); \
+        temp &= ~_mask;  \
+        temp |= _val << _shift;  \
+        ar7100_reg_wr(_reg, temp);\
+    } while (0)
+
+/****************************
+**
+****************************/
+
+uint16_t phy_reg_read(int unit, uint32_t phy_addr, uint8_t reg)
+{
+    ag7100_mac_t *mac   = ag7100_unit2mac(0);
+    uint16_t      addr  = (phy_addr << AG7100_ADDR_SHIFT) | reg, val;
+    volatile int           rddata;
+    uint16_t      ii = 0x1000;
+
+//    ag7100_choose_phy(phy_addr);
+
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CMD, 0x0);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_ADDRESS, addr);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CMD, AG7100_MGMT_CMD_READ);
+
+    do
+    {
+        udelay(5);
+        rddata = ag7100_reg_rd(mac, AG7100_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    val = ag7100_reg_rd(mac, AG7100_MII_MGMT_STATUS);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CMD, 0x0);
+
+    return val;
+}
+
+void phy_reg_write(int unit, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+    ag7100_mac_t *mac   = ag7100_unit2mac(0);
+    uint16_t      addr  = (phy_addr << AG7100_ADDR_SHIFT) | reg;
+    volatile int rddata;
+    uint16_t      ii = 0x1000;
+
+//    ag7100_choose_phy(phy_addr);
+
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_ADDRESS, addr);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CTRL, data);
+
+    do
+    {
+        rddata = ag7100_reg_rd(mac, AG7100_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+}
+
+void ag7100_ahb_feq_adjust(void)
+{
+    unsigned int pll_fb = 0, ahb_div = 0, cpu_div = 0, mask = 0; 
+
+    mask = PLL_CONFIG_PLL_FB_MASK;
+    get_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_PLL_FB_SHIFT, pll_fb);
+
+    mask = PLL_CONFIG_AHB_DIV_MASK;
+    get_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_AHB_DIV_SHIFT, old_ahb_div);
+
+    mask = PLL_CONFIG_CPU_DIV_MASK;
+    get_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_CPU_DIV_SHIFT, cpu_div);
+    
+    ahb_div = ( (2*pll_fb + 2)/(5*cpu_div + 5) + 1)/2 - 1;
+    mask = PLL_CONFIG_AHB_DIV_MASK;
+    set_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_AHB_DIV_SHIFT, ahb_div);
+}
+
+void ag7100_ahb_feq_restore(void)
+{
+    unsigned int mask = 0;
+    mask = PLL_CONFIG_AHB_DIV_MASK;
+    set_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_AHB_DIV_SHIFT, old_ahb_div); 
+}
+
+void athrs26_reg_init()
+{
+    if (athr26_init_flag)
+        return;
+
+    athrs26_reg_write(0x200, 0x200);
+    athrs26_reg_write(0x300, 0x200);
+    athrs26_reg_write(0x400, 0x200);
+    athrs26_reg_write(0x500, 0x200);
+    athrs26_reg_write(0x600, 0x7d);
+
+#ifdef S26_VER_1_0
+    phyRegWrite(ATHR_PHYBASE(0), 0, 29, 41);
+    phyRegWrite(ATHR_PHYBASE(0), 0, 30, 0);
+    phyRegWrite(ATHR_PHYBASE(0), 1, 29, 41);
+    phyRegWrite(ATHR_PHYBASE(0), 1, 30, 0);
+    phyRegWrite(ATHR_PHYBASE(0), 2, 29, 41);
+    phyRegWrite(ATHR_PHYBASE(0), 2, 30, 0);
+    phyRegWrite(ATHR_PHYBASE(0), 3, 29, 41);
+    phyRegWrite(ATHR_PHYBASE(0), 3, 30, 0);
+    phyRegWrite(ATHR_PHYBASE(0), 4, 29, 41);
+    phyRegWrite(ATHR_PHYBASE(0), 4, 30, 0);
+#endif
+        
+    athrs26_reg_write(0x38, 0xc000050e);
+#ifdef HEADER_EN        
+    athrs26_reg_write(0x104, 0x4804);
+#else
+    athrs26_reg_write(0x104, 0x4004);
+#endif
+       
+    athrs26_reg_write(0x60, 0xffffffff);
+    athrs26_reg_write(0x64, 0xaaaaaaaa);
+    athrs26_reg_write(0x68, 0x55555555);    
+    athrs26_reg_write(0x6c, 0x0);    
+    athrs26_reg_write(0x70, 0x41af);
+
+    athr26_init_flag = 1;
+}
+
+
+static unsigned int phy_val_saved = 0;
+/******************************************************************************
+*
+* athrs26_phy_off - power off the phy to change its speed
+*
+* Power off the phy
+*/
+void athrs26_phy_off(ag7100_mac_t *mac)
+{
+    if (mac->mac_unit == ENET_UNIT_LAN)
+        return;
+
+    phy_val_saved = phy_reg_read(0, ATHR_PHY4_ADDR, ATHR_PHY_CONTROL);
+    phy_reg_write(0, ATHR_PHY4_ADDR, ATHR_PHY_CONTROL, phy_val_saved | 0x800);
+}
+
+/******************************************************************************
+*
+* athrs26_phy_on - power on the phy after speed changed
+*
+* Power on the phy
+*/
+void athrs26_phy_on(ag7100_mac_t *mac)
+{
+    if ((mac->mac_unit == ENET_UNIT_LAN) || (phy_val_saved == 0))
+        return;
+        
+    phy_reg_write(0, ATHR_PHY4_ADDR, ATHR_PHY_CONTROL, phy_val_saved & 0xf7ff);
+}
+
+/******************************************************************************
+*
+* athrs26_mac_speed_set - set mac in s26 speed mode (actually RMII mode)
+*
+* Set mac speed mode
+*/
+void athrs26_mac_speed_set(ag7100_mac_t *mac, ag7100_phy_speed_t speed)
+{
+    uint32_t reg_val;
+    
+    if ((mac->mac_unit == ENET_UNIT_LAN))
+        return;
+    
+    reg_val = athrs26_reg_read(0x600);
+    
+    switch (speed) {
+        case AG7100_PHY_SPEED_100TX:
+            athrs26_reg_write (0x600, (reg_val & 0xfffffffc) | 0x1);
+            break;
+           
+        case AG7100_PHY_SPEED_10T:
+            athrs26_reg_write (0x600, (reg_val & 0xfffffffc));
+            break; 
+        
+        default:
+            break;  
+    }
+}
+
+/******************************************************************************
+*
+* athrs26_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs26_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+
+/******************************************************************************
+*
+* athrs26_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL athrs26_phy_setup(int ethUnit)
+{
+    int         phyUnit;
+    uint16_t    phyHwStatus;
+    uint16_t    timeout;
+    int         liveLinks = 0;
+    uint32_t    phyBase = 0;
+    BOOL        foundPhy = FALSE;
+    uint32_t    phyAddr = 0;
+    
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    DEBUGOUT("start auto negogiation on each phy\n");
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        DEBUGOUT("PHY Base: 0x%x PHY Addr: 0x%x\n",phyBase,phyAddr);
+        
+        phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+
+        /* Reset PHYs*/
+        phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+                      ATHR_CTRL_AUTONEGOTIATION_ENABLE 
+                      | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+    if (!foundPhy) {
+        DEBUGOUT("No PHY's configured for this ethUnit\n");
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+    
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    sysMsDelay(100);
+    
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    DEBUGOUT("associated PHY\n");
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DEBUGOUT("Port %d, Neg Success\n", phyUnit);
+                break;
+            }
+            if (timeout == 0) {
+                DEBUGOUT("Port %d, Negogiation timeout\n", phyUnit);
+                break;
+            }
+            if (--timeout == 0) {
+                DEBUGOUT("Port %d, Negogiation timeout\n", phyUnit);
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    DEBUGOUT("Initialize software status\n");
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+
+        DEBUGOUT("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit, 
+            phy_reg_read(ATHR_PHYBASE(phyUnit),
+                       ATHR_PHYADDR(phyUnit),
+                       ATHR_PHY_SPEC_STATUS));
+    }
+
+    if (ethUnit == ENET_UNIT_LAN) {
+        ag7100_ahb_feq_adjust();  
+        athrs26_reg_init();
+        ag7100_ahb_feq_restore();       
+    }    
+    
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs26_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs26_phy_is_fdx(int ethUnit)
+{
+    int         phyUnit;
+    uint32_t    phyBase;
+    uint32_t    phyAddr;
+    uint16_t    phyHwStatus;
+    int         ii = 200;
+    
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+    
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read (phyBase, phyAddr, 
+                                              ATHR_PHY_SPEC_STATUS);
+                sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+
+/******************************************************************************
+*
+* athrs26_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7100_PHY_SPEED_10T, AG7100_PHY_SPEED_100TX;
+*               AG7100_PHY_SPEED_1000T;
+*/
+
+int
+athrs26_phy_speed(int ethUnit)
+{
+    int         phyUnit;
+    uint16_t    phyHwStatus;
+    uint32_t    phyBase;
+    uint32_t    phyAddr;
+    int         ii = 200;
+    
+    if (ethUnit == ENET_UNIT_LAN)
+        return AG7100_PHY_SPEED_100TX;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+            
+            do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
+                                              ATHR_PHY_SPEC_STATUS);
+                sysMsDelay(10);
+            }while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                return AG7100_PHY_SPEED_10T;
+            case 1:
+                return AG7100_PHY_SPEED_100TX;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        }
+    }
+
+    return AG7100_PHY_SPEED_10T;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int athrs26_phy_is_up(int ethUnit)
+{
+    int             phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t  *lastStatus;
+    int             linkCount   = 0;
+    int             lostLinks   = 0;
+    int             gainedLinks = 0;
+    uint32_t        phyBase;
+    uint32_t        phyAddr;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DEBUGOUT("\nenet%d port%d down\n",ethUnit, phyUnit);
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS);
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+            phyHwControl = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+            /* Check for AutoNegotiation complete */            
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                DEBUGOUT("\nenet%d port%d up\n",ethUnit, phyUnit);
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+        
+    return(linkCount);
+
+//    if (linkCount == 0) {
+//        if (lostLinks) {
+//            /* We just lost the last link for this MAC */
+//            phyLinkLost(ethUnit);
+//        }
+//    } else {
+//        if (gainedLinks == linkCount) {
+//            /* We just gained our first link(s) for this MAC */
+//            phyLinkGained(ethUnit);
+//        }
+//    }
+}
+
+static uint32_t
+athrs26_reg_read(uint16_t reg_addr)
+{
+    uint16_t reg_word_addr;
+    uint32_t phy_addr, phy_val0, phy_val1, phy_val;
+    uint8_t phy_reg;
+
+    /* read the first 16 bits*/
+    reg_word_addr = (reg_addr / 4) * 2;
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val0 = (reg_word_addr >> 8) & 0x1ff;         /* bit16-8 of reg address*/
+    phy_reg_write (0, phy_addr, phy_reg, phy_val0);
+
+    /* read register with low address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = reg_word_addr & 0x1f;                 /* bit4-0 of reg address */
+    phy_val0 = phy_reg_read(0, phy_addr, phy_reg);
+
+    /* read the second 16 bits*/
+    reg_word_addr++;
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val1 = (reg_word_addr >> 8) & 0x1ff;         /* bit16-8 of reg address*/
+    phy_reg_write (0, phy_addr, phy_reg, phy_val1);
+
+    /* read register with low address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = reg_word_addr & 0x1f;                 /* bit4-0 of reg address */
+    phy_val1 = phy_reg_read(0, phy_addr, phy_reg);
+    phy_val = ((phy_val1 << 16) | phy_val0);
+    return phy_val;
+}
+
+static void
+athrs26_reg_write(uint16_t reg_addr, uint32_t reg_val)
+{
+    uint16_t reg_word_addr, phy_val;
+    uint32_t phy_addr;
+    uint8_t phy_reg;
+
+    /* write the first 16 bits*/
+    reg_word_addr = (reg_addr / 4) * 2;    
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (reg_word_addr >> 8) & 0x1ff;         /* bit16-8 of reg address*/
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* read register with low address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = reg_word_addr & 0x1f;                 /* bit4-0 of reg address */
+    phy_val = reg_val & 0xffff;
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* write the second 16 bits*/
+    reg_word_addr++;    
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (reg_word_addr >> 8) & 0x1ff;         /* bit16-8 of reg address*/
+    phy_reg_write (0, phy_addr, phy_reg, phy_val);
+
+    /* read register with low address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = reg_word_addr & 0x1f;                 /* bit4-0 of reg address */
+    phy_val = (reg_val >> 16) & 0xffff;
+    phy_reg_write(0, phy_addr, phy_reg, phy_val); 
+}
diff --git a/board/ar7100/ap94/athrs26_phy.h b/board/ar7100/ap94/athrs26_phy.h
new file mode 100644
index 0000000000..18cb02af3b
--- /dev/null
+++ b/board/ar7100/ap94/athrs26_phy.h
@@ -0,0 +1,116 @@
+#ifndef _ATHRS26_PHY_H
+#define _ATHRS26_PHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+        
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+
+#define BOOL   			u_int32_t
+#define HEADER_LEN   	2
+#define HEADER_MAX_DATA	10
+#define sysMsDelay(_x) udelay((_x) * 1000)
+#define mdelay(_x)	sysMsDelay(_x)
+
+#undef S26_VER_1_0
+/* Ken: for debug output */
+//#define DEBUGOUT(fmt,args...)	printf(fmt ,##args)
+#define DEBUGOUT(fmt,args...) 
+
+
+/* before define HEADER_REG_CONF, please make sure you also enable s26's */
+/* HEADER_EN on CPU port in bootloader, or the configuration will fail */
+#ifndef CONFIG_AR9100
+#undef HEADER_REG_CONF
+#else
+#define HEADER_REG_CONF 1
+#endif
+#ifdef HEADER_REG_CONF
+#define HEADER_EN
+#endif
+typedef enum {
+    AG7100_PHY_SPEED_10T,
+    AG7100_PHY_SPEED_100TX,
+    AG7100_PHY_SPEED_1000T,
+}ag7100_phy_speed_t;
+
+
+void athrs26_reg_init(void);
+int athrs26_phy_is_up(int unit);
+int athrs26_phy_is_fdx(int unit);
+int athrs26_phy_speed(int unit);
+BOOL athrs26_phy_setup(int unit);
+void athrs26_phy_off(ag7100_mac_t *mac);
+void athrs26_phy_on(ag7100_mac_t *mac);
+void athrs26_mac_speed_set(ag7100_mac_t *mac, ag7100_phy_speed_t speed);
+
+#endif /* _ATHRS26_PHY_H */
+
diff --git a/board/ar7100/ap94/config.mk b/board/ar7100/ap94/config.mk
new file mode 100755
index 0000000000..4a032b7f0c
--- /dev/null
+++ b/board/ar7100/ap94/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0xa0010000
diff --git a/board/ar7100/ap94/lowlevel_init.S b/board/ar7100/ap94/lowlevel_init.S
new file mode 100755
index 0000000000..856312a1fc
--- /dev/null
+++ b/board/ar7100/ap94/lowlevel_init.S
@@ -0,0 +1,217 @@
+/*****************************************************************************/
+/*! file lowlevel_init.s
+** /brief Low Level initialization routine for AP94
+**    
+**  
+**
+**  Copyright (c) 200x Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7100_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define clear_mask(_reg, _mask)                     \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+#define set_val(_reg, _mask, _val)                  \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t9, _val;                                   \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+#define get_val(_reg, _mask, _shift, _res_reg)      \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, _mask;                                  \
+    and t8, t8, t9;                                 \
+    srl _res_reg, t8, _shift                        \
+
+#define pll_clr(_mask)                              \
+    clear_mask(AR7100_CPU_PLL_CONFIG, _mask)
+
+#define pll_set(_mask, _val)                        \
+    set_val(AR7100_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_get(_mask, _shift, _res_reg)            \
+    get_val(AR7100_CPU_PLL_CONFIG, _mask, _shift, _res_reg)
+
+#define clk_clr(_mask)                               \
+    clear_mask(AR7100_CPU_CLOCK_CONTROL, _mask)
+
+#define clk_set(_mask, _val)                         \
+    set_val(AR7100_CPU_CLOCK_CONTROL,  _mask, _val)
+
+#define clk_get(_mask, _shift, _res_reg)              \
+    get_val(AR7100_CPU_CLOCK_CONTROL, _mask, _shift, _res_reg)
+
+#define MEMDELAY(count, reg)	\
+	li	    reg, count;	\
+9:	addi	reg, -1;	\
+	bgtz	reg, 9b;	\
+	nop
+
+
+#define PLL_CONFIG_SW_UPDATE_VAL (1 << 31)
+#define CLOCK_CTRL_SWITCH_VAL (1 << 1)
+
+/******************************************************************************
+ * first level initialization:
+ * 
+ * 0) If clock cntrl reset switch is already set, we're recovering from 
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ * 
+ *****************************************************************************/
+
+.globl lowlevel_init
+
+lowlevel_init:
+
+    /*
+     * The code below is for the real chip. Wont work on FPGA
+     */
+    /* jr ra  */
+
+    clk_get(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CONTROL_RST_SWITCH_SHIFT, t6)
+    bne zero, t6, initialize_pll
+    nop 
+
+    pll_set(PLL_CONFIG_CPU_DIV_MASK,    PLL_CONFIG_CPU_DIV_VAL)
+    pll_set(PLL_CONFIG_AHB_DIV_MASK,    PLL_CONFIG_AHB_DIV_VAL)
+    pll_set(PLL_CONFIG_DDR_DIV_MASK,    PLL_CONFIG_DDR_DIV_VAL)
+	pll_set(PLL_CONFIG_PLL_DIVOUT_MASK, PLL_CONFIG_PLL_DIVOUT_VAL)
+
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+
+    /*
+     * Will cause a reset
+     */
+    clk_set(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CTRL_SWITCH_VAL)
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+    
+initialize_pll:
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+    clk_clr(CLOCK_CONTROL_RST_SWITCH_MASK)
+    pll_set(PLL_CONFIG_PLL_FB_MASK, PLL_CONFIG_PLL_FB_VAL)
+    pll_set(PLL_CONFIG_PLL_LOOP_BW_MASK, PLL_CONFIG_PLL_LOOP_BW_VAL)
+
+    pll_clr(PLL_CONFIG_PLL_POWER_DOWN_MASK);
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK);
+
+wait_for_pll_lock:
+    pll_get(PLL_CONFIG_LOCKED_MASK, PLL_CONFIG_LOCKED_SHIFT, t6)
+    beq zero, t6, wait_for_pll_lock
+    nop 
+
+
+pll_locked:
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+    
+    /*
+    ** Now, time to initialize memory.  We'll do the early initialization here
+    ** (taken directly from Redboot), and the later initialization will not be
+    ** performed.  Better all around.
+    **
+    ** Since AP-94 is a fixed design, we'll ensure the config value has the correct
+    ** CAS latency.
+    */
+    
+    li      a0, KSEG1ADDR(AR7100_DDR_CONFIG)
+	li	    t0, CFG_DDR_CONFIG_VAL
+	sw	    t0, 0(a0)
+	nop
+    
+    /*
+    ** Load all other values
+    */
+
+	li      a1, KSEG1ADDR(AR7100_DDR_CONFIG2)
+	li	    t8, CFG_DDR_CONFIG2_VAL
+	sw	    t8, 0(a1)
+    MEMDELAY(30, t2)
+    
+    /*
+    ** Setting the mode register
+    */
+    
+    li      a0, KSEG1ADDR(AR7100_DDR_CONTROL)
+    li      a1, KSEG1ADDR(AR7100_DDR_EXT_MODE)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, CFG_DDR_EXT_MODE_VAL
+    sw      t5, 0(a1)
+    MEMDELAY(30, t2)
+
+    li      t5, 2
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+	/*
+    **  Want to set the mode value.  since AP-94 only operates at
+    ** one speed, we don't need to check the speed setting
+    */
+    
+    li      a2, KSEG1ADDR(AR7100_DDR_MODE)
+	li	    t5, CFG_DDR_MODE_VAL
+    sw	    t5, 0(a2)
+	MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    /*
+    ** Setting refresh, data this cycle, and tap words
+    */
+    
+    li      a0, KSEG1ADDR(AR7100_DDR_REFRESH)
+    li      t5, CFG_DDR_REFRESH_VAL
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      a2, KSEG1ADDR(AR7100_DDR_RD_DATA_THIS_CYCLE)
+	li	    t5, CFG_DDR_RD_DATA_THIS_CYCLE_VAL
+	sw	    t5, 0(a2)
+	
+    li      a1, 0x07
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL0)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL1)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL2)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL3)
+    sw      a1, 0(a0)
+    nop
+
+    jr ra
+
diff --git a/board/ar7100/ap94/u-boot.lds b/board/ar7100/ap94/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7100/ap94/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/ap96/Makefile b/board/ar7100/ap96/Makefile
new file mode 100644
index 0000000000..11490981b6
--- /dev/null
+++ b/board/ar7100/ap96/Makefile
@@ -0,0 +1,19 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o ../common/ar7100_flash.o ../common/generic_spi.o \
+	../common/athrs16_phy.o ../ap94/ap94_pci.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7100/ap96/ap96.c b/board/ar7100/ap96/ap96.c
new file mode 100644
index 0000000000..ac19dda9aa
--- /dev/null
+++ b/board/ar7100/ap96/ap96.c
@@ -0,0 +1,201 @@
+/*****************************************************************************/
+/*! file ap96.c
+** /brief Boot support for AP96 board
+**    
+**  This provides the support code required for the AP96 board in the U-Boot
+**  environment.  This board is a Hydra based system with two Merlin WLAN
+**  interfaces and S16 GigE interfaces.
+** 
+**  Code derived from AP94
+**
+**  AP96 is similar to AP94 in all respects except the ethernet interfaces. 
+**  AP94 has S26, while AP96 uses S16. PB45 also uses S16, but PB45 has a
+**  32 bit wide memory bus and two mini-PCI slots whereas AP94 and AP96
+**  have a 16 bit wide memory bus and WLAN interfaces on the board. So,
+**  while PB45 doesn't have a caldata partition in flash, AP94 and AP96
+**  will have the radio calibration of the WLAN interfaces in Flash ROM.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7100_soc.h"
+
+extern flash_info_t flash_info[];
+ 
+/******************************************************************************/
+/*!
+**  \brief ar7100_mem_config
+**
+**  This is a "C" level implementation of the memory configuration interface
+**  for the PB45.  
+**
+**  \return RAM size in bytes
+*/
+
+int
+ar7100_mem_config(void)
+{
+
+    /* XXX - should be set based board configuration */
+    *(volatile unsigned int *)0xb8050004 = 0x50C0;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+    *(volatile unsigned int *)0xb805001c = 0x67;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050010 = 0x1099;
+    udelay(10);
+
+    return (ar7100_ddr_find_size());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+long int initdram(int board_type)
+{
+    printf("b8050000: 0x%x\n",* (unsigned long *)(0xb8050000));
+    return (ar7100_mem_config());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+int checkboard (void)
+{
+
+    printf("AP96 (ar7100) U-boot " ATH_AP96_UBOOT_VERSION "\n");
+    return 0;
+}
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = 8*1024*1024; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
+
+#if(0) // (CONFIG_COMMANDS & CFG_CMD_BSP)
+
+/**********************************************************************************
+** do_mac_setting
+**
+** This is the executable portion of the progmac command.  This will process the
+** MAC address strings, and program them into the appropriate flash sector..
+**
+*/
+
+int do_mac (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    char    sectorBuff[65536];
+    int     serno;
+
+    /*
+    ** Argv[1] contains the value string.  Convert to binary, and program the
+    ** values in flash
+    */
+    
+    serno = simple_strtoul(argv[1],0,10);
+    
+    /*
+    ** If the serial number is less than 0, or greater than 0x1fff, it's out of range
+    */
+    
+    if(serno < 0 || serno > 0x1fff)
+    {
+        printf("Serno out of range\n",serno);
+        return 1;
+    }
+    
+    /*
+    ** Create the 24 bit number that composes the lower 3 bytes of the MAC address
+    */
+    
+    serno = 0xFFFFFF & ( (ATHEROS_PRODUCT_ID << 13) | (serno & 0x1fff));
+    
+    /*
+    ** Get the values from flash, and program into the MAC address registers
+    */
+    
+    memcpy(sectorBuff,(void *)BOARDCAL, 65536);
+    
+    /*
+    ** Set the first and second values
+    */
+    
+    sectorBuff[0] = 0x00;
+    sectorBuff[1] = 0x03;
+    sectorBuff[2] = 0x7f;
+
+    sectorBuff[3] = 0xFF & (serno >> 16);
+    sectorBuff[4] = 0xFF & (serno >> 8);
+    sectorBuff[5] = 0xFF &  serno;
+    
+    /*
+    ** Increment by 1 for the second MAC address
+    */
+
+    serno++;    
+    memcpy(&sectorBuff[6],&sectorBuff[0],3);
+    sectorBuff[3] = 0xFF & (serno >> 16);
+    sectorBuff[4] = 0xFF & (serno >> 8);
+    sectorBuff[5] = 0xFF &  serno;
+    
+    flash_erase(flash_info,CAL_SECTOR,CAL_SECTOR);
+    write_buff(flash_info,sectorBuff, BOARDCAL, 65536);
+    
+    return 0;
+}
+
+U_BOOT_CMD(none, 2, 0, do_mac,NULL,NULL);
+    
+
+U_BOOT_CMD(
+    progmac, 2, 0, do_mac,
+    "progmac - Set ethernet MAC addresses\n",
+    "progmac <serno> - Program the MAC addresses\n"
+    "                <serno> is the value of the last\n"
+    "                4 digits (decimal) of the serial number\n"
+);
+
+#endif
diff --git a/board/ar7100/ap96/config.mk b/board/ar7100/ap96/config.mk
new file mode 100644
index 0000000000..4a032b7f0c
--- /dev/null
+++ b/board/ar7100/ap96/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0xa0010000
diff --git a/board/ar7100/ap96/u-boot.lds b/board/ar7100/ap96/u-boot.lds
new file mode 100755
index 0000000000..9ac25bead9
--- /dev/null
+++ b/board/ar7100/ap96/u-boot.lds
@@ -0,0 +1,40 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/common/ar7100_flash.c b/board/ar7100/common/ar7100_flash.c
new file mode 100644
index 0000000000..77efd99835
--- /dev/null
+++ b/board/ar7100/common/ar7100_flash.c
@@ -0,0 +1,183 @@
+#include <common.h>
+#include <jffs2/jffs2.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7100_soc.h"
+#include "ar7100_flash.h"
+
+/*
+ * globals
+ */
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+#define display(x)  ;
+
+#define AR7100_SPI_CMD_WRITE_SR     0x01
+
+/*
+ * statics
+ */
+static void ar7100_spi_write_enable(void);
+static void ar7100_spi_poll(void);
+static void ar7100_spi_write_page(uint32_t addr, uint8_t *data, int len);
+static void ar7100_spi_sector_erase(uint32_t addr);
+static void ar7100_spi_flash_unblock();
+
+static void
+ar7100_spi_flash_unblock()
+{
+    ar7100_spi_write_enable();
+    ar7100_spi_bit_banger(AR7100_SPI_CMD_WRITE_SR);
+    ar7100_spi_bit_banger(0x0);
+    ar7100_spi_go();
+    ar7100_spi_poll();
+}
+
+static void
+read_id()
+{
+    u32 rd = 0x777777;
+
+    ar7100_reg_wr_nf(AR7100_SPI_WRITE, AR7100_SPI_CS_DIS);
+    ar7100_spi_bit_banger(0x9f);
+    ar7100_spi_delay_8();
+    ar7100_spi_delay_8();
+    ar7100_spi_delay_8();
+    ar7100_spi_done(); 
+    /* rd = ar7100_reg_rd(AR7100_SPI_RD_STATUS); */
+    rd = ar7100_reg_rd(AR7100_SPI_READ); 
+    printf("id read %#x\n", rd);
+}
+
+unsigned long 
+flash_init (void)
+{
+    int i;
+    u32 rd = 0x666666;
+
+    ar7100_reg_wr_nf(AR7100_SPI_CLOCK, 0x43);
+    ar7100_spi_flash_unblock();
+    read_id();
+/*
+    rd = ar7100_reg_rd(AR7100_SPI_RD_STATUS);
+    printf ("rd = %x\n", rd);
+    if (rd & 0x80) {
+    }
+*/
+
+    /*
+     * hook into board specific code to fill flash_info
+     */
+    return (flash_get_geom(&flash_info));
+}
+
+
+void flash_print_info (flash_info_t *info)
+{
+    printf("The hell do you want flinfo for??\n");
+}
+
+int
+flash_erase(flash_info_t *info, int s_first, int s_last)
+{
+    int i, sector_size = info->size/info->sector_count;
+
+    printf("\nFirst %#x last %#x sector size %#x\n",
+           s_first, s_last, sector_size);
+
+    for (i = s_first; i <= s_last; i++) {
+        printf("\b\b\b\b%4d", i);
+        ar7100_spi_sector_erase(i * sector_size);
+    }
+    ar7100_spi_done();
+    printf("\n");
+
+    return 0;
+}
+
+/*
+ * Write a buffer from memory to flash:
+ * 0. Assumption: Caller has already erased the appropriate sectors.
+ * 1. call page programming for every 256 bytes
+ */
+int 
+write_buff(flash_info_t *info, uchar *source, ulong addr, ulong len)
+{
+    int total = 0, len_this_lp, bytes_this_page;
+    ulong dst;
+    uchar *src;
+    
+    printf ("write addr: %x\n", addr); 
+    addr = addr - CFG_FLASH_BASE;
+
+    while(total < len) {
+        src              = source + total;
+        dst              = addr   + total;
+        bytes_this_page  = AR7100_SPI_PAGE_SIZE - (addr % AR7100_SPI_PAGE_SIZE);
+        len_this_lp      = ((len - total) > bytes_this_page) ? bytes_this_page
+                                                             : (len - total);
+        ar7100_spi_write_page(dst, src, len_this_lp);
+        total += len_this_lp;
+    }
+
+    ar7100_spi_done();
+
+    return 0;
+}
+
+static void
+ar7100_spi_write_enable()  
+{
+    ar7100_reg_wr_nf(AR7100_SPI_FS, 1);                  
+    ar7100_reg_wr_nf(AR7100_SPI_WRITE, AR7100_SPI_CS_DIS);     
+    ar7100_spi_bit_banger(AR7100_SPI_CMD_WREN);             
+    ar7100_spi_go();
+}
+
+static void
+ar7100_spi_poll()   
+{
+    int rd;                                                 
+
+    do {
+        ar7100_reg_wr_nf(AR7100_SPI_WRITE, AR7100_SPI_CS_DIS);     
+        ar7100_spi_bit_banger(AR7100_SPI_CMD_RD_STATUS);        
+        ar7100_spi_delay_8();
+        rd = (ar7100_reg_rd(AR7100_SPI_RD_STATUS) & 1);               
+    }while(rd);
+}
+
+static void
+ar7100_spi_write_page(uint32_t addr, uint8_t *data, int len)
+{
+    int i;
+    uint8_t ch;
+
+    display(0x77);
+    ar7100_spi_write_enable();
+    ar7100_spi_bit_banger(AR7100_SPI_CMD_PAGE_PROG);
+    ar7100_spi_send_addr(addr);
+
+    for(i = 0; i < len; i++) {
+        ch = *(data + i);
+        ar7100_spi_bit_banger(ch);
+    }
+
+    ar7100_spi_go();
+    display(0x66);
+    ar7100_spi_poll();
+    display(0x6d);
+}
+
+static void
+ar7100_spi_sector_erase(uint32_t addr)
+{
+    ar7100_spi_write_enable();
+    ar7100_spi_bit_banger(AR7100_SPI_CMD_SECTOR_ERASE);
+    ar7100_spi_send_addr(addr);
+    ar7100_spi_go();
+    display(0x7d);
+    ar7100_spi_poll();
+}
+
+
diff --git a/board/ar7100/common/ar7100_flash.h b/board/ar7100/common/ar7100_flash.h
new file mode 100644
index 0000000000..d6a810fa24
--- /dev/null
+++ b/board/ar7100/common/ar7100_flash.h
@@ -0,0 +1,62 @@
+#ifndef _FLASH_H
+#define _FLASH_H
+
+#include "ar7100_soc.h"
+
+#define AR7100_SPI_FS           0x1f000000
+#define AR7100_SPI_CLOCK        0x1f000004
+#define AR7100_SPI_WRITE        0x1f000008
+#define AR7100_SPI_READ         0x1f000000
+#define AR7100_SPI_RD_STATUS    0x1f00000c
+
+#define AR7100_SPI_CS_DIS       0x70000
+#define AR7100_SPI_CE_LOW       0x60000
+#define AR7100_SPI_CE_HIGH      0x60100
+
+#define AR7100_SPI_CMD_WREN         0x06
+#define AR7100_SPI_CMD_RD_STATUS    0x05
+#define AR7100_SPI_CMD_FAST_READ    0x0b
+#define AR7100_SPI_CMD_PAGE_PROG    0x02
+#define AR7100_SPI_CMD_SECTOR_ERASE 0xd8
+
+#define AR7100_SPI_SECTOR_SIZE      (1024*64)
+#define AR7100_SPI_PAGE_SIZE        256
+
+
+#define display(_x)     ar7100_reg_wr_nf(0x18040008, (_x))
+
+/*
+ * primitives
+ */
+
+#define ar7100_be_msb(_val, _i) (((_val) & (1 << (7 - _i))) >> (7 - _i))
+
+#define ar7100_spi_bit_banger(_byte)  do {        \
+    int i;                                      \
+    for(i = 0; i < 8; i++) {                    \
+        ar7100_reg_wr_nf(AR7100_SPI_WRITE,      \
+                        AR7100_SPI_CE_LOW | ar7100_be_msb(_byte, i));  \
+        ar7100_reg_wr_nf(AR7100_SPI_WRITE,      \
+                        AR7100_SPI_CE_HIGH | ar7100_be_msb(_byte, i)); \
+    }       \
+}while(0);
+
+#define ar7100_spi_go() do {        \
+    ar7100_reg_wr_nf(AR7100_SPI_WRITE, AR7100_SPI_CE_LOW); \
+    ar7100_reg_wr_nf(AR7100_SPI_WRITE, AR7100_SPI_CS_DIS); \
+}while(0);
+
+
+#define ar7100_spi_send_addr(_addr) do {                    \
+    ar7100_spi_bit_banger(((addr & 0xff0000) >> 16));                 \
+    ar7100_spi_bit_banger(((addr & 0x00ff00) >> 8));                 \
+    ar7100_spi_bit_banger(addr & 0x0000ff);                 \
+}while(0);
+
+#define ar7100_spi_delay_8()    ar7100_spi_bit_banger(0)
+#define ar7100_spi_done()       ar7100_reg_wr_nf(AR7100_SPI_FS, 0)
+
+
+unsigned long  flash_get_geom (flash_info_t *flash_info);
+
+#endif /*_FLASH_H*/
diff --git a/board/ar7100/common/ar9100_pflash.c b/board/ar7100/common/ar9100_pflash.c
new file mode 100644
index 0000000000..1b87cd3488
--- /dev/null
+++ b/board/ar7100/common/ar9100_pflash.c
@@ -0,0 +1,325 @@
+#include <common.h>
+#include <jffs2/jffs2.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7100_soc.h"
+
+//----------------------------------------------------------------------------
+// Common device details.
+#define FLASHWORD(_x)			((CFG_FLASH_WORD_SIZE)(_x))
+
+#define FLASH_Read_ID                   FLASHWORD( 0x90 )
+#define FLASH_Read_ID_Exit              FLASHWORD( 0xF0 )
+#define FLASH_Reset                     FLASHWORD( 0xFF )
+#define FLASH_Program                   FLASHWORD( 0xA0 )
+#define FLASH_Block_Erase               FLASHWORD( 0x30 )
+
+#define FLASH_Data                      FLASHWORD( 0x80 )	// Data complement
+#define FLASH_Busy                      FLASHWORD( 0x44 )	// "Toggle" bit
+#define FLASH_Err                       FLASHWORD( 0x20 )
+#define FLASH_Sector_Erase_Timer        FLASHWORD( 0x08 )
+
+#define FLASH_Setup_Code1               FLASHWORD( 0xAA )
+#define FLASH_Setup_Code2               FLASHWORD( 0x55 )
+#define FLASH_Setup_Erase               FLASHWORD( 0x80 )
+#define AMD_SPANSION			0x227e
+#define VENDOR_ID(x)			(ushort) ((x & 0x00ff0000) >> 16)
+#define DEVICE_ID(x)			(ushort) (x & 0x0000ffff)
+
+/*
+ * globals
+ */
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+typedef struct ar9100_flash_geom {
+    ushort vendor_id;
+    ushort device_id;
+    char *name;
+    ulong nsectors;
+    ulong sector_size;
+    ulong size;
+} ar9100_flash_geom_t;
+
+ar9100_flash_geom_t flash_geom_tbl[] = {
+    {0x00bf, 0x2780, "SST-39VF400", 8, 0x01000, 0x080000},	/* 512 KB */
+    {0x00bf, 0x2782, "SST-39VF160", 32, 0x01000, 0x200000},	/* 2 MB   */
+    {0x00bf, 0x236b, "SST-39VF6401", 128, 0x01000, 0x800000},	/* 8 MB   */
+    {0x00bf, 0x236a, "SST-39VF6402", 128, 0x01000, 0x800000},	/* 8 MB   */
+    {0x00bf, 0x236d, "SST-39VF6402", 128, 0x01000, 0x800000},	/* 8 MB   */
+    {0x0001, 0x227e, "AMD-SPANSION", 128, 0x02000, 0x1000000},	/* 16 MB  */
+    {0xffff, 0xffff, NULL, 0, 0}	/* end list */
+};
+
+
+/*
+ * statics
+ */
+static int write_word(flash_info_t * info, ulong dest, ulong data);
+static ulong read_id(void);
+
+unsigned long flash_init(void)
+{
+    ulong sector_size;
+    ar9100_flash_geom_t *geom;
+    ushort venid, devid;
+
+    int i;
+
+    flash_info->flash_id = read_id();
+    venid = VENDOR_ID(flash_info->flash_id);
+    devid = DEVICE_ID(flash_info->flash_id);
+
+    for (i = 0; flash_geom_tbl[i].name != NULL; i++) {
+        if (venid == flash_geom_tbl[i].vendor_id &&
+            devid == flash_geom_tbl[i].device_id) {
+            break;
+        }
+    }
+
+    geom = &flash_geom_tbl[i];
+    if (geom->name == NULL) {
+        printf("Unknown flash device\n");
+        return -1;
+    }
+    flash_info->size = geom->size;	/* bytes */
+    flash_info->sector_count = geom->nsectors;
+    sector_size = (geom->sector_size * 16); /* One Erase block size */
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * sector_size);
+        flash_info->protect[i] = 0;
+    }
+    flash_print_info(flash_info);
+
+    return (flash_info->size);
+}
+
+
+void flash_print_info(flash_info_t * info)
+{
+    printf("Name: ");
+    switch (DEVICE_ID(info->flash_id))
+    {
+    case 0x2780: printf ("SST-39VF400");            break;
+    case 0x2782: printf ("SST-39VF160");            break;
+    case 0x236b: printf ("SST-39VF6401");           break;
+    case 0x236a: printf ("SST-39VF6402");           break;
+    case 0x236d: printf ("SST-39VF6402");           break;
+    case 0x227e: printf ("AMD-SPANSION");           break;
+    default:     printf ("Unknown Vendor ");        break;
+    }
+
+    printf(" Flash id: 0x%X, Size: %lu bytes.\n", info->flash_id, info->size);
+}
+
+int flash_erase(flash_info_t * info, int s_first, int s_last)
+{
+    int i = s_first;
+    volatile CFG_FLASH_WORD_SIZE *ROM =
+        (volatile CFG_FLASH_WORD_SIZE *) (info->start[0]);
+    int timeout;
+
+    printf("First %#x last %#x\n", s_first, s_last);
+
+    for (i = s_first; i <= s_last; i++) {
+        CFG_FLASH_WORD_SIZE state, prev_state, rd_data;
+        volatile CFG_FLASH_WORD_SIZE *addr_ptr =
+            (volatile CFG_FLASH_WORD_SIZE *) (info->start[i]);
+
+        // Program data [byte] - 6 step sequence
+        ROM[CFG_FLASH_ADDR0] = FLASH_Setup_Code1;
+        ROM[CFG_FLASH_ADDR1] = FLASH_Setup_Code2;
+        ROM[CFG_FLASH_ADDR0] = FLASH_Setup_Erase;
+        ROM[CFG_FLASH_ADDR0] = FLASH_Setup_Code1;
+        ROM[CFG_FLASH_ADDR1] = FLASH_Setup_Code2;
+        *addr_ptr = FLASH_Block_Erase;
+
+        printf("\b\b\b\b\b %3d\%",(( ((i-s_first) + 1) * 100) / ((s_last-s_first) + 1 )) );
+
+#if 1
+            // Wait for erase completion.
+            timeout = 10000000;
+            while (timeout) {
+		state = *addr_ptr;
+		if (FLASHWORD(0xffff) == state) {
+	    		break;
+		}
+		timeout--;
+            }
+#else
+            // Wait for completion (bit 6 stops toggling)
+            timeout = 5000000;
+            prev_state = *addr_ptr & FLASH_Busy;
+
+            while (timeout) {
+		rd_data = *addr_ptr;
+		state = rd_data & FLASH_Busy;
+		if ((prev_state == state) && (rd_data == FLASHWORD(0xffff))) {
+	    		break;
+	       }
+	       timeout--;
+	       prev_state = state;
+           }
+#endif
+        if (!timeout){
+	    printf("Error erasing flash...\n");
+            return -1;
+        }
+    }
+        printf("\n");
+
+    return 0;
+}
+
+/*
+ * Copy memory to flash, returns:
+ * Assumption: Caller has already erased the appropriate sectors.
+ * 0 - OK
+ * 1 - write timeout
+ */
+int write_buff(flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+    ulong cp, wp, data;
+    int i, l, rc, j=0, count;
+
+    wp = (addr & ~3);   /* get lower word aligned address */
+    count=cnt;
+    printf("\n");
+
+    /*
+     * handle unaligned start bytes
+     */
+    if ((l = addr - wp) != 0) {
+        data = 0;
+        for (i = 0, cp = wp; i < l; ++i, ++cp) {
+            data = (data << 8) | (*(uchar *) cp);
+        }
+        for (; i < 4 && cnt > 0; ++i) {
+            data = (data << 8) | *src++;
+            --cnt;
+            ++cp;
+        }
+        for (; cnt == 0 && i < 4; ++i, ++cp) {
+            data = (data << 8) | (*(uchar *) cp);
+        }
+
+        if ((rc = write_word(info, wp, data)) != 0) {
+            return (rc);
+        }
+	j = j + 4;
+        wp += 4;
+    }
+
+    /*
+     * handle word aligned part
+     */
+    while (cnt >= 4) {
+        data = 0;
+        for (i = 0; i < 4; ++i) {
+            data = (data << 8) | *src++;
+        }
+        if(!(j%1024))
+	   printf("\b\b\b\b\b %3d\%",((j * 100) / count));
+        if ((rc = write_word(info, wp, data)) != 0) {
+            return (rc);
+        }
+        wp += 4;
+        cnt -= 4;
+        j += 4;
+    }
+
+    printf("\b\b\b\b\b %3d\%\n",(((j + 4) * 100 ) / count));
+    if (cnt == 0) {
+        return (0);
+    }
+
+    /*
+     * handle unaligned tail bytes
+     */
+    data = 0;
+    for (i = 0, cp = wp; i < 4 && cnt > 0; ++i, ++cp) {
+        data = (data << 8) | *src++;
+        --cnt;
+    }
+    for (; i < 4; ++i, ++cp) {
+        data = (data << 8) | (*(uchar *) cp);
+    }
+    return (write_word(info, wp, data));
+}
+
+static int write_word(flash_info_t * info, ulong dest, ulong data)
+{
+    volatile CFG_FLASH_WORD_SIZE *ROM =
+        (CFG_FLASH_WORD_SIZE *) (info->start[0]);
+    volatile CFG_FLASH_WORD_SIZE *dest2 = (CFG_FLASH_WORD_SIZE *) dest;
+    CFG_FLASH_WORD_SIZE *data2 = (CFG_FLASH_WORD_SIZE *) & data;
+    int i;
+
+    /* Check if Flash is (sufficiently) erased */
+    if ((*((vu_long *) dest) & data) != data) {
+        return (2);
+    }
+
+    for (i = 0; i < 4 / sizeof(CFG_FLASH_WORD_SIZE); i++) {
+        CFG_FLASH_WORD_SIZE state, prev_state;
+        int timeout;
+
+        ROM[CFG_FLASH_ADDR0] = FLASH_Setup_Code1;
+        ROM[CFG_FLASH_ADDR1] = FLASH_Setup_Code2;
+        ROM[CFG_FLASH_ADDR0] = FLASH_Program;
+        dest2[i] = data2[i];
+
+#if 1
+            timeout = 10000000;
+            while (timeout) {
+		if (dest2[i] == data2[i]) {
+	   		 break;
+		}
+		timeout--;
+            }
+#else
+            // Wait for completion (bit 6 stops toggling)
+            timeout = 5000000;
+            prev_state = dest2[i] & FLASH_Busy;
+            while (timeout) {
+		state = dest2[i] & FLASH_Busy;
+		if (prev_state == state) {
+	    		break;
+		}
+		timeout--;
+		prev_state = state;
+            }
+#endif
+
+        if (!timeout) {
+		printf("Error while Writing into flash...\n");
+            return -1;
+	}
+    }
+
+    return (0);
+}
+
+static ulong read_id()
+{
+    volatile CFG_FLASH_WORD_SIZE *ROM;
+    ulong id;
+
+    ROM = (volatile CFG_FLASH_WORD_SIZE *) CFG_FLASH_BASE;
+
+    ROM[CFG_FLASH_ADDR0] = FLASH_Setup_Code1;
+    ROM[CFG_FLASH_ADDR1] = FLASH_Setup_Code2;
+    ROM[CFG_FLASH_ADDR0] = FLASH_Read_ID;
+
+    udelay(10000);
+
+    id = ROM[0];
+    id = (id << 16) | (ROM[1] & 0xffff);
+
+    ROM[CFG_FLASH_ADDR0] = FLASH_Setup_Code1;
+    ROM[CFG_FLASH_ADDR1] = FLASH_Setup_Code2;
+    ROM[CFG_FLASH_ADDR0] = FLASH_Read_ID_Exit;
+
+    udelay(10000);
+    return id;
+}
diff --git a/board/ar7100/common/athr_phy.h b/board/ar7100/common/athr_phy.h
new file mode 100644
index 0000000000..6fe9c4d416
--- /dev/null
+++ b/board/ar7100/common/athr_phy.h
@@ -0,0 +1,81 @@
+#ifndef _ATHR_PHY_H
+#define _ATHR_PHY_H
+
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+int athr_phy_is_up(int unit);
+int athr_phy_is_fdx(int unit);
+int athr_phy_speed(int unit);
+int athr_phy_setup(int unit);
+
+typedef enum {
+	AG7100_PHY_SPEED_10T,
+	AG7100_PHY_SPEED_100TX,
+	AG7100_PHY_SPEED_1000T,
+}ag7100_phy_speed_t;
+
+#endif /* _ATHR_PHY_H */
+
diff --git a/board/ar7100/common/athrf1_phy.c b/board/ar7100/common/athrf1_phy.c
new file mode 100644
index 0000000000..b64f69f579
--- /dev/null
+++ b/board/ar7100/common/athrf1_phy.c
@@ -0,0 +1,196 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright c 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+#ifdef __BDI
+#include "bdi.h"
+#endif
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include "ar7100_soc.h"
+
+#include "athr_phy.h"
+#define MODULE_NAME "ATHRF1E"
+
+#define mdelay(_x)         udelay((_x)*1000)
+
+typedef struct {
+  int              is_enet_port;
+  int              mac_unit;
+  unsigned int     phy_addr;
+}athr_phy_t;
+
+athr_phy_t phy_info[] = {
+#ifdef CFG_BOARD_PB47
+    {is_enet_port: 1,
+     mac_unit    : 1,
+     phy_addr    : 0x00}
+#else
+    {is_enet_port: 1,
+     mac_unit    : 0,
+     phy_addr    : 0x00},
+    {is_enet_port: 1,
+     mac_unit    : 1,
+     phy_addr    : 0x01}
+#endif
+};
+
+static athr_phy_t *
+athr_phy_find(int unit)
+{
+    int i;
+    athr_phy_t *phy;
+
+    for(i = 0; i < sizeof(phy_info)/sizeof(athr_phy_t); i++) {
+        phy = &phy_info[i];
+        
+        if (phy->is_enet_port && (phy->mac_unit == unit)) 
+            return phy;
+    }
+    
+    return NULL;
+}
+
+/* N.B.: On AR7100, MDC/MDIO is only on MAC0. So, trying to access PHY
+ * registers using MAC1 is futile. Reads will give incorrect values and
+ * writes do not take effect. So, always use as shown below:
+ *
+ *    phy_reg_read(0, ...) phy_reg_write(0, ...) OR
+ *    ag7100_miiphy_read("eth0", ...) ag7100_miiphy_write("eth1", ...)
+ */
+int
+athr_phy_setup(int unit)
+{
+    athr_phy_t *phy = athr_phy_find(unit);
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+
+    if (!phy) {
+        printf(MODULE_NAME": \nNo phy found for unit %d\n", unit);
+        return;
+    }
+    
+     /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+
+    phy_reg_write(0, phy->phy_addr, ATHR_AUTONEG_ADVERT,
+                  ATHR_ADVERTISE_ALL);
+
+    phy_reg_write(0, phy->phy_addr, ATHR_1000BASET_CONTROL,
+                  ATHR_ADVERTISE_1000FULL);
+
+    /* delay rx_clk */
+    phy_reg_write(0, phy->phy_addr, 0x1D, 0x0);
+    phy_reg_write(0, phy->phy_addr, 0x1E, 0x34E); /* 0x24E - no delay, 0x34E - 2ns delay */
+
+    /* delay tx_clk */
+    phy_reg_write(0, phy->phy_addr, 0x1D, 0x5);
+    phy_reg_write(0, phy->phy_addr, 0x1E, 0x3D47); /* 0x3C47 - no delay, 0x3D47 - 1.5ns delay */
+
+    /* Reset PHYs*/
+    phy_reg_write(0, phy->phy_addr, ATHR_PHY_CONTROL,
+                  ATHR_CTRL_AUTONEGOTIATION_ENABLE 
+                  | ATHR_CTRL_SOFTWARE_RESET);
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (timeout=20; timeout; mdelay(150), timeout--) {
+        phy_reg_read(0, phy->phy_addr, ATHR_PHY_CONTROL, &phyHwStatus);
+
+        if (!ATHR_RESET_DONE(phyHwStatus))
+            continue;
+
+        phy_reg_read(0, phy->phy_addr, ATHR_PHY_STATUS, &phyHwStatus);
+        if (ATHR_AUTONEG_DONE(phyHwStatus)) {
+                printf(MODULE_NAME": Port %d, Auto-Negotiation Success\n", unit);
+                break;
+        }
+    }
+    if (timeout == 0)
+        printf(MODULE_NAME": Port %d, Auto-Negotiation timeout\n", unit);
+}
+
+int
+athr_phy_is_up(int unit)
+{
+    uint16_t status;
+    athr_phy_t *phy = athr_phy_find(unit);
+
+    if (!phy) 
+        return 0;
+
+    phy_reg_read(0, phy->phy_addr, ATHR_PHY_SPEC_STATUS, &status);
+
+    if (status & ATHR_STATUS_LINK_PASS)
+        return 1;
+
+    return 0;
+}
+
+int
+athr_phy_is_fdx(int unit)
+{
+    uint16_t status;
+    athr_phy_t *phy = athr_phy_find(unit);
+    int ii = 200;
+
+    if (!phy) 
+        return 0;
+    do {
+        phy_reg_read(0, phy->phy_addr, ATHR_PHY_SPEC_STATUS, &status);
+        mdelay(10);
+    } while((!(status & ATHR_STATUS_RESOVLED)) && --ii);
+    
+    if (status & ATHER_STATUS_FULL_DEPLEX)
+        status = FULL;
+    else
+        status = HALF;
+    
+    return (status);
+}
+int
+athr_phy_speed(int unit)
+{
+    uint16_t status;
+    athr_phy_t *phy = athr_phy_find(unit);
+    int ii = 200;
+
+    if (!phy) 
+        return 0;
+    do {
+        phy_reg_read(0, phy->phy_addr, ATHR_PHY_SPEC_STATUS, &status);
+        mdelay(10);
+    }while((!(status & ATHR_STATUS_RESOVLED)) && --ii);
+
+    status = ((status & ATHER_STATUS_LINK_MASK) >> ATHER_STATUS_LINK_SHIFT);
+
+    switch(status) {
+    case 0:
+        return _10BASET;
+    case 1:
+        return _100BASET;
+    case 2:
+        return _1000BASET;
+    default:
+        printf(MODULE_NAME": Unkown speed read!\n");
+    }
+    return -1;
+}
diff --git a/board/ar7100/common/athrs16_phy.c b/board/ar7100/common/athrs16_phy.c
new file mode 100644
index 0000000000..8331d3102c
--- /dev/null
+++ b/board/ar7100/common/athrs16_phy.c
@@ -0,0 +1,681 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <asm/addrspace.h>
+#include "phy.h"
+#include "ar7100_soc.h"
+#include "../cpu/mips/ar7100/ag7100.h"
+#include "../cpu/mips/ar7100/ag7100_phy.h"
+
+
+/* PHY selections and access functions */
+
+#if 0
+typedef enum {
+    PHY_SRCPORT_INFO, 
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG, 
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+#endif
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X) printf X
+
+#define DRV_DEBUG_PHYERROR  0x00000001
+#define DRV_DEBUG_PHYCHANGE 0x00000002
+#define DRV_DEBUG_PHYSETUP  0x00000004
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+/*depend on connection between cpu mac and s16 mac*/
+#ifdef CFG_BOARD_PB45
+#define ENET_UNIT_LAN 1  
+#define ENET_UNIT_WAN 0
+#elif CFG_BOARD_AP96
+#define ENET_UNIT_LAN 0  /* AR7100's MAC 0 is connected to LAN */
+#define ENET_UNIT_WAN 1  /* AR7100's MAC 1 is connected to WAN */
+#else
+#error "CFG_BOARD_ not defined!"
+#endif
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+#define ATHR_IND_PHY 4
+#define MODULE_NAME "ATHRS16"
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* phy port 0 -- LAN port 0 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY4_ADDR, 
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00, 
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+static uint8_t athr16_init_flag = 0;
+#define ATHR_GLOBALREGBASE    0
+
+//#define ATHR_PHY_MAX (sizeof(athrPhyInfo) / sizeof(athrPhyInfo[0]))
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+            
+/* Forward references */
+BOOL athrs16_phy_is_link_alive(int phyUnit);
+static uint32_t athrs16_reg_read(uint32_t reg_addr);
+static void athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val);
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+
+#ifdef CFG_BOARD_PB45
+/* PB45 runs at PLL_680_340_170, and ag7100_ahb_feq_adjust lowers the
+** AHB frequency from 170 to about 113MHz and it didn't appear that
+** performing s16 register init at 170MHz causes a problem
+*/
+void ag7100_ahb_feq_adjust(void) {}
+void ag7100_ahb_feq_restore(void) {}
+#else
+#define get_field_val(_reg, _mask, _shift, _res_reg)     \
+    do { \
+        unsigned int temp;	\
+        temp = ar7100_reg_rd(_reg); \
+        temp &= (unsigned int)_mask;\
+        _res_reg  = temp >> _shift; \
+    } while (0)
+
+#define set_field_val(_reg, _mask, _shift, _val)                \
+    do { \
+        unsigned int temp; \
+        temp = ar7100_reg_rd(_reg); \
+        temp &= ~_mask;  \
+        temp |= _val << _shift;  \
+        ar7100_reg_wr(_reg, temp);\
+    } while (0)
+
+static unsigned int old_ahb_div = 0;
+
+void ag7100_ahb_feq_adjust(void)
+{
+    unsigned int pll_fb = 0, ahb_div = 0, cpu_div = 0, mask = 0; 
+
+    mask = PLL_CONFIG_PLL_FB_MASK;
+    get_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_PLL_FB_SHIFT, pll_fb);
+
+    mask = PLL_CONFIG_AHB_DIV_MASK;
+    get_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_AHB_DIV_SHIFT, old_ahb_div);
+
+    mask = PLL_CONFIG_CPU_DIV_MASK;
+    get_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_CPU_DIV_SHIFT, cpu_div);
+    
+    //ahb_div = ((((pll_fb + 1) * 40)*2/(200*(cpu_div + 1))) + 1)/2 - 1;
+    ahb_div = ( (2*pll_fb + 2)/(5*cpu_div + 5) + 1)/2 - 1;
+    mask = PLL_CONFIG_AHB_DIV_MASK;
+    set_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_AHB_DIV_SHIFT, ahb_div);
+}
+
+void ag7100_ahb_feq_restore(void)
+{
+    unsigned int mask = 0;
+    mask = PLL_CONFIG_AHB_DIV_MASK;
+    set_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_AHB_DIV_SHIFT, old_ahb_div); 
+}
+#endif
+
+void phy_mode_setup() 
+{
+    /*work around for phy4 rgmii mode*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);    
+
+    /*rx delay*/ 
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 0);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x824e);  
+
+    /*tx delay*/ 
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 5);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x3d47);    
+
+}
+
+void athrs16_reg_init()
+{
+    if (athr16_init_flag)
+        return;
+
+    /*Power on strip mode setup*/
+#ifdef CFG_BOARD_PB45
+    athrs16_reg_write(0x208, 0x2fd0001);  /* vlan */   
+    athrs16_reg_write(0x108, 0x2be0001);  /* vlan */ 
+#elif CFG_BOARD_AP96
+    athrs16_reg_write(0x8, 0x012e1bea);
+#endif
+    
+    athrs16_reg_write(0x100, 0x7e);
+    athrs16_reg_write(0x200, 0x200);
+    athrs16_reg_write(0x300, 0x200);
+    athrs16_reg_write(0x400, 0x200);
+    athrs16_reg_write(0x500, 0x200);
+#ifdef CFG_BOARD_PB45
+    athrs16_reg_write(0x600, 0x200);
+#elif CFG_BOARD_AP96
+    athrs16_reg_write(0x600, 0x0);
+#endif
+
+    athrs16_reg_write(0x38, 0xc000050e);
+        
+#ifdef HEADER_EN        
+    athrs16_reg_write(0x104, 0x4804);
+#else
+    athrs16_reg_write(0x104, 0x4004);
+#endif
+       
+    athrs16_reg_write(0x60, 0xffffffff);
+    athrs16_reg_write(0x64, 0xaaaaaaaa);
+    athrs16_reg_write(0x68, 0x55555555);    
+    athrs16_reg_write(0x6c, 0x0);    
+
+    athrs16_reg_write(0x70, 0x41af);
+
+    athr16_init_flag = 1;
+}
+
+/******************************************************************************
+*
+* athrs16_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs16_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+
+/******************************************************************************
+*
+* athrs16_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs16_phy_setup(int ethUnit)
+{
+    int         phyUnit;
+    uint16_t    phyHwStatus;
+    uint16_t    timeout;
+    int         liveLinks = 0;
+    uint32_t    phyBase = 0;
+    BOOL        foundPhy = FALSE;
+    uint32_t    phyAddr = 0;
+    
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        
+        phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,
+                      ATHR_ADVERTISE_ALL);
+
+        phy_reg_write(phyBase, phyAddr, ATHR_1000BASET_CONTROL,
+                      ATHR_ADVERTISE_1000FULL);
+
+        /* Reset PHYs*/
+        phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+                      ATHR_CTRL_AUTONEGOTIATION_ENABLE 
+                      | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+    
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    sysMsDelay(1000);
+    
+    /*
+     * Wait up to .75 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit, 
+            phy_reg_read(ATHR_PHYBASE(phyUnit),
+                       ATHR_PHYADDR(phyUnit),
+                       ATHR_PHY_SPEC_STATUS)));
+    }
+
+    if (ethUnit == ENET_UNIT_LAN) {
+        ag7100_ahb_feq_adjust();  
+        athrs16_reg_init();
+        ag7100_ahb_feq_restore();       
+    }    
+    
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs16_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs16_phy_is_fdx(int ethUnit)
+{
+    int         phyUnit;
+    uint32_t    phyBase;
+    uint32_t    phyAddr;
+    uint16_t    phyHwStatus;
+    int         ii = 200;
+    
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+    
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
+                                              ATHR_PHY_SPEC_STATUS);
+        	sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+
+/******************************************************************************
+*
+* athrs16_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7100_PHY_SPEED_10T, AG7100_PHY_SPEED_100TX;
+*               AG7100_PHY_SPEED_1000T;
+*/
+
+int
+athrs16_phy_speed(int ethUnit)
+{
+    int         phyUnit;
+    uint16_t    phyHwStatus;
+    uint32_t    phyBase;
+    uint32_t    phyAddr;
+    int         ii = 200;
+    
+    if (ethUnit == ENET_UNIT_LAN)
+        return AG7100_PHY_SPEED_1000T;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+            
+            do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
+                                              ATHR_PHY_SPEC_STATUS);
+                sysMsDelay(10);
+            }while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                return AG7100_PHY_SPEED_10T;
+            case 1:
+                return AG7100_PHY_SPEED_100TX;
+            case 2:
+                return AG7100_PHY_SPEED_1000T;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        }
+    }
+
+    return AG7100_PHY_SPEED_10T;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs16_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS);
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+            phyHwControl = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+            /* Check for AutoNegotiation complete */            
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+
+    return (linkCount);
+}
+
+static uint32_t
+athrs16_reg_read(uint32_t reg_addr)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr, tmp_val, reg_val;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as MIBs, since it is read/clear, we should */
+    /* read the lower 16-bit register then the higher one */
+
+    /* read register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    reg_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    tmp_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+    reg_val |= (tmp_val << 16);
+
+    return reg_val;   
+}
+
+static void
+athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as ARL and VLAN, since they include BUSY bit */
+    /* in lower address, we should write the higher 16-bit register then the */
+    /* lower one */
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) ((reg_val >> 16) & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* write register in lower address */
+    reg_word_addr--;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) (reg_val & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val); 
+}
+
diff --git a/board/ar7100/common/athrs16_phy.h b/board/ar7100/common/athrs16_phy.h
new file mode 100644
index 0000000000..652b9bace1
--- /dev/null
+++ b/board/ar7100/common/athrs16_phy.h
@@ -0,0 +1,105 @@
+
+#ifndef _ATHRS16_PHY_H
+#define _ATHRS16_PHY_H
+
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+/*add feature define here*/
+//#define FULL_FEATURE
+
+#ifdef CONFIG_ATHRS16_PHY 
+#undef HEADER_REG_CONF
+#undef HEADER_EN
+#endif
+
+void athrs16_reg_init(void);
+int athrs16_phy_is_up(int unit);
+int athrs16_phy_is_fdx(int unit);
+int athrs16_phy_speed(int unit);
+BOOL athrs16_phy_setup(int unit);
+
+typedef enum {
+    AG7100_PHY_SPEED_10T = 10,
+    AG7100_PHY_SPEED_100TX = 100,
+    AG7100_PHY_SPEED_1000T = 1000,
+}ag7100_phy_speed_t;
+
+#endif
+
+
diff --git a/board/ar7100/common/athrs26_phy.c b/board/ar7100/common/athrs26_phy.c
new file mode 100644
index 0000000000..62ed60b5df
--- /dev/null
+++ b/board/ar7100/common/athrs26_phy.c
@@ -0,0 +1,828 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include "ar7100_soc.h"
+#include "athrs26_phy.h"
+
+
+/* PHY selections and access functions */
+
+typedef enum {
+    PHY_SRCPORT_INFO, 
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG, 
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#ifdef DEBUG
+#define DRV_DEBUG 1
+#endif
+#define DRV_DEBUG 1
+
+#define DRV_DEBUG_PHYERROR  0x00000001
+#define DRV_DEBUG_PHYCHANGE 0x00000002
+#define DRV_DEBUG_PHYSETUP  0x00000004
+
+#if DRV_DEBUG
+int athrPhyDebug = DRV_DEBUG_PHYERROR;
+
+#define DRV_LOG(FLG, X0, X1, X2, X3, X4, X5, X6)    \
+{                                                   \
+    if (athrPhyDebug & (FLG)) {                       \
+        logMsg(X0, X1, X2, X3, X4, X5, X6);         \
+    }                                               \
+}
+
+#define DRV_MSG(x,a,b,c,d,e,f)                      \
+    logMsg(x,a,b,c,d,e,f)
+
+#define DRV_PRINT(FLG, X)                           \
+{                                                   \
+    if (athrPhyDebug & (FLG)) {                       \
+        printf X;                                   \
+    }                                               \
+}
+
+#else /* !DRV_DEBUG */
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+#endif
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+#define ENET_UNIT_LAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* phy port 0 -- LAN port 0 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+     FALSE,
+     1,
+     0,
+     ATHR_PHY4_ADDR, 
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00, 
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+#ifdef CFG_ATHRHDR_EN
+typedef struct {
+    uint8_t data[ATHRHDR_MAX_DATA];
+    uint8_t len;
+    uint32_t seq;
+} cmd_resp_t;
+
+typedef struct {
+ uint16_t reg_addr;
+ uint16_t cmd_len;
+ uint8_t *reg_data;
+}cmd_write_t;
+
+static cmd_write_t cmd_write,cmd_read;
+static cmd_resp_t cmd_resp;
+static struct eth_device *lan_mac;
+//static atomic_t seqcnt = ATOMIC_INIT(0);
+static int  seqcnt = 0;
+static int cmd = 1;
+//volatile uchar AthrHdrPkt[60];
+#endif
+
+#define ATHR_GLOBALREGBASE    0
+
+//#define ATHR_PHY_MAX (sizeof(athrPhyInfo) / sizeof(athrPhyInfo[0]))
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+            
+/* Forward references */
+BOOL       athrs26_phy_is_link_alive(int phyUnit);
+static uint32_t athrs26_reg_read(uint16_t reg_addr);
+static void athrs26_reg_write(uint16_t reg_addr, 
+                              uint32_t reg_val);
+
+/******************************************************************************
+*
+* athrs26_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+
+void athrs26_reg_init()
+{
+
+    athrs26_reg_write(0x200, 0x200);
+    athrs26_reg_write(0x300, 0x200);
+    athrs26_reg_write(0x400, 0x200);
+    athrs26_reg_write(0x500, 0x200);
+    athrs26_reg_write(0x600, 0x7d);
+
+#ifdef S26_VER_1_0
+    phy_reg_write(0, 0, 29, 41);
+    phy_reg_write(0, 0, 30, 0);
+    phy_reg_write(0, 1, 29, 41);
+    phy_reg_write(0, 1, 30, 0);
+    phy_reg_write(0, 2, 29, 41);
+    phy_reg_write(0, 2, 30, 0);
+    phy_reg_write(0, 3, 29, 41);
+    phy_reg_write(0, 3, 30, 0);
+    phy_reg_write(0, 4, 29, 41);
+    phy_reg_write(0, 4, 30, 0);
+#endif
+
+    athrs26_reg_write(0x38, 0xc000050e);
+
+#ifdef CFG_ATHRHDR_EN
+    athrs26_reg_write(0x104, 0x4804);
+#else
+    athrs26_reg_write(0x104, 0x4004);
+#endif
+
+    athrs26_reg_write(0x60, 0xffffffff);
+    athrs26_reg_write(0x64, 0xaaaaaaaa);
+    athrs26_reg_write(0x68, 0x55555555);
+    athrs26_reg_write(0x6c, 0x0);
+
+    athrs26_reg_write(0x70, 0x41af);
+}
+
+BOOL
+athrs26_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS, &phyHwStatus);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+
+/*****************************************************************************
+*Following fucntion accepts ethUnit as parameter and  restarts autonegotiation 
+* on corresponding port.
+* 
+**/
+individual_phyreset(int ethUnit)
+{   uint32_t    phyBase = 0;
+    uint32_t    phyAddr = 0;
+    
+    phyBase = ATHR_PHYBASE(ethUnit);
+    phyAddr = ATHR_PHYADDR(ethUnit);
+    printf("Resetting phy on port %d...\n",ethUnit);
+    phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+                      (ATHR_CTRL_AUTONEGOTIATION_ENABLE |ATHR_CTRL_RESTART_AUTONEGOTIATION));
+    return 0;
+}
+/******************************************************************************
+*
+* athrs26_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs26_phy_setup(int ethUnit)
+{
+    int         phyUnit;
+    uint16_t    phyHwStatus;
+    uint16_t    timeout;
+    int         liveLinks = 0;
+    uint32_t    phyBase = 0;
+    BOOL        foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+    uint32_t  regVal;
+    
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        
+        phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,
+                      ATHR_ADVERTISE_ALL);
+
+        /* Reset PHYs*/
+        phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+                      ATHR_CTRL_AUTONEGOTIATION_ENABLE 
+                      | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+    
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    sysMsDelay(1000);
+    
+    /*
+     * Wait up to .75 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL, &phyHwStatus);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+
+        phy_reg_read(ATHR_PHYBASE(phyUnit), ATHR_PHYADDR(phyUnit), 
+                    ATHR_PHY_SPEC_STATUS, &regVal);
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Specific Status=%4.4x\n", ethUnit, regVal)); 
+    }
+#if 0
+    /* if using header for register configuration, we have to     */
+    /* configure s26 register after frame transmission is enabled */
+
+    athrs26_reg_write(0x200, 0x200);
+    athrs26_reg_write(0x300, 0x200);
+    athrs26_reg_write(0x400, 0x200);
+    athrs26_reg_write(0x500, 0x200);
+    athrs26_reg_write(0x600, 0x200);
+	athrs26_reg_write(0x38, 0x50e);
+#endif
+#ifndef CFG_ATHRHDR_EN       
+/* if using header for register configuration, we have to     */
+    /* configure s26 register after frame transmission is enabled */
+        athrs26_reg_init();
+#endif
+    
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs26_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1  --> FULL
+*    0 --> HALF
+*/
+int
+athrs26_phy_is_fdx(int ethUnit)
+{
+    int         phyUnit;
+    uint32_t    phyBase;
+    uint32_t    phyAddr;
+    uint16_t    phyHwStatus;
+    int         ii = 200;
+    
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+    
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS, &phyHwStatus);
+        	    sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+
+/******************************************************************************
+*
+* athrs26_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7100_PHY_SPEED_10T, AG7100_PHY_SPEED_100TX;
+*               AG7100_PHY_SPEED_1000T;
+*/
+
+BOOL
+athrs26_phy_speed(int ethUnit)
+{
+    int         phyUnit;
+    uint16_t    phyHwStatus;
+    uint32_t    phyBase;
+    uint32_t    phyAddr;
+    int         ii = 200;
+    
+    if (ethUnit == ENET_UNIT_LAN)
+        return _100BASET;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+            
+            do {
+                phy_reg_read(phyBase, phyAddr, 
+                                           ATHR_PHY_SPEC_STATUS, &phyHwStatus);
+                sysMsDelay(10);
+            }while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                return _10BASET;
+            case 1:
+                return _100BASET;
+            case 2:
+                return _1000BASET;
+            default:
+                DRV_PRINT(DRV_DEBUG_PHYERROR, ("Unkown speed read!\n"));
+            }
+        }
+    }
+
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs26_phy_is_up(int ethUnit)
+{
+    int             phyUnit;
+    uint16_t        phyHwStatus;
+    athrPhyInfo_t  *lastStatus;
+    int             linkCount   = 0;
+    int             lostLinks   = 0;
+    int             gainedLinks = 0;
+    uint32_t        phyBase;
+    uint32_t        phyAddr;
+#ifdef CFG_ATHRHDR_REG
+    /* if using header to config s26, the link of MAC0 should always be up */
+    if (ethUnit == ENET_UNIT_LAN)
+        return 1;
+#endif
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+
+        lastStatus = &athrPhyInfo[phyUnit];
+        phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS, &phyHwStatus);
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS, &phyHwStatus);
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+            /* Check for AutoNegotiation complete */            
+            if (ATHR_AUTONEG_DONE(phyHwStatus)) {
+                //printk("autoneg done\n");
+                gainedLinks++;
+                linkCount++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+            }
+        }
+    }
+
+    return (linkCount);
+
+#if 0
+    if (linkCount == 0) {
+        if (lostLinks) {
+            /* We just lost the last link for this MAC */
+            phyLinkLost(ethUnit);
+        }
+    } else {
+        if (gainedLinks == linkCount) {
+            /* We just gained our first link(s) for this MAC */
+            phyLinkGained(ethUnit);
+        }
+    }
+#endif
+}
+
+#ifdef CFG_ATHRHDR_EN
+void athr_hdr_timeout(void){
+	printf("%s\n",__func__);
+	eth_halt();
+        NetState = NETLOOP_FAIL; 
+}
+
+void athr_hdr_handler(uchar *recv_pkt, unsigned dest, unsigned src, unsigned len){
+	header_receive_pkt(recv_pkt);
+	NetState = NETLOOP_SUCCESS;
+}
+static int
+athrs26_header_config_reg (struct eth_device *dev, uint8_t wr_flag,
+                           uint16_t reg_addr, uint16_t cmd_len,
+                           uint8_t *val)
+{
+    at_header_t at_header;
+    reg_cmd_t reg_cmd;
+    uchar *AthrHdrPkt;
+
+    AthrHdrPkt = NetTxPacket - 2;
+
+    if(AthrHdrPkt == NULL) {
+		printf("Null packet\n");
+		return;
+    }
+    memset(AthrHdrPkt,0,62);
+
+    /*fill at_header*/
+    at_header.reserved0 = 0x10;  //default
+    at_header.priority = 0;
+    at_header.type = 0x5;
+    at_header.broadcast = 0;
+    at_header.from_cpu = 1;
+    at_header.reserved1 = 0x01; //default
+    at_header.port_num = 0;
+
+    AthrHdrPkt[2] = at_header.port_num;
+    AthrHdrPkt[2] |= at_header.reserved1 << 4;
+    AthrHdrPkt[2] |= at_header.from_cpu << 6;
+    AthrHdrPkt[2] |= at_header.broadcast << 7;
+
+    AthrHdrPkt[3] = at_header.type;
+    AthrHdrPkt[3] |= at_header.priority << 4;
+    AthrHdrPkt[3] |= at_header.reserved0 << 6;
+
+
+    /*fill reg cmd*/
+    if(cmd_len > 4)
+        cmd_len = 4;//only support 32bits register r/w
+
+    reg_cmd.reg_addr = reg_addr&0x3FFFC;
+    reg_cmd.cmd_len = cmd_len;
+    reg_cmd.cmd = wr_flag;
+    reg_cmd.reserved2 = 0x5; //default
+    reg_cmd.seq_num = seqcnt;
+
+    AthrHdrPkt[4] = reg_cmd.reg_addr & 0xff;
+    AthrHdrPkt[5] = (reg_cmd.reg_addr & 0xff00) >> 8;
+    AthrHdrPkt[6] = (reg_cmd.reg_addr & 0x30000) >> 16;
+    AthrHdrPkt[6] |= reg_cmd.cmd_len << 4;
+    AthrHdrPkt[7] = reg_cmd.cmd << 4;
+    AthrHdrPkt[7] |= reg_cmd.reserved2 << 5;
+    AthrHdrPkt[8] = (reg_cmd.seq_num & 0x7f) << 1;
+    AthrHdrPkt[9] = (reg_cmd.seq_num & 0x7f80) >> 7;
+    AthrHdrPkt[10] = (reg_cmd.seq_num & 0x7f8000) >> 15;
+    AthrHdrPkt[11] = (reg_cmd.seq_num & 0x7f800000) >> 23;
+
+    /*fill reg data*/
+    if(!wr_flag)//write
+        memcpy((AthrHdrPkt + 12), val, cmd_len);
+    
+   /* add identify for header */
+    AthrHdrPkt[0] = 0x7f;
+    AthrHdrPkt[1] = 0x5d;
+
+
+    /*start xmit*/
+    if(dev == NULL) {
+	printf("ERROR device not found\n");
+	return -1;
+    }
+    header_xmit(dev, AthrHdrPkt ,62);
+    return 0;
+}
+void athr_hdr_func(void) {
+
+   NetSetTimeout (1 * CFG_HZ,athr_hdr_timeout );
+   NetSetHandler (athr_hdr_handler);
+
+   if(cmd) 
+   	athrs26_header_config_reg(lan_mac, cmd, cmd_read.reg_addr, cmd_read.cmd_len, cmd_read.reg_data);
+   else 
+        athrs26_header_config_reg(lan_mac, cmd, cmd_write.reg_addr, cmd_write.cmd_len, cmd_write.reg_data);
+}
+static int
+athrs26_header_write_reg(uint16_t reg_addr, uint16_t cmd_len, uint8_t *reg_data)
+{
+    int i = 2;
+    cmd_write.reg_addr = reg_addr;
+    cmd_write.cmd_len = cmd_len;
+    cmd_write.reg_data = reg_data;
+    cmd = 0;
+    seqcnt++;
+
+    do {
+	if (NetLoop(ATHRHDR) >= 0) /* polls for read/write ack from PHY */
+	   break;
+    } while (i--);
+
+    return i;
+}
+
+static int
+athrs26_header_read_reg(uint16_t reg_addr, uint16_t cmd_len, uint8_t *reg_data)
+{
+    int i = 2;
+
+    cmd_read.reg_addr = reg_addr;
+    cmd_read.cmd_len = cmd_len;
+    cmd_read.reg_data = reg_data;
+    cmd = 1;
+    seqcnt++;
+
+    do {
+        if (NetLoop(ATHRHDR) >= 0) /* polls for read/write ack from PHY */
+           break;
+    } while (i--);
+
+    if ((i==0) || (seqcnt != cmd_resp.seq) || (cmd_len != cmd_resp.len)) {
+        return -1;
+    }
+    memcpy (cmd_read.reg_data, cmd_resp.data, cmd_len);
+    return 0;
+}
+int header_receive_pkt(uchar *recv_pkt)
+{
+    cmd_resp.len = recv_pkt[4] >> 4;
+    if (cmd_resp.len > 10)
+        goto out;
+
+    cmd_resp.seq = recv_pkt[6] >> 1;
+    cmd_resp.seq |= recv_pkt[7] << 7;
+    cmd_resp.seq |= recv_pkt[8] << 15;
+    cmd_resp.seq |= recv_pkt[9] << 23;
+
+    if (cmd_resp.seq < seqcnt)
+        goto out;
+    memcpy (cmd_resp.data, (recv_pkt + 10), cmd_resp.len);
+out:
+     return 0;
+}
+
+void athrs26_reg_dev(struct eth_device *mac)
+{
+    lan_mac = mac;
+}
+
+#endif
+
+static uint32_t
+athrs26_reg_read(uint16_t reg_addr)
+{
+#ifndef CFG_ATHRHDR_REG
+    uint16_t reg_word_addr = reg_addr / 2, phy_val;
+    uint32_t phy_addr;
+    uint8_t phy_reg; 
+    
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (reg_word_addr >> 8) & 0x1ff;         /* bit16-8 of reg address*/
+    phy_reg_write (0, phy_addr, phy_reg, phy_val);
+
+    /* read register with low address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = reg_word_addr & 0x1f;                 /* bit 4-0 of reg address*/
+    phy_reg_read(0, phy_addr, phy_reg, &phy_val);
+    
+    return phy_val;
+#else
+    uint8_t reg_data[4];
+
+    memset (reg_data, 0, 4);
+    athrs26_header_read_reg(reg_addr, 4, reg_data);
+    return (reg_data[0] | (reg_data[1] << 8) | (reg_data[2] << 16) | (reg_data[3] << 24));
+#endif
+}
+
+static void
+athrs26_reg_write(uint16_t reg_addr, uint32_t reg_val)
+{
+#ifndef CFG_ATHRHDR_REG
+    uint16_t reg_word_addr = reg_addr / 2, phy_val;
+    uint32_t phy_addr;
+    uint8_t phy_reg; 
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (reg_word_addr >> 8) & 0x1ff;         /* bit16-8 of reg address*/
+    phy_reg_write (0, phy_addr, phy_reg, phy_val);
+
+    /* read register with low address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = reg_word_addr & 0x1f;                 /* bit 4-0 of reg address */
+    phy_reg_write (0, phy_addr, phy_reg, reg_val);
+#else
+    uint8_t reg_data[4];
+
+    memset (reg_data, 0, 4);
+    reg_data[0] = (uint8_t)(0x00ff & reg_val);
+    reg_data[1] = (uint8_t)((0xff00 & reg_val) >> 8);
+    reg_data[2] = (uint8_t)((0xff0000 & reg_val) >> 16);
+    reg_data[3] = (uint8_t)((0xff000000 & reg_val) >> 24);
+
+    athrs26_header_write_reg (reg_addr, 4, reg_data);
+#endif
+
+}
+
diff --git a/board/ar7100/common/athrs26_phy.h b/board/ar7100/common/athrs26_phy.h
new file mode 100644
index 0000000000..0fdde376eb
--- /dev/null
+++ b/board/ar7100/common/athrs26_phy.h
@@ -0,0 +1,134 @@
+#ifndef _ATHRS26_PHY_H
+#define _ATHRS26_PHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+        
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+#ifndef BOOL
+#define BOOL    int
+#define TRUE    1
+#define FALSE   0
+#endif
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+
+#undef S26_VER_1_0
+
+#ifdef CFG_ATHRHDR_EN
+
+#include <net.h>
+#define header_xmit(dev,pkt,len) dev->send(dev,pkt,len) //dev_queue_xmit(skb)
+#define header_recv_ack(dev) dev->recv(dev) //dev_queue_xmit(skb)
+
+typedef enum {
+    NORMAL_PACKET,
+    RESERVED0,
+    MIB_1ST,
+    RESERVED1,
+    RESERVED2,
+    READ_WRITE_REG,
+    READ_WRITE_REG_ACK,
+    RESERVED3
+} ATHR_HDR_TYPE;
+
+typedef struct {
+    uint16_t    reserved0;
+    uint16_t    priority;
+    uint16_t    type ;
+    uint16_t    broadcast;
+    uint16_t    from_cpu;
+    uint16_t    reserved1;
+    uint16_t    port_num;
+}at_header_t;
+
+typedef struct {
+    uint64_t    reg_addr;
+    uint64_t    reserved0;
+    uint64_t    cmd_len;
+    uint64_t    reserved1;
+    uint64_t    cmd;
+    uint64_t    reserved2;
+    uint64_t    seq_num;
+}reg_cmd_t;
+void athrs26_reg_init(void);
+int header_receive_pkt(uchar *pkt);
+void athrs26_reg_dev(struct eth_device *mac);
+
+#endif
+
+int athrs26_phy_is_up(int unit);
+int athrs26_phy_is_fdx(int unit);
+int athrs26_phy_speed(int unit);
+BOOL athrs26_phy_setup(int unit);
+
+#endif /* _ATHRS26_PHY_H */
+
diff --git a/board/ar7100/common/g5_Plus1_2_29a_unmanaged_Atheros_v5.c b/board/ar7100/common/g5_Plus1_2_29a_unmanaged_Atheros_v5.c
new file mode 100644
index 0000000000..1aea750379
--- /dev/null
+++ b/board/ar7100/common/g5_Plus1_2_29a_unmanaged_Atheros_v5.c
@@ -0,0 +1,511 @@
+static unsigned char g5_Plus1_2_29a_unmanaged_Atheros_v5 [] = {
+0x02, 0x0b, 0x1e, 0x8f, 0x2e, 0x12, 0x1f, 0xa1, 0x12, 0x09, 0xbf, 0x50, 0x03, 0x7f, 0x01, 0x22,
+0xe5, 0x2e, 0xb4, 0x06, 0x03, 0x7f, 0x01, 0x22, 0x7f, 0x00, 0x22, 0x02, 0x19, 0xbb, 0x75, 0x22,
+0x01, 0x80, 0xfe, 0x02, 0x14, 0xc6, 0xae, 0x05, 0xad, 0x07, 0x75, 0x3c, 0x06, 0xee, 0x70, 0x04,
+0x7f, 0x01, 0x80, 0x02, 0x7f, 0x00, 0x8f, 0x3d, 0x7b, 0x19, 0x7f, 0x20, 0x02, 0x17, 0x6c, 0x22,
+0x00, 0x01, 0xc1, 0x00, 0x00, 0x00, 0x8f, 0x24, 0x8d, 0x25, 0x8b, 0x26, 0xe5, 0x26, 0x7b, 0xff,
+0x60, 0x06, 0x7a, 0x12, 0x79, 0x74, 0x80, 0x04, 0x7a, 0x12, 0x79, 0x73, 0x12, 0x19, 0xe0, 0x7b,
+0xff, 0x7a, 0x12, 0x79, 0x75, 0x12, 0x19, 0xe0, 0xe5, 0x24, 0xc3, 0x94, 0x07, 0x40, 0x08, 0xe4,
+0xf5, 0x24, 0x75, 0x27, 0x06, 0x80, 0x11, 0xe5, 0x26, 0x60, 0x0a, 0x53, 0x24, 0xfe, 0xe5, 0x24,
+0x04, 0xf5, 0x27, 0x80, 0x03, 0x85, 0x24, 0x27, 0xe5, 0x25, 0xb4, 0xff, 0x05, 0x75, 0x29, 0x07,
+0x80, 0x0f, 0xaf, 0x25, 0x74, 0x01, 0xa8, 0x07, 0x08, 0x80, 0x02, 0xc3, 0x33, 0xd8, 0xfc, 0xf5,
+0x29, 0x7b, 0x0d, 0x12, 0x03, 0x2b, 0x7b, 0x0e, 0x12, 0x03, 0x2b, 0x12, 0x03, 0x66, 0x12, 0x1b,
+0x33, 0x12, 0x09, 0x43, 0xe5, 0x24, 0x90, 0x1f, 0xb6, 0x93, 0xf5, 0x30, 0xe5, 0x26, 0x60, 0x1e,
+0xe5, 0x24, 0x24, 0x01, 0xff, 0xe4, 0x33, 0xfe, 0xc3, 0xef, 0x94, 0x07, 0xee, 0x64, 0x80, 0x94,
+0x80, 0x50, 0x08, 0xe5, 0x24, 0xa3, 0x93, 0xf5, 0x31, 0x80, 0x03, 0x75, 0x31, 0x07, 0x7e, 0x00,
+0x7f, 0x02, 0x7d, 0xff, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x2a, 0x12, 0x05, 0x2e, 0x75, 0x28, 0x02,
+0xe5, 0x28, 0xf4, 0x70, 0x03, 0x02, 0x02, 0x50, 0x74, 0x01, 0x7e, 0x00, 0xa8, 0x28, 0x08, 0x80,
+0x05, 0xc3, 0x33, 0xce, 0x33, 0xce, 0xd8, 0xf9, 0xff, 0xef, 0x55, 0x29, 0x70, 0x03, 0x02, 0x02,
+0x4b, 0xe5, 0x28, 0xd3, 0x94, 0x02, 0x40, 0x03, 0x02, 0x01, 0xec, 0xaf, 0x30, 0x12, 0x1e, 0x80,
+0x40, 0x03, 0x02, 0x02, 0x4b, 0xaf, 0x31, 0x12, 0x1e, 0x80, 0x50, 0x07, 0xe5, 0x31, 0xc3, 0x94,
+0x07, 0x40, 0x07, 0xe5, 0x26, 0x60, 0x03, 0x02, 0x02, 0x4b, 0xe5, 0x30, 0x64, 0x06, 0x70, 0x1b,
+0xe5, 0x28, 0x70, 0x09, 0x12, 0x03, 0x5d, 0x20, 0xe4, 0x03, 0x02, 0x02, 0x4b, 0xe5, 0x28, 0xb4,
+0x01, 0x09, 0x12, 0x03, 0x5d, 0x20, 0xe6, 0x03, 0x02, 0x02, 0x4b, 0xe5, 0x26, 0x60, 0x67, 0xe5,
+0x28, 0xc3, 0x94, 0x02, 0x50, 0x6f, 0xe5, 0x31, 0x64, 0x06, 0x70, 0x25, 0xe5, 0x28, 0x70, 0x0e,
+0x7d, 0x01, 0xaf, 0x31, 0x12, 0x13, 0x0d, 0xee, 0x20, 0xe4, 0x03, 0x02, 0x02, 0x4b, 0xe5, 0x28,
+0xb4, 0x01, 0x0e, 0x7d, 0x01, 0xaf, 0x31, 0x12, 0x13, 0x0d, 0xee, 0x20, 0xe6, 0x03, 0x02, 0x02,
+0x4b, 0x12, 0x03, 0x70, 0xe4, 0xf5, 0x2e, 0xf5, 0x2f, 0xaf, 0x30, 0x12, 0x1e, 0x9c, 0x50, 0x07,
+0xaf, 0x31, 0x12, 0x1e, 0x9c, 0x40, 0x2e, 0xe5, 0x2f, 0xc3, 0x94, 0x03, 0x50, 0x27, 0x7f, 0x0a,
+0x12, 0x1d, 0x5e, 0x05, 0x2e, 0xe5, 0x2e, 0xc3, 0x94, 0xfa, 0x40, 0xdd, 0x12, 0x03, 0x70, 0x05,
+0x2f, 0xe4, 0xf5, 0x2e, 0x80, 0xd3, 0xe5, 0x28, 0x44, 0x90, 0xfd, 0xaf, 0x30, 0x12, 0x13, 0xb6,
+0x7f, 0x0a, 0x12, 0x1e, 0xfb, 0xad, 0x28, 0xaf, 0x30, 0x12, 0x10, 0xc8, 0xe5, 0x26, 0x60, 0x07,
+0xad, 0x28, 0xaf, 0x31, 0x12, 0x10, 0xc8, 0x7f, 0x05, 0x12, 0x1e, 0xfb, 0xe5, 0x26, 0x60, 0x41,
+0xad, 0x31, 0x12, 0x03, 0x4e, 0x80, 0x02, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0x4a, 0x80, 0x02,
+0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0xad, 0x30, 0xaf, 0x31, 0x12, 0x0f,
+0x20, 0xe5, 0x28, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x06, 0x08, 0x80, 0x02, 0xc3, 0x33, 0xd8, 0xfc,
+0x12, 0x1b, 0x4a, 0x80, 0x02, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2b, 0x4f, 0xf5, 0x2b, 0x80,
+0x1a, 0xad, 0x30, 0x12, 0x03, 0x4e, 0x80, 0x02, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0x4a, 0x80,
+0x02, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0x15, 0x28, 0x02, 0x00, 0xf0,
+0xe4, 0xf5, 0x2d, 0xe5, 0x26, 0x70, 0x07, 0xe5, 0x2d, 0xc3, 0x94, 0x01, 0x40, 0x11, 0xe5, 0x26,
+0x70, 0x03, 0x02, 0x02, 0xfd, 0xe5, 0x2d, 0xc3, 0x94, 0x02, 0x40, 0x03, 0x02, 0x02, 0xfd, 0x12,
+0x1f, 0x19, 0x7f, 0x04, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1a, 0xb0, 0x7f, 0x04, 0x12, 0x1d,
+0x23, 0xe4, 0xf5, 0x28, 0xe5, 0x28, 0x25, 0xe0, 0xff, 0x74, 0x2a, 0x25, 0x2d, 0xf8, 0xe6, 0xfe,
+0xa8, 0x07, 0x08, 0x80, 0x02, 0xc3, 0x13, 0xd8, 0xfc, 0x54, 0x03, 0xf5, 0x2c, 0xb4, 0x03, 0x07,
+0x7f, 0x08, 0x12, 0x1d, 0x23, 0x80, 0x24, 0xe5, 0x2c, 0x7b, 0xff, 0x70, 0x09, 0x7a, 0x12, 0x79,
+0x8e, 0x12, 0x19, 0xe0, 0x80, 0x15, 0x7a, 0x12, 0x79, 0x97, 0x12, 0x19, 0xe0, 0xaf, 0x2c, 0xe4,
+0xfc, 0xfd, 0xfe, 0x12, 0x0e, 0x3b, 0x7f, 0x20, 0x12, 0x1f, 0xc8, 0x05, 0x28, 0xe5, 0x28, 0xc3,
+0x94, 0x03, 0x40, 0xb0, 0xe5, 0x2d, 0x70, 0x0b, 0xaf, 0x30, 0x12, 0x1e, 0x80, 0x50, 0x10, 0xaf,
+0x30, 0x80, 0x09, 0xaf, 0x31, 0x12, 0x1e, 0x80, 0x50, 0x05, 0xaf, 0x31, 0x12, 0x1f, 0x2d, 0x05,
+0x24, 0xe5, 0x24, 0xd3, 0x95, 0x27, 0x50, 0x05, 0x05, 0x2d, 0x02, 0x02, 0x53, 0xe5, 0x24, 0xd3,
+0x95, 0x27, 0x50, 0x03, 0x02, 0x00, 0xb4, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x9e, 0x12, 0x19, 0xe0,
+0x7b, 0x0d, 0x12, 0x03, 0x3e, 0x12, 0x09, 0x43, 0x7b, 0x0e, 0x12, 0x03, 0x3e, 0x12, 0x09, 0x43,
+0x12, 0x03, 0x66, 0x7f, 0x5f, 0x12, 0x1b, 0x35, 0x02, 0x09, 0x43, 0xe4, 0xfd, 0x7f, 0x40, 0x12,
+0x09, 0x3c, 0x7f, 0x00, 0x7e, 0x00, 0x7d, 0x00, 0x7c, 0x00, 0x12, 0x09, 0x43, 0x22, 0xe4, 0xfd,
+0x7f, 0x40, 0x12, 0x09, 0x3c, 0x7f, 0x5f, 0x7e, 0x00, 0x7d, 0x00, 0x7c, 0x00, 0x22, 0xaf, 0x30,
+0x12, 0x0f, 0x20, 0xe5, 0x28, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x06, 0x08, 0x22, 0x7d, 0x01, 0xaf,
+0x30, 0x12, 0x13, 0x0d, 0xee, 0x22, 0x7b, 0x0f, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x09, 0x3c, 0x22,
+0xab, 0x28, 0xad, 0x31, 0xaf, 0x30, 0x12, 0x18, 0xd6, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a,
+0x83, 0xe0, 0x22, 0x50, 0x02, 0xe7, 0x22, 0xbb, 0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83,
+0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0x22, 0x50, 0x02, 0xf7, 0x22,
+0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xe8, 0x8f, 0xf0, 0xa4, 0xcc, 0x8b, 0xf0, 0xa4, 0x2c, 0xfc, 0xe9,
+0x8e, 0xf0, 0xa4, 0x2c, 0xfc, 0x8a, 0xf0, 0xed, 0xa4, 0x2c, 0xfc, 0xea, 0x8e, 0xf0, 0xa4, 0xcd,
+0xa8, 0xf0, 0x8b, 0xf0, 0xa4, 0x2d, 0xcc, 0x38, 0x25, 0xf0, 0xfd, 0xe9, 0x8f, 0xf0, 0xa4, 0x2c,
+0xcd, 0x35, 0xf0, 0xfc, 0xeb, 0x8e, 0xf0, 0xa4, 0xfe, 0xa9, 0xf0, 0xeb, 0x8f, 0xf0, 0xa4, 0xcf,
+0xc5, 0xf0, 0x2e, 0xcd, 0x39, 0xfe, 0xe4, 0x3c, 0xfc, 0xea, 0xa4, 0x2d, 0xce, 0x35, 0xf0, 0xfd,
+0xe4, 0x3c, 0xfc, 0x22, 0x75, 0xf0, 0x08, 0x75, 0x82, 0x00, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe,
+0xcd, 0x33, 0xcd, 0xcc, 0x33, 0xcc, 0xc5, 0x82, 0x33, 0xc5, 0x82, 0x9b, 0xed, 0x9a, 0xec, 0x99,
+0xe5, 0x82, 0x98, 0x40, 0x0c, 0xf5, 0x82, 0xee, 0x9b, 0xfe, 0xed, 0x9a, 0xfd, 0xec, 0x99, 0xfc,
+0x0f, 0xd5, 0xf0, 0xd6, 0xe4, 0xce, 0xfb, 0xe4, 0xcd, 0xfa, 0xe4, 0xcc, 0xf9, 0xa8, 0x82, 0x22,
+0xb8, 0x00, 0xc1, 0xb9, 0x00, 0x59, 0xba, 0x00, 0x2d, 0xec, 0x8b, 0xf0, 0x84, 0xcf, 0xce, 0xcd,
+0xfc, 0xe5, 0xf0, 0xcb, 0xf9, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd,
+0xec, 0x33, 0xfc, 0xeb, 0x33, 0xfb, 0x10, 0xd7, 0x03, 0x99, 0x40, 0x04, 0xeb, 0x99, 0xfb, 0x0f,
+0xd8, 0xe5, 0xe4, 0xf9, 0xfa, 0x22, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33,
+0xfd, 0xec, 0x33, 0xfc, 0xc9, 0x33, 0xc9, 0x10, 0xd7, 0x05, 0x9b, 0xe9, 0x9a, 0x40, 0x07, 0xec,
+0x9b, 0xfc, 0xe9, 0x9a, 0xf9, 0x0f, 0xd8, 0xe0, 0xe4, 0xc9, 0xfa, 0xe4, 0xcc, 0xfb, 0x22, 0x75,
+0xf0, 0x10, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xcc, 0x33, 0xcc, 0xc8, 0x33,
+0xc8, 0x10, 0xd7, 0x07, 0x9b, 0xec, 0x9a, 0xe8, 0x99, 0x40, 0x0a, 0xed, 0x9b, 0xfd, 0xec, 0x9a,
+0xfc, 0xe8, 0x99, 0xf8, 0x0f, 0xd5, 0xf0, 0xda, 0xe4, 0xcd, 0xfb, 0xe4, 0xcc, 0xfa, 0xe4, 0xc8,
+0xf9, 0x22, 0xcf, 0xf4, 0xcf, 0xce, 0xf4, 0xce, 0xcd, 0xf4, 0xcd, 0xcc, 0xf4, 0xcc, 0x22, 0xeb,
+0x9f, 0xf5, 0xf0, 0xea, 0x9e, 0x42, 0xf0, 0xe9, 0x9d, 0x42, 0xf0, 0xe8, 0x9c, 0x45, 0xf0, 0x22,
+0xe8, 0x60, 0x0f, 0xec, 0xc3, 0x13, 0xfc, 0xed, 0x13, 0xfd, 0xee, 0x13, 0xfe, 0xef, 0x13, 0xff,
+0xd8, 0xf1, 0x22, 0xe8, 0x60, 0x0f, 0xef, 0xc3, 0x33, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd,
+0xec, 0x33, 0xfc, 0xd8, 0xf1, 0x22, 0xe6, 0xfc, 0x08, 0xe6, 0xfd, 0x08, 0xe6, 0xfe, 0x08, 0xe6,
+0xff, 0x22, 0xe4, 0x93, 0xfc, 0x74, 0x01, 0x93, 0xfd, 0x74, 0x02, 0x93, 0xfe, 0x74, 0x03, 0x93,
+0xff, 0x22, 0xec, 0xf6, 0x08, 0xed, 0xf6, 0x08, 0xee, 0xf6, 0x08, 0xef, 0xf6, 0x22, 0xef, 0x4e,
+0x60, 0x12, 0xef, 0x60, 0x01, 0x0e, 0xed, 0xbb, 0x01, 0x0b, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0xa3,
+0xdf, 0xfc, 0xde, 0xfa, 0x22, 0x89, 0xf0, 0x50, 0x07, 0xf7, 0x09, 0xdf, 0xfc, 0xa9, 0xf0, 0x22,
+0xbb, 0xfe, 0xfc, 0xf3, 0x09, 0xdf, 0xfc, 0xa9, 0xf0, 0x22, 0xa8, 0x1a, 0xe6, 0xf5, 0x24, 0x64,
+0x20, 0x60, 0x09, 0xe5, 0x24, 0x64, 0x0d, 0x60, 0x03, 0x7f, 0x01, 0x22, 0xe4, 0xf5, 0x19, 0xfe,
+0x7f, 0x10, 0x7d, 0xff, 0xfb, 0x7a, 0x00, 0x79, 0x52, 0x12, 0x05, 0x2e, 0x12, 0x1e, 0xe5, 0x75,
+0x25, 0x0a, 0xe4, 0xf5, 0x27, 0xa8, 0x1a, 0xe6, 0x64, 0x30, 0x70, 0x1b, 0xe8, 0x04, 0xf8, 0xe6,
+0xff, 0x12, 0x1c, 0x44, 0xbf, 0x58, 0x10, 0x75, 0x25, 0x10, 0x05, 0x1a, 0x05, 0x1a, 0xa8, 0x1a,
+0xe6, 0xb4, 0x20, 0x03, 0x7f, 0x01, 0x22, 0xa8, 0x1a, 0xe6, 0xf5, 0x24, 0x64, 0x20, 0x60, 0x06,
+0xe5, 0x24, 0x64, 0x0d, 0x70, 0x7c, 0xe5, 0x27, 0xd3, 0x94, 0x00, 0x40, 0x6a, 0xe4, 0xf5, 0x35,
+0xf5, 0x34, 0xf5, 0x33, 0xf5, 0x32, 0xf5, 0x26, 0xe5, 0x26, 0xc3, 0x95, 0x27, 0x50, 0x3a, 0xaf,
+0x25, 0xe4, 0xfc, 0xfd, 0xfe, 0xab, 0x35, 0xaa, 0x34, 0xa9, 0x33, 0xa8, 0x32, 0x12, 0x03, 0xa5,
+0xc0, 0x04, 0xa9, 0x05, 0xaa, 0x06, 0xab, 0x07, 0x74, 0x28, 0x25, 0x26, 0xf8, 0xe6, 0xff, 0xe4,
+0xfc, 0xfd, 0xfe, 0xd0, 0x00, 0xeb, 0x2f, 0xf5, 0x35, 0xee, 0x3a, 0xf5, 0x34, 0xed, 0x39, 0xf5,
+0x33, 0xec, 0x38, 0xf5, 0x32, 0x05, 0x26, 0x80, 0xbf, 0xe5, 0x19, 0xc3, 0x94, 0x04, 0x50, 0x17,
+0xaf, 0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0xab, 0x19, 0x05, 0x19, 0xeb, 0x25, 0xe0, 0x25,
+0xe0, 0x24, 0x52, 0xf8, 0x12, 0x05, 0x22, 0xe5, 0x24, 0x64, 0x0d, 0x60, 0x03, 0x02, 0x05, 0x7c,
+0xff, 0x22, 0xaf, 0x24, 0x12, 0x19, 0x95, 0x8f, 0x24, 0xe5, 0x24, 0xf4, 0x60, 0x1d, 0xe5, 0x27,
+0xc3, 0x94, 0x0a, 0x50, 0x19, 0xaf, 0x27, 0x05, 0x27, 0x74, 0x28, 0x2f, 0xf8, 0xa6, 0x24, 0xe5,
+0x24, 0xd3, 0x94, 0x09, 0x40, 0x08, 0x75, 0x25, 0x10, 0x80, 0x03, 0x7f, 0x01, 0x22, 0x05, 0x1a,
+0x02, 0x05, 0xa7, 0xa8, 0x1a, 0xe6, 0xf5, 0x23, 0x05, 0x1a, 0x12, 0x05, 0x5a, 0xef, 0x60, 0x03,
+0x7f, 0x01, 0x22, 0xaf, 0x23, 0x12, 0x1c, 0x44, 0xef, 0x24, 0xb7, 0x60, 0x64, 0x24, 0xfa, 0x60,
+0x7a, 0x24, 0xfd, 0x60, 0x17, 0x24, 0xfe, 0x70, 0x03, 0x02, 0x07, 0x25, 0x24, 0xfd, 0x60, 0x28,
+0x04, 0x60, 0x03, 0x02, 0x07, 0x60, 0x12, 0x0e, 0xb1, 0x02, 0x07, 0x63, 0x12, 0x1f, 0x0f, 0x12,
+0x1a, 0x15, 0xc0, 0x07, 0x12, 0x1a, 0x05, 0xc0, 0x05, 0x12, 0x1a, 0x0d, 0xd0, 0x05, 0xd0, 0x07,
+0x12, 0x09, 0x28, 0x12, 0x1c, 0x12, 0x80, 0x3e, 0xe5, 0x19, 0xc3, 0x94, 0x04, 0x50, 0x03, 0x02,
+0x07, 0x63, 0x12, 0x1a, 0x15, 0xc0, 0x07, 0x12, 0x1a, 0x05, 0xc0, 0x05, 0x12, 0x1a, 0x0d, 0xd0,
+0x05, 0xd0, 0x07, 0x12, 0x09, 0x3c, 0x78, 0x5e, 0x12, 0x05, 0x06, 0x12, 0x09, 0x43, 0x02, 0x07,
+0x63, 0x12, 0x1f, 0x0f, 0x78, 0x52, 0x12, 0x05, 0x06, 0xc0, 0x07, 0x12, 0x1a, 0x05, 0xd0, 0x07,
+0x12, 0x13, 0x0d, 0x12, 0x1d, 0xfc, 0x12, 0x1f, 0x19, 0x80, 0x68, 0xe5, 0x19, 0xc3, 0x94, 0x03,
+0x40, 0x61, 0x78, 0x52, 0x12, 0x05, 0x06, 0xc0, 0x07, 0x12, 0x1a, 0x05, 0xc0, 0x05, 0x12, 0x1a,
+0x0d, 0xaa, 0x06, 0x78, 0x5e, 0x12, 0x05, 0x06, 0x8e, 0x3d, 0x8f, 0x3e, 0xd0, 0x05, 0xd0, 0x07,
+0x12, 0x19, 0x49, 0x80, 0x3e, 0x78, 0x52, 0x12, 0x05, 0x06, 0xef, 0x24, 0xfe, 0x60, 0x17, 0x04,
+0x70, 0x2b, 0x78, 0x56, 0x12, 0x05, 0x06, 0xc0, 0x07, 0x78, 0x5a, 0x12, 0x05, 0x06, 0xad, 0x07,
+0xd0, 0x07, 0xe4, 0xfb, 0x80, 0x12, 0x78, 0x56, 0x12, 0x05, 0x06, 0xc0, 0x07, 0x78, 0x5a, 0x12,
+0x05, 0x06, 0xad, 0x07, 0xd0, 0x07, 0x7b, 0x01, 0x12, 0x00, 0x46, 0x80, 0x06, 0x7f, 0x01, 0x22,
+0x7f, 0x01, 0x22, 0x7f, 0x00, 0x22, 0x8f, 0x2a, 0x7f, 0x01, 0xed, 0x54, 0x30, 0xfe, 0xbe, 0x30,
+0x04, 0x7e, 0x01, 0x80, 0x02, 0x7e, 0x00, 0xed, 0x54, 0x03, 0xfc, 0xbc, 0x02, 0x04, 0x7c, 0x01,
+0x80, 0x02, 0x7c, 0x00, 0x8c, 0x2c, 0xed, 0x20, 0xe4, 0x07, 0xef, 0x60, 0x04, 0x7d, 0x01, 0x80,
+0x02, 0x7d, 0x00, 0xef, 0x60, 0x03, 0xee, 0x70, 0x03, 0xed, 0x60, 0x04, 0x7f, 0x01, 0x80, 0x02,
+0x7f, 0x00, 0x8f, 0x2b, 0x7d, 0x30, 0xaf, 0x2a, 0x12, 0x18, 0x84, 0x7b, 0x08, 0xad, 0x2a, 0x7f,
+0x20, 0x12, 0x09, 0x3c, 0xe5, 0x31, 0xfe, 0xe5, 0x32, 0xff, 0xad, 0x30, 0x7c, 0x00, 0x12, 0x09,
+0x59, 0x12, 0x09, 0x43, 0x7b, 0x0c, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0xe5, 0x34, 0xfe,
+0xe5, 0x35, 0xff, 0xad, 0x33, 0x7c, 0x00, 0x12, 0x09, 0x59, 0x12, 0x09, 0x43, 0xe5, 0x2b, 0x60,
+0x1e, 0x75, 0x2d, 0x17, 0x75, 0x2e, 0xb6, 0x12, 0x08, 0x52, 0x7f, 0xff, 0x7e, 0x00, 0x7d, 0x03,
+0x7c, 0x00, 0x12, 0x09, 0x43, 0x85, 0x2a, 0x3c, 0xe4, 0xf5, 0x3d, 0x7b, 0x12, 0x80, 0x1d, 0x75,
+0x2d, 0x17, 0x75, 0x2e, 0x9e, 0x12, 0x08, 0x52, 0x7f, 0x00, 0x7e, 0x00, 0x7d, 0x00, 0x7c, 0x00,
+0x12, 0x09, 0x43, 0x85, 0x2a, 0x3c, 0x75, 0x3d, 0x01, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x12,
+0x17, 0x6c, 0xe4, 0xf5, 0x2f, 0xe5, 0x2f, 0x24, 0xde, 0xfb, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x09,
+0x3c, 0x85, 0x2e, 0x82, 0x85, 0x2d, 0x83, 0x12, 0x05, 0x12, 0x12, 0x09, 0x43, 0x74, 0x04, 0x25,
+0x2e, 0xf5, 0x2e, 0xe4, 0x35, 0x2d, 0xf5, 0x2d, 0x05, 0x2f, 0xe5, 0x2f, 0xc3, 0x94, 0x06, 0x40,
+0xd4, 0x22, 0x7b, 0x04, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0x22, 0x8f, 0x2b, 0x8c, 0x2c,
+0x8d, 0x2d, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0x0a, 0xf5, 0x31, 0xf5, 0x30, 0xf5, 0x2f, 0xf5,
+0x2e, 0x80, 0x12, 0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf, 0x2b, 0x12, 0x11, 0x92, 0x8f, 0x31, 0x8e,
+0x30, 0x8d, 0x2f, 0x8c, 0x2e, 0x12, 0x09, 0x1e, 0xe5, 0x31, 0x54, 0xf8, 0xff, 0xe5, 0x30, 0xfe,
+0xe5, 0x2f, 0xfd, 0xe5, 0x2e, 0xfc, 0xef, 0x44, 0x31, 0xff, 0xec, 0x44, 0x20, 0xfc, 0x12, 0x09,
+0x43, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0x23, 0xfd, 0xaf, 0x2b, 0x12, 0x1e, 0xb7, 0x12, 0x09,
+0x1e, 0x7f, 0x30, 0x7e, 0x00, 0x7d, 0x00, 0x7c, 0x20, 0x12, 0x09, 0x43, 0x85, 0x2b, 0x3c, 0x75,
+0x3d, 0x01, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x02, 0x17, 0x6c, 0xaf, 0x2b, 0x12, 0x1f, 0x6d,
+0xe4, 0xfc, 0xfd, 0xfe, 0x78, 0x13, 0x12, 0x04, 0xf3, 0xec, 0x44, 0x08, 0xfc, 0xe5, 0x31, 0x4f,
+0xf5, 0x31, 0xe5, 0x30, 0x4e, 0xf5, 0x30, 0xe5, 0x2f, 0x4d, 0xf5, 0x2f, 0xe5, 0x2e, 0x4c, 0xf5,
+0x2e, 0xe4, 0xfb, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0xaf, 0x31, 0xae, 0x30, 0xad, 0x2f,
+0xac, 0x2e, 0x12, 0x09, 0x43, 0xaf, 0x2b, 0x12, 0x1b, 0x51, 0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf,
+0x2b, 0x12, 0x18, 0xfd, 0xe5, 0x2b, 0xb4, 0x06, 0x04, 0xff, 0x12, 0x16, 0xcf, 0x22, 0xe4, 0xfb,
+0xad, 0x2b, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0x22, 0xef, 0x2d, 0xf5, 0xf9, 0x8b, 0xfa, 0x30, 0xf8,
+0xfd, 0xd2, 0xf8, 0xac, 0xff, 0xad, 0xfe, 0xae, 0xfd, 0xaf, 0xfc, 0x22, 0xef, 0x2d, 0xf5, 0x4b,
+0x8b, 0x4c, 0x22, 0x8c, 0xff, 0x8d, 0xfe, 0x8e, 0xfd, 0x8f, 0xfc, 0xe5, 0x4b, 0xf5, 0xf9, 0xe5,
+0x4c, 0xf5, 0xfb, 0x30, 0xf8, 0xfd, 0xd2, 0xf8, 0x22, 0x22, 0xec, 0xfe, 0xed, 0xff, 0x22, 0x01,
+0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0xe4, 0xfe, 0xcf, 0x90, 0x09, 0x5f, 0xb4, 0x08, 0x00,
+0x50, 0x03, 0x93, 0xff, 0x22, 0x94, 0x08, 0x93, 0xfe, 0x22, 0xef, 0x90, 0x09, 0x5f, 0x93, 0xff,
+0x22, 0x90, 0x09, 0x5f, 0xef, 0x93, 0xff, 0xf4, 0xfe, 0xbb, 0x01, 0x0e, 0x89, 0x82, 0x8a, 0x83,
+0xe0, 0x5e, 0xbd, 0x00, 0x02, 0x80, 0x01, 0x4f, 0xf0, 0x22, 0xbb, 0x00, 0x0b, 0xe9, 0xf8, 0xe6,
+0x5e, 0xbd, 0x00, 0x02, 0x80, 0x01, 0x4f, 0xf6, 0x22, 0x74, 0x1f, 0xc3, 0x9f, 0x13, 0x13, 0x13,
+0x54, 0x03, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x07, 0x5f, 0xff, 0x12, 0x09, 0x81, 0x22, 0x90,
+0x09, 0x5f, 0xef, 0x93, 0xff, 0xbb, 0x01, 0x07, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x80, 0x06, 0xbb,
+0x00, 0x08, 0xe9, 0xf8, 0xe6, 0x5f, 0x60, 0x02, 0xd3, 0x22, 0xc3, 0x22, 0x74, 0x1f, 0xc3, 0x9f,
+0x13, 0x13, 0x13, 0x54, 0x03, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x07, 0x5f, 0xff, 0x12, 0x09,
+0xbf, 0x22, 0x8f, 0x36, 0xe5, 0x36, 0x64, 0x06, 0x70, 0x54, 0x7b, 0x22, 0x7a, 0x1a, 0x7d, 0x17,
+0x12, 0x17, 0xce, 0xaf, 0x36, 0x12, 0x17, 0xfe, 0x12, 0x0a, 0x7f, 0x7a, 0x02, 0x12, 0x0a, 0x75,
+0x7b, 0xb5, 0x7a, 0x52, 0x7d, 0x1f, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x7b, 0x0f, 0x7a, 0x00, 0x7d,
+0x02, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x7b, 0x2a, 0x7a, 0x47, 0x7d, 0x01, 0xaf, 0x36, 0x12, 0x17,
+0xce, 0x7b, 0xa4, 0x7a, 0x8f, 0xe4, 0xfd, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x12, 0x0a, 0x7f, 0x7a,
+0x00, 0x12, 0x0a, 0x75, 0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0xaf, 0x36, 0x02, 0x17, 0xce, 0xaf, 0x36,
+0x12, 0x0d, 0xc4, 0xaf, 0x36, 0x12, 0x1c, 0xa3, 0x7b, 0x64, 0x7a, 0x00, 0x7d, 0x1b, 0xaf, 0x36,
+0x12, 0x17, 0xce, 0x75, 0x3d, 0x00, 0x75, 0x3e, 0x0f, 0x7b, 0x03, 0x7a, 0x00, 0x7d, 0x1e, 0xaf,
+0x36, 0x12, 0x19, 0x49, 0x22, 0x7b, 0x12, 0x7d, 0x08, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x22, 0x7b,
+0x30, 0x7a, 0x2a, 0x7d, 0x1f, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x22, 0x8f, 0x38, 0x12, 0x1f, 0x5c,
+0x12, 0x1a, 0x59, 0x12, 0x0b, 0x0a, 0x12, 0x1f, 0x53, 0x7a, 0xaf, 0x12, 0x0a, 0xec, 0x75, 0x3d,
+0x00, 0x75, 0x3e, 0x0c, 0x7d, 0x11, 0x12, 0x0b, 0x00, 0x7a, 0x8f, 0x12, 0x0a, 0xec, 0x7a, 0xaf,
+0x12, 0x0a, 0xf6, 0x75, 0x3d, 0x00, 0x75, 0x3e, 0x0c, 0x7d, 0x12, 0x12, 0x0b, 0x00, 0x7a, 0x8f,
+0x12, 0x0a, 0xf6, 0x7a, 0xaf, 0x12, 0x0b, 0x14, 0x75, 0x3d, 0x01, 0x75, 0x3e, 0x80, 0x7b, 0x00,
+0x7a, 0x01, 0x7d, 0x11, 0xaf, 0x38, 0x12, 0x19, 0x49, 0x7a, 0x8f, 0x12, 0x0b, 0x14, 0xaf, 0x38,
+0x12, 0x1f, 0x5c, 0x12, 0x1a, 0x64, 0x12, 0x0b, 0x0a, 0x02, 0x1f, 0x65, 0x7b, 0x8a, 0x7d, 0x10,
+0xaf, 0x38, 0x12, 0x17, 0xce, 0x22, 0x7b, 0x86, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xce, 0x22,
+0x7b, 0x08, 0x7a, 0x00, 0xaf, 0x38, 0x12, 0x19, 0x49, 0x22, 0x7d, 0x08, 0xaf, 0x38, 0x12, 0x19,
+0x49, 0xaf, 0x38, 0x22, 0x7b, 0x82, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xce, 0x22, 0x78, 0xfe,
+0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x4f, 0x00, 0x75, 0x50, 0x00, 0x75, 0x81, 0xa7, 0x02, 0x0b, 0x6b,
+0x02, 0x0b, 0xb0, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x03, 0xf6, 0x80, 0x01, 0xf2,
+0x08, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x07, 0x24, 0x0c, 0xc8, 0xc3, 0x33,
+0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4, 0x56, 0x80, 0x01, 0x46, 0xf6, 0xdf,
+0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x18, 0x2d, 0xe4, 0x7e,
+0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09, 0x54, 0x1f, 0xfe, 0xe4, 0x93,
+0xa3, 0x60, 0x01, 0x0e, 0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3,
+0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca,
+0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe,
+0x12, 0x1f, 0xce, 0x12, 0x18, 0xae, 0xd2, 0xa1, 0xc2, 0x91, 0xe4, 0xf5, 0x39, 0x75, 0x38, 0x01,
+0xf5, 0x37, 0xf5, 0x36, 0xf5, 0x3d, 0x75, 0x3c, 0x1f, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x10, 0xfd,
+0x7f, 0xe0, 0x12, 0x10, 0x60, 0x12, 0x1d, 0x4b, 0x12, 0x1c, 0x75, 0xd2, 0xaf, 0x7f, 0x14, 0x12,
+0x1d, 0x5e, 0x12, 0x0d, 0x46, 0x12, 0x1f, 0xcf, 0x12, 0x1a, 0x8f, 0xef, 0x70, 0x03, 0x30, 0x07,
+0x03, 0x12, 0x00, 0x1e, 0x12, 0x1a, 0xd1, 0x12, 0x1c, 0xd1, 0xef, 0x60, 0x03, 0x12, 0x00, 0x1e,
+0x12, 0x17, 0x04, 0x12, 0x1c, 0x2b, 0x30, 0x07, 0x16, 0xc2, 0x07, 0x7b, 0x16, 0xe4, 0xfd, 0x7f,
+0xe0, 0x12, 0x09, 0x3c, 0x7f, 0x00, 0x7e, 0x00, 0x7d, 0xff, 0x7c, 0xff, 0x12, 0x09, 0x43, 0x12,
+0x0c, 0x3f, 0x30, 0x00, 0x08, 0xc2, 0x00, 0x12, 0x1e, 0x0b, 0x12, 0x1b, 0xde, 0x30, 0x01, 0xd6,
+0xc2, 0x01, 0x12, 0x1d, 0xdd, 0x12, 0x1c, 0x8c, 0xa2, 0x81, 0xb3, 0x92, 0x91, 0x80, 0xc7, 0x12,
+0x15, 0xba, 0x40, 0x03, 0x02, 0x0c, 0xc4, 0x75, 0x1a, 0x62, 0x12, 0x1e, 0xe5, 0x12, 0x1a, 0x1f,
+0x75, 0x27, 0x1e, 0x75, 0x28, 0x72, 0x12, 0x15, 0x05, 0xef, 0x70, 0x04, 0xf5, 0x22, 0x80, 0x4a,
+0x12, 0x1a, 0x1f, 0x75, 0x27, 0x1e, 0x75, 0x28, 0x78, 0x12, 0x15, 0x05, 0xef, 0x70, 0x36, 0x74,
+0x07, 0x25, 0x1a, 0xf5, 0x1a, 0x12, 0x05, 0x5a, 0xef, 0x60, 0x02, 0x80, 0x06, 0xe5, 0x19, 0x64,
+0x02, 0x60, 0x05, 0x75, 0x22, 0x01, 0x80, 0x18, 0x78, 0x52, 0x12, 0x05, 0x06, 0xc0, 0x06, 0xc0,
+0x07, 0x12, 0x1a, 0x05, 0xac, 0x06, 0xd0, 0x07, 0xd0, 0x06, 0x12, 0x0f, 0xf7, 0x12, 0x1d, 0x71,
+0xe4, 0xf5, 0x22, 0x80, 0x05, 0x12, 0x06, 0x63, 0x8f, 0x22, 0xe5, 0x22, 0x60, 0x13, 0x12, 0x1e,
+0xc4, 0x50, 0x05, 0x12, 0x1d, 0xed, 0x80, 0xf6, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x54, 0x12, 0x19,
+0xe0, 0xe4, 0xf5, 0x18, 0x22, 0x8f, 0x23, 0x74, 0xa0, 0x2f, 0xf8, 0xe6, 0x24, 0xfe, 0x60, 0x2a,
+0x14, 0x60, 0x5c, 0x24, 0x02, 0x70, 0x6e, 0x7b, 0xe1, 0x7a, 0x05, 0x7d, 0x04, 0xaf, 0x23, 0x12,
+0x17, 0xce, 0x7b, 0x00, 0x7a, 0x06, 0x7d, 0x09, 0xaf, 0x23, 0x12, 0x17, 0xce, 0xaf, 0x23, 0x12,
+0x1e, 0x1a, 0x74, 0xa0, 0x25, 0x23, 0xf8, 0x76, 0x02, 0x22, 0x30, 0x09, 0x48, 0xaf, 0x23, 0x12,
+0x1e, 0x9c, 0x50, 0x41, 0x12, 0x1f, 0xa1, 0x7d, 0x01, 0xaf, 0x23, 0x12, 0x09, 0x81, 0xaf, 0x23,
+0x12, 0x1c, 0x5d, 0x8f, 0x24, 0xad, 0x24, 0xaf, 0x23, 0x12, 0x1b, 0x8b, 0xad, 0x24, 0xaf, 0x23,
+0x12, 0x15, 0xf6, 0x74, 0xa0, 0x25, 0x23, 0xf8, 0x76, 0x03, 0xaf, 0x23, 0x02, 0x1f, 0xcb, 0x30,
+0x09, 0x13, 0xaf, 0x23, 0x12, 0x1e, 0x9c, 0x40, 0x0c, 0x74, 0xa0, 0x25, 0x23, 0xf8, 0x76, 0x02,
+0xaf, 0x23, 0x12, 0x1b, 0x6e, 0x22, 0x12, 0x00, 0x3f, 0xe4, 0x75, 0x26, 0xc0, 0xf5, 0x25, 0xf5,
+0x24, 0xf5, 0x23, 0xf5, 0x22, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x23, 0xaf, 0x22, 0x12, 0x09, 0xdc,
+0x40, 0x21, 0xe4, 0xfb, 0x7d, 0x02, 0x7f, 0x60, 0x12, 0x09, 0x3c, 0xe4, 0x25, 0x22, 0xff, 0xe4,
+0x34, 0x04, 0xfe, 0xe4, 0x34, 0x01, 0xfd, 0xe4, 0x34, 0x01, 0xfc, 0x12, 0x09, 0x43, 0x7f, 0x02,
+0x12, 0x1d, 0x5e, 0x05, 0x22, 0xe5, 0x22, 0xd3, 0x94, 0x0f, 0x40, 0xc9, 0x7f, 0x03, 0x12, 0x1e,
+0xfb, 0x12, 0x1f, 0x93, 0x12, 0x1e, 0xda, 0x7f, 0x04, 0x12, 0x1e, 0xfb, 0x75, 0x3c, 0x01, 0x75,
+0x3d, 0x01, 0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x17, 0x6c, 0x7f, 0x14, 0x12, 0x1d, 0x5e,
+0x7b, 0x04, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x09, 0x3c, 0x7f, 0x5f, 0x12, 0x1f, 0x9a, 0x12, 0x09,
+0x43, 0x02, 0x14, 0x44, 0x8f, 0x37, 0x12, 0x0a, 0x8b, 0xaf, 0x37, 0x12, 0x12, 0xb1, 0x75, 0x3d,
+0x00, 0x75, 0x3e, 0x40, 0x7b, 0x40, 0x7d, 0x12, 0x12, 0x0e, 0x31, 0x12, 0x1f, 0x5c, 0x75, 0x3d,
+0x0f, 0x75, 0x3e, 0xc0, 0x7b, 0x40, 0x7a, 0x02, 0x7d, 0x16, 0xaf, 0x37, 0x12, 0x19, 0x49, 0x75,
+0x3d, 0x60, 0x75, 0x3e, 0x00, 0x7b, 0x00, 0x7a, 0x40, 0x7d, 0x14, 0xaf, 0x37, 0x12, 0x19, 0x49,
+0x75, 0x3d, 0x00, 0x75, 0x3e, 0x38, 0x7b, 0x30, 0x7d, 0x18, 0x12, 0x0e, 0x31, 0x12, 0x1f, 0x4a,
+0x75, 0x3d, 0xe0, 0x12, 0x1a, 0x4f, 0xaf, 0x37, 0x12, 0x19, 0x49, 0xaf, 0x37, 0x12, 0x1f, 0x65,
+0x75, 0x3d, 0xe0, 0x75, 0x3e, 0x0e, 0x7b, 0x02, 0x7a, 0x80, 0x7d, 0x18, 0xaf, 0x37, 0x02, 0x19,
+0x49, 0x7a, 0x00, 0xaf, 0x37, 0x12, 0x19, 0x49, 0xaf, 0x37, 0x22, 0x8f, 0x35, 0x8e, 0x34, 0x8d,
+0x33, 0x8c, 0x32, 0xe4, 0xf5, 0x40, 0xe4, 0xff, 0xfe, 0xfd, 0xfc, 0xab, 0x35, 0xaa, 0x34, 0xa9,
+0x33, 0xa8, 0x32, 0xd3, 0x12, 0x04, 0xcf, 0x40, 0x37, 0xe4, 0x7b, 0x0a, 0xfa, 0xf9, 0xf8, 0xaf,
+0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0x12, 0x04, 0x30, 0xaf, 0x03, 0x74, 0x36, 0x25, 0x40,
+0xf8, 0xa6, 0x07, 0xaf, 0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0xe4, 0x7b, 0x0a, 0xfa, 0xf9,
+0xf8, 0x12, 0x04, 0x30, 0x8f, 0x35, 0x8e, 0x34, 0x8d, 0x33, 0x8c, 0x32, 0x05, 0x40, 0x80, 0xb6,
+0xe5, 0x40, 0x70, 0x05, 0x7f, 0x30, 0x02, 0x1d, 0x84, 0x15, 0x40, 0xe5, 0x40, 0xf4, 0x60, 0x10,
+0x74, 0x36, 0x25, 0x40, 0xf8, 0xe6, 0x24, 0x30, 0xff, 0x12, 0x1d, 0x84, 0x15, 0x40, 0x80, 0xeb,
+0x22, 0x7b, 0xff, 0x7a, 0x1e, 0x79, 0x29, 0x12, 0x19, 0xe0, 0x12, 0x1f, 0x19, 0x7b, 0xff, 0x7a,
+0x12, 0x79, 0x66, 0x12, 0x19, 0xe0, 0x7b, 0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x09, 0x28, 0x12,
+0x1c, 0x12, 0x12, 0x1f, 0x19, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x6b, 0x12, 0x19, 0xe0, 0xe4, 0xf5,
+0x24, 0xaf, 0x24, 0x12, 0x1a, 0xb0, 0x7f, 0x03, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1e, 0x64,
+0x7f, 0x02, 0x12, 0x1d, 0x23, 0x7f, 0x01, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1f, 0xa8, 0xe4,
+0xfc, 0xfd, 0xfe, 0x12, 0x0e, 0x3b, 0x7f, 0x03, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1f, 0xaf,
+0x12, 0x1a, 0xb0, 0x12, 0x1f, 0x19, 0x05, 0x24, 0xe5, 0x24, 0xc3, 0x94, 0x07, 0x40, 0xc2, 0x22,
+0x8f, 0x32, 0x8d, 0x33, 0x7b, 0x24, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0x7f, 0x06, 0x12, 0x1b, 0x35,
+0x12, 0x09, 0x43, 0xe5, 0x32, 0x24, 0x80, 0xfb, 0x75, 0x3c, 0x1b, 0x75, 0x3d, 0x01, 0xe4, 0xfd,
+0x7f, 0x40, 0x12, 0x17, 0x6c, 0x7f, 0x02, 0x12, 0x1e, 0xfb, 0xaf, 0x33, 0x12, 0x1a, 0x6e, 0x7f,
+0x0a, 0x12, 0x1f, 0x85, 0x12, 0x1e, 0xcf, 0x40, 0x05, 0x12, 0x1f, 0xbd, 0x50, 0xf6, 0x12, 0x1f,
+0xbd, 0x40, 0x13, 0xad, 0x33, 0xaf, 0x32, 0x12, 0x13, 0x66, 0xef, 0x70, 0x04, 0xf5, 0x34, 0x80,
+0x08, 0x75, 0x34, 0x01, 0x80, 0x03, 0x75, 0x34, 0x02, 0xe5, 0x32, 0x24, 0x80, 0xfb, 0x75, 0x3c,
+0x1b, 0xe4, 0xf5, 0x3d, 0xfd, 0x7f, 0x40, 0x12, 0x17, 0x6c, 0xaf, 0x34, 0x22, 0x8f, 0x0a, 0xc3,
+0xed, 0x94, 0x40, 0xec, 0x94, 0x00, 0x50, 0x16, 0xc3, 0x74, 0x40, 0x9d, 0xff, 0xe4, 0x9c, 0xfe,
+0xef, 0x78, 0x02, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0xf5, 0x0b, 0x80, 0x1c, 0xed, 0x24,
+0x03, 0xff, 0xe4, 0x3c, 0xfe, 0xef, 0x78, 0x02, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x30,
+0xe0, 0x05, 0x75, 0x0b, 0x01, 0x80, 0x03, 0xe4, 0xf5, 0x0b, 0xc3, 0xed, 0x94, 0x40, 0xec, 0x94,
+0x00, 0x40, 0x0e, 0xae, 0x04, 0xaf, 0x05, 0xe4, 0xfc, 0xfd, 0x78, 0x10, 0x12, 0x04, 0xf3, 0x80,
+0x08, 0x7f, 0x00, 0x7e, 0x00, 0x7d, 0x40, 0x7c, 0x00, 0x12, 0x15, 0x42, 0x7f, 0x20, 0x7e, 0x05,
+0x7d, 0x00, 0x7c, 0x00, 0x02, 0x15, 0x42, 0x8e, 0x23, 0x8f, 0x24, 0x8c, 0x25, 0x8d, 0x26, 0x7f,
+0x0a, 0x12, 0x1d, 0x37, 0x12, 0x1f, 0x37, 0x40, 0x52, 0x12, 0x1e, 0x38, 0xe4, 0xff, 0x12, 0x1d,
+0xa8, 0x7f, 0x02, 0x12, 0x1a, 0x29, 0xe5, 0x23, 0xff, 0x12, 0x1a, 0x29, 0xaf, 0x24, 0x12, 0x1a,
+0x29, 0xe4, 0xf5, 0x27, 0x12, 0x1f, 0x37, 0x40, 0x24, 0x12, 0x1e, 0xc4, 0x50, 0xfb, 0x12, 0x1d,
+0xed, 0x12, 0x1a, 0x29, 0x05, 0x24, 0xe5, 0x24, 0x70, 0x02, 0x05, 0x23, 0xe5, 0x26, 0x15, 0x26,
+0x70, 0x02, 0x15, 0x25, 0x05, 0x27, 0xe5, 0x27, 0xc3, 0x94, 0x20, 0x40, 0xd7, 0x7f, 0x01, 0x12,
+0x1d, 0xa8, 0x12, 0x1c, 0xba, 0xef, 0x30, 0xe0, 0xab, 0x80, 0xf7, 0xe4, 0xff, 0x02, 0x1d, 0x37,
+0x8f, 0x33, 0x8d, 0x34, 0x8b, 0x35, 0xe5, 0x39, 0x55, 0x3d, 0xf5, 0x39, 0xe5, 0x38, 0x55, 0x3c,
+0xf5, 0x38, 0xe5, 0x37, 0x55, 0x3b, 0xf5, 0x37, 0xe5, 0x36, 0x55, 0x3a, 0xf5, 0x36, 0x12, 0x09,
+0x28, 0xa8, 0x04, 0xa9, 0x05, 0xaa, 0x06, 0xab, 0x07, 0xaf, 0x3d, 0xae, 0x3c, 0xad, 0x3b, 0xac,
+0x3a, 0x12, 0x04, 0xc2, 0xeb, 0x5f, 0xff, 0xea, 0x5e, 0xfe, 0xe9, 0x5d, 0xfd, 0xe8, 0x5c, 0xfc,
+0xe5, 0x39, 0x4f, 0xf5, 0x39, 0xe5, 0x38, 0x4e, 0xf5, 0x38, 0xe5, 0x37, 0x4d, 0xf5, 0x37, 0xe5,
+0x36, 0x4c, 0xf5, 0x36, 0xab, 0x35, 0xad, 0x34, 0xaf, 0x33, 0x12, 0x09, 0x3c, 0xaf, 0x39, 0xae,
+0x38, 0xad, 0x37, 0xac, 0x36, 0x02, 0x09, 0x43, 0x8f, 0x32, 0x8d, 0x33, 0x7b, 0x19, 0xad, 0x32,
+0x7f, 0x20, 0x12, 0x09, 0x3c, 0x12, 0x1b, 0x33, 0x12, 0x09, 0x43, 0xe5, 0x33, 0x44, 0x10, 0xfd,
+0xaf, 0x32, 0x12, 0x11, 0x92, 0xef, 0xf5, 0x37, 0xee, 0xf5, 0x36, 0xed, 0x44, 0x01, 0xf5, 0x35,
+0xec, 0x44, 0x10, 0xf5, 0x34, 0x12, 0x11, 0x23, 0xe5, 0x37, 0x44, 0x30, 0xff, 0xe5, 0x36, 0xfe,
+0xe5, 0x35, 0xfd, 0xe5, 0x34, 0x44, 0x20, 0xfc, 0x12, 0x09, 0x43, 0x12, 0x11, 0x23, 0xaf, 0x37,
+0xae, 0x36, 0xad, 0x35, 0xac, 0x34, 0x12, 0x09, 0x43, 0xe5, 0x32, 0xb4, 0x06, 0x04, 0xff, 0x12,
+0x16, 0xcf, 0x22, 0xe4, 0xfb, 0xad, 0x32, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0x22, 0x7f, 0x0a, 0x12,
+0x1d, 0x37, 0xe4, 0xff, 0xfe, 0x12, 0x19, 0x6f, 0xef, 0x7f, 0x00, 0xfe, 0xc0, 0x07, 0xc0, 0x06,
+0x0f, 0x7e, 0x00, 0x12, 0x19, 0x6f, 0xef, 0xfd, 0xd0, 0xe0, 0xf5, 0x1b, 0xd0, 0xe0, 0x4d, 0xf5,
+0x1c, 0x24, 0x01, 0xff, 0xe4, 0x35, 0x1b, 0xfe, 0x12, 0x19, 0x6f, 0x8f, 0x1d, 0xe4, 0xff, 0x12,
+0x1d, 0x37, 0xe5, 0x1c, 0x15, 0x1c, 0x70, 0x02, 0x15, 0x1b, 0xe4, 0xff, 0xfe, 0xc3, 0xef, 0x95,
+0x1c, 0xee, 0x95, 0x1b, 0x50, 0x11, 0x8f, 0x82, 0x8e, 0x83, 0xe4, 0x93, 0x25, 0x1d, 0xf5, 0x1d,
+0x0f, 0xbf, 0x00, 0x01, 0x0e, 0x80, 0xe6, 0xe5, 0x1d, 0x70, 0x04, 0x7f, 0x01, 0x80, 0x02, 0x7f,
+0x00, 0x22, 0xef, 0x64, 0x06, 0xef, 0x64, 0x06, 0x70, 0x24, 0xbd, 0x10, 0x08, 0x7f, 0x43, 0x7e,
+0x04, 0x7d, 0x04, 0xfc, 0x22, 0xed, 0x70, 0x04, 0x7f, 0x43, 0x80, 0x20, 0xbd, 0x11, 0x04, 0x7f,
+0x42, 0x80, 0x24, 0xbd, 0x01, 0x04, 0x7f, 0x42, 0x80, 0x29, 0x7f, 0x81, 0x80, 0x2e, 0xbd, 0x10,
+0x06, 0x7f, 0x44, 0x7e, 0x04, 0x80, 0x12, 0xed, 0x70, 0x08, 0x7f, 0x44, 0x7e, 0x04, 0xfd, 0x7c,
+0x80, 0x22, 0xbd, 0x11, 0x09, 0x7f, 0x44, 0x7e, 0x24, 0x7d, 0x04, 0x7c, 0x00, 0x22, 0xbd, 0x01,
+0x09, 0x7f, 0x44, 0x7e, 0x24, 0x7d, 0x00, 0x7c, 0x80, 0x22, 0x7f, 0x84, 0x7e, 0x01, 0x7d, 0x06,
+0x7c, 0x00, 0x22, 0x8f, 0x2c, 0x7f, 0x32, 0x12, 0x1f, 0x85, 0x7b, 0xd8, 0xad, 0x2c, 0x7f, 0x20,
+0x12, 0x09, 0x28, 0x78, 0x08, 0x12, 0x04, 0xe0, 0xef, 0x54, 0x3f, 0xff, 0xe4, 0xfe, 0xfd, 0xfc,
+0xfb, 0xfa, 0xf9, 0xf8, 0xc3, 0x12, 0x04, 0xcf, 0x70, 0x32, 0x7b, 0x0c, 0xfd, 0x7f, 0xa0, 0x12,
+0x09, 0x28, 0xc0, 0x04, 0xc0, 0x05, 0xc0, 0x06, 0xc0, 0x07, 0xaf, 0x2c, 0x12, 0x09, 0x7a, 0xe4,
+0xfc, 0xfd, 0xfe, 0xd0, 0x03, 0xd0, 0x02, 0xd0, 0x01, 0xd0, 0x00, 0xeb, 0x5f, 0xff, 0xe4, 0xfb,
+0xfa, 0xf9, 0xf8, 0xc3, 0x12, 0x04, 0xcf, 0x60, 0x03, 0x7f, 0x01, 0x22, 0x12, 0x1f, 0xbd, 0x50,
+0xa9, 0x7f, 0x00, 0x22, 0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x63, 0x6f, 0x6d, 0x6d,
+0x61, 0x6e, 0x64, 0x0d, 0x0a, 0x00, 0x69, 0x64, 0x3a, 0x20, 0x00, 0x00, 0x50, 0x00, 0x4d, 0x00,
+0x50, 0x20, 0x00, 0x00, 0x00, 0x0d, 0x0a, 0x20, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x20, 0x40,
+0x31, 0x30, 0x20, 0x40, 0x31, 0x30, 0x30, 0x20, 0x40, 0x31, 0x30, 0x30, 0x30, 0x00, 0x4f, 0x6b,
+0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x00, 0x0d, 0x0a,
+0x54, 0x65, 0x73, 0x74, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x0d, 0x0a,
+0x00, 0x8f, 0x38, 0x12, 0x1f, 0x5c, 0x12, 0x1a, 0x59, 0x12, 0x12, 0xf9, 0x12, 0x1f, 0x53, 0x7a,
+0xb6, 0x12, 0x13, 0x03, 0x75, 0x3d, 0xff, 0x75, 0x3e, 0x07, 0x7b, 0x03, 0x7a, 0x00, 0x7d, 0x12,
+0xaf, 0x38, 0x12, 0x19, 0x49, 0x75, 0x3d, 0x00, 0x75, 0x3e, 0xff, 0x7b, 0xa2, 0x7a, 0x00, 0x7d,
+0x11, 0xaf, 0x38, 0x12, 0x19, 0x49, 0x7a, 0x96, 0x12, 0x13, 0x03, 0xaf, 0x38, 0x12, 0x1f, 0x5c,
+0x12, 0x1a, 0x64, 0x12, 0x12, 0xf9, 0x02, 0x1f, 0x65, 0x7d, 0x08, 0xaf, 0x38, 0x12, 0x19, 0x49,
+0xaf, 0x38, 0x22, 0x7b, 0x8a, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xce, 0x22, 0x8f, 0x3f, 0x8d,
+0x40, 0x12, 0x1f, 0xa8, 0x8f, 0x45, 0xaf, 0x3f, 0x12, 0x1f, 0xaf, 0x8f, 0x46, 0x7b, 0x01, 0xad,
+0x45, 0x7f, 0x60, 0x12, 0x09, 0x3c, 0xe5, 0x46, 0x75, 0xf0, 0x20, 0xa4, 0xff, 0xe5, 0xf0, 0x44,
+0x04, 0xfc, 0xef, 0x45, 0x40, 0xfd, 0xe4, 0xff, 0xfe, 0x12, 0x09, 0x59, 0x12, 0x09, 0x43, 0xaf,
+0x45, 0x12, 0x1b, 0x13, 0x7b, 0x02, 0xad, 0x45, 0x7f, 0x60, 0x12, 0x09, 0x28, 0x8f, 0x44, 0x8e,
+0x43, 0x8d, 0x42, 0x8c, 0x41, 0xe5, 0x42, 0x54, 0x01, 0xfd, 0xed, 0x70, 0x05, 0xae, 0x43, 0xaf,
+0x44, 0x22, 0xe4, 0xfe, 0xff, 0x22, 0x8f, 0x35, 0x8d, 0x36, 0xe4, 0xf5, 0x38, 0xfb, 0x7a, 0x00,
+0x79, 0x39, 0x12, 0x14, 0x86, 0xef, 0x64, 0x80, 0x4e, 0x60, 0x03, 0x75, 0x38, 0x01, 0xe5, 0x39,
+0x65, 0x35, 0x60, 0x03, 0x75, 0x38, 0x01, 0xe5, 0x38, 0x70, 0x25, 0xf5, 0x37, 0x12, 0x1c, 0xfb,
+0xa8, 0x04, 0xa9, 0x05, 0xaa, 0x06, 0xab, 0x07, 0xe4, 0x25, 0x36, 0x12, 0x1b, 0x3c, 0xc3, 0x12,
+0x04, 0xcf, 0x60, 0x03, 0x75, 0x38, 0x01, 0x05, 0x37, 0xe5, 0x37, 0xc3, 0x94, 0x1f, 0x40, 0xdd,
+0x12, 0x1d, 0x0f, 0xaf, 0x38, 0x22, 0x8f, 0x35, 0x8d, 0x36, 0xe4, 0xfb, 0xfa, 0xfd, 0x12, 0x17,
+0xce, 0xe5, 0x36, 0x54, 0x03, 0xff, 0x70, 0x06, 0xf5, 0x37, 0xf5, 0x38, 0x80, 0x14, 0xbf, 0x01,
+0x08, 0x75, 0x37, 0x20, 0x75, 0x38, 0x00, 0x80, 0x09, 0xbf, 0x02, 0x06, 0x75, 0x37, 0x00, 0x75,
+0x38, 0x40, 0xe5, 0x36, 0x30, 0xe4, 0x03, 0x43, 0x37, 0x01, 0xe5, 0x36, 0x30, 0xe7, 0x03, 0x43,
+0x37, 0x40, 0xab, 0x38, 0xaa, 0x37, 0xe4, 0xfd, 0xaf, 0x35, 0x02, 0x17, 0xce, 0x8f, 0x27, 0x12,
+0x1f, 0x53, 0x7b, 0xf0, 0x7a, 0xaf, 0x7d, 0x10, 0xaf, 0x27, 0x12, 0x17, 0xce, 0x7d, 0x11, 0xaf,
+0x27, 0x12, 0x13, 0x0d, 0xee, 0xc4, 0xf8, 0x54, 0xf0, 0xc8, 0xef, 0xc4, 0x54, 0x0f, 0x48, 0x54,
+0x1f, 0xff, 0xc3, 0x94, 0x10, 0x40, 0x06, 0xef, 0xd3, 0x94, 0x14, 0x40, 0x12, 0xaf, 0x27, 0x12,
+0x1f, 0x5c, 0x75, 0x3d, 0x03, 0x12, 0x1a, 0x67, 0x7d, 0x0c, 0xaf, 0x27, 0x12, 0x19, 0x49, 0xaf,
+0x27, 0x02, 0x1f, 0x65, 0x75, 0x27, 0x01, 0x7b, 0x06, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x09, 0x3c,
+0x7f, 0x80, 0x7e, 0x01, 0x7d, 0x00, 0x7c, 0x00, 0x12, 0x09, 0x43, 0x7b, 0x07, 0xe4, 0xfd, 0x7f,
+0x40, 0x12, 0x09, 0x3c, 0xe4, 0x25, 0x27, 0xff, 0xe4, 0x33, 0xfe, 0xe4, 0x33, 0xfd, 0xe4, 0x34,
+0xc2, 0xfc, 0x12, 0x09, 0x43, 0x7f, 0x01, 0x7e, 0x26, 0x12, 0x16, 0x65, 0x05, 0x27, 0xe5, 0x27,
+0xd3, 0x94, 0x0f, 0x40, 0xc2, 0x22, 0x8b, 0x3a, 0x8a, 0x3b, 0x89, 0x3c, 0xe4, 0xf5, 0x08, 0xf5,
+0x09, 0x12, 0x14, 0xba, 0xe5, 0x3d, 0x54, 0x3f, 0xf5, 0x41, 0x85, 0x3e, 0x42, 0xe5, 0x3b, 0x45,
+0x3c, 0x45, 0x3a, 0x60, 0x10, 0xe5, 0x40, 0x54, 0x07, 0xab, 0x3a, 0xaa, 0x3b, 0xa9, 0x3c, 0x12,
+0x03, 0x93, 0x12, 0x14, 0xba, 0xae, 0x41, 0xaf, 0x42, 0x22, 0x12, 0x1c, 0xfb, 0x8f, 0x40, 0x8e,
+0x3f, 0x8d, 0x3e, 0x8c, 0x3d, 0x22, 0xc0, 0xe0, 0xc0, 0xd0, 0x75, 0xd0, 0x10, 0x30, 0x98, 0x29,
+0xaf, 0x99, 0xc2, 0x98, 0xe5, 0x1e, 0x24, 0x01, 0xfd, 0xe4, 0x33, 0xfc, 0xe5, 0x1f, 0x7a, 0x00,
+0xb5, 0x15, 0x08, 0xea, 0xb5, 0x14, 0x04, 0xd2, 0x05, 0x80, 0x0e, 0x74, 0x80, 0x25, 0x1e, 0xf8,
+0xa6, 0x17, 0xe5, 0x1e, 0x04, 0x54, 0x1f, 0xf5, 0x1e, 0x30, 0x99, 0x04, 0xc2, 0x99, 0xd2, 0x06,
+0xd0, 0xd0, 0xd0, 0xe0, 0x32, 0x8b, 0x23, 0x8a, 0x24, 0x89, 0x25, 0xab, 0x26, 0xaa, 0x27, 0xa9,
+0x28, 0x12, 0x03, 0x7a, 0xf5, 0x29, 0x70, 0x02, 0xff, 0x22, 0x74, 0x01, 0x25, 0x28, 0xf5, 0x28,
+0xe4, 0x35, 0x27, 0xf5, 0x27, 0xab, 0x23, 0x05, 0x25, 0xe5, 0x25, 0xaa, 0x24, 0x70, 0x02, 0x05,
+0x24, 0x14, 0xf9, 0x12, 0x03, 0x7a, 0xff, 0x12, 0x1c, 0x44, 0xef, 0x65, 0x29, 0x60, 0xcc, 0x7f,
+0x01, 0x22, 0x8f, 0x3a, 0x8e, 0x39, 0x8d, 0x38, 0x8c, 0x37, 0x20, 0x08, 0x30, 0x7b, 0xc0, 0xad,
+0x0a, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0xaf, 0x3a, 0xae, 0x39, 0xad, 0x38, 0xac, 0x37, 0x12, 0x09,
+0x43, 0xe4, 0x78, 0xa7, 0xf6, 0x7b, 0xc8, 0xad, 0x0a, 0x7f, 0x20, 0x12, 0x09, 0x28, 0xee, 0x30,
+0xe0, 0x0b, 0x78, 0xa7, 0x06, 0xe6, 0xd3, 0x94, 0x64, 0x40, 0xea, 0xd2, 0x08, 0x22, 0x12, 0x19,
+0x23, 0x8f, 0x2b, 0xe4, 0xf5, 0x2a, 0xaf, 0x2a, 0x12, 0x09, 0x7a, 0xef, 0xf4, 0xff, 0xef, 0x55,
+0x2b, 0xff, 0xe4, 0x8f, 0x39, 0xf5, 0x38, 0xf5, 0x37, 0xf5, 0x36, 0xe5, 0x2a, 0x24, 0x80, 0xfb,
+0xe4, 0x75, 0x3d, 0x5f, 0xf5, 0x3c, 0xf5, 0x3b, 0xf5, 0x3a, 0xfd, 0x7f, 0x40, 0x12, 0x10, 0x60,
+0x05, 0x2a, 0xe5, 0x2a, 0xc3, 0x94, 0x07, 0x40, 0xcd, 0x22, 0x12, 0x1e, 0xc4, 0x50, 0x35, 0x12,
+0x1d, 0xed, 0xef, 0x64, 0x0a, 0x60, 0x2d, 0xbf, 0x08, 0x0b, 0xe5, 0x18, 0xd3, 0x94, 0x00, 0x40,
+0x23, 0x15, 0x18, 0x80, 0x1f, 0xe5, 0x18, 0xc3, 0x94, 0x1e, 0x50, 0x0a, 0xae, 0x18, 0x05, 0x18,
+0x74, 0x62, 0x2e, 0xf8, 0xa6, 0x07, 0xbf, 0x0d, 0x0b, 0xe5, 0x18, 0xb4, 0x1e, 0x04, 0x78, 0x7f,
+0x76, 0x0d, 0xd3, 0x22, 0xc3, 0x22, 0x8f, 0x25, 0x8d, 0x26, 0xe5, 0x25, 0x64, 0x06, 0x60, 0x2d,
+0xe5, 0x26, 0x54, 0x03, 0xff, 0xbf, 0x02, 0x05, 0xaf, 0x25, 0x12, 0x13, 0xfd, 0xe5, 0x26, 0x54,
+0x03, 0x70, 0x1a, 0xaf, 0x25, 0x12, 0x1f, 0x5c, 0x12, 0x1a, 0x4c, 0xaf, 0x25, 0x12, 0x19, 0x49,
+0x12, 0x1a, 0x4c, 0xaf, 0x25, 0x12, 0x19, 0x49, 0xaf, 0x25, 0x12, 0x1f, 0x65, 0x22, 0xaf, 0x0b,
+0x15, 0x0b, 0xef, 0xd3, 0x94, 0x00, 0x40, 0x0d, 0x7f, 0x55, 0x7e, 0x55, 0x7d, 0x55, 0x7c, 0x55,
+0x12, 0x15, 0x42, 0x80, 0xe9, 0x30, 0x08, 0x09, 0x75, 0x3c, 0x01, 0x12, 0x16, 0x58, 0xc2, 0x08,
+0x22, 0xe4, 0xf5, 0x3c, 0x12, 0x16, 0x58, 0x22, 0x75, 0x3d, 0x01, 0x7b, 0xc4, 0xad, 0x0a, 0x7f,
+0x20, 0x12, 0x17, 0x6c, 0x22, 0x8e, 0x28, 0x8f, 0x29, 0x7b, 0xb0, 0xe4, 0xfd, 0x7f, 0x40, 0x12,
+0x09, 0x3c, 0xae, 0x28, 0xaf, 0x29, 0xe4, 0xfc, 0xfd, 0x12, 0x09, 0x43, 0x7f, 0x0a, 0x12, 0x1f,
+0x85, 0x7b, 0xb0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x09, 0x28, 0xef, 0x54, 0x07, 0x60, 0x0a, 0x12,
+0x1f, 0xbd, 0x50, 0xed, 0x7f, 0x04, 0x12, 0x1f, 0xc5, 0x22, 0x8f, 0x28, 0x8d, 0x29, 0xe5, 0x29,
+0xf4, 0x60, 0x29, 0x7b, 0x10, 0xad, 0x28, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0x7f, 0x00, 0x7e, 0x06,
+0x7d, 0x00, 0x7c, 0x00, 0x12, 0x09, 0x43, 0xad, 0x29, 0xaf, 0x28, 0x12, 0x07, 0x66, 0xe4, 0xfd,
+0xaf, 0x28, 0x12, 0x00, 0x26, 0x7d, 0x01, 0xaf, 0x28, 0x12, 0x1e, 0xb7, 0x02, 0x15, 0x7e, 0x8f,
+0x38, 0x75, 0x3c, 0x05, 0x75, 0x3d, 0x01, 0x7b, 0x19, 0xad, 0x38, 0x7f, 0x20, 0x12, 0x17, 0x6c,
+0xe5, 0x38, 0xb4, 0x06, 0x0e, 0x75, 0x3c, 0x02, 0x75, 0x3d, 0x01, 0x7b, 0x19, 0xfd, 0x7f, 0x20,
+0x12, 0x17, 0x6c, 0x7b, 0x05, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x09, 0x3c, 0x7f, 0x22, 0x12, 0x1f,
+0x9a, 0x02, 0x09, 0x43, 0xe4, 0xf5, 0x22, 0xe5, 0x22, 0x24, 0x80, 0xfb, 0xe4, 0xfd, 0x7f, 0x40,
+0x12, 0x09, 0x3c, 0x7f, 0x00, 0x12, 0x1f, 0x9a, 0x12, 0x09, 0x43, 0xe5, 0x22, 0xb4, 0x06, 0x05,
+0x7d, 0x12, 0xff, 0x80, 0x04, 0x7d, 0xff, 0xaf, 0x22, 0x12, 0x1b, 0x8b, 0x05, 0x22, 0xe5, 0x22,
+0xc3, 0x94, 0x07, 0x40, 0xd2, 0x02, 0x15, 0x7e, 0x8b, 0x2b, 0x8a, 0x2c, 0x89, 0x2d, 0xe4, 0xf5,
+0x2e, 0xab, 0x2b, 0x05, 0x2d, 0xe5, 0x2d, 0xaa, 0x2c, 0x70, 0x02, 0x05, 0x2c, 0x14, 0xf9, 0x12,
+0x03, 0x7a, 0xff, 0x12, 0x1b, 0xf9, 0xe5, 0x2e, 0xc3, 0x94, 0x05, 0x50, 0x05, 0x7f, 0x2d, 0x12,
+0x1f, 0xc8, 0x05, 0x2e, 0xe5, 0x2e, 0xc3, 0x94, 0x06, 0x40, 0xd6, 0x22, 0x8f, 0x39, 0x8d, 0x3a,
+0x8b, 0x3b, 0x12, 0x09, 0x28, 0x8f, 0x41, 0x8e, 0x40, 0x8d, 0x3f, 0x8c, 0x3e, 0x7b, 0x00, 0x7a,
+0x00, 0x79, 0x3e, 0xad, 0x3d, 0xaf, 0x3c, 0x12, 0x09, 0xa9, 0xab, 0x3b, 0xad, 0x3a, 0xaf, 0x39,
+0x12, 0x09, 0x3c, 0xaf, 0x41, 0xae, 0x40, 0xad, 0x3f, 0xac, 0x3e, 0x02, 0x09, 0x43, 0x00, 0x00,
+0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x15, 0x00, 0x10, 0x00, 0x15, 0x00, 0x12,
+0x00, 0x15, 0x00, 0x14, 0x00, 0x15, 0x00, 0x00, 0x10, 0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0a,
+0x00, 0x18, 0x00, 0x0b, 0x00, 0x18, 0x00, 0x0c, 0x00, 0x18, 0x00, 0x0d, 0x00, 0x18, 0x8f, 0x3f,
+0x8d, 0x40, 0x8a, 0x41, 0x8b, 0x42, 0x12, 0x1f, 0xa8, 0x8f, 0x43, 0xaf, 0x3f, 0x12, 0x1f, 0xaf,
+0x8f, 0x44, 0x7b, 0x01, 0xad, 0x43, 0x7f, 0x60, 0x12, 0x09, 0x3c, 0xab, 0x44, 0xad, 0x40, 0xaf,
+0x42, 0xae, 0x41, 0x12, 0x1f, 0x05, 0x12, 0x09, 0x43, 0xaf, 0x43, 0x02, 0x1b, 0x13, 0x8f, 0x37,
+0x7b, 0x00, 0x7a, 0x80, 0xe4, 0xfd, 0x12, 0x17, 0xce, 0x7f, 0x02, 0x12, 0x1d, 0x5e, 0xe4, 0xf5,
+0x38, 0xe4, 0xfd, 0xaf, 0x37, 0x12, 0x13, 0x0d, 0xee, 0x30, 0xe7, 0x10, 0x05, 0x38, 0xe5, 0x38,
+0xd3, 0x94, 0xc8, 0x50, 0x07, 0x7f, 0x01, 0x12, 0x1d, 0x5e, 0x80, 0xe5, 0x22, 0xc1, 0x05, 0xc1,
+0x04, 0x01, 0x1e, 0x00, 0x01, 0x1f, 0x00, 0xc1, 0x00, 0xc1, 0x01, 0x01, 0x0e, 0x00, 0xc1, 0x02,
+0xc1, 0x03, 0x01, 0x0c, 0x0a, 0x01, 0x0d, 0x64, 0xc1, 0x07, 0x01, 0x0f, 0x00, 0xc1, 0x08, 0x01,
+0x18, 0x00, 0x01, 0x4d, 0x00, 0x01, 0x51, 0x00, 0x00, 0x8f, 0x2a, 0x8e, 0x29, 0x8d, 0x28, 0x8c,
+0x27, 0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x09, 0x3c, 0xaf, 0x2a, 0xae, 0x29, 0xad, 0x28,
+0xac, 0x27, 0x12, 0x09, 0x43, 0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x09, 0x28, 0xef, 0x54,
+0x03, 0x70, 0xf2, 0x22, 0xe4, 0xfe, 0xee, 0x90, 0x00, 0x40, 0x93, 0xfc, 0xed, 0x2e, 0xf8, 0xa6,
+0x04, 0x0e, 0xbe, 0x06, 0xf1, 0xed, 0x24, 0x05, 0xf8, 0xe6, 0x2f, 0xf6, 0xc3, 0x9f, 0x50, 0x0d,
+0xed, 0x24, 0x04, 0xf8, 0x06, 0xe6, 0x70, 0x05, 0xed, 0x24, 0x03, 0xf8, 0x06, 0x22, 0x7b, 0x17,
+0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x09, 0x3c, 0x7f, 0xff, 0x7e, 0xff, 0x7d, 0xff, 0x7c, 0xff, 0x12,
+0x09, 0x43, 0x7b, 0x16, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x09, 0x3c, 0x7f, 0x9b, 0x7e, 0x22, 0x7d,
+0x00, 0x7c, 0x00, 0x02, 0x09, 0x43, 0x8f, 0x32, 0x8d, 0x33, 0x8b, 0x34, 0x12, 0x1f, 0x2d, 0xaf,
+0x33, 0x12, 0x1f, 0x2d, 0x7f, 0x05, 0x12, 0x1e, 0xfb, 0xe5, 0x34, 0x44, 0x10, 0xfd, 0xaf, 0x32,
+0x12, 0x13, 0xb6, 0xe5, 0x34, 0x44, 0x10, 0xfd, 0xaf, 0x33, 0x02, 0x13, 0xb6, 0x8f, 0x32, 0xed,
+0x70, 0x02, 0x80, 0x01, 0xe4, 0x75, 0x39, 0x86, 0x75, 0x38, 0x02, 0xf5, 0x37, 0xf5, 0x36, 0x75,
+0x3d, 0xff, 0x75, 0x3c, 0x0f, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x02, 0xad, 0x32, 0x7f, 0x20, 0x12,
+0x10, 0x60, 0x22, 0xe4, 0xf5, 0x2c, 0xf5, 0x2d, 0xaf, 0x2d, 0x12, 0x00, 0x03, 0xef, 0x60, 0x0d,
+0x7b, 0x00, 0x7a, 0x00, 0x79, 0x2c, 0x7d, 0x01, 0xaf, 0x2d, 0x12, 0x09, 0x81, 0x05, 0x2d, 0xe5,
+0x2d, 0xc3, 0x94, 0x07, 0x40, 0xe2, 0xaf, 0x2c, 0x22, 0x8f, 0x39, 0x8d, 0x3a, 0x8a, 0x3b, 0x8b,
+0x3c, 0x12, 0x13, 0x0d, 0xe5, 0x3e, 0xf4, 0xfd, 0xe5, 0x3d, 0xf4, 0x5e, 0xfe, 0xef, 0x5d, 0x42,
+0x3c, 0xee, 0x42, 0x3b, 0xab, 0x3c, 0xaa, 0x3b, 0xad, 0x3a, 0xaf, 0x39, 0x02, 0x17, 0xce, 0x8e,
+0x48, 0x8f, 0x49, 0xe4, 0xff, 0x12, 0x1d, 0xa8, 0x7f, 0x03, 0x12, 0x1a, 0x29, 0xe5, 0x48, 0xff,
+0x12, 0x1a, 0x29, 0xaf, 0x49, 0x12, 0x1a, 0x29, 0x12, 0x1a, 0xf2, 0x8f, 0x4a, 0x7f, 0x01, 0x12,
+0x1d, 0xa8, 0xaf, 0x4a, 0x22, 0x12, 0x1c, 0x44, 0x74, 0x30, 0xd3, 0x9f, 0x50, 0x0a, 0xef, 0x94,
+0x39, 0x50, 0x05, 0xef, 0x24, 0xd0, 0xff, 0x22, 0x74, 0x41, 0xd3, 0x9f, 0x50, 0x0a, 0xef, 0x94,
+0x46, 0x50, 0x05, 0xef, 0x24, 0xc9, 0xff, 0x22, 0x7f, 0xff, 0x22, 0xc2, 0x8e, 0x75, 0x8b, 0x92,
+0x75, 0x8d, 0xe6, 0xd2, 0x8e, 0xd2, 0x03, 0xd5, 0x0c, 0x15, 0x75, 0x0c, 0x0a, 0xd2, 0x00, 0xd5,
+0x0d, 0x05, 0x75, 0x0d, 0x64, 0xd2, 0x01, 0x30, 0x02, 0x05, 0xd5, 0x0e, 0x02, 0xc2, 0x02, 0x32,
+0x8b, 0x32, 0x8a, 0x33, 0x89, 0x34, 0xab, 0x32, 0xaa, 0x33, 0xa9, 0x34, 0x12, 0x03, 0x7a, 0x60,
+0x13, 0x05, 0x34, 0xe5, 0x34, 0x70, 0x02, 0x05, 0x33, 0x14, 0xf9, 0x12, 0x03, 0x7a, 0xff, 0x12,
+0x1d, 0x84, 0x80, 0xe2, 0x22, 0x78, 0x56, 0x12, 0x05, 0x06, 0xad, 0x07, 0x22, 0x78, 0x5a, 0x12,
+0x05, 0x06, 0xab, 0x07, 0x22, 0x78, 0x52, 0x12, 0x05, 0x06, 0x78, 0x05, 0x02, 0x04, 0xf3, 0xa9,
+0x1a, 0x7a, 0x00, 0x7b, 0x00, 0x75, 0x26, 0xff, 0x22, 0x8f, 0x29, 0xe4, 0xf5, 0x2a, 0xe5, 0x29,
+0x54, 0x80, 0xff, 0x12, 0x1d, 0xba, 0xe5, 0x29, 0x25, 0xe0, 0xf5, 0x29, 0x12, 0x1f, 0x75, 0x12,
+0x1f, 0x7d, 0x05, 0x2a, 0xe5, 0x2a, 0xc3, 0x94, 0x08, 0x40, 0xe3, 0x22, 0x75, 0x3d, 0x60, 0x75,
+0x3e, 0x00, 0x7b, 0x00, 0x7a, 0x20, 0x7d, 0x14, 0x22, 0x75, 0x3d, 0x02, 0x75, 0x3e, 0x00, 0x7b,
+0x00, 0x7a, 0x02, 0x22, 0x75, 0x3d, 0x02, 0x75, 0x3e, 0x00, 0xe4, 0xfb, 0xfa, 0x22, 0x8f, 0x35,
+0x7d, 0x80, 0x7c, 0x00, 0x12, 0x0f, 0x8d, 0xe4, 0xf5, 0x36, 0xe4, 0x25, 0x35, 0x12, 0x1b, 0x3c,
+0x12, 0x15, 0x42, 0x05, 0x36, 0xe5, 0x36, 0xc3, 0x94, 0x20, 0x40, 0xee, 0x02, 0x16, 0x2e, 0x7b,
+0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x09, 0x28, 0xec, 0x54, 0x0f, 0xfc, 0x7b, 0xe9, 0x7a, 0x50,
+0x79, 0x38, 0x78, 0x07, 0xc3, 0x12, 0x04, 0xcf, 0x60, 0x03, 0x7f, 0x01, 0x22, 0x7f, 0x00, 0x22,
+0x8f, 0x32, 0xe5, 0x32, 0xd3, 0x94, 0x09, 0x40, 0x0b, 0xe5, 0x32, 0x75, 0xf0, 0x0a, 0x84, 0x12,
+0x1f, 0x23, 0x80, 0x02, 0x7f, 0x20, 0x12, 0x1d, 0x84, 0xe5, 0x32, 0x12, 0x1f, 0x23, 0x02, 0x1d,
+0x84, 0xe4, 0xf5, 0x4e, 0x7f, 0x03, 0x12, 0x1e, 0xfb, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e,
+0x80, 0x50, 0x05, 0xaf, 0x22, 0x12, 0x09, 0xf2, 0x05, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x07, 0x40,
+0xeb, 0x22, 0xe4, 0xf5, 0x29, 0xe5, 0x2a, 0x25, 0xe0, 0xf5, 0x2a, 0x12, 0x1f, 0x75, 0x12, 0x1d,
+0xcc, 0xef, 0x42, 0x2a, 0x12, 0x1f, 0x7d, 0x05, 0x29, 0xe5, 0x29, 0xc3, 0x94, 0x08, 0x40, 0xe5,
+0xaf, 0x2a, 0x22, 0x8f, 0x47, 0x7f, 0x05, 0x12, 0x1f, 0x85, 0xe4, 0xfb, 0xad, 0x47, 0x7f, 0x60,
+0x12, 0x09, 0x28, 0xef, 0x54, 0x0b, 0x60, 0x0a, 0x12, 0x1f, 0xbd, 0x50, 0xed, 0x7f, 0x02, 0x12,
+0x1f, 0xc5, 0x22, 0x7f, 0x00, 0x7e, 0x00, 0x7d, 0x00, 0x7c, 0x00, 0x22, 0xff, 0xe4, 0x34, 0x56,
+0xfe, 0xe4, 0x34, 0x34, 0xfd, 0xe4, 0x34, 0x12, 0xfc, 0x22, 0xff, 0x74, 0x03, 0xa8, 0x06, 0x08,
+0x22, 0xad, 0x07, 0xe4, 0xf5, 0x39, 0xf5, 0x38, 0x75, 0x37, 0x01, 0x75, 0x36, 0x10, 0xf5, 0x3d,
+0xf5, 0x3c, 0x75, 0x3b, 0x01, 0x75, 0x3a, 0x18, 0xfb, 0x7f, 0x20, 0x02, 0x10, 0x60, 0x8f, 0x25,
+0x12, 0x1f, 0xa1, 0xe4, 0xfd, 0x12, 0x09, 0x81, 0xaf, 0x25, 0x12, 0x1e, 0x80, 0x50, 0x05, 0xaf,
+0x25, 0x12, 0x1f, 0x41, 0x7d, 0xff, 0xaf, 0x25, 0x02, 0x1b, 0x8b, 0x8f, 0x26, 0x8d, 0x27, 0xe5,
+0x26, 0x64, 0x05, 0x60, 0x11, 0xe5, 0x27, 0xfd, 0x7c, 0x00, 0xaf, 0x26, 0x12, 0x1d, 0x96, 0xad,
+0x27, 0xaf, 0x26, 0x12, 0x16, 0x9a, 0x22, 0xbf, 0x06, 0x03, 0x7f, 0x12, 0x22, 0x7d, 0x1c, 0x12,
+0x13, 0x0d, 0xef, 0x13, 0x13, 0x13, 0x54, 0x03, 0xfe, 0xef, 0x30, 0xe5, 0x03, 0x43, 0x06, 0x10,
+0xaf, 0x06, 0x22, 0x8f, 0x2b, 0x12, 0x1e, 0x56, 0x7d, 0x01, 0xaf, 0x2b, 0x12, 0x1e, 0xaa, 0xaf,
+0x2b, 0x12, 0x09, 0x7a, 0x12, 0x11, 0xf3, 0xe4, 0xfd, 0xaf, 0x2b, 0x02, 0x1e, 0xaa, 0xe4, 0xf5,
+0x22, 0xaf, 0x22, 0x12, 0x1e, 0x80, 0x50, 0x05, 0xaf, 0x22, 0x12, 0x0c, 0xc5, 0x05, 0x22, 0xe5,
+0x22, 0xc3, 0x94, 0x07, 0x40, 0xeb, 0xc2, 0x09, 0x22, 0x8f, 0x2f, 0xe5, 0x2f, 0xc4, 0x54, 0x0f,
+0xff, 0x12, 0x1e, 0x47, 0x12, 0x1d, 0x84, 0xe5, 0x2f, 0x54, 0x0f, 0xff, 0x12, 0x1e, 0x47, 0x02,
+0x1d, 0x84, 0x8f, 0x28, 0x8e, 0x27, 0x8d, 0x26, 0x8c, 0x25, 0x78, 0x10, 0x12, 0x04, 0xe0, 0x12,
+0x1d, 0xfc, 0xe5, 0x28, 0xff, 0xe5, 0x27, 0xfe, 0x02, 0x1d, 0xfc, 0xe4, 0xf5, 0x22, 0xaf, 0x22,
+0x12, 0x1e, 0xf0, 0x74, 0xa0, 0x25, 0x22, 0xf8, 0xa6, 0x07, 0x05, 0x22, 0xe5, 0x22, 0xc3, 0x94,
+0x07, 0x40, 0xeb, 0x22, 0xd3, 0xef, 0x64, 0x80, 0xf8, 0x74, 0x61, 0x64, 0x80, 0x98, 0x50, 0x0c,
+0xef, 0x64, 0x80, 0x94, 0xfa, 0x50, 0x05, 0xef, 0x24, 0xe0, 0xff, 0x22, 0x22, 0x8f, 0x25, 0x12,
+0x1b, 0xa7, 0x8f, 0x26, 0x7d, 0x05, 0xaf, 0x25, 0x12, 0x13, 0x0d, 0xee, 0x30, 0xe2, 0x03, 0x43,
+0x26, 0x20, 0xaf, 0x26, 0x22, 0x75, 0xcb, 0xff, 0x75, 0xca, 0x02, 0x75, 0xcd, 0xff, 0x75, 0xcc,
+0x02, 0x75, 0xc8, 0x34, 0x75, 0x98, 0x52, 0xd2, 0xbc, 0xd2, 0xac, 0x22, 0x12, 0x1a, 0x8f, 0xef,
+0x60, 0x05, 0x7f, 0x05, 0x12, 0x1f, 0xc5, 0x12, 0x1c, 0xd1, 0xef, 0x60, 0x05, 0x7f, 0x06, 0x12,
+0x1f, 0xc5, 0x22, 0x8f, 0x37, 0x12, 0x1f, 0x5c, 0x75, 0x3d, 0x03, 0x12, 0x1a, 0x5c, 0x7d, 0x0c,
+0xaf, 0x37, 0x12, 0x19, 0x49, 0xaf, 0x37, 0x02, 0x1f, 0x65, 0xe4, 0xff, 0x12, 0x1d, 0xa8, 0x7f,
+0x05, 0x12, 0x1a, 0x29, 0x12, 0x1a, 0xf2, 0x8f, 0x28, 0x7f, 0x01, 0x12, 0x1d, 0xa8, 0xaf, 0x28,
+0x22, 0xe4, 0xf5, 0x23, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e, 0x80, 0x05, 0x22, 0xe5, 0x22, 0xc3,
+0x94, 0x07, 0x40, 0xf2, 0xaf, 0x23, 0x22, 0xe4, 0xf5, 0xff, 0xf5, 0xfe, 0xf5, 0xfd, 0x75, 0xfc,
+0x01, 0x75, 0xf9, 0xe0, 0x75, 0xfb, 0x14, 0xd2, 0xf8, 0x80, 0xfe, 0xe5, 0x08, 0xfd, 0xe5, 0x09,
+0xfb, 0x7f, 0x80, 0x12, 0x09, 0x28, 0x05, 0x09, 0xe5, 0x09, 0x70, 0x02, 0x05, 0x08, 0x22, 0xe4,
+0xfb, 0x7d, 0x04, 0x7f, 0x80, 0x12, 0x09, 0x3c, 0x7f, 0x00, 0x7e, 0x00, 0x7d, 0x00, 0x7c, 0x00,
+0x02, 0x09, 0x43, 0x8f, 0x32, 0xaf, 0x32, 0x15, 0x32, 0xef, 0xd3, 0x94, 0x00, 0x40, 0x07, 0x7f,
+0x20, 0x12, 0x1d, 0x84, 0x80, 0xef, 0x22, 0x8f, 0x51, 0x7b, 0x35, 0xe4, 0xfd, 0x7f, 0xe0, 0x12,
+0x09, 0x3c, 0xaf, 0x51, 0xe4, 0xfc, 0xfd, 0xfe, 0x02, 0x09, 0x43, 0x53, 0x89, 0x0f, 0x43, 0x89,
+0x10, 0x75, 0x8b, 0x92, 0x75, 0x8d, 0xe6, 0xc2, 0xbb, 0xd2, 0xab, 0xd2, 0x8e, 0x22, 0xc2, 0x03,
+0xae, 0x07, 0x1f, 0xee, 0xd3, 0x94, 0x00, 0x40, 0x07, 0x30, 0x03, 0xfd, 0xc2, 0x03, 0x80, 0xf0,
+0x22, 0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x09, 0x3c, 0x7f, 0x01, 0x12, 0x1f, 0x9a, 0x12,
+0x09, 0x43, 0x80, 0xfe, 0xc2, 0x06, 0x8f, 0x99, 0x7f, 0x02, 0x12, 0x1f, 0x85, 0x20, 0x06, 0x05,
+0x12, 0x1f, 0xbd, 0x50, 0xf8, 0x22, 0x8f, 0x28, 0x8c, 0x29, 0x8d, 0x2a, 0x12, 0x1b, 0xc3, 0xad,
+0x2a, 0xac, 0x29, 0xaf, 0x28, 0x02, 0x08, 0x5c, 0xef, 0x60, 0x06, 0xe5, 0x51, 0x44, 0x02, 0x80,
+0x04, 0xe5, 0x51, 0x54, 0xfd, 0xff, 0x12, 0x1d, 0x37, 0x22, 0xef, 0x60, 0x06, 0xe5, 0x51, 0x44,
+0x01, 0x80, 0x04, 0xe5, 0x51, 0x54, 0xfe, 0xff, 0x12, 0x1d, 0x37, 0x22, 0x7b, 0x35, 0xe4, 0xfd,
+0x7f, 0xe0, 0x12, 0x09, 0x28, 0xef, 0x54, 0x10, 0xc4, 0x54, 0x0f, 0xff, 0x22, 0x05, 0x0f, 0xe5,
+0x0f, 0xc3, 0x94, 0x96, 0x40, 0x06, 0xe4, 0xf5, 0x0f, 0x12, 0x1f, 0x8c, 0x22, 0x74, 0x80, 0x25,
+0x1f, 0xf8, 0xe6, 0xff, 0xe5, 0x1f, 0x04, 0x54, 0x1f, 0xf5, 0x1f, 0x22, 0x8e, 0x29, 0x8f, 0x2a,
+0xe5, 0x29, 0xff, 0x12, 0x1b, 0xf9, 0xaf, 0x2a, 0x02, 0x1b, 0xf9, 0x05, 0x4d, 0xe5, 0x4d, 0xc3,
+0x94, 0x0a, 0x40, 0x05, 0xe4, 0xf5, 0x4d, 0xd2, 0x09, 0x22, 0x75, 0x3d, 0x12, 0x75, 0x3e, 0x00,
+0x7b, 0x00, 0x7a, 0x12, 0xe4, 0xfd, 0x02, 0x19, 0x49, 0x4c, 0x75, 0x74, 0x20, 0x32, 0x2e, 0x32,
+0x39, 0x62, 0x5f, 0x61, 0x74, 0x68, 0x00, 0x00, 0xe4, 0xff, 0x12, 0x1d, 0xa8, 0x7f, 0x06, 0x12,
+0x1a, 0x29, 0x7f, 0x01, 0x02, 0x1d, 0xa8, 0xef, 0xc3, 0x94, 0x0a, 0xef, 0x50, 0x04, 0x24, 0x30,
+0xff, 0x22, 0x24, 0x57, 0xff, 0x22, 0xad, 0x07, 0x75, 0x3c, 0x10, 0xe4, 0xf5, 0x3d, 0xfb, 0x7f,
+0x20, 0x02, 0x17, 0x6c, 0x7d, 0x25, 0x12, 0x18, 0x84, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x25, 0x02,
+0x17, 0x38, 0x45, 0x52, 0x41, 0x53, 0x45, 0x00, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x00,
+0xef, 0x90, 0x1e, 0x95, 0x93, 0xd3, 0x94, 0x01, 0x50, 0x02, 0x80, 0x01, 0xc3, 0x22, 0x00, 0x01,
+0x02, 0x03, 0x04, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 0x7d, 0x01, 0x12, 0x13,
+0x0d, 0xef, 0x30, 0xe2, 0x03, 0xd3, 0x80, 0x01, 0xc3, 0x22, 0x8f, 0x3c, 0x8d, 0x3d, 0x7b, 0x0e,
+0xe4, 0xfd, 0x7f, 0xa0, 0x02, 0x17, 0x6c, 0x8f, 0x3c, 0x8d, 0x3d, 0x7b, 0x10, 0xe4, 0xfd, 0x7f,
+0x40, 0x02, 0x17, 0x6c, 0xe5, 0x1e, 0x65, 0x1f, 0x60, 0x03, 0xd3, 0x80, 0x01, 0xc3, 0x22, 0xe5,
+0xaa, 0x54, 0x03, 0x60, 0x03, 0xd3, 0x80, 0x01, 0xc3, 0x22, 0x7f, 0x03, 0x7e, 0x00, 0x7d, 0x00,
+0x7c, 0x00, 0x02, 0x18, 0x59, 0xa8, 0x1a, 0xe6, 0xb4, 0x20, 0x04, 0x05, 0x1a, 0x80, 0xf6, 0x22,
+0x12, 0x1e, 0x80, 0x50, 0x03, 0x7f, 0x01, 0x22, 0x7f, 0x00, 0x22, 0xc2, 0x02, 0x8f, 0x0e, 0xd2,
+0x02, 0x20, 0x02, 0xfd, 0x22, 0xeb, 0x75, 0xf0, 0x20, 0xa4, 0x4d, 0xac, 0xf0, 0xfd, 0x22, 0x7f,
+0x30, 0x12, 0x1d, 0x84, 0x7f, 0x78, 0x02, 0x1d, 0x84, 0x7f, 0x0d, 0x12, 0x1d, 0x84, 0x7f, 0x0a,
+0x02, 0x1d, 0x84, 0x75, 0xf0, 0x0a, 0x84, 0xe5, 0xf0, 0x24, 0x30, 0xff, 0x22, 0x8f, 0x35, 0x12,
+0x17, 0xfe, 0xaf, 0x35, 0x02, 0x09, 0xf2, 0xd3, 0xe5, 0x26, 0x94, 0x00, 0xe5, 0x25, 0x94, 0x00,
+0x22, 0xef, 0x64, 0x06, 0x60, 0x03, 0x12, 0x1c, 0xa3, 0x22, 0x7b, 0x01, 0x7a, 0x00, 0x7d, 0x1f,
+0x02, 0x17, 0xce, 0x7b, 0xb5, 0x7a, 0x52, 0x7d, 0x1f, 0x02, 0x17, 0xce, 0x7b, 0x30, 0x7a, 0x2a,
+0x7d, 0x1f, 0x02, 0x17, 0xce, 0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0x02, 0x17, 0xce, 0x7d, 0x32, 0x12,
+0x18, 0x84, 0xaf, 0x37, 0x22, 0xe5, 0x51, 0x44, 0x04, 0xff, 0x02, 0x1d, 0x37, 0xe5, 0x51, 0x54,
+0xfb, 0xff, 0x02, 0x1d, 0x37, 0xc2, 0x02, 0x8f, 0x0e, 0xd2, 0x02, 0x22, 0x7f, 0x03, 0x7e, 0x00,
+0x02, 0x16, 0x65, 0x7f, 0x05, 0x7e, 0x00, 0x02, 0x16, 0x65, 0x7e, 0x00, 0x7d, 0x00, 0x7c, 0x00,
+0x22, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x4e, 0x22, 0xef, 0x90, 0x1e, 0x95, 0x93, 0xff, 0x22, 0xef,
+0x90, 0x1e, 0x8e, 0x93, 0xff, 0x22, 0x00, 0x01, 0x02, 0x03, 0x04, 0x06, 0x05, 0xa2, 0x02, 0xb3,
+0x22, 0x12, 0x11, 0x2d, 0x22, 0xd2, 0x07, 0x22, 0x02, 0x1d, 0x84, 0x02, 0x15, 0x7e, 0x22, 0x22
+};
diff --git a/board/ar7100/common/g5_Plus1_2_29b_unmanaged_Atheros_v5.c b/board/ar7100/common/g5_Plus1_2_29b_unmanaged_Atheros_v5.c
new file mode 100644
index 0000000000..74a5afe088
--- /dev/null
+++ b/board/ar7100/common/g5_Plus1_2_29b_unmanaged_Atheros_v5.c
@@ -0,0 +1,511 @@
+static unsigned char g5_Plus1_2_29b_unmanaged_Atheros_v5 [] = {
+	0x2, 0xb, 0x1e, 0x8f, 0x2e, 0x12, 0x1f, 0xa1, 0x12, 0x9, 0xbf, 0x50, 0x3, 0x7f, 0x1, 0x22, 
+	0xe5, 0x2e, 0xb4, 0x6, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x2, 0x19, 0xbb, 0x75, 0x22, 
+	0x1, 0x80, 0xfe, 0x2, 0x14, 0xc6, 0xae, 0x5, 0xad, 0x7, 0x75, 0x3c, 0x6, 0xee, 0x70, 0x4, 
+	0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x8f, 0x3d, 0x7b, 0x19, 0x7f, 0x20, 0x2, 0x17, 0x6c, 0x22, 
+	00, 0x1, 0xc1, 00, 00, 00, 0x8f, 0x24, 0x8d, 0x25, 0x8b, 0x26, 0xe5, 0x26, 0x7b, 0xff, 
+	0x60, 0x6, 0x7a, 0x12, 0x79, 0x74, 0x80, 0x4, 0x7a, 0x12, 0x79, 0x73, 0x12, 0x19, 0xe0, 0x7b, 
+	0xff, 0x7a, 0x12, 0x79, 0x75, 0x12, 0x19, 0xe0, 0xe5, 0x24, 0xc3, 0x94, 0x7, 0x40, 0x8, 0xe4, 
+	0xf5, 0x24, 0x75, 0x27, 0x6, 0x80, 0x11, 0xe5, 0x26, 0x60, 0xa, 0x53, 0x24, 0xfe, 0xe5, 0x24, 
+	0x4, 0xf5, 0x27, 0x80, 0x3, 0x85, 0x24, 0x27, 0xe5, 0x25, 0xb4, 0xff, 0x5, 0x75, 0x29, 0x7, 
+	0x80, 0xf, 0xaf, 0x25, 0x74, 0x1, 0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf5, 
+	0x29, 0x7b, 0xd, 0x12, 0x3, 0x2b, 0x7b, 0xe, 0x12, 0x3, 0x2b, 0x12, 0x3, 0x66, 0x12, 0x1b, 
+	0x33, 0x12, 0x9, 0x43, 0xe5, 0x24, 0x90, 0x1f, 0xb6, 0x93, 0xf5, 0x30, 0xe5, 0x26, 0x60, 0x1e, 
+	0xe5, 0x24, 0x24, 0x1, 0xff, 0xe4, 0x33, 0xfe, 0xc3, 0xef, 0x94, 0x7, 0xee, 0x64, 0x80, 0x94, 
+	0x80, 0x50, 0x8, 0xe5, 0x24, 0xa3, 0x93, 0xf5, 0x31, 0x80, 0x3, 0x75, 0x31, 0x7, 0x7e, 00, 
+	0x7f, 0x2, 0x7d, 0xff, 0x7b, 00, 0x7a, 00, 0x79, 0x2a, 0x12, 0x5, 0x2e, 0x75, 0x28, 0x2, 
+	0xe5, 0x28, 0xf4, 0x70, 0x3, 0x2, 0x2, 0x50, 0x74, 0x1, 0x7e, 00, 0xa8, 0x28, 0x8, 0x80, 
+	0x5, 0xc3, 0x33, 0xce, 0x33, 0xce, 0xd8, 0xf9, 0xff, 0xef, 0x55, 0x29, 0x70, 0x3, 0x2, 0x2, 
+	0x4b, 0xe5, 0x28, 0xd3, 0x94, 0x2, 0x40, 0x3, 0x2, 0x1, 0xec, 0xaf, 0x30, 0x12, 0x1e, 0x80, 
+	0x40, 0x3, 0x2, 0x2, 0x4b, 0xaf, 0x31, 0x12, 0x1e, 0x80, 0x50, 0x7, 0xe5, 0x31, 0xc3, 0x94, 
+	0x7, 0x40, 0x7, 0xe5, 0x26, 0x60, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x30, 0x64, 0x6, 0x70, 0x1b, 
+	0xe5, 0x28, 0x70, 0x9, 0x12, 0x3, 0x5d, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x28, 0xb4, 
+	0x1, 0x9, 0x12, 0x3, 0x5d, 0x20, 0xe6, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x26, 0x60, 0x67, 0xe5, 
+	0x28, 0xc3, 0x94, 0x2, 0x50, 0x6f, 0xe5, 0x31, 0x64, 0x6, 0x70, 0x25, 0xe5, 0x28, 0x70, 0xe, 
+	0x7d, 0x1, 0xaf, 0x31, 0x12, 0x13, 0xd, 0xee, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x28, 
+	0xb4, 0x1, 0xe, 0x7d, 0x1, 0xaf, 0x31, 0x12, 0x13, 0xd, 0xee, 0x20, 0xe6, 0x3, 0x2, 0x2, 
+	0x4b, 0x12, 0x3, 0x70, 0xe4, 0xf5, 0x2e, 0xf5, 0x2f, 0xaf, 0x30, 0x12, 0x1e, 0x9c, 0x50, 0x7, 
+	0xaf, 0x31, 0x12, 0x1e, 0x9c, 0x40, 0x2e, 0xe5, 0x2f, 0xc3, 0x94, 0x3, 0x50, 0x27, 0x7f, 0xa, 
+	0x12, 0x1d, 0x5e, 0x5, 0x2e, 0xe5, 0x2e, 0xc3, 0x94, 0xfa, 0x40, 0xdd, 0x12, 0x3, 0x70, 0x5, 
+	0x2f, 0xe4, 0xf5, 0x2e, 0x80, 0xd3, 0xe5, 0x28, 0x44, 0x90, 0xfd, 0xaf, 0x30, 0x12, 0x13, 0xb6, 
+	0x7f, 0xa, 0x12, 0x1e, 0xfb, 0xad, 0x28, 0xaf, 0x30, 0x12, 0x10, 0xc8, 0xe5, 0x26, 0x60, 0x7, 
+	0xad, 0x28, 0xaf, 0x31, 0x12, 0x10, 0xc8, 0x7f, 0x5, 0x12, 0x1e, 0xfb, 0xe5, 0x26, 0x60, 0x41, 
+	0xad, 0x31, 0x12, 0x3, 0x4e, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0x4a, 0x80, 0x2, 
+	0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0xad, 0x30, 0xaf, 0x31, 0x12, 0xf, 
+	0x20, 0xe5, 0x28, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x6, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 
+	0x12, 0x1b, 0x4a, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2b, 0x4f, 0xf5, 0x2b, 0x80, 
+	0x1a, 0xad, 0x30, 0x12, 0x3, 0x4e, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0x4a, 0x80, 
+	0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0x15, 0x28, 0x2, 00, 0xf0, 
+	0xe4, 0xf5, 0x2d, 0xe5, 0x26, 0x70, 0x7, 0xe5, 0x2d, 0xc3, 0x94, 0x1, 0x40, 0x11, 0xe5, 0x26, 
+	0x70, 0x3, 0x2, 0x2, 0xfd, 0xe5, 0x2d, 0xc3, 0x94, 0x2, 0x40, 0x3, 0x2, 0x2, 0xfd, 0x12, 
+	0x1f, 0x19, 0x7f, 0x4, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1a, 0xb0, 0x7f, 0x4, 0x12, 0x1d, 
+	0x23, 0xe4, 0xf5, 0x28, 0xe5, 0x28, 0x25, 0xe0, 0xff, 0x74, 0x2a, 0x25, 0x2d, 0xf8, 0xe6, 0xfe, 
+	0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x13, 0xd8, 0xfc, 0x54, 0x3, 0xf5, 0x2c, 0xb4, 0x3, 0x7, 
+	0x7f, 0x8, 0x12, 0x1d, 0x23, 0x80, 0x24, 0xe5, 0x2c, 0x7b, 0xff, 0x70, 0x9, 0x7a, 0x12, 0x79, 
+	0x8e, 0x12, 0x19, 0xe0, 0x80, 0x15, 0x7a, 0x12, 0x79, 0x97, 0x12, 0x19, 0xe0, 0xaf, 0x2c, 0xe4, 
+	0xfc, 0xfd, 0xfe, 0x12, 0xe, 0x3b, 0x7f, 0x20, 0x12, 0x1f, 0xc8, 0x5, 0x28, 0xe5, 0x28, 0xc3, 
+	0x94, 0x3, 0x40, 0xb0, 0xe5, 0x2d, 0x70, 0xb, 0xaf, 0x30, 0x12, 0x1e, 0x80, 0x50, 0x10, 0xaf, 
+	0x30, 0x80, 0x9, 0xaf, 0x31, 0x12, 0x1e, 0x80, 0x50, 0x5, 0xaf, 0x31, 0x12, 0x1f, 0x2d, 0x5, 
+	0x24, 0xe5, 0x24, 0xd3, 0x95, 0x27, 0x50, 0x5, 0x5, 0x2d, 0x2, 0x2, 0x53, 0xe5, 0x24, 0xd3, 
+	0x95, 0x27, 0x50, 0x3, 0x2, 00, 0xb4, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x9e, 0x12, 0x19, 0xe0, 
+	0x7b, 0xd, 0x12, 0x3, 0x3e, 0x12, 0x9, 0x43, 0x7b, 0xe, 0x12, 0x3, 0x3e, 0x12, 0x9, 0x43, 
+	0x12, 0x3, 0x66, 0x7f, 0x5f, 0x12, 0x1b, 0x35, 0x2, 0x9, 0x43, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 
+	0x9, 0x3c, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x43, 0x22, 0xe4, 0xfd, 
+	0x7f, 0x40, 0x12, 0x9, 0x3c, 0x7f, 0x5f, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0xaf, 0x30, 
+	0x12, 0xf, 0x20, 0xe5, 0x28, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x6, 0x8, 0x22, 0x7d, 0x1, 0xaf, 
+	0x30, 0x12, 0x13, 0xd, 0xee, 0x22, 0x7b, 0xf, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x3c, 0x22, 
+	0xab, 0x28, 0xad, 0x31, 0xaf, 0x30, 0x12, 0x18, 0xd6, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82, 0x8a, 
+	0x83, 0xe0, 0x22, 0x50, 0x2, 0xe7, 0x22, 0xbb, 0xfe, 0x2, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 
+	0xe4, 0x93, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0x22, 0x50, 0x2, 0xf7, 0x22, 
+	0xbb, 0xfe, 0x1, 0xf3, 0x22, 0xe8, 0x8f, 0xf0, 0xa4, 0xcc, 0x8b, 0xf0, 0xa4, 0x2c, 0xfc, 0xe9, 
+	0x8e, 0xf0, 0xa4, 0x2c, 0xfc, 0x8a, 0xf0, 0xed, 0xa4, 0x2c, 0xfc, 0xea, 0x8e, 0xf0, 0xa4, 0xcd, 
+	0xa8, 0xf0, 0x8b, 0xf0, 0xa4, 0x2d, 0xcc, 0x38, 0x25, 0xf0, 0xfd, 0xe9, 0x8f, 0xf0, 0xa4, 0x2c, 
+	0xcd, 0x35, 0xf0, 0xfc, 0xeb, 0x8e, 0xf0, 0xa4, 0xfe, 0xa9, 0xf0, 0xeb, 0x8f, 0xf0, 0xa4, 0xcf, 
+	0xc5, 0xf0, 0x2e, 0xcd, 0x39, 0xfe, 0xe4, 0x3c, 0xfc, 0xea, 0xa4, 0x2d, 0xce, 0x35, 0xf0, 0xfd, 
+	0xe4, 0x3c, 0xfc, 0x22, 0x75, 0xf0, 0x8, 0x75, 0x82, 00, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 
+	0xcd, 0x33, 0xcd, 0xcc, 0x33, 0xcc, 0xc5, 0x82, 0x33, 0xc5, 0x82, 0x9b, 0xed, 0x9a, 0xec, 0x99, 
+	0xe5, 0x82, 0x98, 0x40, 0xc, 0xf5, 0x82, 0xee, 0x9b, 0xfe, 0xed, 0x9a, 0xfd, 0xec, 0x99, 0xfc, 
+	0xf, 0xd5, 0xf0, 0xd6, 0xe4, 0xce, 0xfb, 0xe4, 0xcd, 0xfa, 0xe4, 0xcc, 0xf9, 0xa8, 0x82, 0x22, 
+	0xb8, 00, 0xc1, 0xb9, 00, 0x59, 0xba, 00, 0x2d, 0xec, 0x8b, 0xf0, 0x84, 0xcf, 0xce, 0xcd, 
+	0xfc, 0xe5, 0xf0, 0xcb, 0xf9, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 
+	0xec, 0x33, 0xfc, 0xeb, 0x33, 0xfb, 0x10, 0xd7, 0x3, 0x99, 0x40, 0x4, 0xeb, 0x99, 0xfb, 0xf, 
+	0xd8, 0xe5, 0xe4, 0xf9, 0xfa, 0x22, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 
+	0xfd, 0xec, 0x33, 0xfc, 0xc9, 0x33, 0xc9, 0x10, 0xd7, 0x5, 0x9b, 0xe9, 0x9a, 0x40, 0x7, 0xec, 
+	0x9b, 0xfc, 0xe9, 0x9a, 0xf9, 0xf, 0xd8, 0xe0, 0xe4, 0xc9, 0xfa, 0xe4, 0xcc, 0xfb, 0x22, 0x75, 
+	0xf0, 0x10, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xcc, 0x33, 0xcc, 0xc8, 0x33, 
+	0xc8, 0x10, 0xd7, 0x7, 0x9b, 0xec, 0x9a, 0xe8, 0x99, 0x40, 0xa, 0xed, 0x9b, 0xfd, 0xec, 0x9a, 
+	0xfc, 0xe8, 0x99, 0xf8, 0xf, 0xd5, 0xf0, 0xda, 0xe4, 0xcd, 0xfb, 0xe4, 0xcc, 0xfa, 0xe4, 0xc8, 
+	0xf9, 0x22, 0xcf, 0xf4, 0xcf, 0xce, 0xf4, 0xce, 0xcd, 0xf4, 0xcd, 0xcc, 0xf4, 0xcc, 0x22, 0xeb, 
+	0x9f, 0xf5, 0xf0, 0xea, 0x9e, 0x42, 0xf0, 0xe9, 0x9d, 0x42, 0xf0, 0xe8, 0x9c, 0x45, 0xf0, 0x22, 
+	0xe8, 0x60, 0xf, 0xec, 0xc3, 0x13, 0xfc, 0xed, 0x13, 0xfd, 0xee, 0x13, 0xfe, 0xef, 0x13, 0xff, 
+	0xd8, 0xf1, 0x22, 0xe8, 0x60, 0xf, 0xef, 0xc3, 0x33, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 
+	0xec, 0x33, 0xfc, 0xd8, 0xf1, 0x22, 0xe6, 0xfc, 0x8, 0xe6, 0xfd, 0x8, 0xe6, 0xfe, 0x8, 0xe6, 
+	0xff, 0x22, 0xe4, 0x93, 0xfc, 0x74, 0x1, 0x93, 0xfd, 0x74, 0x2, 0x93, 0xfe, 0x74, 0x3, 0x93, 
+	0xff, 0x22, 0xec, 0xf6, 0x8, 0xed, 0xf6, 0x8, 0xee, 0xf6, 0x8, 0xef, 0xf6, 0x22, 0xef, 0x4e, 
+	0x60, 0x12, 0xef, 0x60, 0x1, 0xe, 0xed, 0xbb, 0x1, 0xb, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0xa3, 
+	0xdf, 0xfc, 0xde, 0xfa, 0x22, 0x89, 0xf0, 0x50, 0x7, 0xf7, 0x9, 0xdf, 0xfc, 0xa9, 0xf0, 0x22, 
+	0xbb, 0xfe, 0xfc, 0xf3, 0x9, 0xdf, 0xfc, 0xa9, 0xf0, 0x22, 0xa8, 0x1a, 0xe6, 0xf5, 0x24, 0x64, 
+	0x20, 0x60, 0x9, 0xe5, 0x24, 0x64, 0xd, 0x60, 0x3, 0x7f, 0x1, 0x22, 0xe4, 0xf5, 0x19, 0xfe, 
+	0x7f, 0x10, 0x7d, 0xff, 0xfb, 0x7a, 00, 0x79, 0x52, 0x12, 0x5, 0x2e, 0x12, 0x1e, 0xe5, 0x75, 
+	0x25, 0xa, 0xe4, 0xf5, 0x27, 0xa8, 0x1a, 0xe6, 0x64, 0x30, 0x70, 0x1b, 0xe8, 0x4, 0xf8, 0xe6, 
+	0xff, 0x12, 0x1c, 0x44, 0xbf, 0x58, 0x10, 0x75, 0x25, 0x10, 0x5, 0x1a, 0x5, 0x1a, 0xa8, 0x1a, 
+	0xe6, 0xb4, 0x20, 0x3, 0x7f, 0x1, 0x22, 0xa8, 0x1a, 0xe6, 0xf5, 0x24, 0x64, 0x20, 0x60, 0x6, 
+	0xe5, 0x24, 0x64, 0xd, 0x70, 0x7c, 0xe5, 0x27, 0xd3, 0x94, 00, 0x40, 0x6a, 0xe4, 0xf5, 0x35, 
+	0xf5, 0x34, 0xf5, 0x33, 0xf5, 0x32, 0xf5, 0x26, 0xe5, 0x26, 0xc3, 0x95, 0x27, 0x50, 0x3a, 0xaf, 
+	0x25, 0xe4, 0xfc, 0xfd, 0xfe, 0xab, 0x35, 0xaa, 0x34, 0xa9, 0x33, 0xa8, 0x32, 0x12, 0x3, 0xa5, 
+	0xc0, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7, 0x74, 0x28, 0x25, 0x26, 0xf8, 0xe6, 0xff, 0xe4, 
+	0xfc, 0xfd, 0xfe, 0xd0, 00, 0xeb, 0x2f, 0xf5, 0x35, 0xee, 0x3a, 0xf5, 0x34, 0xed, 0x39, 0xf5, 
+	0x33, 0xec, 0x38, 0xf5, 0x32, 0x5, 0x26, 0x80, 0xbf, 0xe5, 0x19, 0xc3, 0x94, 0x4, 0x50, 0x17, 
+	0xaf, 0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0xab, 0x19, 0x5, 0x19, 0xeb, 0x25, 0xe0, 0x25, 
+	0xe0, 0x24, 0x52, 0xf8, 0x12, 0x5, 0x22, 0xe5, 0x24, 0x64, 0xd, 0x60, 0x3, 0x2, 0x5, 0x7c, 
+	0xff, 0x22, 0xaf, 0x24, 0x12, 0x19, 0x95, 0x8f, 0x24, 0xe5, 0x24, 0xf4, 0x60, 0x1d, 0xe5, 0x27, 
+	0xc3, 0x94, 0xa, 0x50, 0x19, 0xaf, 0x27, 0x5, 0x27, 0x74, 0x28, 0x2f, 0xf8, 0xa6, 0x24, 0xe5, 
+	0x24, 0xd3, 0x94, 0x9, 0x40, 0x8, 0x75, 0x25, 0x10, 0x80, 0x3, 0x7f, 0x1, 0x22, 0x5, 0x1a, 
+	0x2, 0x5, 0xa7, 0xa8, 0x1a, 0xe6, 0xf5, 0x23, 0x5, 0x1a, 0x12, 0x5, 0x5a, 0xef, 0x60, 0x3, 
+	0x7f, 0x1, 0x22, 0xaf, 0x23, 0x12, 0x1c, 0x44, 0xef, 0x24, 0xb7, 0x60, 0x64, 0x24, 0xfa, 0x60, 
+	0x7a, 0x24, 0xfd, 0x60, 0x17, 0x24, 0xfe, 0x70, 0x3, 0x2, 0x7, 0x25, 0x24, 0xfd, 0x60, 0x28, 
+	0x4, 0x60, 0x3, 0x2, 0x7, 0x60, 0x12, 0xe, 0xb1, 0x2, 0x7, 0x63, 0x12, 0x1f, 0xf, 0x12, 
+	0x1a, 0x15, 0xc0, 0x7, 0x12, 0x1a, 0x5, 0xc0, 0x5, 0x12, 0x1a, 0xd, 0xd0, 0x5, 0xd0, 0x7, 
+	0x12, 0x9, 0x28, 0x12, 0x1c, 0x12, 0x80, 0x3e, 0xe5, 0x19, 0xc3, 0x94, 0x4, 0x50, 0x3, 0x2, 
+	0x7, 0x63, 0x12, 0x1a, 0x15, 0xc0, 0x7, 0x12, 0x1a, 0x5, 0xc0, 0x5, 0x12, 0x1a, 0xd, 0xd0, 
+	0x5, 0xd0, 0x7, 0x12, 0x9, 0x3c, 0x78, 0x5e, 0x12, 0x5, 0x6, 0x12, 0x9, 0x43, 0x2, 0x7, 
+	0x63, 0x12, 0x1f, 0xf, 0x78, 0x52, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x12, 0x1a, 0x5, 0xd0, 0x7, 
+	0x12, 0x13, 0xd, 0x12, 0x1d, 0xfc, 0x12, 0x1f, 0x19, 0x80, 0x68, 0xe5, 0x19, 0xc3, 0x94, 0x3, 
+	0x40, 0x61, 0x78, 0x52, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x12, 0x1a, 0x5, 0xc0, 0x5, 0x12, 0x1a, 
+	0xd, 0xaa, 0x6, 0x78, 0x5e, 0x12, 0x5, 0x6, 0x8e, 0x3d, 0x8f, 0x3e, 0xd0, 0x5, 0xd0, 0x7, 
+	0x12, 0x19, 0x49, 0x80, 0x3e, 0x78, 0x52, 0x12, 0x5, 0x6, 0xef, 0x24, 0xfe, 0x60, 0x17, 0x4, 
+	0x70, 0x2b, 0x78, 0x56, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x78, 0x5a, 0x12, 0x5, 0x6, 0xad, 0x7, 
+	0xd0, 0x7, 0xe4, 0xfb, 0x80, 0x12, 0x78, 0x56, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x78, 0x5a, 0x12, 
+	0x5, 0x6, 0xad, 0x7, 0xd0, 0x7, 0x7b, 0x1, 0x12, 00, 0x46, 0x80, 0x6, 0x7f, 0x1, 0x22, 
+	0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x8f, 0x2a, 0x7f, 0x1, 0xed, 0x54, 0x30, 0xfe, 0xbe, 0x30, 
+	0x4, 0x7e, 0x1, 0x80, 0x2, 0x7e, 00, 0xed, 0x54, 0x3, 0xfc, 0xbc, 0x2, 0x4, 0x7c, 0x1, 
+	0x80, 0x2, 0x7c, 00, 0x8c, 0x2c, 0xed, 0x20, 0xe4, 0x7, 0xef, 0x60, 0x4, 0x7d, 0x1, 0x80, 
+	0x2, 0x7d, 00, 0xef, 0x60, 0x3, 0xee, 0x70, 0x3, 0xed, 0x60, 0x4, 0x7f, 0x1, 0x80, 0x2, 
+	0x7f, 00, 0x8f, 0x2b, 0x7d, 0x30, 0xaf, 0x2a, 0x12, 0x18, 0x84, 0x7b, 0x8, 0xad, 0x2a, 0x7f, 
+	0x20, 0x12, 0x9, 0x3c, 0xe5, 0x31, 0xfe, 0xe5, 0x32, 0xff, 0xad, 0x30, 0x7c, 00, 0x12, 0x9, 
+	0x59, 0x12, 0x9, 0x43, 0x7b, 0xc, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0xe5, 0x34, 0xfe, 
+	0xe5, 0x35, 0xff, 0xad, 0x33, 0x7c, 00, 0x12, 0x9, 0x59, 0x12, 0x9, 0x43, 0xe5, 0x2b, 0x60, 
+	0x1e, 0x75, 0x2d, 0x17, 0x75, 0x2e, 0xb6, 0x12, 0x8, 0x52, 0x7f, 0xff, 0x7e, 00, 0x7d, 0x3, 
+	0x7c, 00, 0x12, 0x9, 0x43, 0x85, 0x2a, 0x3c, 0xe4, 0xf5, 0x3d, 0x7b, 0x12, 0x80, 0x1d, 0x75, 
+	0x2d, 0x17, 0x75, 0x2e, 0x9e, 0x12, 0x8, 0x52, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 
+	0x12, 0x9, 0x43, 0x85, 0x2a, 0x3c, 0x75, 0x3d, 0x1, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x12, 
+	0x17, 0x6c, 0xe4, 0xf5, 0x2f, 0xe5, 0x2f, 0x24, 0xde, 0xfb, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9, 
+	0x3c, 0x85, 0x2e, 0x82, 0x85, 0x2d, 0x83, 0x12, 0x5, 0x12, 0x12, 0x9, 0x43, 0x74, 0x4, 0x25, 
+	0x2e, 0xf5, 0x2e, 0xe4, 0x35, 0x2d, 0xf5, 0x2d, 0x5, 0x2f, 0xe5, 0x2f, 0xc3, 0x94, 0x6, 0x40, 
+	0xd4, 0x22, 0x7b, 0x4, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0x22, 0x8f, 0x2b, 0x8c, 0x2c, 
+	0x8d, 0x2d, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0xa, 0xf5, 0x31, 0xf5, 0x30, 0xf5, 0x2f, 0xf5, 
+	0x2e, 0x80, 0x12, 0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf, 0x2b, 0x12, 0x11, 0x92, 0x8f, 0x31, 0x8e, 
+	0x30, 0x8d, 0x2f, 0x8c, 0x2e, 0x12, 0x9, 0x1e, 0xe5, 0x31, 0x54, 0xf8, 0xff, 0xe5, 0x30, 0xfe, 
+	0xe5, 0x2f, 0xfd, 0xe5, 0x2e, 0xfc, 0xef, 0x44, 0x31, 0xff, 0xec, 0x44, 0x20, 0xfc, 0x12, 0x9, 
+	0x43, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0x23, 0xfd, 0xaf, 0x2b, 0x12, 0x1e, 0xb7, 0x12, 0x9, 
+	0x1e, 0x7f, 0x30, 0x7e, 00, 0x7d, 00, 0x7c, 0x20, 0x12, 0x9, 0x43, 0x85, 0x2b, 0x3c, 0x75, 
+	0x3d, 0x1, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x2, 0x17, 0x6c, 0xaf, 0x2b, 0x12, 0x1f, 0x6d, 
+	0xe4, 0xfc, 0xfd, 0xfe, 0x78, 0x13, 0x12, 0x4, 0xf3, 0xec, 0x44, 0x8, 0xfc, 0xe5, 0x31, 0x4f, 
+	0xf5, 0x31, 0xe5, 0x30, 0x4e, 0xf5, 0x30, 0xe5, 0x2f, 0x4d, 0xf5, 0x2f, 0xe5, 0x2e, 0x4c, 0xf5, 
+	0x2e, 0xe4, 0xfb, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0xaf, 0x31, 0xae, 0x30, 0xad, 0x2f, 
+	0xac, 0x2e, 0x12, 0x9, 0x43, 0xaf, 0x2b, 0x12, 0x1b, 0x51, 0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf, 
+	0x2b, 0x12, 0x18, 0xfd, 0xe5, 0x2b, 0xb4, 0x6, 0x4, 0xff, 0x12, 0x16, 0xcf, 0x22, 0xe4, 0xfb, 
+	0xad, 0x2b, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0x22, 0xef, 0x2d, 0xf5, 0xf9, 0x8b, 0xfa, 0x30, 0xf8, 
+	0xfd, 0xd2, 0xf8, 0xac, 0xff, 0xad, 0xfe, 0xae, 0xfd, 0xaf, 0xfc, 0x22, 0xef, 0x2d, 0xf5, 0x4b, 
+	0x8b, 0x4c, 0x22, 0x8c, 0xff, 0x8d, 0xfe, 0x8e, 0xfd, 0x8f, 0xfc, 0xe5, 0x4b, 0xf5, 0xf9, 0xe5, 
+	0x4c, 0xf5, 0xfb, 0x30, 0xf8, 0xfd, 0xd2, 0xf8, 0x22, 0x22, 0xec, 0xfe, 0xed, 0xff, 0x22, 0x1, 
+	0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0xe4, 0xfe, 0xcf, 0x90, 0x9, 0x5f, 0xb4, 0x8, 00, 
+	0x50, 0x3, 0x93, 0xff, 0x22, 0x94, 0x8, 0x93, 0xfe, 0x22, 0xef, 0x90, 0x9, 0x5f, 0x93, 0xff, 
+	0x22, 0x90, 0x9, 0x5f, 0xef, 0x93, 0xff, 0xf4, 0xfe, 0xbb, 0x1, 0xe, 0x89, 0x82, 0x8a, 0x83, 
+	0xe0, 0x5e, 0xbd, 00, 0x2, 0x80, 0x1, 0x4f, 0xf0, 0x22, 0xbb, 00, 0xb, 0xe9, 0xf8, 0xe6, 
+	0x5e, 0xbd, 00, 0x2, 0x80, 0x1, 0x4f, 0xf6, 0x22, 0x74, 0x1f, 0xc3, 0x9f, 0x13, 0x13, 0x13, 
+	0x54, 0x3, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x7, 0x5f, 0xff, 0x12, 0x9, 0x81, 0x22, 0x90, 
+	0x9, 0x5f, 0xef, 0x93, 0xff, 0xbb, 0x1, 0x7, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x80, 0x6, 0xbb, 
+	00, 0x8, 0xe9, 0xf8, 0xe6, 0x5f, 0x60, 0x2, 0xd3, 0x22, 0xc3, 0x22, 0x74, 0x1f, 0xc3, 0x9f, 
+	0x13, 0x13, 0x13, 0x54, 0x3, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x7, 0x5f, 0xff, 0x12, 0x9, 
+	0xbf, 0x22, 0x8f, 0x36, 0xe5, 0x36, 0x64, 0x6, 0x70, 0x54, 0x7b, 0x22, 0x7a, 0x1a, 0x7d, 0x17, 
+	0x12, 0x17, 0xce, 0xaf, 0x36, 0x12, 0x17, 0xfe, 0x12, 0xa, 0x7f, 0x7a, 0x2, 0x12, 0xa, 0x75, 
+	0x7b, 0xb5, 0x7a, 0x52, 0x7d, 0x1f, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x7b, 0xf, 0x7a, 00, 0x7d, 
+	0x2, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x7b, 0x2a, 0x7a, 0x47, 0x7d, 0x1, 0xaf, 0x36, 0x12, 0x17, 
+	0xce, 0x7b, 0xa4, 0x7a, 0x8f, 0xe4, 0xfd, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x12, 0xa, 0x7f, 0x7a, 
+	00, 0x12, 0xa, 0x75, 0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0xaf, 0x36, 0x2, 0x17, 0xce, 0xaf, 0x36, 
+	0x12, 0xd, 0xc4, 0xaf, 0x36, 0x12, 0x1c, 0xa3, 0x7b, 0x64, 0x7a, 00, 0x7d, 0x1b, 0xaf, 0x36, 
+	0x12, 0x17, 0xce, 0x75, 0x3d, 00, 0x75, 0x3e, 0xf, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x1e, 0xaf, 
+	0x36, 0x12, 0x19, 0x49, 0x22, 0x7b, 0x12, 0x7d, 0x8, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x22, 0x7b, 
+	0x30, 0x7a, 0x2a, 0x7d, 0x1f, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x22, 0x8f, 0x38, 0x12, 0x1f, 0x5c, 
+	0x12, 0x1a, 0x59, 0x12, 0xb, 0xa, 0x12, 0x1f, 0x53, 0x7a, 0xaf, 0x12, 0xa, 0xec, 0x75, 0x3d, 
+	00, 0x75, 0x3e, 0xc, 0x7d, 0x11, 0x12, 0xb, 00, 0x7a, 0x8f, 0x12, 0xa, 0xec, 0x7a, 0xaf, 
+	0x12, 0xa, 0xf6, 0x75, 0x3d, 00, 0x75, 0x3e, 0xc, 0x7d, 0x12, 0x12, 0xb, 00, 0x7a, 0x8f, 
+	0x12, 0xa, 0xf6, 0x7a, 0xaf, 0x12, 0xb, 0x14, 0x75, 0x3d, 0x1, 0x75, 0x3e, 0x80, 0x7b, 00, 
+	0x7a, 0x1, 0x7d, 0x11, 0xaf, 0x38, 0x12, 0x19, 0x49, 0x7a, 0x8f, 0x12, 0xb, 0x14, 0xaf, 0x38, 
+	0x12, 0x1f, 0x5c, 0x12, 0x1a, 0x64, 0x12, 0xb, 0xa, 0x2, 0x1f, 0x65, 0x7b, 0x8a, 0x7d, 0x10, 
+	0xaf, 0x38, 0x12, 0x17, 0xce, 0x22, 0x7b, 0x86, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xce, 0x22, 
+	0x7b, 0x8, 0x7a, 00, 0xaf, 0x38, 0x12, 0x19, 0x49, 0x22, 0x7d, 0x8, 0xaf, 0x38, 0x12, 0x19, 
+	0x49, 0xaf, 0x38, 0x22, 0x7b, 0x82, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xce, 0x22, 0x78, 0xfe, 
+	0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x4f, 00, 0x75, 0x50, 00, 0x75, 0x81, 0xa7, 0x2, 0xb, 0x6b, 
+	0x2, 0xb, 0xb0, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x3, 0xf6, 0x80, 0x1, 0xf2, 
+	0x8, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x7, 0x24, 0xc, 0xc8, 0xc3, 0x33, 
+	0xc4, 0x54, 0xf, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x4, 0xf4, 0x56, 0x80, 0x1, 0x46, 0xf6, 0xdf, 
+	0xe4, 0x80, 0xb, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x90, 0x18, 0x2d, 0xe4, 0x7e, 
+	0x1, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x9, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 
+	0xa3, 0x60, 0x1, 0xe, 0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3, 
+	0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 
+	0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 
+	0x12, 0x1f, 0xce, 0x12, 0x18, 0xae, 0xd2, 0xa1, 0xc2, 0x91, 0xe4, 0xf5, 0x39, 0x75, 0x38, 0x1, 
+	0xf5, 0x37, 0xf5, 0x36, 0xf5, 0x3d, 0x75, 0x3c, 0x1f, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x10, 0xfd, 
+	0x7f, 0xe0, 0x12, 0x10, 0x60, 0x12, 0x1d, 0x4b, 0x12, 0x1c, 0x75, 0xd2, 0xaf, 0x7f, 0x14, 0x12, 
+	0x1d, 0x5e, 0x12, 0xd, 0x46, 0x12, 0x1f, 0xcf, 0x12, 0x1a, 0x8f, 0xef, 0x70, 0x3, 0x30, 0x7, 
+	0x3, 0x12, 00, 0x1e, 0x12, 0x1a, 0xd1, 0x12, 0x1c, 0xd1, 0xef, 0x60, 0x3, 0x12, 00, 0x1e, 
+	0x12, 0x17, 0x4, 0x12, 0x1c, 0x2b, 0x30, 0x7, 0x16, 0xc2, 0x7, 0x7b, 0x16, 0xe4, 0xfd, 0x7f, 
+	0xe0, 0x12, 0x9, 0x3c, 0x7f, 00, 0x7e, 00, 0x7d, 0xff, 0x7c, 0xff, 0x12, 0x9, 0x43, 0x12, 
+	0xc, 0x3f, 0x30, 00, 0x8, 0xc2, 00, 0x12, 0x1e, 0xb, 0x12, 0x1b, 0xde, 0x30, 0x1, 0xd6, 
+	0xc2, 0x1, 0x12, 0x1d, 0xdd, 0x12, 0x1c, 0x8c, 0xa2, 0x81, 0xb3, 0x92, 0x91, 0x80, 0xc7, 0x12, 
+	0x15, 0xba, 0x40, 0x3, 0x2, 0xc, 0xc4, 0x75, 0x1a, 0x62, 0x12, 0x1e, 0xe5, 0x12, 0x1a, 0x1f, 
+	0x75, 0x27, 0x1e, 0x75, 0x28, 0x72, 0x12, 0x15, 0x5, 0xef, 0x70, 0x4, 0xf5, 0x22, 0x80, 0x4a, 
+	0x12, 0x1a, 0x1f, 0x75, 0x27, 0x1e, 0x75, 0x28, 0x78, 0x12, 0x15, 0x5, 0xef, 0x70, 0x36, 0x74, 
+	0x7, 0x25, 0x1a, 0xf5, 0x1a, 0x12, 0x5, 0x5a, 0xef, 0x60, 0x2, 0x80, 0x6, 0xe5, 0x19, 0x64, 
+	0x2, 0x60, 0x5, 0x75, 0x22, 0x1, 0x80, 0x18, 0x78, 0x52, 0x12, 0x5, 0x6, 0xc0, 0x6, 0xc0, 
+	0x7, 0x12, 0x1a, 0x5, 0xac, 0x6, 0xd0, 0x7, 0xd0, 0x6, 0x12, 0xf, 0xf7, 0x12, 0x1d, 0x71, 
+	0xe4, 0xf5, 0x22, 0x80, 0x5, 0x12, 0x6, 0x63, 0x8f, 0x22, 0xe5, 0x22, 0x60, 0x13, 0x12, 0x1e, 
+	0xc4, 0x50, 0x5, 0x12, 0x1d, 0xed, 0x80, 0xf6, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x54, 0x12, 0x19, 
+	0xe0, 0xe4, 0xf5, 0x18, 0x22, 0x8f, 0x23, 0x74, 0xa0, 0x2f, 0xf8, 0xe6, 0x24, 0xfe, 0x60, 0x2a, 
+	0x14, 0x60, 0x5c, 0x24, 0x2, 0x70, 0x6e, 0x7b, 0xe1, 0x7a, 0x5, 0x7d, 0x4, 0xaf, 0x23, 0x12, 
+	0x17, 0xce, 0x7b, 00, 0x7a, 0x6, 0x7d, 0x9, 0xaf, 0x23, 0x12, 0x17, 0xce, 0xaf, 0x23, 0x12, 
+	0x1e, 0x1a, 0x74, 0xa0, 0x25, 0x23, 0xf8, 0x76, 0x2, 0x22, 0x30, 0x9, 0x48, 0xaf, 0x23, 0x12, 
+	0x1e, 0x9c, 0x50, 0x41, 0x12, 0x1f, 0xa1, 0x7d, 0x1, 0xaf, 0x23, 0x12, 0x9, 0x81, 0xaf, 0x23, 
+	0x12, 0x1c, 0x5d, 0x8f, 0x24, 0xad, 0x24, 0xaf, 0x23, 0x12, 0x1b, 0x8b, 0xad, 0x24, 0xaf, 0x23, 
+	0x12, 0x15, 0xf6, 0x74, 0xa0, 0x25, 0x23, 0xf8, 0x76, 0x3, 0xaf, 0x23, 0x2, 0x1f, 0xcb, 0x30, 
+	0x9, 0x13, 0xaf, 0x23, 0x12, 0x1e, 0x9c, 0x40, 0xc, 0x74, 0xa0, 0x25, 0x23, 0xf8, 0x76, 0x2, 
+	0xaf, 0x23, 0x12, 0x1b, 0x6e, 0x22, 0x12, 00, 0x3f, 0xe4, 0x75, 0x26, 0xc0, 0xf5, 0x25, 0xf5, 
+	0x24, 0xf5, 0x23, 0xf5, 0x22, 0x7b, 00, 0x7a, 00, 0x79, 0x23, 0xaf, 0x22, 0x12, 0x9, 0xdc, 
+	0x40, 0x21, 0xe4, 0xfb, 0x7d, 0x2, 0x7f, 0x60, 0x12, 0x9, 0x3c, 0xe4, 0x25, 0x22, 0xff, 0xe4, 
+	0x34, 0x4, 0xfe, 0xe4, 0x34, 0x1, 0xfd, 0xe4, 0x34, 0x1, 0xfc, 0x12, 0x9, 0x43, 0x7f, 0x2, 
+	0x12, 0x1d, 0x5e, 0x5, 0x22, 0xe5, 0x22, 0xd3, 0x94, 0xf, 0x40, 0xc9, 0x7f, 0x3, 0x12, 0x1e, 
+	0xfb, 0x12, 0x1f, 0x93, 0x12, 0x1e, 0xda, 0x7f, 0x4, 0x12, 0x1e, 0xfb, 0x75, 0x3c, 0x1, 0x75, 
+	0x3d, 0x1, 0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x17, 0x6c, 0x7f, 0x14, 0x12, 0x1d, 0x5e, 
+	0x7b, 0x4, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x3c, 0x7f, 0x5f, 0x12, 0x1f, 0x9a, 0x12, 0x9, 
+	0x43, 0x2, 0x14, 0x44, 0x8f, 0x37, 0x12, 0xa, 0x8b, 0xaf, 0x37, 0x12, 0x12, 0xb1, 0x75, 0x3d, 
+	00, 0x75, 0x3e, 0x40, 0x7b, 0x40, 0x7d, 0x12, 0x12, 0xe, 0x31, 0x12, 0x1f, 0x5c, 0x75, 0x3d, 
+	0xf, 0x75, 0x3e, 0xc0, 0x7b, 0x40, 0x7a, 0x2, 0x7d, 0x16, 0xaf, 0x37, 0x12, 0x19, 0x49, 0x75, 
+	0x3d, 0x60, 0x75, 0x3e, 00, 0x7b, 00, 0x7a, 0x40, 0x7d, 0x14, 0xaf, 0x37, 0x12, 0x19, 0x49, 
+	0x75, 0x3d, 00, 0x75, 0x3e, 0x38, 0x7b, 0x30, 0x7d, 0x18, 0x12, 0xe, 0x31, 0x12, 0x1f, 0x4a, 
+	0x75, 0x3d, 0xe0, 0x12, 0x1a, 0x4f, 0xaf, 0x37, 0x12, 0x19, 0x49, 0xaf, 0x37, 0x12, 0x1f, 0x65, 
+	0x75, 0x3d, 0xe0, 0x75, 0x3e, 0xe, 0x7b, 0x2, 0x7a, 0x80, 0x7d, 0x18, 0xaf, 0x37, 0x2, 0x19, 
+	0x49, 0x7a, 00, 0xaf, 0x37, 0x12, 0x19, 0x49, 0xaf, 0x37, 0x22, 0x8f, 0x35, 0x8e, 0x34, 0x8d, 
+	0x33, 0x8c, 0x32, 0xe4, 0xf5, 0x40, 0xe4, 0xff, 0xfe, 0xfd, 0xfc, 0xab, 0x35, 0xaa, 0x34, 0xa9, 
+	0x33, 0xa8, 0x32, 0xd3, 0x12, 0x4, 0xcf, 0x40, 0x37, 0xe4, 0x7b, 0xa, 0xfa, 0xf9, 0xf8, 0xaf, 
+	0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0x12, 0x4, 0x30, 0xaf, 0x3, 0x74, 0x36, 0x25, 0x40, 
+	0xf8, 0xa6, 0x7, 0xaf, 0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0xe4, 0x7b, 0xa, 0xfa, 0xf9, 
+	0xf8, 0x12, 0x4, 0x30, 0x8f, 0x35, 0x8e, 0x34, 0x8d, 0x33, 0x8c, 0x32, 0x5, 0x40, 0x80, 0xb6, 
+	0xe5, 0x40, 0x70, 0x5, 0x7f, 0x30, 0x2, 0x1d, 0x84, 0x15, 0x40, 0xe5, 0x40, 0xf4, 0x60, 0x10, 
+	0x74, 0x36, 0x25, 0x40, 0xf8, 0xe6, 0x24, 0x30, 0xff, 0x12, 0x1d, 0x84, 0x15, 0x40, 0x80, 0xeb, 
+	0x22, 0x7b, 0xff, 0x7a, 0x1e, 0x79, 0x29, 0x12, 0x19, 0xe0, 0x12, 0x1f, 0x19, 0x7b, 0xff, 0x7a, 
+	0x12, 0x79, 0x66, 0x12, 0x19, 0xe0, 0x7b, 0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x28, 0x12, 
+	0x1c, 0x12, 0x12, 0x1f, 0x19, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x6b, 0x12, 0x19, 0xe0, 0xe4, 0xf5, 
+	0x24, 0xaf, 0x24, 0x12, 0x1a, 0xb0, 0x7f, 0x3, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1e, 0x64, 
+	0x7f, 0x2, 0x12, 0x1d, 0x23, 0x7f, 0x1, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1f, 0xa8, 0xe4, 
+	0xfc, 0xfd, 0xfe, 0x12, 0xe, 0x3b, 0x7f, 0x3, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1f, 0xaf, 
+	0x12, 0x1a, 0xb0, 0x12, 0x1f, 0x19, 0x5, 0x24, 0xe5, 0x24, 0xc3, 0x94, 0x7, 0x40, 0xc2, 0x22, 
+	0x8f, 0x32, 0x8d, 0x33, 0x7b, 0x24, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0x7f, 0x6, 0x12, 0x1b, 0x35, 
+	0x12, 0x9, 0x43, 0xe5, 0x32, 0x24, 0x80, 0xfb, 0x75, 0x3c, 0x1b, 0x75, 0x3d, 0x1, 0xe4, 0xfd, 
+	0x7f, 0x40, 0x12, 0x17, 0x6c, 0x7f, 0x2, 0x12, 0x1e, 0xfb, 0xaf, 0x33, 0x12, 0x1a, 0x6e, 0x7f, 
+	0xa, 0x12, 0x1f, 0x85, 0x12, 0x1e, 0xcf, 0x40, 0x5, 0x12, 0x1f, 0xbd, 0x50, 0xf6, 0x12, 0x1f, 
+	0xbd, 0x40, 0x13, 0xad, 0x33, 0xaf, 0x32, 0x12, 0x13, 0x66, 0xef, 0x70, 0x4, 0xf5, 0x34, 0x80, 
+	0x8, 0x75, 0x34, 0x1, 0x80, 0x3, 0x75, 0x34, 0x2, 0xe5, 0x32, 0x24, 0x80, 0xfb, 0x75, 0x3c, 
+	0x1b, 0xe4, 0xf5, 0x3d, 0xfd, 0x7f, 0x40, 0x12, 0x17, 0x6c, 0xaf, 0x34, 0x22, 0x8f, 0xa, 0xc3, 
+	0xed, 0x94, 0x40, 0xec, 0x94, 00, 0x50, 0x16, 0xc3, 0x74, 0x40, 0x9d, 0xff, 0xe4, 0x9c, 0xfe, 
+	0xef, 0x78, 0x2, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0xf5, 0xb, 0x80, 0x1c, 0xed, 0x24, 
+	0x3, 0xff, 0xe4, 0x3c, 0xfe, 0xef, 0x78, 0x2, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x30, 
+	0xe0, 0x5, 0x75, 0xb, 0x1, 0x80, 0x3, 0xe4, 0xf5, 0xb, 0xc3, 0xed, 0x94, 0x40, 0xec, 0x94, 
+	00, 0x40, 0xe, 0xae, 0x4, 0xaf, 0x5, 0xe4, 0xfc, 0xfd, 0x78, 0x10, 0x12, 0x4, 0xf3, 0x80, 
+	0x8, 0x7f, 00, 0x7e, 00, 0x7d, 0x40, 0x7c, 00, 0x12, 0x15, 0x42, 0x7f, 0x20, 0x7e, 0x5, 
+	0x7d, 00, 0x7c, 00, 0x2, 0x15, 0x42, 0x8e, 0x23, 0x8f, 0x24, 0x8c, 0x25, 0x8d, 0x26, 0x7f, 
+	0xa, 0x12, 0x1d, 0x37, 0x12, 0x1f, 0x37, 0x40, 0x52, 0x12, 0x1e, 0x38, 0xe4, 0xff, 0x12, 0x1d, 
+	0xa8, 0x7f, 0x2, 0x12, 0x1a, 0x29, 0xe5, 0x23, 0xff, 0x12, 0x1a, 0x29, 0xaf, 0x24, 0x12, 0x1a, 
+	0x29, 0xe4, 0xf5, 0x27, 0x12, 0x1f, 0x37, 0x40, 0x24, 0x12, 0x1e, 0xc4, 0x50, 0xfb, 0x12, 0x1d, 
+	0xed, 0x12, 0x1a, 0x29, 0x5, 0x24, 0xe5, 0x24, 0x70, 0x2, 0x5, 0x23, 0xe5, 0x26, 0x15, 0x26, 
+	0x70, 0x2, 0x15, 0x25, 0x5, 0x27, 0xe5, 0x27, 0xc3, 0x94, 0x20, 0x40, 0xd7, 0x7f, 0x1, 0x12, 
+	0x1d, 0xa8, 0x12, 0x1c, 0xba, 0xef, 0x30, 0xe0, 0xab, 0x80, 0xf7, 0xe4, 0xff, 0x2, 0x1d, 0x37, 
+	0x8f, 0x33, 0x8d, 0x34, 0x8b, 0x35, 0xe5, 0x39, 0x55, 0x3d, 0xf5, 0x39, 0xe5, 0x38, 0x55, 0x3c, 
+	0xf5, 0x38, 0xe5, 0x37, 0x55, 0x3b, 0xf5, 0x37, 0xe5, 0x36, 0x55, 0x3a, 0xf5, 0x36, 0x12, 0x9, 
+	0x28, 0xa8, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7, 0xaf, 0x3d, 0xae, 0x3c, 0xad, 0x3b, 0xac, 
+	0x3a, 0x12, 0x4, 0xc2, 0xeb, 0x5f, 0xff, 0xea, 0x5e, 0xfe, 0xe9, 0x5d, 0xfd, 0xe8, 0x5c, 0xfc, 
+	0xe5, 0x39, 0x4f, 0xf5, 0x39, 0xe5, 0x38, 0x4e, 0xf5, 0x38, 0xe5, 0x37, 0x4d, 0xf5, 0x37, 0xe5, 
+	0x36, 0x4c, 0xf5, 0x36, 0xab, 0x35, 0xad, 0x34, 0xaf, 0x33, 0x12, 0x9, 0x3c, 0xaf, 0x39, 0xae, 
+	0x38, 0xad, 0x37, 0xac, 0x36, 0x2, 0x9, 0x43, 0x8f, 0x32, 0x8d, 0x33, 0x7b, 0x19, 0xad, 0x32, 
+	0x7f, 0x20, 0x12, 0x9, 0x3c, 0x12, 0x1b, 0x33, 0x12, 0x9, 0x43, 0xe5, 0x33, 0x44, 0x10, 0xfd, 
+	0xaf, 0x32, 0x12, 0x11, 0x92, 0xef, 0xf5, 0x37, 0xee, 0xf5, 0x36, 0xed, 0x44, 0x1, 0xf5, 0x35, 
+	0xec, 0x44, 0x10, 0xf5, 0x34, 0x12, 0x11, 0x23, 0xe5, 0x37, 0x44, 0x30, 0xff, 0xe5, 0x36, 0xfe, 
+	0xe5, 0x35, 0xfd, 0xe5, 0x34, 0x44, 0x20, 0xfc, 0x12, 0x9, 0x43, 0x12, 0x11, 0x23, 0xaf, 0x37, 
+	0xae, 0x36, 0xad, 0x35, 0xac, 0x34, 0x12, 0x9, 0x43, 0xe5, 0x32, 0xb4, 0x6, 0x4, 0xff, 0x12, 
+	0x16, 0xcf, 0x22, 0xe4, 0xfb, 0xad, 0x32, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0x22, 0x7f, 0xa, 0x12, 
+	0x1d, 0x37, 0xe4, 0xff, 0xfe, 0x12, 0x19, 0x6f, 0xef, 0x7f, 00, 0xfe, 0xc0, 0x7, 0xc0, 0x6, 
+	0xf, 0x7e, 00, 0x12, 0x19, 0x6f, 0xef, 0xfd, 0xd0, 0xe0, 0xf5, 0x1b, 0xd0, 0xe0, 0x4d, 0xf5, 
+	0x1c, 0x24, 0x1, 0xff, 0xe4, 0x35, 0x1b, 0xfe, 0x12, 0x19, 0x6f, 0x8f, 0x1d, 0xe4, 0xff, 0x12, 
+	0x1d, 0x37, 0xe5, 0x1c, 0x15, 0x1c, 0x70, 0x2, 0x15, 0x1b, 0xe4, 0xff, 0xfe, 0xc3, 0xef, 0x95, 
+	0x1c, 0xee, 0x95, 0x1b, 0x50, 0x11, 0x8f, 0x82, 0x8e, 0x83, 0xe4, 0x93, 0x25, 0x1d, 0xf5, 0x1d, 
+	0xf, 0xbf, 00, 0x1, 0xe, 0x80, 0xe6, 0xe5, 0x1d, 0x70, 0x4, 0x7f, 0x1, 0x80, 0x2, 0x7f, 
+	00, 0x22, 0xef, 0x64, 0x6, 0xef, 0x64, 0x6, 0x70, 0x24, 0xbd, 0x10, 0x8, 0x7f, 0x43, 0x7e, 
+	0x4, 0x7d, 0x4, 0xfc, 0x22, 0xed, 0x70, 0x4, 0x7f, 0x43, 0x80, 0x20, 0xbd, 0x11, 0x4, 0x7f, 
+	0x42, 0x80, 0x24, 0xbd, 0x1, 0x4, 0x7f, 0x42, 0x80, 0x29, 0x7f, 0x81, 0x80, 0x2e, 0xbd, 0x10, 
+	0x6, 0x7f, 0x44, 0x7e, 0x4, 0x80, 0x12, 0xed, 0x70, 0x8, 0x7f, 0x44, 0x7e, 0x4, 0xfd, 0x7c, 
+	0x80, 0x22, 0xbd, 0x11, 0x9, 0x7f, 0x44, 0x7e, 0x24, 0x7d, 0x4, 0x7c, 00, 0x22, 0xbd, 0x1, 
+	0x9, 0x7f, 0x44, 0x7e, 0x24, 0x7d, 00, 0x7c, 0x80, 0x22, 0x7f, 0x84, 0x7e, 0x1, 0x7d, 0x6, 
+	0x7c, 00, 0x22, 0x8f, 0x2c, 0x7f, 0x32, 0x12, 0x1f, 0x85, 0x7b, 0xd8, 0xad, 0x2c, 0x7f, 0x20, 
+	0x12, 0x9, 0x28, 0x78, 0x8, 0x12, 0x4, 0xe0, 0xef, 0x54, 0x3f, 0xff, 0xe4, 0xfe, 0xfd, 0xfc, 
+	0xfb, 0xfa, 0xf9, 0xf8, 0xc3, 0x12, 0x4, 0xcf, 0x70, 0x32, 0x7b, 0xc, 0xfd, 0x7f, 0xa0, 0x12, 
+	0x9, 0x28, 0xc0, 0x4, 0xc0, 0x5, 0xc0, 0x6, 0xc0, 0x7, 0xaf, 0x2c, 0x12, 0x9, 0x7a, 0xe4, 
+	0xfc, 0xfd, 0xfe, 0xd0, 0x3, 0xd0, 0x2, 0xd0, 0x1, 0xd0, 00, 0xeb, 0x5f, 0xff, 0xe4, 0xfb, 
+	0xfa, 0xf9, 0xf8, 0xc3, 0x12, 0x4, 0xcf, 0x60, 0x3, 0x7f, 0x1, 0x22, 0x12, 0x1f, 0xbd, 0x50, 
+	0xa9, 0x7f, 00, 0x22, 0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 
+	0x61, 0x6e, 0x64, 0xd, 0xa, 00, 0x69, 0x64, 0x3a, 0x20, 00, 00, 0x50, 00, 0x4d, 00, 
+	0x50, 0x20, 00, 00, 00, 0xd, 0xa, 0x20, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x20, 0x40, 
+	0x31, 0x30, 0x20, 0x40, 0x31, 0x30, 0x30, 0x20, 0x40, 0x31, 0x30, 0x30, 0x30, 00, 0x4f, 0x6b, 
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 00, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x20, 00, 0xd, 0xa, 
+	0x54, 0x65, 0x73, 0x74, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0xd, 0xa, 
+	00, 0x8f, 0x38, 0x12, 0x1f, 0x5c, 0x12, 0x1a, 0x59, 0x12, 0x12, 0xf9, 0x12, 0x1f, 0x53, 0x7a, 
+	0xb6, 0x12, 0x13, 0x3, 0x75, 0x3d, 0xff, 0x75, 0x3e, 0x7, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x12, 
+	0xaf, 0x38, 0x12, 0x19, 0x49, 0x75, 0x3d, 00, 0x75, 0x3e, 0xff, 0x7b, 0xa2, 0x7a, 00, 0x7d, 
+	0x11, 0xaf, 0x38, 0x12, 0x19, 0x49, 0x7a, 0x96, 0x12, 0x13, 0x3, 0xaf, 0x38, 0x12, 0x1f, 0x5c, 
+	0x12, 0x1a, 0x64, 0x12, 0x12, 0xf9, 0x2, 0x1f, 0x65, 0x7d, 0x8, 0xaf, 0x38, 0x12, 0x19, 0x49, 
+	0xaf, 0x38, 0x22, 0x7b, 0x8a, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xce, 0x22, 0x8f, 0x3f, 0x8d, 
+	0x40, 0x12, 0x1f, 0xa8, 0x8f, 0x45, 0xaf, 0x3f, 0x12, 0x1f, 0xaf, 0x8f, 0x46, 0x7b, 0x1, 0xad, 
+	0x45, 0x7f, 0x60, 0x12, 0x9, 0x3c, 0xe5, 0x46, 0x75, 0xf0, 0x20, 0xa4, 0xff, 0xe5, 0xf0, 0x44, 
+	0x4, 0xfc, 0xef, 0x45, 0x40, 0xfd, 0xe4, 0xff, 0xfe, 0x12, 0x9, 0x59, 0x12, 0x9, 0x43, 0xaf, 
+	0x45, 0x12, 0x1b, 0x13, 0x7b, 0x2, 0xad, 0x45, 0x7f, 0x60, 0x12, 0x9, 0x28, 0x8f, 0x44, 0x8e, 
+	0x43, 0x8d, 0x42, 0x8c, 0x41, 0xe5, 0x42, 0x54, 0x1, 0xfd, 0xed, 0x70, 0x5, 0xae, 0x43, 0xaf, 
+	0x44, 0x22, 0xe4, 0xfe, 0xff, 0x22, 0x8f, 0x35, 0x8d, 0x36, 0xe4, 0xf5, 0x38, 0xfb, 0x7a, 00, 
+	0x79, 0x39, 0x12, 0x14, 0x86, 0xef, 0x64, 0x80, 0x4e, 0x60, 0x3, 0x75, 0x38, 0x1, 0xe5, 0x39, 
+	0x65, 0x35, 0x60, 0x3, 0x75, 0x38, 0x1, 0xe5, 0x38, 0x70, 0x25, 0xf5, 0x37, 0x12, 0x1c, 0xfb, 
+	0xa8, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7, 0xe4, 0x25, 0x36, 0x12, 0x1b, 0x3c, 0xc3, 0x12, 
+	0x4, 0xcf, 0x60, 0x3, 0x75, 0x38, 0x1, 0x5, 0x37, 0xe5, 0x37, 0xc3, 0x94, 0x1f, 0x40, 0xdd, 
+	0x12, 0x1d, 0xf, 0xaf, 0x38, 0x22, 0x8f, 0x35, 0x8d, 0x36, 0xe4, 0xfb, 0xfa, 0xfd, 0x12, 0x17, 
+	0xce, 0xe5, 0x36, 0x54, 0x3, 0xff, 0x70, 0x6, 0xf5, 0x37, 0xf5, 0x38, 0x80, 0x14, 0xbf, 0x1, 
+	0x8, 0x75, 0x37, 0x20, 0x75, 0x38, 00, 0x80, 0x9, 0xbf, 0x2, 0x6, 0x75, 0x37, 00, 0x75, 
+	0x38, 0x40, 0xe5, 0x36, 0x30, 0xe4, 0x3, 0x43, 0x37, 0x1, 0xe5, 0x36, 0x30, 0xe7, 0x3, 0x43, 
+	0x37, 0x40, 0xab, 0x38, 0xaa, 0x37, 0xe4, 0xfd, 0xaf, 0x35, 0x2, 0x17, 0xce, 0x8f, 0x27, 0x12, 
+	0x1f, 0x53, 0x7b, 0xf0, 0x7a, 0xaf, 0x7d, 0x10, 0xaf, 0x27, 0x12, 0x17, 0xce, 0x7d, 0x11, 0xaf, 
+	0x27, 0x12, 0x13, 0xd, 0xee, 0xc4, 0xf8, 0x54, 0xf0, 0xc8, 0xef, 0xc4, 0x54, 0xf, 0x48, 0x54, 
+	0x1f, 0xff, 0xc3, 0x94, 0x10, 0x40, 0x6, 0xef, 0xd3, 0x94, 0x14, 0x40, 0x12, 0xaf, 0x27, 0x12, 
+	0x1f, 0x5c, 0x75, 0x3d, 0x3, 0x12, 0x1a, 0x67, 0x7d, 0xc, 0xaf, 0x27, 0x12, 0x19, 0x49, 0xaf, 
+	0x27, 0x2, 0x1f, 0x65, 0x75, 0x27, 0x1, 0x7b, 0x6, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x3c, 
+	0x7f, 0x80, 0x7e, 0x1, 0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x43, 0x7b, 0x7, 0xe4, 0xfd, 0x7f, 
+	0x40, 0x12, 0x9, 0x3c, 0xe4, 0x25, 0x27, 0xff, 0xe4, 0x33, 0xfe, 0xe4, 0x33, 0xfd, 0xe4, 0x34, 
+	0xc2, 0xfc, 0x12, 0x9, 0x43, 0x7f, 0x1, 0x7e, 0x26, 0x12, 0x16, 0x65, 0x5, 0x27, 0xe5, 0x27, 
+	0xd3, 0x94, 0xf, 0x40, 0xc2, 0x22, 0x8b, 0x3a, 0x8a, 0x3b, 0x89, 0x3c, 0xe4, 0xf5, 0x8, 0xf5, 
+	0x9, 0x12, 0x14, 0xba, 0xe5, 0x3d, 0x54, 0x3f, 0xf5, 0x41, 0x85, 0x3e, 0x42, 0xe5, 0x3b, 0x45, 
+	0x3c, 0x45, 0x3a, 0x60, 0x10, 0xe5, 0x40, 0x54, 0x7, 0xab, 0x3a, 0xaa, 0x3b, 0xa9, 0x3c, 0x12, 
+	0x3, 0x93, 0x12, 0x14, 0xba, 0xae, 0x41, 0xaf, 0x42, 0x22, 0x12, 0x1c, 0xfb, 0x8f, 0x40, 0x8e, 
+	0x3f, 0x8d, 0x3e, 0x8c, 0x3d, 0x22, 0xc0, 0xe0, 0xc0, 0xd0, 0x75, 0xd0, 0x10, 0x30, 0x98, 0x29, 
+	0xaf, 0x99, 0xc2, 0x98, 0xe5, 0x1e, 0x24, 0x1, 0xfd, 0xe4, 0x33, 0xfc, 0xe5, 0x1f, 0x7a, 00, 
+	0xb5, 0x15, 0x8, 0xea, 0xb5, 0x14, 0x4, 0xd2, 0x5, 0x80, 0xe, 0x74, 0x80, 0x25, 0x1e, 0xf8, 
+	0xa6, 0x17, 0xe5, 0x1e, 0x4, 0x54, 0x1f, 0xf5, 0x1e, 0x30, 0x99, 0x4, 0xc2, 0x99, 0xd2, 0x6, 
+	0xd0, 0xd0, 0xd0, 0xe0, 0x32, 0x8b, 0x23, 0x8a, 0x24, 0x89, 0x25, 0xab, 0x26, 0xaa, 0x27, 0xa9, 
+	0x28, 0x12, 0x3, 0x7a, 0xf5, 0x29, 0x70, 0x2, 0xff, 0x22, 0x74, 0x1, 0x25, 0x28, 0xf5, 0x28, 
+	0xe4, 0x35, 0x27, 0xf5, 0x27, 0xab, 0x23, 0x5, 0x25, 0xe5, 0x25, 0xaa, 0x24, 0x70, 0x2, 0x5, 
+	0x24, 0x14, 0xf9, 0x12, 0x3, 0x7a, 0xff, 0x12, 0x1c, 0x44, 0xef, 0x65, 0x29, 0x60, 0xcc, 0x7f, 
+	0x1, 0x22, 0x8f, 0x3a, 0x8e, 0x39, 0x8d, 0x38, 0x8c, 0x37, 0x20, 0x8, 0x30, 0x7b, 0xc0, 0xad, 
+	0xa, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0xaf, 0x3a, 0xae, 0x39, 0xad, 0x38, 0xac, 0x37, 0x12, 0x9, 
+	0x43, 0xe4, 0x78, 0xa7, 0xf6, 0x7b, 0xc8, 0xad, 0xa, 0x7f, 0x20, 0x12, 0x9, 0x28, 0xee, 0x30, 
+	0xe0, 0xb, 0x78, 0xa7, 0x6, 0xe6, 0xd3, 0x94, 0x64, 0x40, 0xea, 0xd2, 0x8, 0x22, 0x12, 0x19, 
+	0x23, 0x8f, 0x2b, 0xe4, 0xf5, 0x2a, 0xaf, 0x2a, 0x12, 0x9, 0x7a, 0xef, 0xf4, 0xff, 0xef, 0x55, 
+	0x2b, 0xff, 0xe4, 0x8f, 0x39, 0xf5, 0x38, 0xf5, 0x37, 0xf5, 0x36, 0xe5, 0x2a, 0x24, 0x80, 0xfb, 
+	0xe4, 0x75, 0x3d, 0x5f, 0xf5, 0x3c, 0xf5, 0x3b, 0xf5, 0x3a, 0xfd, 0x7f, 0x40, 0x12, 0x10, 0x60, 
+	0x5, 0x2a, 0xe5, 0x2a, 0xc3, 0x94, 0x7, 0x40, 0xcd, 0x22, 0x12, 0x1e, 0xc4, 0x50, 0x35, 0x12, 
+	0x1d, 0xed, 0xef, 0x64, 0xa, 0x60, 0x2d, 0xbf, 0x8, 0xb, 0xe5, 0x18, 0xd3, 0x94, 00, 0x40, 
+	0x23, 0x15, 0x18, 0x80, 0x1f, 0xe5, 0x18, 0xc3, 0x94, 0x1e, 0x50, 0xa, 0xae, 0x18, 0x5, 0x18, 
+	0x74, 0x62, 0x2e, 0xf8, 0xa6, 0x7, 0xbf, 0xd, 0xb, 0xe5, 0x18, 0xb4, 0x1e, 0x4, 0x78, 0x7f, 
+	0x76, 0xd, 0xd3, 0x22, 0xc3, 0x22, 0x8f, 0x25, 0x8d, 0x26, 0xe5, 0x25, 0x64, 0x6, 0x60, 0x2d, 
+	0xe5, 0x26, 0x54, 0x3, 0xff, 0xbf, 0x2, 0x5, 0xaf, 0x25, 0x12, 0x13, 0xfd, 0xe5, 0x26, 0x54, 
+	0x3, 0x70, 0x1a, 0xaf, 0x25, 0x12, 0x1f, 0x5c, 0x12, 0x1a, 0x4c, 0xaf, 0x25, 0x12, 0x19, 0x49, 
+	0x12, 0x1a, 0x4c, 0xaf, 0x25, 0x12, 0x19, 0x49, 0xaf, 0x25, 0x12, 0x1f, 0x65, 0x22, 0xaf, 0xb, 
+	0x15, 0xb, 0xef, 0xd3, 0x94, 00, 0x40, 0xd, 0x7f, 0x55, 0x7e, 0x55, 0x7d, 0x55, 0x7c, 0x55, 
+	0x12, 0x15, 0x42, 0x80, 0xe9, 0x30, 0x8, 0x9, 0x75, 0x3c, 0x1, 0x12, 0x16, 0x58, 0xc2, 0x8, 
+	0x22, 0xe4, 0xf5, 0x3c, 0x12, 0x16, 0x58, 0x22, 0x75, 0x3d, 0x1, 0x7b, 0xc4, 0xad, 0xa, 0x7f, 
+	0x20, 0x12, 0x17, 0x6c, 0x22, 0x8e, 0x28, 0x8f, 0x29, 0x7b, 0xb0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 
+	0x9, 0x3c, 0xae, 0x28, 0xaf, 0x29, 0xe4, 0xfc, 0xfd, 0x12, 0x9, 0x43, 0x7f, 0xa, 0x12, 0x1f, 
+	0x85, 0x7b, 0xb0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x28, 0xef, 0x54, 0x7, 0x60, 0xa, 0x12, 
+	0x1f, 0xbd, 0x50, 0xed, 0x7f, 0x4, 0x12, 0x1f, 0xc5, 0x22, 0x8f, 0x28, 0x8d, 0x29, 0xe5, 0x29, 
+	0xf4, 0x60, 0x29, 0x7b, 0x10, 0xad, 0x28, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0x7f, 00, 0x7e, 0x6, 
+	0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x43, 0xad, 0x29, 0xaf, 0x28, 0x12, 0x7, 0x66, 0xe4, 0xfd, 
+	0xaf, 0x28, 0x12, 00, 0x26, 0x7d, 0x1, 0xaf, 0x28, 0x12, 0x1e, 0xb7, 0x2, 0x15, 0x7e, 0x8f, 
+	0x38, 0x75, 0x3c, 0x5, 0x75, 0x3d, 0x1, 0x7b, 0x19, 0xad, 0x38, 0x7f, 0x20, 0x12, 0x17, 0x6c, 
+	0xe5, 0x38, 0xb4, 0x6, 0xe, 0x75, 0x3c, 0x2, 0x75, 0x3d, 0x1, 0x7b, 0x19, 0xfd, 0x7f, 0x20, 
+	0x12, 0x17, 0x6c, 0x7b, 0x5, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x3c, 0x7f, 0x22, 0x12, 0x1f, 
+	0x9a, 0x2, 0x9, 0x43, 0xe4, 0xf5, 0x22, 0xe5, 0x22, 0x24, 0x80, 0xfb, 0xe4, 0xfd, 0x7f, 0x40, 
+	0x12, 0x9, 0x3c, 0x7f, 00, 0x12, 0x1f, 0x9a, 0x12, 0x9, 0x43, 0xe5, 0x22, 0xb4, 0x6, 0x5, 
+	0x7d, 0x12, 0xff, 0x80, 0x4, 0x7d, 0xff, 0xaf, 0x22, 0x12, 0x1b, 0x8b, 0x5, 0x22, 0xe5, 0x22, 
+	0xc3, 0x94, 0x7, 0x40, 0xd2, 0x2, 0x15, 0x7e, 0x8b, 0x2b, 0x8a, 0x2c, 0x89, 0x2d, 0xe4, 0xf5, 
+	0x2e, 0xab, 0x2b, 0x5, 0x2d, 0xe5, 0x2d, 0xaa, 0x2c, 0x70, 0x2, 0x5, 0x2c, 0x14, 0xf9, 0x12, 
+	0x3, 0x7a, 0xff, 0x12, 0x1b, 0xf9, 0xe5, 0x2e, 0xc3, 0x94, 0x5, 0x50, 0x5, 0x7f, 0x2d, 0x12, 
+	0x1f, 0xc8, 0x5, 0x2e, 0xe5, 0x2e, 0xc3, 0x94, 0x6, 0x40, 0xd6, 0x22, 0x8f, 0x39, 0x8d, 0x3a, 
+	0x8b, 0x3b, 0x12, 0x9, 0x28, 0x8f, 0x41, 0x8e, 0x40, 0x8d, 0x3f, 0x8c, 0x3e, 0x7b, 00, 0x7a, 
+	00, 0x79, 0x3e, 0xad, 0x3d, 0xaf, 0x3c, 0x12, 0x9, 0xa9, 0xab, 0x3b, 0xad, 0x3a, 0xaf, 0x39, 
+	0x12, 0x9, 0x3c, 0xaf, 0x41, 0xae, 0x40, 0xad, 0x3f, 0xac, 0x3e, 0x2, 0x9, 0x43, 00, 00, 
+	0x10, 0x10, 00, 00, 00, 00, 00, 0xe, 00, 0x15, 00, 0x10, 00, 0x15, 00, 0x12, 
+	00, 0x15, 00, 0x14, 00, 0x15, 00, 00, 0x10, 0xc, 00, 00, 00, 0x1, 00, 0xa, 
+	00, 0x18, 00, 0xb, 00, 0x18, 00, 0xc, 00, 0x18, 00, 0xd, 00, 0x18, 0x8f, 0x3f, 
+	0x8d, 0x40, 0x8a, 0x41, 0x8b, 0x42, 0x12, 0x1f, 0xa8, 0x8f, 0x43, 0xaf, 0x3f, 0x12, 0x1f, 0xaf, 
+	0x8f, 0x44, 0x7b, 0x1, 0xad, 0x43, 0x7f, 0x60, 0x12, 0x9, 0x3c, 0xab, 0x44, 0xad, 0x40, 0xaf, 
+	0x42, 0xae, 0x41, 0x12, 0x1f, 0x5, 0x12, 0x9, 0x43, 0xaf, 0x43, 0x2, 0x1b, 0x13, 0x8f, 0x37, 
+	0x7b, 00, 0x7a, 0x80, 0xe4, 0xfd, 0x12, 0x17, 0xce, 0x7f, 0x2, 0x12, 0x1d, 0x5e, 0xe4, 0xf5, 
+	0x38, 0xe4, 0xfd, 0xaf, 0x37, 0x12, 0x13, 0xd, 0xee, 0x30, 0xe7, 0x10, 0x5, 0x38, 0xe5, 0x38, 
+	0xd3, 0x94, 0xc8, 0x50, 0x7, 0x7f, 0x1, 0x12, 0x1d, 0x5e, 0x80, 0xe5, 0x22, 0xc1, 0x5, 0xc1, 
+	0x4, 0x1, 0x1e, 00, 0x1, 0x1f, 00, 0xc1, 00, 0xc1, 0x1, 0x1, 0xe, 00, 0xc1, 0x2, 
+	0xc1, 0x3, 0x1, 0xc, 0xa, 0x1, 0xd, 0x64, 0xc1, 0x7, 0x1, 0xf, 00, 0xc1, 0x8, 0x1, 
+	0x18, 00, 0x1, 0x4d, 00, 0x1, 0x51, 00, 00, 0x8f, 0x2a, 0x8e, 0x29, 0x8d, 0x28, 0x8c, 
+	0x27, 0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x3c, 0xaf, 0x2a, 0xae, 0x29, 0xad, 0x28, 
+	0xac, 0x27, 0x12, 0x9, 0x43, 0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x28, 0xef, 0x54, 
+	0x3, 0x70, 0xf2, 0x22, 0xe4, 0xfe, 0xee, 0x90, 00, 0x40, 0x93, 0xfc, 0xed, 0x2e, 0xf8, 0xa6, 
+	0x4, 0xe, 0xbe, 0x6, 0xf1, 0xed, 0x24, 0x5, 0xf8, 0xe6, 0x2f, 0xf6, 0xc3, 0x9f, 0x50, 0xd, 
+	0xed, 0x24, 0x4, 0xf8, 0x6, 0xe6, 0x70, 0x5, 0xed, 0x24, 0x3, 0xf8, 0x6, 0x22, 0x7b, 0x17, 
+	0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x3c, 0x7f, 0xff, 0x7e, 0xff, 0x7d, 0xff, 0x7c, 0xff, 0x12, 
+	0x9, 0x43, 0x7b, 0x16, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x3c, 0x7f, 0x9b, 0x7e, 0x22, 0x7d, 
+	00, 0x7c, 00, 0x2, 0x9, 0x43, 0x8f, 0x32, 0x8d, 0x33, 0x8b, 0x34, 0x12, 0x1f, 0x2d, 0xaf, 
+	0x33, 0x12, 0x1f, 0x2d, 0x7f, 0x5, 0x12, 0x1e, 0xfb, 0xe5, 0x34, 0x44, 0x10, 0xfd, 0xaf, 0x32, 
+	0x12, 0x13, 0xb6, 0xe5, 0x34, 0x44, 0x10, 0xfd, 0xaf, 0x33, 0x2, 0x13, 0xb6, 0x8f, 0x32, 0xed, 
+	0x70, 0x2, 0x80, 0x1, 0xe4, 0x75, 0x39, 0x86, 0x75, 0x38, 0x2, 0xf5, 0x37, 0xf5, 0x36, 0x75, 
+	0x3d, 0xff, 0x75, 0x3c, 0xf, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x2, 0xad, 0x32, 0x7f, 0x20, 0x12, 
+	0x10, 0x60, 0x22, 0xe4, 0xf5, 0x2c, 0xf5, 0x2d, 0xaf, 0x2d, 0x12, 00, 0x3, 0xef, 0x60, 0xd, 
+	0x7b, 00, 0x7a, 00, 0x79, 0x2c, 0x7d, 0x1, 0xaf, 0x2d, 0x12, 0x9, 0x81, 0x5, 0x2d, 0xe5, 
+	0x2d, 0xc3, 0x94, 0x7, 0x40, 0xe2, 0xaf, 0x2c, 0x22, 0x8f, 0x39, 0x8d, 0x3a, 0x8a, 0x3b, 0x8b, 
+	0x3c, 0x12, 0x13, 0xd, 0xe5, 0x3e, 0xf4, 0xfd, 0xe5, 0x3d, 0xf4, 0x5e, 0xfe, 0xef, 0x5d, 0x42, 
+	0x3c, 0xee, 0x42, 0x3b, 0xab, 0x3c, 0xaa, 0x3b, 0xad, 0x3a, 0xaf, 0x39, 0x2, 0x17, 0xce, 0x8e, 
+	0x48, 0x8f, 0x49, 0xe4, 0xff, 0x12, 0x1d, 0xa8, 0x7f, 0x3, 0x12, 0x1a, 0x29, 0xe5, 0x48, 0xff, 
+	0x12, 0x1a, 0x29, 0xaf, 0x49, 0x12, 0x1a, 0x29, 0x12, 0x1a, 0xf2, 0x8f, 0x4a, 0x7f, 0x1, 0x12, 
+	0x1d, 0xa8, 0xaf, 0x4a, 0x22, 0x12, 0x1c, 0x44, 0x74, 0x30, 0xd3, 0x9f, 0x50, 0xa, 0xef, 0x94, 
+	0x39, 0x50, 0x5, 0xef, 0x24, 0xd0, 0xff, 0x22, 0x74, 0x41, 0xd3, 0x9f, 0x50, 0xa, 0xef, 0x94, 
+	0x46, 0x50, 0x5, 0xef, 0x24, 0xc9, 0xff, 0x22, 0x7f, 0xff, 0x22, 0xc2, 0x8e, 0x75, 0x8b, 0x92, 
+	0x75, 0x8d, 0xe6, 0xd2, 0x8e, 0xd2, 0x3, 0xd5, 0xc, 0x15, 0x75, 0xc, 0xa, 0xd2, 00, 0xd5, 
+	0xd, 0x5, 0x75, 0xd, 0x64, 0xd2, 0x1, 0x30, 0x2, 0x5, 0xd5, 0xe, 0x2, 0xc2, 0x2, 0x32, 
+	0x8b, 0x32, 0x8a, 0x33, 0x89, 0x34, 0xab, 0x32, 0xaa, 0x33, 0xa9, 0x34, 0x12, 0x3, 0x7a, 0x60, 
+	0x13, 0x5, 0x34, 0xe5, 0x34, 0x70, 0x2, 0x5, 0x33, 0x14, 0xf9, 0x12, 0x3, 0x7a, 0xff, 0x12, 
+	0x1d, 0x84, 0x80, 0xe2, 0x22, 0x78, 0x56, 0x12, 0x5, 0x6, 0xad, 0x7, 0x22, 0x78, 0x5a, 0x12, 
+	0x5, 0x6, 0xab, 0x7, 0x22, 0x78, 0x52, 0x12, 0x5, 0x6, 0x78, 0x5, 0x2, 0x4, 0xf3, 0xa9, 
+	0x1a, 0x7a, 00, 0x7b, 00, 0x75, 0x26, 0xff, 0x22, 0x8f, 0x29, 0xe4, 0xf5, 0x2a, 0xe5, 0x29, 
+	0x54, 0x80, 0xff, 0x12, 0x1d, 0xba, 0xe5, 0x29, 0x25, 0xe0, 0xf5, 0x29, 0x12, 0x1f, 0x75, 0x12, 
+	0x1f, 0x7d, 0x5, 0x2a, 0xe5, 0x2a, 0xc3, 0x94, 0x8, 0x40, 0xe3, 0x22, 0x75, 0x3d, 0x60, 0x75, 
+	0x3e, 00, 0x7b, 00, 0x7a, 0x20, 0x7d, 0x14, 0x22, 0x75, 0x3d, 0x2, 0x75, 0x3e, 00, 0x7b, 
+	00, 0x7a, 0x2, 0x22, 0x75, 0x3d, 0x2, 0x75, 0x3e, 00, 0xe4, 0xfb, 0xfa, 0x22, 0x8f, 0x35, 
+	0x7d, 0x80, 0x7c, 00, 0x12, 0xf, 0x8d, 0xe4, 0xf5, 0x36, 0xe4, 0x25, 0x35, 0x12, 0x1b, 0x3c, 
+	0x12, 0x15, 0x42, 0x5, 0x36, 0xe5, 0x36, 0xc3, 0x94, 0x20, 0x40, 0xee, 0x2, 0x16, 0x2e, 0x7b, 
+	0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x28, 0xec, 0x54, 0xf, 0xfc, 0x7b, 0xe9, 0x7a, 0x50, 
+	0x79, 0x38, 0x78, 0x7, 0xc3, 0x12, 0x4, 0xcf, 0x60, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 
+	0x8f, 0x32, 0xe5, 0x32, 0xd3, 0x94, 0x9, 0x40, 0xb, 0xe5, 0x32, 0x75, 0xf0, 0xa, 0x84, 0x12, 
+	0x1f, 0x23, 0x80, 0x2, 0x7f, 0x20, 0x12, 0x1d, 0x84, 0xe5, 0x32, 0x12, 0x1f, 0x23, 0x2, 0x1d, 
+	0x84, 0xe4, 0xf5, 0x4e, 0x7f, 0x3, 0x12, 0x1e, 0xfb, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e, 
+	0x80, 0x50, 0x5, 0xaf, 0x22, 0x12, 0x9, 0xf2, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 
+	0xeb, 0x22, 0xe4, 0xf5, 0x29, 0xe5, 0x2a, 0x25, 0xe0, 0xf5, 0x2a, 0x12, 0x1f, 0x75, 0x12, 0x1d, 
+	0xcc, 0xef, 0x42, 0x2a, 0x12, 0x1f, 0x7d, 0x5, 0x29, 0xe5, 0x29, 0xc3, 0x94, 0x8, 0x40, 0xe5, 
+	0xaf, 0x2a, 0x22, 0x8f, 0x47, 0x7f, 0x5, 0x12, 0x1f, 0x85, 0xe4, 0xfb, 0xad, 0x47, 0x7f, 0x60, 
+	0x12, 0x9, 0x28, 0xef, 0x54, 0xb, 0x60, 0xa, 0x12, 0x1f, 0xbd, 0x50, 0xed, 0x7f, 0x2, 0x12, 
+	0x1f, 0xc5, 0x22, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0xff, 0xe4, 0x34, 0x56, 
+	0xfe, 0xe4, 0x34, 0x34, 0xfd, 0xe4, 0x34, 0x12, 0xfc, 0x22, 0xff, 0x74, 0x3, 0xa8, 0x6, 0x8, 
+	0x22, 0xad, 0x7, 0xe4, 0xf5, 0x39, 0xf5, 0x38, 0x75, 0x37, 0x1, 0x75, 0x36, 0x10, 0xf5, 0x3d, 
+	0xf5, 0x3c, 0x75, 0x3b, 0x1, 0x75, 0x3a, 0x18, 0xfb, 0x7f, 0x20, 0x2, 0x10, 0x60, 0x8f, 0x25, 
+	0x12, 0x1f, 0xa1, 0xe4, 0xfd, 0x12, 0x9, 0x81, 0xaf, 0x25, 0x12, 0x1e, 0x80, 0x50, 0x5, 0xaf, 
+	0x25, 0x12, 0x1f, 0x41, 0x7d, 0xff, 0xaf, 0x25, 0x2, 0x1b, 0x8b, 0x8f, 0x26, 0x8d, 0x27, 0xe5, 
+	0x26, 0x64, 0x5, 0x60, 0x11, 0xe5, 0x27, 0xfd, 0x7c, 00, 0xaf, 0x26, 0x12, 0x1d, 0x96, 0xad, 
+	0x27, 0xaf, 0x26, 0x12, 0x16, 0x9a, 0x22, 0xbf, 0x6, 0x3, 0x7f, 0x12, 0x22, 0x7d, 0x1c, 0x12, 
+	0x13, 0xd, 0xef, 0x13, 0x13, 0x13, 0x54, 0x3, 0xfe, 0xef, 0x30, 0xe5, 0x3, 0x43, 0x6, 0x10, 
+	0xaf, 0x6, 0x22, 0x8f, 0x2b, 0x12, 0x1e, 0x56, 0x7d, 0x1, 0xaf, 0x2b, 0x12, 0x1e, 0xaa, 0xaf, 
+	0x2b, 0x12, 0x9, 0x7a, 0x12, 0x11, 0xf3, 0xe4, 0xfd, 0xaf, 0x2b, 0x2, 0x1e, 0xaa, 0xe4, 0xf5, 
+	0x22, 0xaf, 0x22, 0x12, 0x1e, 0x80, 0x50, 0x5, 0xaf, 0x22, 0x12, 0xc, 0xc5, 0x5, 0x22, 0xe5, 
+	0x22, 0xc3, 0x94, 0x7, 0x40, 0xeb, 0xc2, 0x9, 0x22, 0x8f, 0x2f, 0xe5, 0x2f, 0xc4, 0x54, 0xf, 
+	0xff, 0x12, 0x1e, 0x47, 0x12, 0x1d, 0x84, 0xe5, 0x2f, 0x54, 0xf, 0xff, 0x12, 0x1e, 0x47, 0x2, 
+	0x1d, 0x84, 0x8f, 0x28, 0x8e, 0x27, 0x8d, 0x26, 0x8c, 0x25, 0x78, 0x10, 0x12, 0x4, 0xe0, 0x12, 
+	0x1d, 0xfc, 0xe5, 0x28, 0xff, 0xe5, 0x27, 0xfe, 0x2, 0x1d, 0xfc, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 
+	0x12, 0x1e, 0xf0, 0x74, 0xa0, 0x25, 0x22, 0xf8, 0xa6, 0x7, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 
+	0x7, 0x40, 0xeb, 0x22, 0xd3, 0xef, 0x64, 0x80, 0xf8, 0x74, 0x61, 0x64, 0x80, 0x98, 0x50, 0xc, 
+	0xef, 0x64, 0x80, 0x94, 0xfa, 0x50, 0x5, 0xef, 0x24, 0xe0, 0xff, 0x22, 0x22, 0x8f, 0x25, 0x12, 
+	0x1b, 0xa7, 0x8f, 0x26, 0x7d, 0x5, 0xaf, 0x25, 0x12, 0x13, 0xd, 0xee, 0x30, 0xe2, 0x3, 0x43, 
+	0x26, 0x20, 0xaf, 0x26, 0x22, 0x75, 0xcb, 0xff, 0x75, 0xca, 0x2, 0x75, 0xcd, 0xff, 0x75, 0xcc, 
+	0x2, 0x75, 0xc8, 0x34, 0x75, 0x98, 0x52, 0xd2, 0xbc, 0xd2, 0xac, 0x22, 0x12, 0x1a, 0x8f, 0xef, 
+	0x60, 0x5, 0x7f, 0x5, 0x12, 0x1f, 0xc5, 0x12, 0x1c, 0xd1, 0xef, 0x60, 0x5, 0x7f, 0x6, 0x12, 
+	0x1f, 0xc5, 0x22, 0x8f, 0x37, 0x12, 0x1f, 0x5c, 0x75, 0x3d, 0x3, 0x12, 0x1a, 0x5c, 0x7d, 0xc, 
+	0xaf, 0x37, 0x12, 0x19, 0x49, 0xaf, 0x37, 0x2, 0x1f, 0x65, 0xe4, 0xff, 0x12, 0x1d, 0xa8, 0x7f, 
+	0x5, 0x12, 0x1a, 0x29, 0x12, 0x1a, 0xf2, 0x8f, 0x28, 0x7f, 0x1, 0x12, 0x1d, 0xa8, 0xaf, 0x28, 
+	0x22, 0xe4, 0xf5, 0x23, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e, 0x80, 0x5, 0x22, 0xe5, 0x22, 0xc3, 
+	0x94, 0x7, 0x40, 0xf2, 0xaf, 0x23, 0x22, 0xe4, 0xf5, 0xff, 0xf5, 0xfe, 0xf5, 0xfd, 0x75, 0xfc, 
+	0x1, 0x75, 0xf9, 0xe0, 0x75, 0xfb, 0x14, 0xd2, 0xf8, 0x80, 0xfe, 0xe5, 0x8, 0xfd, 0xe5, 0x9, 
+	0xfb, 0x7f, 0x80, 0x12, 0x9, 0x28, 0x5, 0x9, 0xe5, 0x9, 0x70, 0x2, 0x5, 0x8, 0x22, 0xe4, 
+	0xfb, 0x7d, 0x4, 0x7f, 0x80, 0x12, 0x9, 0x3c, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 
+	0x2, 0x9, 0x43, 0x8f, 0x32, 0xaf, 0x32, 0x15, 0x32, 0xef, 0xd3, 0x94, 00, 0x40, 0x7, 0x7f, 
+	0x20, 0x12, 0x1d, 0x84, 0x80, 0xef, 0x22, 0x8f, 0x51, 0x7b, 0x35, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 
+	0x9, 0x3c, 0xaf, 0x51, 0xe4, 0xfc, 0xfd, 0xfe, 0x2, 0x9, 0x43, 0x53, 0x89, 0xf, 0x43, 0x89, 
+	0x10, 0x75, 0x8b, 0x92, 0x75, 0x8d, 0xe6, 0xc2, 0xbb, 0xd2, 0xab, 0xd2, 0x8e, 0x22, 0xc2, 0x3, 
+	0xae, 0x7, 0x1f, 0xee, 0xd3, 0x94, 00, 0x40, 0x7, 0x30, 0x3, 0xfd, 0xc2, 0x3, 0x80, 0xf0, 
+	0x22, 0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x3c, 0x7f, 0x1, 0x12, 0x1f, 0x9a, 0x12, 
+	0x9, 0x43, 0x80, 0xfe, 0xc2, 0x6, 0x8f, 0x99, 0x7f, 0x2, 0x12, 0x1f, 0x85, 0x20, 0x6, 0x5, 
+	0x12, 0x1f, 0xbd, 0x50, 0xf8, 0x22, 0x8f, 0x28, 0x8c, 0x29, 0x8d, 0x2a, 0x12, 0x1b, 0xc3, 0xad, 
+	0x2a, 0xac, 0x29, 0xaf, 0x28, 0x2, 0x8, 0x5c, 0xef, 0x60, 0x6, 0xe5, 0x51, 0x44, 0x2, 0x80, 
+	0x4, 0xe5, 0x51, 0x54, 0xfd, 0xff, 0x12, 0x1d, 0x37, 0x22, 0xef, 0x60, 0x6, 0xe5, 0x51, 0x44, 
+	0x1, 0x80, 0x4, 0xe5, 0x51, 0x54, 0xfe, 0xff, 0x12, 0x1d, 0x37, 0x22, 0x7b, 0x35, 0xe4, 0xfd, 
+	0x7f, 0xe0, 0x12, 0x9, 0x28, 0xef, 0x54, 0x10, 0xc4, 0x54, 0xf, 0xff, 0x22, 0x5, 0xf, 0xe5, 
+	0xf, 0xc3, 0x94, 0x96, 0x40, 0x6, 0xe4, 0xf5, 0xf, 0x12, 0x1f, 0x8c, 0x22, 0x74, 0x80, 0x25, 
+	0x1f, 0xf8, 0xe6, 0xff, 0xe5, 0x1f, 0x4, 0x54, 0x1f, 0xf5, 0x1f, 0x22, 0x8e, 0x29, 0x8f, 0x2a, 
+	0xe5, 0x29, 0xff, 0x12, 0x1b, 0xf9, 0xaf, 0x2a, 0x2, 0x1b, 0xf9, 0x5, 0x4d, 0xe5, 0x4d, 0xc3, 
+	0x94, 0xa, 0x40, 0x5, 0xe4, 0xf5, 0x4d, 0xd2, 0x9, 0x22, 0x75, 0x3d, 0x12, 0x75, 0x3e, 00, 
+	0x7b, 00, 0x7a, 0x12, 0xe4, 0xfd, 0x2, 0x19, 0x49, 0x4c, 0x75, 0x74, 0x20, 0x32, 0x2e, 0x32, 
+	0x39, 0x62, 0x5f, 0x61, 0x74, 0x68, 00, 00, 0xe4, 0xff, 0x12, 0x1d, 0xa8, 0x7f, 0x6, 0x12, 
+	0x1a, 0x29, 0x7f, 0x1, 0x2, 0x1d, 0xa8, 0xef, 0xc3, 0x94, 0xa, 0xef, 0x50, 0x4, 0x24, 0x30, 
+	0xff, 0x22, 0x24, 0x57, 0xff, 0x22, 0xad, 0x7, 0x75, 0x3c, 0x10, 0xe4, 0xf5, 0x3d, 0xfb, 0x7f, 
+	0x20, 0x2, 0x17, 0x6c, 0x7d, 0x25, 0x12, 0x18, 0x84, 0x7b, 00, 0x7a, 00, 0x79, 0x25, 0x2, 
+	0x17, 0x38, 0x45, 0x52, 0x41, 0x53, 0x45, 00, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 00, 
+	0xef, 0x90, 0x1e, 0x95, 0x93, 0xd3, 0x94, 0x1, 0x50, 0x2, 0x80, 0x1, 0xc3, 0x22, 00, 0x1, 
+	0x2, 0x3, 0x4, 0xff, 0x6, 00, 00, 00, 00, 00, 0xff, 0x1, 0x7d, 0x1, 0x12, 0x13, 
+	0xd, 0xef, 0x30, 0xe2, 0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0x8f, 0x3c, 0x8d, 0x3d, 0x7b, 0xe, 
+	0xe4, 0xfd, 0x7f, 0xa0, 0x2, 0x17, 0x6c, 0x8f, 0x3c, 0x8d, 0x3d, 0x7b, 0x10, 0xe4, 0xfd, 0x7f, 
+	0x40, 0x2, 0x17, 0x6c, 0xe5, 0x1e, 0x65, 0x1f, 0x60, 0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0xe5, 
+	0xaa, 0x54, 0x3, 0x60, 0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0x7f, 0x3, 0x7e, 00, 0x7d, 00, 
+	0x7c, 00, 0x2, 0x18, 0x59, 0xa8, 0x1a, 0xe6, 0xb4, 0x20, 0x4, 0x5, 0x1a, 0x80, 0xf6, 0x22, 
+	0x12, 0x1e, 0x80, 0x50, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0xc2, 0x2, 0x8f, 0xe, 0xd2, 
+	0x2, 0x20, 0x2, 0xfd, 0x22, 0xeb, 0x75, 0xf0, 0x20, 0xa4, 0x4d, 0xac, 0xf0, 0xfd, 0x22, 0x7f, 
+	0x30, 0x12, 0x1d, 0x84, 0x7f, 0x78, 0x2, 0x1d, 0x84, 0x7f, 0xd, 0x12, 0x1d, 0x84, 0x7f, 0xa, 
+	0x2, 0x1d, 0x84, 0x75, 0xf0, 0xa, 0x84, 0xe5, 0xf0, 0x24, 0x30, 0xff, 0x22, 0x8f, 0x35, 0x12, 
+	0x17, 0xfe, 0xaf, 0x35, 0x2, 0x9, 0xf2, 0xd3, 0xe5, 0x26, 0x94, 00, 0xe5, 0x25, 0x94, 00, 
+	0x22, 0xef, 0x64, 0x6, 0x60, 0x3, 0x12, 0x1c, 0xa3, 0x22, 0x7b, 0x1, 0x7a, 00, 0x7d, 0x1f, 
+	0x2, 0x17, 0xce, 0x7b, 0xb5, 0x7a, 0x52, 0x7d, 0x1f, 0x2, 0x17, 0xce, 0x7b, 0x30, 0x7a, 0x2a, 
+	0x7d, 0x1f, 0x2, 0x17, 0xce, 0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0x2, 0x17, 0xce, 0x7d, 0x32, 0x12, 
+	0x18, 0x84, 0xaf, 0x37, 0x22, 0xe5, 0x51, 0x44, 0x4, 0xff, 0x2, 0x1d, 0x37, 0xe5, 0x51, 0x54, 
+	0xfb, 0xff, 0x2, 0x1d, 0x37, 0xc2, 0x2, 0x8f, 0xe, 0xd2, 0x2, 0x22, 0x7f, 0x3, 0x7e, 00, 
+	0x2, 0x16, 0x65, 0x7f, 0x5, 0x7e, 00, 0x2, 0x16, 0x65, 0x7e, 00, 0x7d, 00, 0x7c, 00, 
+	0x22, 0x7b, 00, 0x7a, 00, 0x79, 0x4e, 0x22, 0xef, 0x90, 0x1e, 0x95, 0x93, 0xff, 0x22, 0xef, 
+	0x90, 0x1e, 0x8e, 0x93, 0xff, 0x22, 00, 0x1, 0x2, 0x3, 0x4, 0x6, 0x5, 0xa2, 0x2, 0xb3, 
+	0x22, 0x12, 0x11, 0x2d, 0x22, 0xd2, 0x7, 0x22, 0x2, 0x1d, 0x84, 0x2, 0x15, 0x7e, 0x22, 0x22, 
+};
diff --git a/board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v3.c b/board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v3.c
new file mode 100644
index 0000000000..1ea408ba42
--- /dev/null
+++ b/board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v3.c
@@ -0,0 +1,521 @@
+/*
+ * Microcode for VSC 7385, with
+ *	- 3 delay in RGMII port
+ *	- Latest phy settings
+ *	- Flush port entries when link goes down
+ *	  (to avoid ~30sec delay when we move between
+ *	  different ports of the switch)
+ */
+static unsigned char g5_Plus1_2_31_unmanaged_Atheros_v3 [] = {
+	0x2, 0xd, 0x57, 0x8f, 0x2e, 0x12, 0x1f, 0xb9, 0x12, 0xb, 0x45, 0x50, 0x3, 0x7f, 0x1, 0x22,
+	0xe5, 0x2e, 0xb4, 0x6, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x2, 0x1a, 0x22, 0x7e, 00,
+	0x2, 0xb, 0x78, 0x2, 0x15, 0xb6, 0x78, 0x5a, 0x12, 0x4, 0xee, 0xad, 0x7, 0x22, 0x78, 0x5e,
+	0x12, 0x4, 0xee, 0xab, 0x7, 0x22, 0x78, 0x56, 0x12, 0x4, 0xee, 0x78, 0x5, 0x2, 0x4, 0xdb,
+	00, 0x1, 0xc1, 00, 00, 00, 0x8f, 0x23, 0x8d, 0x24, 0x8b, 0x25, 0xe5, 0x25, 0x7b, 0xff,
+	0x60, 0x6, 0x7a, 0x1e, 0x79, 0x27, 0x80, 0x4, 0x7a, 0x1e, 0x79, 0x26, 0x12, 0x1a, 0x47, 0x7b,
+	0xff, 0x7a, 0x1e, 0x79, 0x28, 0x12, 0x1a, 0x47, 0xe5, 0x23, 0xc3, 0x94, 0x7, 0x40, 0x8, 0xe4,
+	0xf5, 0x23, 0x75, 0x26, 0x6, 0x80, 0x11, 0xe5, 0x25, 0x60, 0xa, 0x53, 0x23, 0xfe, 0xe5, 0x23,
+	0x4, 0xf5, 0x26, 0x80, 0x3, 0x85, 0x23, 0x26, 0xe5, 0x24, 0xb4, 0xff, 0x5, 0x75, 0x28, 0x7,
+	0x80, 0xf, 0xaf, 0x24, 0x74, 0x1, 0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf5,
+	0x28, 0x7b, 0xd, 0x12, 0x3, 0x13, 0x7b, 0xe, 0x12, 0x3, 0x13, 0x12, 0x3, 0x4e, 0x12, 0x1b,
+	0x96, 0x12, 0xa, 0xc9, 0xe5, 0x23, 0x90, 0x1f, 0xce, 0x93, 0xf5, 0x2f, 0xe5, 0x25, 0x60, 0x1e,
+	0xe5, 0x23, 0x24, 0x1, 0xff, 0xe4, 0x33, 0xfe, 0xc3, 0xef, 0x94, 0x7, 0xee, 0x64, 0x80, 0x94,
+	0x80, 0x50, 0x8, 0xe5, 0x23, 0xa3, 0x93, 0xf5, 0x30, 0x80, 0x3, 0x75, 0x30, 0x7, 0x7e, 00,
+	0x7f, 0x2, 0x7d, 0xff, 0x7b, 00, 0x7a, 00, 0x79, 0x29, 0x12, 0x5, 0x16, 0x75, 0x27, 0x2,
+	0xe5, 0x27, 0xf4, 0x70, 0x3, 0x2, 0x2, 0x50, 0x74, 0x1, 0x7e, 00, 0xa8, 0x27, 0x8, 0x80,
+	0x5, 0xc3, 0x33, 0xce, 0x33, 0xce, 0xd8, 0xf9, 0xff, 0xef, 0x55, 0x28, 0x70, 0x3, 0x2, 0x2,
+	0x4b, 0xe5, 0x27, 0xd3, 0x94, 0x2, 0x40, 0x3, 0x2, 0x1, 0xec, 0xaf, 0x2f, 0x12, 0x1e, 0xa2,
+	0x40, 0x3, 0x2, 0x2, 0x4b, 0xaf, 0x30, 0x12, 0x1e, 0xa2, 0x50, 0x7, 0xe5, 0x30, 0xc3, 0x94,
+	0x7, 0x40, 0x7, 0xe5, 0x25, 0x60, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x2f, 0x64, 0x6, 0x70, 0x1b,
+	0xe5, 0x27, 0x70, 0x9, 0x12, 0x3, 0x45, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x27, 0xb4,
+	0x1, 0x9, 0x12, 0x3, 0x45, 0x20, 0xe6, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x25, 0x60, 0x67, 0xe5,
+	0x27, 0xc3, 0x94, 0x2, 0x50, 0x6f, 0xe5, 0x30, 0x64, 0x6, 0x70, 0x25, 0xe5, 0x27, 0x70, 0xe,
+	0x7d, 0x1, 0xaf, 0x30, 0x12, 0x13, 0x79, 0xee, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x27,
+	0xb4, 0x1, 0xe, 0x7d, 0x1, 0xaf, 0x30, 0x12, 0x13, 0x79, 0xee, 0x20, 0xe6, 0x3, 0x2, 0x2,
+	0x4b, 0x12, 0x3, 0x58, 0xe4, 0xf5, 0x2d, 0xf5, 0x2e, 0xaf, 0x2f, 0x12, 0x1e, 0xbe, 0x50, 0x7,
+	0xaf, 0x30, 0x12, 0x1e, 0xbe, 0x40, 0x2e, 0xe5, 0x2e, 0xc3, 0x94, 0x3, 0x50, 0x27, 0x7f, 0xa,
+	0x12, 0x1d, 0x8d, 0x5, 0x2d, 0xe5, 0x2d, 0xc3, 0x94, 0xfa, 0x40, 0xdd, 0x12, 0x3, 0x58, 0x5,
+	0x2e, 0xe4, 0xf5, 0x2d, 0x80, 0xd3, 0xe5, 0x27, 0x44, 0x90, 0xfd, 0xaf, 0x2f, 0x12, 0x14, 0x22,
+	0x7f, 0xa, 0x12, 0x1f, 0x1d, 0xad, 0x27, 0xaf, 0x2f, 0x12, 0x11, 0x2c, 0xe5, 0x25, 0x60, 0x7,
+	0xad, 0x27, 0xaf, 0x30, 0x12, 0x11, 0x2c, 0x7f, 0x5, 0x12, 0x1f, 0x1d, 0xe5, 0x25, 0x60, 0x41,
+	0xad, 0x30, 0x12, 0x3, 0x36, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0xad, 0x80, 0x2,
+	0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x29, 0x4f, 0xf5, 0x29, 0xad, 0x2f, 0xaf, 0x30, 0x12, 0xf,
+	0xed, 0xe5, 0x27, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x6, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc,
+	0x12, 0x1b, 0xad, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0x80,
+	0x1a, 0xad, 0x2f, 0x12, 0x3, 0x36, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0xad, 0x80,
+	0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x29, 0x4f, 0xf5, 0x29, 0x15, 0x27, 0x2, 00, 0xf0,
+	0xe4, 0xf5, 0x2c, 0xe5, 0x25, 0x70, 0x7, 0xe5, 0x2c, 0xc3, 0x94, 0x1, 0x40, 0xe, 0xe5, 0x25,
+	0x70, 0x3, 0x2, 0x2, 0xe5, 0xe5, 0x2c, 0xc3, 0x94, 0x2, 0x50, 0x79, 0x12, 0x1f, 0x3b, 0xaf,
+	0x23, 0x12, 0x1a, 0xf3, 0xe4, 0xf5, 0x27, 0xe5, 0x27, 0x25, 0xe0, 0xff, 0x74, 0x29, 0x25, 0x2c,
+	0xf8, 0xe6, 0xfe, 0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x13, 0xd8, 0xfc, 0x54, 0x3, 0xf5, 0x2b,
+	0x64, 0x3, 0x60, 0x1f, 0xe5, 0x2b, 0x7b, 0xff, 0x70, 0x9, 0x7a, 0x1e, 0x79, 0x29, 0x12, 0x1a,
+	0x47, 0x80, 0x10, 0x7a, 0x1e, 0x79, 0x2a, 0x12, 0x1a, 0x47, 0xaf, 0x2b, 0xe4, 0xfc, 0xfd, 0xfe,
+	0x12, 0xf, 0x77, 0x5, 0x27, 0xe5, 0x27, 0xc3, 0x94, 0x3, 0x40, 0xbb, 0xe5, 0x2c, 0x70, 0xb,
+	0xaf, 0x2f, 0x12, 0x1e, 0xa2, 0x50, 0x10, 0xaf, 0x2f, 0x80, 0x9, 0xaf, 0x30, 0x12, 0x1e, 0xa2,
+	0x50, 0x5, 0xaf, 0x30, 0x12, 0x1f, 0x4f, 0x5, 0x23, 0xe5, 0x23, 0xd3, 0x95, 0x26, 0x50, 0x5,
+	0x5, 0x2c, 0x2, 0x2, 0x53, 0xe5, 0x23, 0xd3, 0x95, 0x26, 0x50, 0x3, 0x2, 00, 0xb4, 0x7b,
+	0xff, 0x7a, 0x1e, 0x79, 0x2b, 0x12, 0x1a, 0x47, 0x7b, 0xd, 0x12, 0x3, 0x26, 0x12, 0xa, 0xc9,
+	0x7b, 0xe, 0x12, 0x3, 0x26, 0x12, 0xa, 0xc9, 0x12, 0x3, 0x4e, 0x7f, 0x5f, 0x12, 0x1b, 0x98,
+	0x2, 0xa, 0xc9, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2, 0x7f, 00, 0x7e, 00, 0x7d, 00,
+	0x7c, 00, 0x12, 0xa, 0xc9, 0x22, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2, 0x7f, 0x5f, 0x7e,
+	00, 0x7d, 00, 0x7c, 00, 0x22, 0xaf, 0x2f, 0x12, 0xf, 0xed, 0xe5, 0x27, 0x25, 0xe0, 0xfe,
+	0xef, 0xa8, 0x6, 0x8, 0x22, 0x7d, 0x1, 0xaf, 0x2f, 0x12, 0x13, 0x79, 0xee, 0x22, 0x7b, 0xf,
+	0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2, 0x22, 0xab, 0x27, 0xad, 0x30, 0xaf, 0x2f, 0x12, 0x19,
+	0x3d, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x2, 0xe7, 0x22, 0xbb,
+	0xfe, 0x2, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82,
+	0x8a, 0x83, 0xf0, 0x22, 0x50, 0x2, 0xf7, 0x22, 0xbb, 0xfe, 0x1, 0xf3, 0x22, 0xe8, 0x8f, 0xf0,
+	0xa4, 0xcc, 0x8b, 0xf0, 0xa4, 0x2c, 0xfc, 0xe9, 0x8e, 0xf0, 0xa4, 0x2c, 0xfc, 0x8a, 0xf0, 0xed,
+	0xa4, 0x2c, 0xfc, 0xea, 0x8e, 0xf0, 0xa4, 0xcd, 0xa8, 0xf0, 0x8b, 0xf0, 0xa4, 0x2d, 0xcc, 0x38,
+	0x25, 0xf0, 0xfd, 0xe9, 0x8f, 0xf0, 0xa4, 0x2c, 0xcd, 0x35, 0xf0, 0xfc, 0xeb, 0x8e, 0xf0, 0xa4,
+	0xfe, 0xa9, 0xf0, 0xeb, 0x8f, 0xf0, 0xa4, 0xcf, 0xc5, 0xf0, 0x2e, 0xcd, 0x39, 0xfe, 0xe4, 0x3c,
+	0xfc, 0xea, 0xa4, 0x2d, 0xce, 0x35, 0xf0, 0xfd, 0xe4, 0x3c, 0xfc, 0x22, 0x75, 0xf0, 0x8, 0x75,
+	0x82, 00, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xcd, 0x33, 0xcd, 0xcc, 0x33, 0xcc, 0xc5, 0x82,
+	0x33, 0xc5, 0x82, 0x9b, 0xed, 0x9a, 0xec, 0x99, 0xe5, 0x82, 0x98, 0x40, 0xc, 0xf5, 0x82, 0xee,
+	0x9b, 0xfe, 0xed, 0x9a, 0xfd, 0xec, 0x99, 0xfc, 0xf, 0xd5, 0xf0, 0xd6, 0xe4, 0xce, 0xfb, 0xe4,
+	0xcd, 0xfa, 0xe4, 0xcc, 0xf9, 0xa8, 0x82, 0x22, 0xb8, 00, 0xc1, 0xb9, 00, 0x59, 0xba, 00,
+	0x2d, 0xec, 0x8b, 0xf0, 0x84, 0xcf, 0xce, 0xcd, 0xfc, 0xe5, 0xf0, 0xcb, 0xf9, 0x78, 0x18, 0xef,
+	0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xeb, 0x33, 0xfb, 0x10, 0xd7,
+	0x3, 0x99, 0x40, 0x4, 0xeb, 0x99, 0xfb, 0xf, 0xd8, 0xe5, 0xe4, 0xf9, 0xfa, 0x22, 0x78, 0x18,
+	0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xc9, 0x33, 0xc9, 0x10,
+	0xd7, 0x5, 0x9b, 0xe9, 0x9a, 0x40, 0x7, 0xec, 0x9b, 0xfc, 0xe9, 0x9a, 0xf9, 0xf, 0xd8, 0xe0,
+	0xe4, 0xc9, 0xfa, 0xe4, 0xcc, 0xfb, 0x22, 0x75, 0xf0, 0x10, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe,
+	0xed, 0x33, 0xfd, 0xcc, 0x33, 0xcc, 0xc8, 0x33, 0xc8, 0x10, 0xd7, 0x7, 0x9b, 0xec, 0x9a, 0xe8,
+	0x99, 0x40, 0xa, 0xed, 0x9b, 0xfd, 0xec, 0x9a, 0xfc, 0xe8, 0x99, 0xf8, 0xf, 0xd5, 0xf0, 0xda,
+	0xe4, 0xcd, 0xfb, 0xe4, 0xcc, 0xfa, 0xe4, 0xc8, 0xf9, 0x22, 0xcf, 0xf4, 0xcf, 0xce, 0xf4, 0xce,
+	0xcd, 0xf4, 0xcd, 0xcc, 0xf4, 0xcc, 0x22, 0xeb, 0x9f, 0xf5, 0xf0, 0xea, 0x9e, 0x42, 0xf0, 0xe9,
+	0x9d, 0x42, 0xf0, 0xe8, 0x9c, 0x45, 0xf0, 0x22, 0xe8, 0x60, 0xf, 0xec, 0xc3, 0x13, 0xfc, 0xed,
+	0x13, 0xfd, 0xee, 0x13, 0xfe, 0xef, 0x13, 0xff, 0xd8, 0xf1, 0x22, 0xe8, 0x60, 0xf, 0xef, 0xc3,
+	0x33, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xd8, 0xf1, 0x22, 0xe6, 0xfc,
+	0x8, 0xe6, 0xfd, 0x8, 0xe6, 0xfe, 0x8, 0xe6, 0xff, 0x22, 0xe4, 0x93, 0xfc, 0x74, 0x1, 0x93,
+	0xfd, 0x74, 0x2, 0x93, 0xfe, 0x74, 0x3, 0x93, 0xff, 0x22, 0xec, 0xf6, 0x8, 0xed, 0xf6, 0x8,
+	0xee, 0xf6, 0x8, 0xef, 0xf6, 0x22, 0xef, 0x4e, 0x60, 0x12, 0xef, 0x60, 0x1, 0xe, 0xed, 0xbb,
+	0x1, 0xb, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0xa3, 0xdf, 0xfc, 0xde, 0xfa, 0x22, 0x89, 0xf0, 0x50,
+	0x7, 0xf7, 0x9, 0xdf, 0xfc, 0xa9, 0xf0, 0x22, 0xbb, 0xfe, 0xfc, 0xf3, 0x9, 0xdf, 0xfc, 0xa9,
+	0xf0, 0x22, 0x8f, 0x36, 0x12, 0xc, 0x1b, 0xaf, 0x36, 0x12, 0x13, 0x1d, 0x7d, 0x3, 0xaf, 0x36,
+	0x12, 0x13, 0x79, 0xef, 0x54, 0xf, 0xf5, 0x37, 0x70, 0x7b, 0x12, 0x6, 0x67, 0x12, 0x1f, 0x6b,
+	0x7b, 0x92, 0x7a, 00, 0x7d, 0x12, 0xaf, 0x36, 0x12, 0x17, 0xdf, 0x7b, 0x3, 0x7a, 0x28, 0x12,
+	0x6, 0xc4, 0x7b, 0xfa, 0x7a, 0x87, 0x12, 0x6, 0x8f, 0xaf, 0x36, 0x12, 0x1f, 0x7d, 0x12, 0x6,
+	0x67, 0x12, 0x6, 0xac, 0x7b, 0x89, 0x7a, 0x6, 0x12, 0x6, 0xc4, 0x7b, 0x92, 0x7a, 0x8f, 0x7d,
+	0x10, 0x12, 0x6, 0xcc, 0x12, 0x6, 0xac, 0x7b, 0x35, 0x7a, 0xe, 0x7d, 0x11, 0xaf, 0x36, 0x12,
+	0x17, 0xdf, 0x7b, 0x86, 0x7a, 0x97, 0x12, 0x6, 0x8f, 0x7b, 0x80, 0x7a, 0xff, 0x7d, 0x17, 0xaf,
+	0x36, 0x12, 0x17, 0xdf, 0xe4, 0xfb, 0xfa, 0x7d, 0x17, 0x12, 0x6, 0xcc, 0x12, 0x1f, 0x74, 0x75,
+	0x3d, 0x80, 0x75, 0x3e, 00, 0x7b, 00, 0x7a, 0x80, 0x7d, 0x2, 0xaf, 0x36, 0x12, 0x19, 0xb0,
+	0xaf, 0x36, 0x12, 0x1f, 0x7d, 0xaf, 0x36, 0x12, 0x1f, 0x7d, 0x75, 0x3d, 00, 0x75, 0x3e, 0x40,
+	0x7b, 0x40, 0x7d, 0x12, 0x12, 0x6, 0xba, 0x12, 0x1f, 0x74, 0x12, 0x6, 0xd4, 0x12, 0x6, 0xd4,
+	0xaf, 0x36, 0x12, 0x1f, 0x7d, 0xe5, 0x37, 0xaf, 0x36, 0x70, 0x1a, 0x12, 0x1f, 0x74, 0x75, 0x3d,
+	0x60, 0x75, 0x3e, 00, 0x7a, 0x40, 0x12, 0x6, 0x80, 0x75, 0x3d, 0xe0, 0x75, 0x3e, 0xe, 0x7b,
+	0xe, 0x7a, 0xa0, 0x80, 0x4a, 0x12, 0x1f, 0x74, 0x75, 0x3d, 0xf, 0x75, 0x3e, 0xc0, 0x7b, 0x40,
+	0x7a, 0x2, 0x7d, 0x16, 0xaf, 0x36, 0x12, 0x19, 0xb0, 0x75, 0x3d, 0x60, 0x75, 0x3e, 00, 0x7b,
+	00, 0x7a, 0x40, 0x7d, 0x14, 0xaf, 0x36, 0x12, 0x19, 0xb0, 0x75, 0x3d, 00, 0x75, 0x3e, 0x38,
+	0x7b, 0x30, 0x7d, 0x18, 0x12, 0x6, 0xba, 0x12, 0x1f, 0x62, 0x75, 0x3d, 0xe0, 0x75, 0x3e, 00,
+	0x7a, 0x20, 0x12, 0x6, 0x80, 0x75, 0x3d, 0xe0, 0x75, 0x3e, 0xe, 0x7b, 0x2, 0x7a, 0x80, 0x7d,
+	0x18, 0xaf, 0x36, 0x12, 0x19, 0xb0, 0x22, 0xaf, 0x36, 0x12, 0x1f, 0x74, 0x75, 0x3d, 0x2, 0x75,
+	0x3e, 00, 0x7b, 00, 0x7a, 0x2, 0x7d, 0x8, 0xaf, 0x36, 0x12, 0x19, 0xb0, 0xaf, 0x36, 0x22,
+	0x7b, 00, 0x7d, 0x14, 0xaf, 0x36, 0x12, 0x19, 0xb0, 0xaf, 0x36, 0x12, 0x1f, 0x7d, 0x22, 0x7d,
+	0x10, 0xaf, 0x36, 0x12, 0x17, 0xdf, 0xaf, 0x36, 0x12, 0x1f, 0x74, 0x75, 0x3d, 0x2, 0x75, 0x3e,
+	00, 0xe4, 0xfb, 0xfa, 0x7d, 0x8, 0xaf, 0x36, 0x12, 0x19, 0xb0, 0x22, 0x12, 0x1f, 0x6b, 0xe4,
+	0xfb, 0xfa, 0x7d, 0x12, 0xaf, 0x36, 0x12, 0x17, 0xdf, 0x22, 0x7a, 00, 0xaf, 0x36, 0x12, 0x19,
+	0xb0, 0xaf, 0x36, 0x22, 0x7d, 0x11, 0xaf, 0x36, 0x12, 0x17, 0xdf, 0x22, 0xaf, 0x36, 0x12, 0x17,
+	0xdf, 0xaf, 0x36, 0x22, 0x7b, 0x82, 0x7a, 0xf0, 0x7d, 0x3, 0xaf, 0x36, 0x12, 0x17, 0xdf, 0x22,
+	0xa8, 0x1a, 0xe6, 0xf5, 0x23, 0x64, 0x20, 0x60, 0x9, 0xe5, 0x23, 0x64, 0xd, 0x60, 0x3, 0x7f,
+	0x1, 0x22, 0xe4, 0xf5, 0x19, 0xfe, 0x7f, 0x10, 0x7d, 0xff, 0xfb, 0x7a, 00, 0x79, 0x56, 0x12,
+	0x5, 0x16, 0x12, 0x1f, 0x7, 0x75, 0x24, 0xa, 0xe4, 0xf5, 0x26, 0xa8, 0x1a, 0xe6, 0x64, 0x30,
+	0x70, 0x1b, 0xe8, 0x4, 0xf8, 0xe6, 0xff, 0x12, 0x1c, 0x8a, 0xbf, 0x58, 0x10, 0x75, 0x24, 0x10,
+	0x5, 0x1a, 0x5, 0x1a, 0xa8, 0x1a, 0xe6, 0xb4, 0x20, 0x3, 0x7f, 0x1, 0x22, 0xa8, 0x1a, 0xe6,
+	0xf5, 0x23, 0x64, 0x20, 0x60, 0x6, 0xe5, 0x23, 0x64, 0xd, 0x70, 0x7c, 0xe5, 0x26, 0xd3, 0x94,
+	00, 0x40, 0x6a, 0xe4, 0xf5, 0x34, 0xf5, 0x33, 0xf5, 0x32, 0xf5, 0x31, 0xf5, 0x25, 0xe5, 0x25,
+	0xc3, 0x95, 0x26, 0x50, 0x3a, 0xaf, 0x24, 0xe4, 0xfc, 0xfd, 0xfe, 0xab, 0x34, 0xaa, 0x33, 0xa9,
+	0x32, 0xa8, 0x31, 0x12, 0x3, 0x8d, 0xc0, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7, 0x74, 0x27,
+	0x25, 0x25, 0xf8, 0xe6, 0xff, 0xe4, 0xfc, 0xfd, 0xfe, 0xd0, 00, 0xeb, 0x2f, 0xf5, 0x34, 0xee,
+	0x3a, 0xf5, 0x33, 0xed, 0x39, 0xf5, 0x32, 0xec, 0x38, 0xf5, 0x31, 0x5, 0x25, 0x80, 0xbf, 0xe5,
+	0x19, 0xc3, 0x94, 0x4, 0x50, 0x17, 0xaf, 0x34, 0xae, 0x33, 0xad, 0x32, 0xac, 0x31, 0xab, 0x19,
+	0x5, 0x19, 0xeb, 0x25, 0xe0, 0x25, 0xe0, 0x24, 0x56, 0xf8, 0x12, 0x5, 0xa, 0xe5, 0x23, 0x64,
+	0xd, 0x60, 0x3, 0x2, 0x7, 0x2, 0xff, 0x22, 0xaf, 0x23, 0x12, 0x19, 0xfc, 0x8f, 0x23, 0xe5,
+	0x23, 0xf4, 0x60, 0x1d, 0xe5, 0x26, 0xc3, 0x94, 0xa, 0x50, 0x19, 0xaf, 0x26, 0x5, 0x26, 0x74,
+	0x27, 0x2f, 0xf8, 0xa6, 0x23, 0xe5, 0x23, 0xd3, 0x94, 0x9, 0x40, 0x8, 0x75, 0x24, 0x10, 0x80,
+	0x3, 0x7f, 0x1, 0x22, 0x5, 0x1a, 0x2, 0x7, 0x2d, 0xa8, 0x1a, 0xe6, 0xf5, 0x22, 0x5, 0x1a,
+	0x12, 0x6, 0xe0, 0xef, 0x60, 0x3, 0x7f, 0x1, 0x22, 0xaf, 0x22, 0x12, 0x1c, 0x8a, 0xef, 0x24,
+	0xb7, 0x60, 0x64, 0x24, 0xfa, 0x60, 0x7a, 0x24, 0xfd, 0x60, 0x17, 0x24, 0xfe, 0x70, 0x3, 0x2,
+	0x8, 0xab, 0x24, 0xfd, 0x60, 0x28, 0x4, 0x60, 0x3, 0x2, 0x8, 0xe6, 0x12, 0x11, 0x91, 0x2,
+	0x8, 0xe9, 0x12, 0x1f, 0x31, 0x12, 00, 0x36, 0xc0, 0x7, 0x12, 00, 0x26, 0xc0, 0x5, 0x12,
+	00, 0x2e, 0xd0, 0x5, 0xd0, 0x7, 0x12, 0xa, 0xae, 0x12, 0x1c, 0x58, 0x80, 0x3e, 0xe5, 0x19,
+	0xc3, 0x94, 0x4, 0x50, 0x3, 0x2, 0x8, 0xe9, 0x12, 00, 0x36, 0xc0, 0x7, 0x12, 00, 0x26,
+	0xc0, 0x5, 0x12, 00, 0x2e, 0xd0, 0x5, 0xd0, 0x7, 0x12, 0xa, 0xc2, 0x78, 0x62, 0x12, 0x4,
+	0xee, 0x12, 0xa, 0xc9, 0x2, 0x8, 0xe9, 0x12, 0x1f, 0x31, 0x78, 0x56, 0x12, 0x4, 0xee, 0xc0,
+	0x7, 0x12, 00, 0x26, 0xd0, 0x7, 0x12, 0x13, 0x79, 0x12, 0x1e, 0x3b, 0x12, 0x1f, 0x3b, 0x80,
+	0x68, 0xe5, 0x19, 0xc3, 0x94, 0x3, 0x40, 0x61, 0x78, 0x56, 0x12, 0x4, 0xee, 0xc0, 0x7, 0x12,
+	00, 0x26, 0xc0, 0x5, 0x12, 00, 0x2e, 0xaa, 0x6, 0x78, 0x62, 0x12, 0x4, 0xee, 0x8e, 0x3d,
+	0x8f, 0x3e, 0xd0, 0x5, 0xd0, 0x7, 0x12, 0x19, 0xb0, 0x80, 0x3e, 0x78, 0x56, 0x12, 0x4, 0xee,
+	0xef, 0x24, 0xfe, 0x60, 0x17, 0x4, 0x70, 0x2b, 0x78, 0x5a, 0x12, 0x4, 0xee, 0xc0, 0x7, 0x78,
+	0x5e, 0x12, 0x4, 0xee, 0xad, 0x7, 0xd0, 0x7, 0xe4, 0xfb, 0x80, 0x12, 0x78, 0x5a, 0x12, 0x4,
+	0xee, 0xc0, 0x7, 0x78, 0x5e, 0x12, 0x4, 0xee, 0xad, 0x7, 0xd0, 0x7, 0x7b, 0x1, 0x12, 00,
+	0x46, 0x80, 0x6, 0x7f, 0x1, 0x22, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x8f, 0x2a, 0x7f, 0x1,
+	0xed, 0x54, 0x30, 0xfe, 0xbe, 0x30, 0x4, 0x7e, 0x1, 0x80, 0x2, 0x7e, 00, 0xed, 0x54, 0x3,
+	0xfc, 0xbc, 0x2, 0x4, 0x7c, 0x1, 0x80, 0x2, 0x7c, 00, 0x8c, 0x2c, 0xed, 0x20, 0xe4, 0x7,
+	0xef, 0x60, 0x4, 0x7d, 0x1, 0x80, 0x2, 0x7d, 00, 0xef, 0x60, 0x3, 0xee, 0x70, 0x3, 0xed,
+	0x60, 0x4, 0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x8f, 0x2b, 0x7d, 0x30, 0xaf, 0x2a, 0x12, 0x18,
+	0xc3, 0x7b, 0x8, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0xa, 0xc2, 0xe5, 0x31, 0xfe, 0xe5, 0x32, 0xff,
+	0xad, 0x30, 0x7c, 00, 0x12, 0xa, 0xdf, 0x12, 0xa, 0xc9, 0x7b, 0xc, 0xad, 0x2a, 0x7f, 0x20,
+	0x12, 0xa, 0xc2, 0xe5, 0x34, 0xfe, 0xe5, 0x35, 0xff, 0xad, 0x33, 0x7c, 00, 0x12, 0xa, 0xdf,
+	0x12, 0xa, 0xc9, 0xe5, 0x2b, 0x60, 0x1e, 0x75, 0x2d, 0x17, 0x75, 0x2e, 0xc7, 0x12, 0x9, 0xd8,
+	0x7f, 0xff, 0x7e, 00, 0x7d, 0x3, 0x7c, 00, 0x12, 0xa, 0xc9, 0x85, 0x2a, 0x3b, 0xe4, 0xf5,
+	0x3c, 0x7b, 0x12, 0x80, 0x1d, 0x75, 0x2d, 0x17, 0x75, 0x2e, 0xaf, 0x12, 0x9, 0xd8, 0x7f, 00,
+	0x7e, 00, 0x7d, 00, 0x7c, 00, 0x12, 0xa, 0xc9, 0x85, 0x2a, 0x3b, 0x75, 0x3c, 0x1, 0x7b,
+	0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x12, 0x17, 0x7d, 0xe4, 0xf5, 0x2f, 0xe5, 0x2f, 0x24, 0xde, 0xfb,
+	0xad, 0x2a, 0x7f, 0x20, 0x12, 0xa, 0xc2, 0x85, 0x2e, 0x82, 0x85, 0x2d, 0x83, 0x12, 0x4, 0xfa,
+	0x12, 0xa, 0xc9, 0x74, 0x4, 0x25, 0x2e, 0xf5, 0x2e, 0xe4, 0x35, 0x2d, 0xf5, 0x2d, 0x5, 0x2f,
+	0xe5, 0x2f, 0xc3, 0x94, 0x6, 0x40, 0xd4, 0x22, 0x7b, 0x4, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0xa,
+	0xc2, 0x22, 0x8f, 0x2b, 0x8c, 0x2c, 0x8d, 0x2d, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0xa, 0xf5,
+	0x31, 0xf5, 0x30, 0xf5, 0x2f, 0xf5, 0x2e, 0x80, 0x12, 0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf, 0x2b,
+	0x12, 0x12, 0x5b, 0x8f, 0x31, 0x8e, 0x30, 0x8d, 0x2f, 0x8c, 0x2e, 0x12, 0xa, 0xa4, 0xe5, 0x31,
+	0x54, 0xf8, 0xff, 0xe5, 0x30, 0xfe, 0xe5, 0x2f, 0xfd, 0xe5, 0x2e, 0xfc, 0xef, 0x44, 0x31, 0xff,
+	0xec, 0x44, 0x20, 0xfc, 0x12, 0xa, 0xc9, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0x23, 0xfd, 0xaf,
+	0x2b, 0x12, 0x1e, 0xd9, 0x12, 0xa, 0xa4, 0x7f, 0x30, 0x7e, 00, 0x7d, 00, 0x7c, 0x20, 0x12,
+	0xa, 0xc9, 0x85, 0x2b, 0x3b, 0x75, 0x3c, 0x1, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x2, 0x17,
+	0x7d, 0xaf, 0x2b, 0x12, 0x1f, 0x85, 0xe4, 0xfc, 0xfd, 0xfe, 0x78, 0x13, 0x12, 0x4, 0xdb, 0xec,
+	0x44, 0x8, 0xfc, 0xe5, 0x31, 0x4f, 0xf5, 0x31, 0xe5, 0x30, 0x4e, 0xf5, 0x30, 0xe5, 0x2f, 0x4d,
+	0xf5, 0x2f, 0xe5, 0x2e, 0x4c, 0xf5, 0x2e, 0xe4, 0xfb, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0xa, 0xc2,
+	0xaf, 0x31, 0xae, 0x30, 0xad, 0x2f, 0xac, 0x2e, 0x12, 0xa, 0xc9, 0xaf, 0x2b, 0x12, 0x1b, 0xb4,
+	0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf, 0x2b, 0x12, 0x19, 0x64, 0xe5, 0x2b, 0xb4, 0x6, 0x4, 0xff,
+	0x12, 0x14, 0xb0, 0x22, 0xe4, 0xfb, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0xa, 0xc2, 0x22, 0xef, 0x2d,
+	0xf5, 0xf9, 0x8b, 0xfa, 0x30, 0xf8, 0xfd, 0xd2, 0xf8, 0xac, 0xff, 0xad, 0xfe, 0xae, 0xfd, 0xaf,
+	0xfc, 0x22, 0xef, 0x2d, 0xf5, 0x4b, 0x8b, 0x4c, 0x22, 0x8c, 0xff, 0x8d, 0xfe, 0x8e, 0xfd, 0x8f,
+	0xfc, 0xe5, 0x4b, 0xf5, 0xf9, 0xe5, 0x4c, 0xf5, 0xfb, 0x30, 0xf8, 0xfd, 0xd2, 0xf8, 0x22, 0x22,
+	0xec, 0xfe, 0xed, 0xff, 0x22, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0xe4, 0xfe, 0xcf,
+	0x90, 0xa, 0xe5, 0xb4, 0x8, 00, 0x50, 0x3, 0x93, 0xff, 0x22, 0x94, 0x8, 0x93, 0xfe, 0x22,
+	0xef, 0x90, 0xa, 0xe5, 0x93, 0xff, 0x22, 0x90, 0xa, 0xe5, 0xef, 0x93, 0xff, 0xf4, 0xfe, 0xbb,
+	0x1, 0xe, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x5e, 0xbd, 00, 0x2, 0x80, 0x1, 0x4f, 0xf0, 0x22,
+	0xbb, 00, 0xb, 0xe9, 0xf8, 0xe6, 0x5e, 0xbd, 00, 0x2, 0x80, 0x1, 0x4f, 0xf6, 0x22, 0x74,
+	0x1f, 0xc3, 0x9f, 0x13, 0x13, 0x13, 0x54, 0x3, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x7, 0x5f,
+	0xff, 0x12, 0xb, 0x7, 0x22, 0x90, 0xa, 0xe5, 0xef, 0x93, 0xff, 0xbb, 0x1, 0x7, 0x89, 0x82,
+	0x8a, 0x83, 0xe0, 0x80, 0x6, 0xbb, 00, 0x8, 0xe9, 0xf8, 0xe6, 0x5f, 0x60, 0x2, 0xd3, 0x22,
+	0xc3, 0x22, 0x74, 0x1f, 0xc3, 0x9f, 0x13, 0x13, 0x13, 0x54, 0x3, 0x29, 0xf9, 0xe4, 0x3a, 0xfa,
+	0x74, 0x7, 0x5f, 0xff, 0x12, 0xb, 0x45, 0x22, 0xab, 0x7, 0xaa, 0x6, 0xe4, 0xf5, 0x29, 0xf5,
+	0x28, 0xf5, 0x27, 0xf5, 0x26, 0xeb, 0x4a, 0x70, 0x8, 0xf5, 0x29, 0xf5, 0x28, 0xf5, 0x27, 0x80,
+	0x53, 0xeb, 0x64, 0x1, 0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x1, 0x80, 0x44,
+	0xeb, 0x64, 0x2, 0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x2, 0x80, 0x35, 0xeb,
+	0x64, 0x3, 0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x3, 0x80, 0x26, 0xeb, 0x64,
+	0x4, 0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x4, 0x80, 0x17, 0xeb, 0x64, 0x5,
+	0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x5, 0x80, 0x8, 0xe4, 0xf5, 0x29, 0xf5,
+	0x28, 0x75, 0x27, 0x6, 0x75, 0x26, 0x80, 0x12, 0xc, 0x11, 0xaf, 0x29, 0xae, 0x28, 0xad, 0x27,
+	0xac, 0x26, 0x12, 0xa, 0xc9, 0x7f, 0x3, 0x7e, 00, 0x12, 0x16, 0xe0, 0x7f, 0x3, 0x7e, 00,
+	0x12, 0x16, 0xe0, 0x12, 0xc, 0x11, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x2, 0xa,
+	0xc9, 0x7b, 0x9, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2, 0x22, 0x8f, 0x38, 0x12, 0x1f, 0x74,
+	0x12, 0x1b, 0x76, 0x12, 0xc, 0xaa, 0x12, 0x1f, 0x6b, 0x7a, 0xaf, 0x12, 0xc, 0x96, 0x12, 0x1b,
+	0x8b, 0x12, 0xc, 0x80, 0x7a, 0x8f, 0x12, 0xc, 0x96, 0x7a, 0xaf, 0x12, 0xc, 0xa0, 0xe4, 0xf5,
+	0x3d, 0xf5, 0x3e, 0xfb, 0xfa, 0x7d, 0x11, 0xaf, 0x38, 0x12, 0x19, 0xb0, 0x12, 0x1b, 0x8b, 0x7d,
+	0x12, 0xaf, 0x38, 0x12, 0x19, 0xb0, 0x7a, 0x8f, 0x12, 0xc, 0xa0, 0x7a, 0xaf, 0x12, 0xc, 0xb4,
+	0x75, 0x3d, 0x1, 0x75, 0x3e, 0x80, 0x7b, 00, 0x7a, 0x1, 0x12, 0xc, 0x80, 0x7a, 0x8f, 0x12,
+	0xc, 0xb4, 0xaf, 0x38, 0x12, 0x1f, 0x74, 0x12, 0x1b, 0x81, 0x12, 0xc, 0xaa, 0x2, 0x1f, 0x7d,
+	0x7d, 0x11, 0xaf, 0x38, 0x12, 0x19, 0xb0, 0xe4, 0xf5, 0x3d, 0xf5, 0x3e, 0xfb, 0xfa, 0x7d, 0x12,
+	0xaf, 0x38, 0x12, 0x19, 0xb0, 0x22, 0x7b, 0x8a, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xdf, 0x22,
+	0x7b, 0x86, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xdf, 0x22, 0x7d, 0x8, 0xaf, 0x38, 0x12, 0x19,
+	0xb0, 0xaf, 0x38, 0x22, 0x7b, 0x82, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xdf, 0x22, 0x8f, 0x35,
+	0xe5, 0x35, 0x64, 0x6, 0x70, 0x54, 0x7b, 0x22, 0x7a, 0x1a, 0x7d, 0x17, 0x12, 0x17, 0xdf, 0xaf,
+	0x35, 0x12, 0x18, 0xf, 0x12, 0xd, 0x4b, 0x7a, 0x2, 0x12, 0xd, 0x41, 0x7b, 0xb5, 0x7a, 0x52,
+	0x7d, 0x1f, 0xaf, 0x35, 0x12, 0x17, 0xdf, 0x7b, 0xf, 0x7a, 00, 0x7d, 0x2, 0xaf, 0x35, 0x12,
+	0x17, 0xdf, 0x7b, 0x2a, 0x7a, 0x47, 0x7d, 0x1, 0xaf, 0x35, 0x12, 0x17, 0xdf, 0x7b, 0xa4, 0x7a,
+	0x8f, 0xe4, 0xfd, 0xaf, 0x35, 0x12, 0x17, 0xdf, 0x12, 0xd, 0x4b, 0x7a, 00, 0x12, 0xd, 0x41,
+	0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0xaf, 0x35, 0x2, 0x17, 0xdf, 0xaf, 0x35, 0x12, 0x5, 0x42, 0xaf,
+	0x35, 0x12, 0x1c, 0xe9, 0x7b, 0x64, 0x7a, 00, 0x7d, 0x1b, 0xaf, 0x35, 0x12, 0x17, 0xdf, 0x75,
+	0x3d, 00, 0x75, 0x3e, 0xf, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x1e, 0xaf, 0x35, 0x12, 0x19, 0xb0,
+	0x22, 0x7b, 0x12, 0x7d, 0x8, 0xaf, 0x35, 0x12, 0x17, 0xdf, 0x22, 0x7b, 0x30, 0x7a, 0x2a, 0x7d,
+	0x1f, 0xaf, 0x35, 0x12, 0x17, 0xdf, 0x22, 0x78, 0xfe, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x53, 00,
+	0x75, 0x54, 00, 0x75, 0x81, 0xab, 0x2, 0xd, 0xa4, 0x2, 0xd, 0xe9, 0xe4, 0x93, 0xa3, 0xf8,
+	0xe4, 0x93, 0xa3, 0x40, 0x3, 0xf6, 0x80, 0x1, 0xf2, 0x8, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93,
+	0xa3, 0xf8, 0x54, 0x7, 0x24, 0xc, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0xf, 0x44, 0x20, 0xc8, 0x83,
+	0x40, 0x4, 0xf4, 0x56, 0x80, 0x1, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0xb, 0x1, 0x2, 0x4, 0x8,
+	0x10, 0x20, 0x40, 0x80, 0x90, 0x18, 0x6c, 0xe4, 0x7e, 0x1, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54,
+	0x3f, 0x30, 0xe5, 0x9, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x1, 0xe, 0xcf, 0x54, 0xc0,
+	0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93,
+	0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca,
+	0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 0x12, 0x1f, 0xec, 0x12, 0x19, 0x15, 0xd2,
+	0xa1, 0xc2, 0x91, 0xe4, 0xf5, 0x39, 0x75, 0x38, 0x1, 0xf5, 0x37, 0xf5, 0x36, 0xf5, 0x3d, 0x75,
+	0x3c, 0x1f, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x10, 0xfd, 0x7f, 0xe0, 0x12, 0x10, 0xc4, 0x12, 0x1d,
+	0x7a, 0x12, 0x1c, 0xbb, 0xd2, 0xaf, 0x7f, 0x14, 0x12, 0x1d, 0x8d, 0x12, 0xe, 0xf9, 0x12, 0x1f,
+	0xed, 0x12, 0x1a, 0xd2, 0xef, 0x70, 0x3, 0x30, 0x7, 0x3, 0x12, 0x1f, 0xd5, 0x12, 0x1b, 0x14,
+	0x12, 0x1d, 00, 0xef, 0x60, 0x3, 0x12, 0x1f, 0xd5, 0x12, 0x17, 0x15, 0x12, 0x1c, 0x71, 0x30,
+	0x7, 0x16, 0xc2, 0x7, 0x7b, 0x16, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0xa, 0xc2, 0x7f, 00, 0x7e,
+	00, 0x7d, 0xff, 0x7c, 0xff, 0x12, 0xa, 0xc9, 0x12, 0x18, 0xed, 0x30, 00, 0x8, 0xc2, 00,
+	0x12, 0x1e, 0x4a, 0x12, 0x1c, 0x24, 0x30, 0x1, 0xd6, 0xc2, 0x1, 0x12, 0x1e, 0xc, 0x12, 0x1c,
+	0xd2, 0xa2, 0x81, 0xb3, 0x92, 0x91, 0x80, 0xc7, 0x8f, 0x23, 0x74, 0xa4, 0x2f, 0xf8, 0xe6, 0x24,
+	0xfe, 0x60, 0x2a, 0x14, 0x60, 0x5c, 0x24, 0x2, 0x70, 0x6e, 0x7b, 0xe1, 0x7a, 0x5, 0x7d, 0x4,
+	0xaf, 0x23, 0x12, 0x17, 0xdf, 0x7b, 00, 0x7a, 0x6, 0x7d, 0x9, 0xaf, 0x23, 0x12, 0x17, 0xdf,
+	0xaf, 0x23, 0x12, 0x1e, 0x59, 0x74, 0xa4, 0x25, 0x23, 0xf8, 0x76, 0x2, 0x22, 0x30, 0x9, 0x48,
+	0xaf, 0x23, 0x12, 0x1e, 0xbe, 0x50, 0x41, 0x12, 0x1f, 0xb9, 0x7d, 0x1, 0xaf, 0x23, 0x12, 0xb,
+	0x7, 0xaf, 0x23, 0x12, 0x1c, 0xa3, 0x8f, 0x24, 0xad, 0x24, 0xaf, 0x23, 0x12, 0x1b, 0xd1, 0xad,
+	0x24, 0xaf, 0x23, 0x12, 0x15, 0x76, 0x74, 0xa4, 0x25, 0x23, 0xf8, 0x76, 0x3, 0xaf, 0x23, 0x2,
+	0x1f, 0xe8, 0x30, 0x9, 0x13, 0xaf, 0x23, 0x12, 0x1e, 0xbe, 0x40, 0xc, 0x74, 0xa4, 0x25, 0x23,
+	0xf8, 0x76, 0x2, 0xaf, 0x23, 0x12, 0x1a, 0x8f, 0x22, 0x12, 0x1f, 0xeb, 0xe4, 0x75, 0x26, 0xc0,
+	0xf5, 0x25, 0xf5, 0x24, 0xf5, 0x23, 0xf5, 0x22, 0x7b, 00, 0x7a, 00, 0x79, 0x23, 0xaf, 0x22,
+	0x12, 0xb, 0x62, 0x40, 0x21, 0xe4, 0xfb, 0x7d, 0x2, 0x7f, 0x60, 0x12, 0xa, 0xc2, 0xe4, 0x25,
+	0x22, 0xff, 0xe4, 0x34, 0x4, 0xfe, 0xe4, 0x34, 0x1, 0xfd, 0xe4, 0x34, 0x1, 0xfc, 0x12, 0xa,
+	0xc9, 0x7f, 0x2, 0x12, 0x1d, 0x8d, 0x5, 0x22, 0xe5, 0x22, 0xd3, 0x94, 0xf, 0x40, 0xc9, 0x7f,
+	0x3, 0x12, 0x1f, 0x1d, 0x12, 0x1f, 0xab, 0x12, 0x1e, 0xfc, 0x7f, 0x4, 0x12, 0x1f, 0x1d, 0x75,
+	0x3b, 0x1, 0x75, 0x3c, 0x1, 0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x17, 0x7d, 0x7f, 0x14,
+	0x12, 0x1d, 0x8d, 0x7b, 0x4, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2, 0x7f, 0x5f, 0x12, 0x1f,
+	0xb2, 0x12, 0xa, 0xc9, 0x2, 0x14, 0xf4, 0x8f, 0x34, 0x8e, 0x33, 0x8d, 0x32, 0x8c, 0x31, 0xe4,
+	0xf5, 0x3f, 0xe4, 0xff, 0xfe, 0xfd, 0xfc, 0xab, 0x34, 0xaa, 0x33, 0xa9, 0x32, 0xa8, 0x31, 0xd3,
+	0x12, 0x4, 0xb7, 0x40, 0x37, 0xe4, 0x7b, 0xa, 0xfa, 0xf9, 0xf8, 0xaf, 0x34, 0xae, 0x33, 0xad,
+	0x32, 0xac, 0x31, 0x12, 0x4, 0x18, 0xaf, 0x3, 0x74, 0x35, 0x25, 0x3f, 0xf8, 0xa6, 0x7, 0xaf,
+	0x34, 0xae, 0x33, 0xad, 0x32, 0xac, 0x31, 0xe4, 0x7b, 0xa, 0xfa, 0xf9, 0xf8, 0x12, 0x4, 0x18,
+	0x8f, 0x34, 0x8e, 0x33, 0x8d, 0x32, 0x8c, 0x31, 0x5, 0x3f, 0x80, 0xb6, 0xe5, 0x3f, 0x70, 0x5,
+	0x7f, 0x30, 0x2, 0x1d, 0xb3, 0x15, 0x3f, 0xe5, 0x3f, 0xf4, 0x60, 0x10, 0x74, 0x35, 0x25, 0x3f,
+	0xf8, 0xe6, 0x24, 0x30, 0xff, 0x12, 0x1d, 0xb3, 0x15, 0x3f, 0x80, 0xeb, 0x22, 0x8f, 0x31, 0x8d,
+	0x32, 0x7b, 0x24, 0x7f, 0x20, 0x12, 0xa, 0xc2, 0x7f, 0x6, 0x12, 0x1b, 0x98, 0x12, 0xa, 0xc9,
+	0xe5, 0x31, 0x24, 0x80, 0xfb, 0x75, 0x3b, 0x1b, 0x75, 0x3c, 0x1, 0xe4, 0xfd, 0x7f, 0x40, 0x12,
+	0x17, 0x7d, 0x7f, 0x2, 0x12, 0x1f, 0x1d, 0xaf, 0x32, 0x12, 0x1a, 0xb1, 0x7f, 0xa, 0x12, 0x1f,
+	0x9d, 0x12, 0x1e, 0xf1, 0x40, 0x5, 0x12, 0x1f, 0xda, 0x50, 0xf6, 0x12, 0x1f, 0xda, 0x40, 0x13,
+	0xad, 0x32, 0xaf, 0x31, 0x12, 0x13, 0xd2, 0xef, 0x70, 0x4, 0xf5, 0x33, 0x80, 0x8, 0x75, 0x33,
+	0x1, 0x80, 0x3, 0x75, 0x33, 0x2, 0xe5, 0x31, 0x24, 0x80, 0xfb, 0x75, 0x3b, 0x1b, 0xe4, 0xf5,
+	0x3c, 0xfd, 0x7f, 0x40, 0x12, 0x17, 0x7d, 0xaf, 0x33, 0x22, 0x8f, 0xa, 0xc3, 0xed, 0x94, 0x40,
+	0xec, 0x94, 00, 0x50, 0x16, 0xc3, 0x74, 0x40, 0x9d, 0xff, 0xe4, 0x9c, 0xfe, 0xef, 0x78, 0x2,
+	0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0xf5, 0xb, 0x80, 0x1c, 0xed, 0x24, 0x3, 0xff, 0xe4,
+	0x3c, 0xfe, 0xef, 0x78, 0x2, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x30, 0xe0, 0x5, 0x75,
+	0xb, 0x1, 0x80, 0x3, 0xe4, 0xf5, 0xb, 0xc3, 0xed, 0x94, 0x40, 0xec, 0x94, 00, 0x40, 0xe,
+	0xae, 0x4, 0xaf, 0x5, 0xe4, 0xfc, 0xfd, 0x78, 0x10, 0x12, 0x4, 0xdb, 0x80, 0x8, 0x7f, 00,
+	0x7e, 00, 0x7d, 0x40, 0x7c, 00, 0x12, 0x15, 0xf5, 0x7f, 0x20, 0x7e, 0x5, 0x7d, 00, 0x7c,
+	00, 0x2, 0x15, 0xf5, 0x8f, 0x33, 0x8d, 0x34, 0x8b, 0x35, 0xe5, 0x39, 0x55, 0x3d, 0xf5, 0x39,
+	0xe5, 0x38, 0x55, 0x3c, 0xf5, 0x38, 0xe5, 0x37, 0x55, 0x3b, 0xf5, 0x37, 0xe5, 0x36, 0x55, 0x3a,
+	0xf5, 0x36, 0x12, 0xa, 0xae, 0xa8, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7, 0xaf, 0x3d, 0xae,
+	0x3c, 0xad, 0x3b, 0xac, 0x3a, 0x12, 0x4, 0xaa, 0xeb, 0x5f, 0xff, 0xea, 0x5e, 0xfe, 0xe9, 0x5d,
+	0xfd, 0xe8, 0x5c, 0xfc, 0xe5, 0x39, 0x4f, 0xf5, 0x39, 0xe5, 0x38, 0x4e, 0xf5, 0x38, 0xe5, 0x37,
+	0x4d, 0xf5, 0x37, 0xe5, 0x36, 0x4c, 0xf5, 0x36, 0xab, 0x35, 0xad, 0x34, 0xaf, 0x33, 0x12, 0xa,
+	0xc2, 0xaf, 0x39, 0xae, 0x38, 0xad, 0x37, 0xac, 0x36, 0x2, 0xa, 0xc9, 0x8f, 0x31, 0x8d, 0x32,
+	0x7b, 0x19, 0xad, 0x31, 0x7f, 0x20, 0x12, 0xa, 0xc2, 0x12, 0x1b, 0x96, 0x12, 0xa, 0xc9, 0xe5,
+	0x32, 0x44, 0x10, 0xfd, 0xaf, 0x31, 0x12, 0x12, 0x5b, 0xef, 0xf5, 0x36, 0xee, 0xf5, 0x35, 0xed,
+	0x44, 0x1, 0xf5, 0x34, 0xec, 0x44, 0x10, 0xf5, 0x33, 0x12, 0x11, 0x87, 0xe5, 0x36, 0x44, 0x30,
+	0xff, 0xe5, 0x35, 0xfe, 0xe5, 0x34, 0xfd, 0xe5, 0x33, 0x44, 0x20, 0xfc, 0x12, 0xa, 0xc9, 0x12,
+	0x11, 0x87, 0xaf, 0x36, 0xae, 0x35, 0xad, 0x34, 0xac, 0x33, 0x12, 0xa, 0xc9, 0xe5, 0x31, 0xb4,
+	0x6, 0x4, 0xff, 0x12, 0x14, 0xb0, 0x22, 0xe4, 0xfb, 0xad, 0x31, 0x7f, 0x20, 0x12, 0xa, 0xc2,
+	0x22, 0x7b, 0xff, 0x7a, 0x1e, 0x79, 0x68, 0x12, 0x1a, 0x47, 0x12, 0x1f, 0x3b, 0x7b, 0xff, 0x7a,
+	0x1e, 0x79, 0x20, 0x12, 0x1a, 0x47, 0x7b, 0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0xa, 0xae, 0x12,
+	0x1c, 0x58, 0x12, 0x1f, 0x3b, 0x7b, 0xff, 0x7a, 0x1e, 0x79, 0x22, 0x12, 0x1a, 0x47, 0xe4, 0xf5,
+	0x23, 0xaf, 0x23, 0x12, 0x1a, 0xf3, 0xaf, 0x23, 0x12, 0x1e, 0x94, 0x7f, 0x1, 0x12, 0x1d, 0x52,
+	0xaf, 0x23, 0x12, 0x1f, 0xc0, 0xe4, 0xfc, 0xfd, 0xfe, 0x12, 0xf, 0x77, 0x7f, 0x3, 0x12, 0x1d,
+	0x52, 0xaf, 0x23, 0x12, 0x1f, 0xc7, 0x12, 0x1a, 0xf3, 0x12, 0x1f, 0x3b, 0x5, 0x23, 0xe5, 0x23,
+	0xc3, 0x94, 0x7, 0x40, 0xcc, 0x22, 0x7f, 0xa, 0x12, 0x1d, 0x66, 0xe4, 0xff, 0xfe, 0x12, 0x19,
+	0xd6, 0xef, 0x7f, 00, 0xfe, 0xc0, 0x7, 0xc0, 0x6, 0xf, 0x7e, 00, 0x12, 0x19, 0xd6, 0xef,
+	0xfd, 0xd0, 0xe0, 0xf5, 0x1b, 0xd0, 0xe0, 0x4d, 0xf5, 0x1c, 0x24, 0x1, 0xff, 0xe4, 0x35, 0x1b,
+	0xfe, 0x12, 0x19, 0xd6, 0x8f, 0x1d, 0xe4, 0xff, 0x12, 0x1d, 0x66, 0xe5, 0x1c, 0x15, 0x1c, 0x70,
+	0x2, 0x15, 0x1b, 0xe4, 0xff, 0xfe, 0xc3, 0xef, 0x95, 0x1c, 0xee, 0x95, 0x1b, 0x50, 0x11, 0x8f,
+	0x82, 0x8e, 0x83, 0xe4, 0x93, 0x25, 0x1d, 0xf5, 0x1d, 0xf, 0xbf, 00, 0x1, 0xe, 0x80, 0xe6,
+	0xe5, 0x1d, 0x70, 0x4, 0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x22, 0xef, 0x64, 0x6, 0xef, 0x64,
+	0x6, 0x70, 0x24, 0xbd, 0x10, 0x8, 0x7f, 0x43, 0x7e, 0x4, 0x7d, 0x4, 0xfc, 0x22, 0xed, 0x70,
+	0x4, 0x7f, 0x43, 0x80, 0x20, 0xbd, 0x11, 0x4, 0x7f, 0x42, 0x80, 0x24, 0xbd, 0x1, 0x4, 0x7f,
+	0x42, 0x80, 0x29, 0x7f, 0x81, 0x80, 0x2e, 0xbd, 0x10, 0x6, 0x7f, 0x44, 0x7e, 0x4, 0x80, 0x12,
+	0xed, 0x70, 0x8, 0x7f, 0x44, 0x7e, 0x4, 0xfd, 0x7c, 0x80, 0x22, 0xbd, 0x11, 0x9, 0x7f, 0x44,
+	0x7e, 0x24, 0x7d, 0x4, 0x7c, 00, 0x22, 0xbd, 0x1, 0x9, 0x7f, 0x44, 0x7e, 0x24, 0x7d, 00,
+	0x7c, 0x80, 0x22, 0x7f, 0x84, 0x7e, 0x1, 0x7d, 0x6, 0x7c, 00, 0x22, 0x8f, 0x2c, 0x7f, 0x32,
+	0x12, 0x1f, 0x9d, 0x7b, 0xd8, 0xad, 0x2c, 0x7f, 0x20, 0x12, 0xa, 0xae, 0x78, 0x8, 0x12, 0x4,
+	0xc8, 0xef, 0x54, 0x1f, 0xff, 0xe4, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xc3, 0x12, 0x4,
+	0xb7, 0x70, 0x32, 0x7b, 0xc, 0xfd, 0x7f, 0xa0, 0x12, 0xa, 0xae, 0xc0, 0x4, 0xc0, 0x5, 0xc0,
+	0x6, 0xc0, 0x7, 0xaf, 0x2c, 0x12, 0xb, 00, 0xe4, 0xfc, 0xfd, 0xfe, 0xd0, 0x3, 0xd0, 0x2,
+	0xd0, 0x1, 0xd0, 00, 0xeb, 0x5f, 0xff, 0xe4, 0xfb, 0xfa, 0xf9, 0xf8, 0xc3, 0x12, 0x4, 0xb7,
+	0x60, 0x3, 0x7f, 0x1, 0x22, 0x12, 0x1f, 0xda, 0x50, 0xa9, 0x7f, 00, 0x22, 0x8f, 0x38, 0x12,
+	0x1f, 0x74, 0x12, 0x1b, 0x76, 0x12, 0x13, 0x65, 0x12, 0x1f, 0x6b, 0x7a, 0xb6, 0x12, 0x13, 0x6f,
+	0x75, 0x3d, 0xff, 0x75, 0x3e, 0x7, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x12, 0xaf, 0x38, 0x12, 0x19,
+	0xb0, 0x75, 0x3d, 00, 0x75, 0x3e, 0xff, 0x7b, 0xa2, 0x7a, 00, 0x7d, 0x11, 0xaf, 0x38, 0x12,
+	0x19, 0xb0, 0x7a, 0x96, 0x12, 0x13, 0x6f, 0xaf, 0x38, 0x12, 0x1f, 0x74, 0x12, 0x1b, 0x81, 0x12,
+	0x13, 0x65, 0x2, 0x1f, 0x7d, 0x7d, 0x8, 0xaf, 0x38, 0x12, 0x19, 0xb0, 0xaf, 0x38, 0x22, 0x7b,
+	0x8a, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xdf, 0x22, 0x8f, 0x3f, 0x8d, 0x40, 0x12, 0x1f, 0xc0,
+	0x8f, 0x45, 0xaf, 0x3f, 0x12, 0x1f, 0xc7, 0x8f, 0x46, 0x7b, 0x1, 0xad, 0x45, 0x7f, 0x60, 0x12,
+	0xa, 0xc2, 0xe5, 0x46, 0x75, 0xf0, 0x20, 0xa4, 0xff, 0xe5, 0xf0, 0x44, 0x4, 0xfc, 0xef, 0x45,
+	0x40, 0xfd, 0xe4, 0xff, 0xfe, 0x12, 0xa, 0xdf, 0x12, 0xa, 0xc9, 0xaf, 0x45, 0x12, 0x1b, 0x56,
+	0x7b, 0x2, 0xad, 0x45, 0x7f, 0x60, 0x12, 0xa, 0xae, 0x8f, 0x44, 0x8e, 0x43, 0x8d, 0x42, 0x8c,
+	0x41, 0xe5, 0x42, 0x54, 0x1, 0xfd, 0xed, 0x70, 0x5, 0xae, 0x43, 0xaf, 0x44, 0x22, 0xe4, 0xfe,
+	0xff, 0x22, 0x8f, 0x34, 0x8d, 0x35, 0xe4, 0xf5, 0x37, 0xfb, 0x7a, 00, 0x79, 0x38, 0x12, 0x15,
+	0x36, 0xef, 0x64, 0x80, 0x4e, 0x60, 0x3, 0x75, 0x37, 0x1, 0xe5, 0x38, 0x65, 0x34, 0x60, 0x3,
+	0x75, 0x37, 0x1, 0xe5, 0x37, 0x70, 0x25, 0xf5, 0x36, 0x12, 0x1d, 0x2a, 0xa8, 0x4, 0xa9, 0x5,
+	0xaa, 0x6, 0xab, 0x7, 0xe4, 0x25, 0x35, 0x12, 0x1b, 0x9f, 0xc3, 0x12, 0x4, 0xb7, 0x60, 0x3,
+	0x75, 0x37, 0x1, 0x5, 0x36, 0xe5, 0x36, 0xc3, 0x94, 0x1f, 0x40, 0xdd, 0x12, 0x1d, 0x3e, 0xaf,
+	0x37, 0x22, 0x8f, 0x34, 0x8d, 0x35, 0xe4, 0xfb, 0xfa, 0xfd, 0x12, 0x17, 0xdf, 0xe5, 0x35, 0x54,
+	0x3, 0xff, 0x70, 0x6, 0xf5, 0x36, 0xf5, 0x37, 0x80, 0x14, 0xbf, 0x1, 0x8, 0x75, 0x36, 0x20,
+	0x75, 0x37, 00, 0x80, 0x9, 0xbf, 0x2, 0x6, 0x75, 0x36, 00, 0x75, 0x37, 0x40, 0xe5, 0x35,
+	0x30, 0xe4, 0x3, 0x43, 0x36, 0x1, 0xe5, 0x35, 0x30, 0xe7, 0x3, 0x43, 0x36, 0x40, 0xab, 0x37,
+	0xaa, 0x36, 0xe4, 0xfd, 0xaf, 0x34, 0x2, 0x17, 0xdf, 0x8f, 0x27, 0x12, 0x1f, 0x6b, 0x7b, 0xf0,
+	0x7a, 0xaf, 0x7d, 0x10, 0xaf, 0x27, 0x12, 0x17, 0xdf, 0x7d, 0x11, 0xaf, 0x27, 0x12, 0x13, 0x79,
+	0xee, 0xc4, 0xf8, 0x54, 0xf0, 0xc8, 0xef, 0xc4, 0x54, 0xf, 0x48, 0x54, 0x1f, 0xff, 0xc3, 0x94,
+	0x10, 0x40, 0x6, 0xef, 0xd3, 0x94, 0x14, 0x40, 0x12, 0xaf, 0x27, 0x12, 0x1f, 0x74, 0x75, 0x3d,
+	0x3, 0x12, 0x1b, 0x84, 0x7d, 0xc, 0xaf, 0x27, 0x12, 0x19, 0xb0, 0xaf, 0x27, 0x2, 0x1f, 0x7d,
+	0x8f, 0x37, 0x75, 0x3b, 0x5, 0x75, 0x3c, 0x1, 0x7b, 0x19, 0xad, 0x37, 0x7f, 0x20, 0x12, 0x17,
+	0x7d, 0xe5, 0x37, 0xb4, 0x6, 0x6, 0x75, 0x3b, 0x3, 0x12, 0x14, 0xe8, 0xe5, 0x37, 0xb4, 0x6,
+	0x6, 0x75, 0x3b, 0x2, 0x12, 0x14, 0xe8, 0x7b, 0x5, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0xa, 0xc2,
+	0x7f, 0x33, 0x12, 0x1f, 0xb2, 0x2, 0xa, 0xc9, 0x75, 0x3c, 0x1, 0x7b, 0x19, 0xfd, 0x7f, 0x20,
+	0x12, 0x17, 0x7d, 0x22, 0x75, 0x27, 0x1, 0x7b, 0x6, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2,
+	0x7f, 0x80, 0x7e, 0x1, 0x7d, 00, 0x7c, 00, 0x12, 0xa, 0xc9, 0x7b, 0x7, 0xe4, 0xfd, 0x7f,
+	0x40, 0x12, 0xa, 0xc2, 0xe4, 0x25, 0x27, 0xff, 0xe4, 0x33, 0xfe, 0xe4, 0x33, 0xfd, 0xe4, 0x34,
+	0xc2, 0xfc, 0x12, 0xa, 0xc9, 0x7f, 0x1, 0x7e, 0x26, 0x12, 0x16, 0xe0, 0x5, 0x27, 0xe5, 0x27,
+	0xd3, 0x94, 0xf, 0x40, 0xc2, 0x22, 0x8b, 0x39, 0x8a, 0x3a, 0x89, 0x3b, 0xe4, 0xf5, 0x8, 0xf5,
+	0x9, 0x12, 0x15, 0x6a, 0xe5, 0x3c, 0x54, 0x3f, 0xf5, 0x40, 0x85, 0x3d, 0x41, 0xe5, 0x3a, 0x45,
+	0x3b, 0x45, 0x39, 0x60, 0x10, 0xe5, 0x3f, 0x54, 0x7, 0xab, 0x39, 0xaa, 0x3a, 0xa9, 0x3b, 0x12,
+	0x3, 0x7b, 0x12, 0x15, 0x6a, 0xae, 0x40, 0xaf, 0x41, 0x22, 0x12, 0x1d, 0x2a, 0x8f, 0x3f, 0x8e,
+	0x3e, 0x8d, 0x3d, 0x8c, 0x3c, 0x22, 0x8f, 0x25, 0x8d, 0x26, 0xe5, 0x25, 0x64, 0x6, 0x60, 0x23,
+	0xe5, 0x26, 0x54, 0x3, 0xff, 0xbf, 0x2, 0x5, 0xaf, 0x25, 0x12, 0x14, 0x69, 0xe5, 0x26, 0x54,
+	0x3, 0x70, 0x10, 0xaf, 0x25, 0x12, 0x1f, 0x74, 0x12, 0x15, 0xa4, 0x12, 0x15, 0xa4, 0xaf, 0x25,
+	0x12, 0x1f, 0x7d, 0x22, 0x75, 0x3d, 0x60, 0x75, 0x3e, 00, 0x7b, 00, 0x7a, 0x20, 0x7d, 0x14,
+	0xaf, 0x25, 0x12, 0x19, 0xb0, 0x22, 0xc0, 0xe0, 0xc0, 0xd0, 0x75, 0xd0, 0x10, 0x30, 0x98, 0x29,
+	0xaf, 0x99, 0xc2, 0x98, 0xe5, 0x1e, 0x24, 0x1, 0xfd, 0xe4, 0x33, 0xfc, 0xe5, 0x1f, 0x7a, 00,
+	0xb5, 0x15, 0x8, 0xea, 0xb5, 0x14, 0x4, 0xd2, 0x5, 0x80, 0xe, 0x74, 0x84, 0x25, 0x1e, 0xf8,
+	0xa6, 0x17, 0xe5, 0x1e, 0x4, 0x54, 0x1f, 0xf5, 0x1e, 0x30, 0x99, 0x4, 0xc2, 0x99, 0xd2, 0x6,
+	0xd0, 0xd0, 0xd0, 0xe0, 0x32, 0x8f, 0x39, 0x8e, 0x38, 0x8d, 0x37, 0x8c, 0x36, 0x20, 0x8, 0x30,
+	0x7b, 0xc0, 0xad, 0xa, 0x7f, 0x20, 0x12, 0xa, 0xc2, 0xaf, 0x39, 0xae, 0x38, 0xad, 0x37, 0xac,
+	0x36, 0x12, 0xa, 0xc9, 0xe4, 0x78, 0xab, 0xf6, 0x7b, 0xc8, 0xad, 0xa, 0x7f, 0x20, 0x12, 0xa,
+	0xae, 0xee, 0x30, 0xe0, 0xb, 0x78, 0xab, 0x6, 0xe6, 0xd3, 0x94, 0x64, 0x40, 0xea, 0xd2, 0x8,
+	0x22, 0x12, 0x19, 0x8a, 0x8f, 0x2b, 0xe4, 0xf5, 0x2a, 0xaf, 0x2a, 0x12, 0xb, 00, 0xef, 0xf4,
+	0xff, 0xef, 0x55, 0x2b, 0xff, 0xe4, 0x8f, 0x39, 0xf5, 0x38, 0xf5, 0x37, 0xf5, 0x36, 0xe5, 0x2a,
+	0x24, 0x80, 0xfb, 0xe4, 0x75, 0x3d, 0x5f, 0xf5, 0x3c, 0xf5, 0x3b, 0xf5, 0x3a, 0xfd, 0x7f, 0x40,
+	0x12, 0x10, 0xc4, 0x5, 0x2a, 0xe5, 0x2a, 0xc3, 0x94, 0x7, 0x40, 0xcd, 0x22, 0x12, 0x1e, 0xe6,
+	0x50, 0x35, 0x12, 0x1e, 0x2c, 0xef, 0x64, 0xa, 0x60, 0x2d, 0xbf, 0x8, 0xb, 0xe5, 0x18, 0xd3,
+	0x94, 00, 0x40, 0x23, 0x15, 0x18, 0x80, 0x1f, 0xe5, 0x18, 0xc3, 0x94, 0x1e, 0x50, 0xa, 0xae,
+	0x18, 0x5, 0x18, 0x74, 0x66, 0x2e, 0xf8, 0xa6, 0x7, 0xbf, 0xd, 0xb, 0xe5, 0x18, 0xb4, 0x1e,
+	0x4, 0x78, 0x83, 0x76, 0xd, 0xd3, 0x22, 0xc3, 0x22, 0xaf, 0xb, 0x15, 0xb, 0xef, 0xd3, 0x94,
+	00, 0x40, 0xd, 0x7f, 0x55, 0x7e, 0x55, 0x7d, 0x55, 0x7c, 0x55, 0x12, 0x15, 0xf5, 0x80, 0xe9,
+	0x30, 0x8, 0x9, 0x75, 0x3b, 0x1, 0x12, 0x16, 0xd3, 0xc2, 0x8, 0x22, 0xe4, 0xf5, 0x3b, 0x12,
+	0x16, 0xd3, 0x22, 0x75, 0x3c, 0x1, 0x7b, 0xc4, 0xad, 0xa, 0x7f, 0x20, 0x12, 0x17, 0x7d, 0x22,
+	0x8e, 0x2a, 0x8f, 0x2b, 0x7b, 0xb0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2, 0xae, 0x2a, 0xaf,
+	0x2b, 0xe4, 0xfc, 0xfd, 0x12, 0xa, 0xc9, 0x7f, 0xa, 0x12, 0x1f, 0x9d, 0x7b, 0xb0, 0xe4, 0xfd,
+	0x7f, 0x40, 0x12, 0xa, 0xae, 0xef, 0x54, 0x7, 0x60, 0xa, 0x12, 0x1f, 0xda, 0x50, 0xed, 0x7f,
+	0x4, 0x12, 0x1f, 0xe2, 0x22, 0xe4, 0xf5, 0x22, 0xe5, 0x22, 0x24, 0x80, 0xfb, 0xe4, 0xfd, 0x7f,
+	0x40, 0x12, 0xa, 0xc2, 0x7f, 00, 0x12, 0x1f, 0xb2, 0x12, 0xa, 0xc9, 0xe5, 0x22, 0xb4, 0x6,
+	0x5, 0x7d, 0x12, 0xff, 0x80, 0x4, 0x7d, 0xff, 0xaf, 0x22, 0x12, 0x1b, 0xd1, 0x5, 0x22, 0xe5,
+	0x22, 0xc3, 0x94, 0x7, 0x40, 0xd2, 0x2, 0x16, 0x31, 0x8b, 0x2a, 0x8a, 0x2b, 0x89, 0x2c, 0xe4,
+	0xf5, 0x2d, 0xab, 0x2a, 0x5, 0x2c, 0xe5, 0x2c, 0xaa, 0x2b, 0x70, 0x2, 0x5, 0x2b, 0x14, 0xf9,
+	0x12, 0x3, 0x62, 0xff, 0x12, 0x1c, 0x3f, 0xe5, 0x2d, 0xc3, 0x94, 0x5, 0x50, 0x5, 0x7f, 0x2d,
+	0x12, 0x1f, 0xe5, 0x5, 0x2d, 0xe5, 0x2d, 0xc3, 0x94, 0x6, 0x40, 0xd6, 0x22, 0x8f, 0x38, 0x8d,
+	0x39, 0x8b, 0x3a, 0x12, 0xa, 0xae, 0x8f, 0x40, 0x8e, 0x3f, 0x8d, 0x3e, 0x8c, 0x3d, 0x7b, 00,
+	0x7a, 00, 0x79, 0x3d, 0xad, 0x3c, 0xaf, 0x3b, 0x12, 0xb, 0x2f, 0xab, 0x3a, 0xad, 0x39, 0xaf,
+	0x38, 0x12, 0xa, 0xc2, 0xaf, 0x40, 0xae, 0x3f, 0xad, 0x3e, 0xac, 0x3d, 0x2, 0xa, 0xc9, 00,
+	00, 0x14, 0x14, 00, 00, 00, 00, 00, 0x15, 00, 0x18, 00, 0x16, 00, 0x18, 00,
+	0x17, 00, 0x18, 00, 0x18, 00, 0x18, 00, 00, 0xc, 0x8, 00, 00, 00, 0x1, 00,
+	0x6, 00, 0x14, 00, 0x7, 00, 0x14, 00, 0x8, 00, 0x14, 00, 0x9, 00, 0x14, 0x8f,
+	0x3f, 0x8d, 0x40, 0x8a, 0x41, 0x8b, 0x42, 0x12, 0x1f, 0xc0, 0x8f, 0x43, 0xaf, 0x3f, 0x12, 0x1f,
+	0xc7, 0x8f, 0x44, 0x7b, 0x1, 0xad, 0x43, 0x7f, 0x60, 0x12, 0xa, 0xc2, 0xab, 0x44, 0xad, 0x40,
+	0xaf, 0x42, 0xae, 0x41, 0x12, 0x1f, 0x27, 0x12, 0xa, 0xc9, 0xaf, 0x43, 0x2, 0x1b, 0x56, 0x8f,
+	0x36, 0x7b, 00, 0x7a, 0x80, 0xe4, 0xfd, 0x12, 0x17, 0xdf, 0x7f, 0x2, 0x12, 0x1d, 0x8d, 0xe4,
+	0xf5, 0x37, 0xe4, 0xfd, 0xaf, 0x36, 0x12, 0x13, 0x79, 0xee, 0x30, 0xe7, 0x10, 0x5, 0x37, 0xe5,
+	0x37, 0xd3, 0x94, 0xc8, 0x50, 0x7, 0x7f, 0x1, 0x12, 0x1d, 0x8d, 0x80, 0xe5, 0x22, 0x8f, 0x28,
+	0x8d, 0x29, 0xe5, 0x29, 0xf4, 0x60, 0x22, 0x7b, 0x10, 0xad, 0x28, 0x7f, 0x20, 0x12, 0xa, 0xc2,
+	0x7f, 00, 0x7e, 0x6, 0x7d, 00, 0x7c, 00, 0x12, 0xa, 0xc9, 0xad, 0x29, 0xaf, 0x28, 0x12,
+	0x8, 0xec, 0x7d, 0x1, 0xaf, 0x28, 0x12, 0x1e, 0xd9, 0x2, 0x16, 0x31, 0xc1, 0x5, 0xc1, 0x4,
+	0x1, 0x1e, 00, 0x1, 0x1f, 00, 0xc1, 00, 0xc1, 0x1, 0x1, 0xe, 00, 0xc1, 0x2, 0xc1,
+	0x3, 0x1, 0xc, 0xa, 0x1, 0xd, 0x64, 0xc1, 0x7, 0x1, 0xf, 00, 0xc1, 0x8, 0x1, 0x18,
+	00, 0x1, 0x4d, 00, 0x1, 0x55, 00, 00, 0x8f, 0x2a, 0x8e, 0x29, 0x8d, 0x28, 0x8c, 0x27,
+	0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2, 0xaf, 0x2a, 0xae, 0x29, 0xad, 0x28, 0xac,
+	0x27, 0x12, 0xa, 0xc9, 0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xae, 0xef, 0x54, 0x3,
+	0x70, 0xf2, 0x22, 0xe4, 0xfe, 0xee, 0x90, 00, 0x40, 0x93, 0xfc, 0xed, 0x2e, 0xf8, 0xa6, 0x4,
+	0xe, 0xbe, 0x6, 0xf1, 0xed, 0x24, 0x5, 0xf8, 0xe6, 0x2f, 0xf6, 0xc3, 0x9f, 0x50, 0xd, 0xed,
+	0x24, 0x4, 0xf8, 0x6, 0xe6, 0x70, 0x5, 0xed, 0x24, 0x3, 0xf8, 0x6, 0x22, 0x12, 0x16, 0x6d,
+	0x50, 0x22, 0x75, 0x1a, 0x66, 0x12, 0x1f, 0x7, 0x12, 0x7, 0xe9, 0xef, 0x60, 0x13, 0x12, 0x1e,
+	0xe6, 0x50, 0x5, 0x12, 0x1e, 0x2c, 0x80, 0xf6, 0x7b, 0xff, 0x7a, 0x1e, 0x79, 0x1c, 0x12, 0x1a,
+	0x47, 0xe4, 0xf5, 0x18, 0x22, 0x7b, 0x17, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0xa, 0xc2, 0x7f, 0xff,
+	0x7e, 0xff, 0x7d, 0xff, 0x7c, 0xff, 0x12, 0xa, 0xc9, 0x7b, 0x16, 0xe4, 0xfd, 0x7f, 0xe0, 0x12,
+	0xa, 0xc2, 0x7f, 0x13, 0x7e, 0x23, 0x7d, 00, 0x7c, 00, 0x2, 0xa, 0xc9, 0x8f, 0x31, 0x8d,
+	0x32, 0x8b, 0x33, 0x12, 0x1f, 0x4f, 0xaf, 0x32, 0x12, 0x1f, 0x4f, 0x7f, 0x5, 0x12, 0x1f, 0x1d,
+	0xe5, 0x33, 0x44, 0x10, 0xfd, 0xaf, 0x31, 0x12, 0x14, 0x22, 0xe5, 0x33, 0x44, 0x10, 0xfd, 0xaf,
+	0x32, 0x2, 0x14, 0x22, 0x8f, 0x32, 0xed, 0x70, 0x2, 0x80, 0x1, 0xe4, 0x75, 0x39, 0x86, 0x75,
+	0x38, 0x2, 0xf5, 0x37, 0xf5, 0x36, 0x75, 0x3d, 0xff, 0x75, 0x3c, 0xf, 0xf5, 0x3b, 0xf5, 0x3a,
+	0x7b, 0x2, 0xad, 0x32, 0x7f, 0x20, 0x12, 0x10, 0xc4, 0x22, 0xe4, 0xf5, 0x2c, 0xf5, 0x2d, 0xaf,
+	0x2d, 0x12, 00, 0x3, 0xef, 0x60, 0xd, 0x7b, 00, 0x7a, 00, 0x79, 0x2c, 0x7d, 0x1, 0xaf,
+	0x2d, 0x12, 0xb, 0x7, 0x5, 0x2d, 0xe5, 0x2d, 0xc3, 0x94, 0x7, 0x40, 0xe2, 0xaf, 0x2c, 0x22,
+	0x8f, 0x39, 0x8d, 0x3a, 0x8a, 0x3b, 0x8b, 0x3c, 0x12, 0x13, 0x79, 0xe5, 0x3e, 0xf4, 0xfd, 0xe5,
+	0x3d, 0xf4, 0x5e, 0xfe, 0xef, 0x5d, 0x42, 0x3c, 0xee, 0x42, 0x3b, 0xab, 0x3c, 0xaa, 0x3b, 0xad,
+	0x3a, 0xaf, 0x39, 0x2, 0x17, 0xdf, 0x8e, 0x48, 0x8f, 0x49, 0xe4, 0xff, 0x12, 0x1d, 0xd7, 0x7f,
+	0x3, 0x12, 0x1a, 0x6c, 0xe5, 0x48, 0xff, 0x12, 0x1a, 0x6c, 0xaf, 0x49, 0x12, 0x1a, 0x6c, 0x12,
+	0x1b, 0x35, 0x8f, 0x4a, 0x7f, 0x1, 0x12, 0x1d, 0xd7, 0xaf, 0x4a, 0x22, 0x12, 0x1c, 0x8a, 0x74,
+	0x30, 0xd3, 0x9f, 0x50, 0xa, 0xef, 0x94, 0x39, 0x50, 0x5, 0xef, 0x24, 0xd0, 0xff, 0x22, 0x74,
+	0x41, 0xd3, 0x9f, 0x50, 0xa, 0xef, 0x94, 0x46, 0x50, 0x5, 0xef, 0x24, 0xc9, 0xff, 0x22, 0x7f,
+	0xff, 0x22, 0xc2, 0x8e, 0x75, 0x8b, 0x92, 0x75, 0x8d, 0xe6, 0xd2, 0x8e, 0xd2, 0x3, 0xd5, 0xc,
+	0x15, 0x75, 0xc, 0xa, 0xd2, 00, 0xd5, 0xd, 0x5, 0x75, 0xd, 0x64, 0xd2, 0x1, 0x30, 0x2,
+	0x5, 0xd5, 0xe, 0x2, 0xc2, 0x2, 0x32, 0x8b, 0x31, 0x8a, 0x32, 0x89, 0x33, 0xab, 0x31, 0xaa,
+	0x32, 0xa9, 0x33, 0x12, 0x3, 0x62, 0x60, 0x13, 0x5, 0x33, 0xe5, 0x33, 0x70, 0x2, 0x5, 0x32,
+	0x14, 0xf9, 0x12, 0x3, 0x62, 0xff, 0x12, 0x1d, 0xb3, 0x80, 0xe2, 0x22, 0x8f, 0x4f, 0xe4, 0xf5,
+	0x50, 0xe5, 0x4f, 0x54, 0x80, 0xff, 0x12, 0x1d, 0xe9, 0xe5, 0x4f, 0x25, 0xe0, 0xf5, 0x4f, 0x12,
+	0x1f, 0x8d, 0x12, 0x1f, 0x95, 0x5, 0x50, 0xe5, 0x50, 0xc3, 0x94, 0x8, 0x40, 0xe3, 0x22, 0x8f,
+	0x25, 0x12, 0x1f, 0xb9, 0xe4, 0xfd, 0x12, 0xb, 0x7, 0xaf, 0x25, 0x12, 0x1e, 0xa2, 0x50, 0x5,
+	0xaf, 0x25, 0x12, 0x1f, 0x59, 0x7d, 0xff, 0xaf, 0x25, 0x12, 0x1b, 0xd1, 0xaf, 0x25, 0x2, 00,
+	0x1e, 0x8f, 0x34, 0x7d, 0x80, 0x7c, 00, 0x12, 0x10, 0x5a, 0xe4, 0xf5, 0x35, 0xe4, 0x25, 0x34,
+	0x12, 0x1b, 0x9f, 0x12, 0x15, 0xf5, 0x5, 0x35, 0xe5, 0x35, 0xc3, 0x94, 0x20, 0x40, 0xee, 0x2,
+	0x16, 0xa9, 0x7b, 0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0xa, 0xae, 0xec, 0x54, 0xf, 0xfc, 0x7b,
+	0xe9, 0x7a, 0x50, 0x79, 0x38, 0x78, 0x7, 0xc3, 0x12, 0x4, 0xb7, 0x60, 0x3, 0x7f, 0x1, 0x22,
+	0x7f, 00, 0x22, 0x8f, 0x31, 0xe5, 0x31, 0xd3, 0x94, 0x9, 0x40, 0xb, 0xe5, 0x31, 0x75, 0xf0,
+	0xa, 0x84, 0x12, 0x1f, 0x45, 0x80, 0x2, 0x7f, 0x20, 0x12, 0x1d, 0xb3, 0xe5, 0x31, 0x12, 0x1f,
+	0x45, 0x2, 0x1d, 0xb3, 0xe4, 0xf5, 0x4e, 0x7f, 0x3, 0x12, 0x1f, 0x1d, 0xe4, 0xf5, 0x22, 0xaf,
+	0x22, 0x12, 0x1e, 0xa2, 0x50, 0x5, 0xaf, 0x22, 0x12, 0xc, 0xbe, 0x5, 0x22, 0xe5, 0x22, 0xc3,
+	0x94, 0x7, 0x40, 0xeb, 0x22, 0xe4, 0xf5, 0x51, 0xe5, 0x52, 0x25, 0xe0, 0xf5, 0x52, 0x12, 0x1f,
+	0x8d, 0x12, 0x1d, 0xfb, 0xef, 0x42, 0x52, 0x12, 0x1f, 0x95, 0x5, 0x51, 0xe5, 0x51, 0xc3, 0x94,
+	0x8, 0x40, 0xe5, 0xaf, 0x52, 0x22, 0x8f, 0x47, 0x7f, 0x5, 0x12, 0x1f, 0x9d, 0xe4, 0xfb, 0xad,
+	0x47, 0x7f, 0x60, 0x12, 0xa, 0xae, 0xef, 0x54, 0xb, 0x60, 0xa, 0x12, 0x1f, 0xda, 0x50, 0xed,
+	0x7f, 0x2, 0x12, 0x1f, 0xe2, 0x22, 0x75, 0x3d, 0x2, 0x75, 0x3e, 00, 0x7b, 00, 0x7a, 0x2,
+	0x22, 0x75, 0x3d, 0x2, 0x75, 0x3e, 00, 0xe4, 0xfb, 0xfa, 0x22, 0x75, 0x3d, 00, 0x75, 0x3e,
+	0xc, 0x7b, 0x8, 0x7a, 00, 0x22, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0xff,
+	0xe4, 0x34, 0x56, 0xfe, 0xe4, 0x34, 0x34, 0xfd, 0xe4, 0x34, 0x12, 0xfc, 0x22, 0xff, 0x74, 0x3,
+	0xa8, 0x6, 0x8, 0x22, 0xad, 0x7, 0xe4, 0xf5, 0x39, 0xf5, 0x38, 0x75, 0x37, 0x1, 0x75, 0x36,
+	0x10, 0xf5, 0x3d, 0xf5, 0x3c, 0x75, 0x3b, 0x1, 0x75, 0x3a, 0x18, 0xfb, 0x7f, 0x20, 0x2, 0x10,
+	0xc4, 0x8f, 0x26, 0x8d, 0x27, 0xe5, 0x26, 0x64, 0x5, 0x60, 0x11, 0xe5, 0x27, 0xfd, 0x7c, 00,
+	0xaf, 0x26, 0x12, 0x1d, 0xc5, 0xad, 0x27, 0xaf, 0x26, 0x12, 0x18, 0x3e, 0x22, 0xbf, 0x6, 0x3,
+	0x7f, 0x12, 0x22, 0x7d, 0x1c, 0x12, 0x13, 0x79, 0xef, 0x13, 0x13, 0x13, 0x54, 0x3, 0xfe, 0xef,
+	0x30, 0xe5, 0x3, 0x43, 0x6, 0x10, 0xaf, 0x6, 0x22, 0x8f, 0x2b, 0x12, 0x1e, 0x86, 0x7d, 0x1,
+	0xaf, 0x2b, 0x12, 0x1e, 0xcc, 0xaf, 0x2b, 0x12, 0xb, 00, 0x12, 0x12, 0xbc, 0xe4, 0xfd, 0xaf,
+	0x2b, 0x2, 0x1e, 0xcc, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e, 0xa2, 0x50, 0x5, 0xaf, 0x22,
+	0x12, 0xe, 0x78, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xeb, 0xc2, 0x9, 0x22, 0x8f,
+	0x2e, 0xe5, 0x2e, 0xc4, 0x54, 0xf, 0xff, 0x12, 0x1e, 0x77, 0x12, 0x1d, 0xb3, 0xe5, 0x2e, 0x54,
+	0xf, 0xff, 0x12, 0x1e, 0x77, 0x2, 0x1d, 0xb3, 0x8f, 0x27, 0x8e, 0x26, 0x8d, 0x25, 0x8c, 0x24,
+	0x78, 0x10, 0x12, 0x4, 0xc8, 0x12, 0x1e, 0x3b, 0xe5, 0x27, 0xff, 0xe5, 0x26, 0xfe, 0x2, 0x1e,
+	0x3b, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1f, 0x12, 0x74, 0xa4, 0x25, 0x22, 0xf8, 0xa6, 0x7,
+	0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xeb, 0x22, 0xd3, 0xef, 0x64, 0x80, 0xf8, 0x74,
+	0x61, 0x64, 0x80, 0x98, 0x50, 0xc, 0xef, 0x64, 0x80, 0x94, 0xfa, 0x50, 0x5, 0xef, 0x24, 0xe0,
+	0xff, 0x22, 0x22, 0x8f, 0x25, 0x12, 0x1b, 0xed, 0x8f, 0x26, 0x7d, 0x5, 0xaf, 0x25, 0x12, 0x13,
+	0x79, 0xee, 0x30, 0xe2, 0x3, 0x43, 0x26, 0x20, 0xaf, 0x26, 0x22, 0x75, 0xcb, 0xff, 0x75, 0xca,
+	0x2, 0x75, 0xcd, 0xff, 0x75, 0xcc, 0x2, 0x75, 0xc8, 0x34, 0x75, 0x98, 0x52, 0xd2, 0xbc, 0xd2,
+	0xac, 0x22, 0x12, 0x1a, 0xd2, 0xef, 0x60, 0x5, 0x7f, 0x5, 0x12, 0x1f, 0xe2, 0x12, 0x1d, 00,
+	0xef, 0x60, 0x5, 0x7f, 0x6, 0x12, 0x1f, 0xe2, 0x22, 0x8f, 0x36, 0x12, 0x1f, 0x74, 0x75, 0x3d,
+	0x3, 0x12, 0x1b, 0x79, 0x7d, 0xc, 0xaf, 0x36, 0x12, 0x19, 0xb0, 0xaf, 0x36, 0x2, 0x1f, 0x7d,
+	0xe4, 0xf5, 0x23, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e, 0xa2, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94,
+	0x7, 0x40, 0xf2, 0xaf, 0x23, 0x22, 0xe4, 0xf5, 0xff, 0xf5, 0xfe, 0xf5, 0xfd, 0x75, 0xfc, 0x1,
+	0x75, 0xf9, 0xe0, 0x75, 0xfb, 0x14, 0xd2, 0xf8, 0x80, 0xfe, 0xe5, 0x8, 0xfd, 0xe5, 0x9, 0xfb,
+	0x7f, 0x80, 0x12, 0xa, 0xae, 0x5, 0x9, 0xe5, 0x9, 0x70, 0x2, 0x5, 0x8, 0x22, 0xe4, 0xfb,
+	0x7d, 0x4, 0x7f, 0x80, 0x12, 0xa, 0xc2, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x2,
+	0xa, 0xc9, 0x8f, 0x24, 0xaf, 0x24, 0x15, 0x24, 0xef, 0xd3, 0x94, 00, 0x40, 0x7, 0x7f, 0x20,
+	0x12, 0x1d, 0xb3, 0x80, 0xef, 0x22, 0x8f, 0x55, 0x7b, 0x35, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0xa,
+	0xc2, 0xaf, 0x55, 0xe4, 0xfc, 0xfd, 0xfe, 0x2, 0xa, 0xc9, 0x53, 0x89, 0xf, 0x43, 0x89, 0x10,
+	0x75, 0x8b, 0x92, 0x75, 0x8d, 0xe6, 0xc2, 0xbb, 0xd2, 0xab, 0xd2, 0x8e, 0x22, 0xc2, 0x3, 0xae,
+	0x7, 0x1f, 0xee, 0xd3, 0x94, 00, 0x40, 0x7, 0x30, 0x3, 0xfd, 0xc2, 0x3, 0x80, 0xf0, 0x22,
+	0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0xa, 0xc2, 0x7f, 0x1, 0x12, 0x1f, 0xb2, 0x12, 0xa,
+	0xc9, 0x80, 0xfe, 0xc2, 0x6, 0x8f, 0x99, 0x7f, 0x2, 0x12, 0x1f, 0x9d, 0x20, 0x6, 0x5, 0x12,
+	0x1f, 0xda, 0x50, 0xf8, 0x22, 0x8f, 0x28, 0x8c, 0x29, 0x8d, 0x2a, 0x12, 0x1c, 0x9, 0xad, 0x2a,
+	0xac, 0x29, 0xaf, 0x28, 0x2, 0x9, 0xe2, 0xef, 0x60, 0x6, 0xe5, 0x55, 0x44, 0x2, 0x80, 0x4,
+	0xe5, 0x55, 0x54, 0xfd, 0xff, 0x12, 0x1d, 0x66, 0x22, 0xef, 0x60, 0x6, 0xe5, 0x55, 0x44, 0x1,
+	0x80, 0x4, 0xe5, 0x55, 0x54, 0xfe, 0xff, 0x12, 0x1d, 0x66, 0x22, 0x7b, 0x35, 0xe4, 0xfd, 0x7f,
+	0xe0, 0x12, 0xa, 0xae, 0xef, 0x54, 0x10, 0xc4, 0x54, 0xf, 0xff, 0x22, 0x5, 0xf, 0xe5, 0xf,
+	0xc3, 0x94, 0x96, 0x40, 0x6, 0xe4, 0xf5, 0xf, 0x12, 0x1f, 0xa4, 0x22, 0x49, 0xd, 0xa, 00,
+	0x69, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 0x74, 0x84, 0x25, 0x1f,
+	0xf8, 0xe6, 0xff, 0xe5, 0x1f, 0x4, 0x54, 0x1f, 0xf5, 0x1f, 0x22, 0x8e, 0x28, 0x8f, 0x29, 0xe5,
+	0x28, 0xff, 0x12, 0x1c, 0x3f, 0xaf, 0x29, 0x2, 0x1c, 0x3f, 0x5, 0x4d, 0xe5, 0x4d, 0xc3, 0x94,
+	0xa, 0x40, 0x5, 0xe4, 0xf5, 0x4d, 0xd2, 0x9, 0x22, 0x75, 0x3d, 0x12, 0x75, 0x3e, 00, 0x7b,
+	00, 0x7a, 0x12, 0xe4, 0xfd, 0x2, 0x19, 0xb0, 0x4c, 0x20, 0x32, 0x2e, 0x33, 0x31, 0x41, 0x74,
+	0x68, 0x33, 00, 00, 00, 00, 00, 0xef, 0xc3, 0x94, 0xa, 0xef, 0x50, 0x4, 0x24, 0x30,
+	0xff, 0x22, 0x24, 0x57, 0xff, 0x22, 0xad, 0x7, 0x75, 0x3b, 0x10, 0xe4, 0xf5, 0x3c, 0xfb, 0x7f,
+	0x20, 0x2, 0x17, 0x7d, 0x7d, 0x24, 0x12, 0x18, 0xc3, 0x7b, 00, 0x7a, 00, 0x79, 0x24, 0x2,
+	0x17, 0x49, 0xef, 0x90, 0x1e, 0xb7, 0x93, 0xd3, 0x94, 0x1, 0x50, 0x2, 0x80, 0x1, 0xc3, 0x22,
+	00, 0x1, 0x2, 0x3, 0x4, 0xff, 0x6, 00, 00, 00, 00, 00, 0xff, 0x1, 0x7d, 0x1,
+	0x12, 0x13, 0x79, 0xef, 0x30, 0xe2, 0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0x8f, 0x3b, 0x8d, 0x3c,
+	0x7b, 0xe, 0xe4, 0xfd, 0x7f, 0xa0, 0x2, 0x17, 0x7d, 0x8f, 0x3b, 0x8d, 0x3c, 0x7b, 0x10, 0xe4,
+	0xfd, 0x7f, 0x40, 0x2, 0x17, 0x7d, 0xe5, 0x1e, 0x65, 0x1f, 0x60, 0x3, 0xd3, 0x80, 0x1, 0xc3,
+	0x22, 0xe5, 0xaa, 0x54, 0x3, 0x60, 0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0x7f, 0x3, 0x7e, 00,
+	0x7d, 00, 0x7c, 00, 0x2, 0x18, 0x98, 0xa8, 0x1a, 0xe6, 0xb4, 0x20, 0x4, 0x5, 0x1a, 0x80,
+	0xf6, 0x22, 0x12, 0x1e, 0xa2, 0x50, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0xc2, 0x2, 0x8f,
+	0xe, 0xd2, 0x2, 0x20, 0x2, 0xfd, 0x22, 0xeb, 0x75, 0xf0, 0x20, 0xa4, 0x4d, 0xac, 0xf0, 0xfd,
+	0x22, 0x7f, 0x30, 0x12, 0x1d, 0xb3, 0x7f, 0x78, 0x2, 0x1d, 0xb3, 0x7f, 0xd, 0x12, 0x1d, 0xb3,
+	0x7f, 0xa, 0x2, 0x1d, 0xb3, 0x75, 0xf0, 0xa, 0x84, 0xe5, 0xf0, 0x24, 0x30, 0xff, 0x22, 0x8f,
+	0x34, 0x12, 0x18, 0xf, 0xaf, 0x34, 0x2, 0xc, 0xbe, 0xef, 0x64, 0x6, 0x60, 0x3, 0x12, 0x1c,
+	0xe9, 0x22, 0x7b, 0x1, 0x7a, 00, 0x7d, 0x1f, 0x2, 0x17, 0xdf, 0x7b, 0xb5, 0x7a, 0x52, 0x7d,
+	0x1f, 0x2, 0x17, 0xdf, 0x7b, 0x30, 0x7a, 0x2a, 0x7d, 0x1f, 0x2, 0x17, 0xdf, 0xe4, 0xfb, 0xfa,
+	0x7d, 0x1f, 0x2, 0x17, 0xdf, 0x7d, 0x32, 0x12, 0x18, 0xc3, 0xaf, 0x37, 0x22, 0xe5, 0x55, 0x44,
+	0x4, 0xff, 0x2, 0x1d, 0x66, 0xe5, 0x55, 0x54, 0xfb, 0xff, 0x2, 0x1d, 0x66, 0xc2, 0x2, 0x8f,
+	0xe, 0xd2, 0x2, 0x22, 0x7f, 0x3, 0x7e, 00, 0x2, 0x16, 0xe0, 0x7f, 0x5, 0x7e, 00, 0x2,
+	0x16, 0xe0, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0x7b, 00, 0x7a, 00, 0x79, 0x4e, 0x22,
+	0xef, 0x90, 0x1e, 0xb7, 0x93, 0xff, 0x22, 0xef, 0x90, 0x1e, 0xb0, 0x93, 0xff, 0x22, 00, 0x1,
+	0x2, 0x3, 0x4, 0x6, 0x5, 0x75, 0x22, 0x1, 0x80, 0xfe, 0xa2, 0x2, 0xb3, 0x22, 0x12, 0x11,
+	0xf6, 0x22, 0xd2, 0x7, 0x22, 0x2, 0x1d, 0xb3, 0x2, 0x16, 0x31, 0x22, 0x22, 0x22,
+};
diff --git a/board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v4.c b/board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v4.c
new file mode 100644
index 0000000000..7608c6f13e
--- /dev/null
+++ b/board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v4.c
@@ -0,0 +1,509 @@
+/*
+ * Microcode for VSC 7395, with
+ *	- 3 delay in RGMII port
+ *	- Latest phy settings
+ *	- Flush port entries when link goes down
+ *	  (to avoid ~30sec delay when we move between
+ *	  different ports of the switch)
+ */
+static unsigned char g5_Plus1_2_31_unmanaged_Atheros_v4 [] = {
+	0x2, 0xc, 0x68, 0x8f, 0x2e, 0x12, 0x1e, 0xef, 0x12, 0x9, 0xc3, 0x50, 0x3, 0x7f, 0x1, 0x22,
+	0xe5, 0x2e, 0xb4, 0x6, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x2, 0x19, 0x5f, 0x7e, 00,
+	0x2, 0x9, 0xf6, 0x2, 0x14, 0x87, 0x78, 0x59, 0x12, 0x4, 0xee, 0xad, 0x7, 0x22, 0x78, 0x5d,
+	0x12, 0x4, 0xee, 0xab, 0x7, 0x22, 0x78, 0x55, 0x12, 0x4, 0xee, 0x78, 0x5, 0x2, 0x4, 0xdb,
+	00, 0x1, 0xc1, 00, 00, 00, 0x8f, 0x23, 0x8d, 0x24, 0x8b, 0x25, 0xe5, 0x25, 0x7b, 0xff,
+	0x60, 0x6, 0x7a, 0x1d, 0x79, 0x5d, 0x80, 0x4, 0x7a, 0x1d, 0x79, 0x5c, 0x12, 0x19, 0x84, 0x7b,
+	0xff, 0x7a, 0x1d, 0x79, 0x5e, 0x12, 0x19, 0x84, 0xe5, 0x23, 0xc3, 0x94, 0x7, 0x40, 0x8, 0xe4,
+	0xf5, 0x23, 0x75, 0x26, 0x6, 0x80, 0x11, 0xe5, 0x25, 0x60, 0xa, 0x53, 0x23, 0xfe, 0xe5, 0x23,
+	0x4, 0xf5, 0x26, 0x80, 0x3, 0x85, 0x23, 0x26, 0xe5, 0x24, 0xb4, 0xff, 0x5, 0x75, 0x28, 0x7,
+	0x80, 0xf, 0xaf, 0x24, 0x74, 0x1, 0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf5,
+	0x28, 0x7b, 0xd, 0x12, 0x3, 0x13, 0x7b, 0xe, 0x12, 0x3, 0x13, 0x12, 0x3, 0x4e, 0x12, 0x1a,
+	0xb3, 0x12, 0x9, 0x47, 0xe5, 0x23, 0x90, 0x1f, 0x4, 0x93, 0xf5, 0x2f, 0xe5, 0x25, 0x60, 0x1e,
+	0xe5, 0x23, 0x24, 0x1, 0xff, 0xe4, 0x33, 0xfe, 0xc3, 0xef, 0x94, 0x7, 0xee, 0x64, 0x80, 0x94,
+	0x80, 0x50, 0x8, 0xe5, 0x23, 0xa3, 0x93, 0xf5, 0x30, 0x80, 0x3, 0x75, 0x30, 0x7, 0x7e, 00,
+	0x7f, 0x2, 0x7d, 0xff, 0x7b, 00, 0x7a, 00, 0x79, 0x29, 0x12, 0x5, 0x16, 0x75, 0x27, 0x2,
+	0xe5, 0x27, 0xf4, 0x70, 0x3, 0x2, 0x2, 0x50, 0x74, 0x1, 0x7e, 00, 0xa8, 0x27, 0x8, 0x80,
+	0x5, 0xc3, 0x33, 0xce, 0x33, 0xce, 0xd8, 0xf9, 0xff, 0xef, 0x55, 0x28, 0x70, 0x3, 0x2, 0x2,
+	0x4b, 0xe5, 0x27, 0xd3, 0x94, 0x2, 0x40, 0x3, 0x2, 0x1, 0xec, 0xaf, 0x2f, 0x12, 0x1d, 0xd8,
+	0x40, 0x3, 0x2, 0x2, 0x4b, 0xaf, 0x30, 0x12, 0x1d, 0xd8, 0x50, 0x7, 0xe5, 0x30, 0xc3, 0x94,
+	0x7, 0x40, 0x7, 0xe5, 0x25, 0x60, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x2f, 0x64, 0x6, 0x70, 0x1b,
+	0xe5, 0x27, 0x70, 0x9, 0x12, 0x3, 0x45, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x27, 0xb4,
+	0x1, 0x9, 0x12, 0x3, 0x45, 0x20, 0xe6, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x25, 0x60, 0x67, 0xe5,
+	0x27, 0xc3, 0x94, 0x2, 0x50, 0x6f, 0xe5, 0x30, 0x64, 0x6, 0x70, 0x25, 0xe5, 0x27, 0x70, 0xe,
+	0x7d, 0x1, 0xaf, 0x30, 0x12, 0x12, 0x8a, 0xee, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x27,
+	0xb4, 0x1, 0xe, 0x7d, 0x1, 0xaf, 0x30, 0x12, 0x12, 0x8a, 0xee, 0x20, 0xe6, 0x3, 0x2, 0x2,
+	0x4b, 0x12, 0x3, 0x58, 0xe4, 0xf5, 0x2d, 0xf5, 0x2e, 0xaf, 0x2f, 0x12, 0x1d, 0xf4, 0x50, 0x7,
+	0xaf, 0x30, 0x12, 0x1d, 0xf4, 0x40, 0x2e, 0xe5, 0x2e, 0xc3, 0x94, 0x3, 0x50, 0x27, 0x7f, 0xa,
+	0x12, 0x1c, 0xc3, 0x5, 0x2d, 0xe5, 0x2d, 0xc3, 0x94, 0xfa, 0x40, 0xdd, 0x12, 0x3, 0x58, 0x5,
+	0x2e, 0xe4, 0xf5, 0x2d, 0x80, 0xd3, 0xe5, 0x27, 0x44, 0x90, 0xfd, 0xaf, 0x2f, 0x12, 0x13, 0x33,
+	0x7f, 0xa, 0x12, 0x1e, 0x53, 0xad, 0x27, 0xaf, 0x2f, 0x12, 0x10, 0x3d, 0xe5, 0x25, 0x60, 0x7,
+	0xad, 0x27, 0xaf, 0x30, 0x12, 0x10, 0x3d, 0x7f, 0x5, 0x12, 0x1e, 0x53, 0xe5, 0x25, 0x60, 0x41,
+	0xad, 0x30, 0x12, 0x3, 0x36, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1a, 0xca, 0x80, 0x2,
+	0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x29, 0x4f, 0xf5, 0x29, 0xad, 0x2f, 0xaf, 0x30, 0x12, 0xe,
+	0xfe, 0xe5, 0x27, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x6, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc,
+	0x12, 0x1a, 0xca, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0x80,
+	0x1a, 0xad, 0x2f, 0x12, 0x3, 0x36, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1a, 0xca, 0x80,
+	0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x29, 0x4f, 0xf5, 0x29, 0x15, 0x27, 0x2, 00, 0xf0,
+	0xe4, 0xf5, 0x2c, 0xe5, 0x25, 0x70, 0x7, 0xe5, 0x2c, 0xc3, 0x94, 0x1, 0x40, 0xe, 0xe5, 0x25,
+	0x70, 0x3, 0x2, 0x2, 0xe5, 0xe5, 0x2c, 0xc3, 0x94, 0x2, 0x50, 0x79, 0x12, 0x1e, 0x71, 0xaf,
+	0x23, 0x12, 0x1a, 0x30, 0xe4, 0xf5, 0x27, 0xe5, 0x27, 0x25, 0xe0, 0xff, 0x74, 0x29, 0x25, 0x2c,
+	0xf8, 0xe6, 0xfe, 0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x13, 0xd8, 0xfc, 0x54, 0x3, 0xf5, 0x2b,
+	0x64, 0x3, 0x60, 0x1f, 0xe5, 0x2b, 0x7b, 0xff, 0x70, 0x9, 0x7a, 0x1d, 0x79, 0x5f, 0x12, 0x19,
+	0x84, 0x80, 0x10, 0x7a, 0x1d, 0x79, 0x60, 0x12, 0x19, 0x84, 0xaf, 0x2b, 0xe4, 0xfc, 0xfd, 0xfe,
+	0x12, 0xe, 0x88, 0x5, 0x27, 0xe5, 0x27, 0xc3, 0x94, 0x3, 0x40, 0xbb, 0xe5, 0x2c, 0x70, 0xb,
+	0xaf, 0x2f, 0x12, 0x1d, 0xd8, 0x50, 0x10, 0xaf, 0x2f, 0x80, 0x9, 0xaf, 0x30, 0x12, 0x1d, 0xd8,
+	0x50, 0x5, 0xaf, 0x30, 0x12, 0x1e, 0x85, 0x5, 0x23, 0xe5, 0x23, 0xd3, 0x95, 0x26, 0x50, 0x5,
+	0x5, 0x2c, 0x2, 0x2, 0x53, 0xe5, 0x23, 0xd3, 0x95, 0x26, 0x50, 0x3, 0x2, 00, 0xb4, 0x7b,
+	0xff, 0x7a, 0x1d, 0x79, 0x61, 0x12, 0x19, 0x84, 0x7b, 0xd, 0x12, 0x3, 0x26, 0x12, 0x9, 0x47,
+	0x7b, 0xe, 0x12, 0x3, 0x26, 0x12, 0x9, 0x47, 0x12, 0x3, 0x4e, 0x7f, 0x5f, 0x12, 0x1a, 0xb5,
+	0x2, 0x9, 0x47, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x40, 0x7f, 00, 0x7e, 00, 0x7d, 00,
+	0x7c, 00, 0x12, 0x9, 0x47, 0x22, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x40, 0x7f, 0x5f, 0x7e,
+	00, 0x7d, 00, 0x7c, 00, 0x22, 0xaf, 0x2f, 0x12, 0xe, 0xfe, 0xe5, 0x27, 0x25, 0xe0, 0xfe,
+	0xef, 0xa8, 0x6, 0x8, 0x22, 0x7d, 0x1, 0xaf, 0x2f, 0x12, 0x12, 0x8a, 0xee, 0x22, 0x7b, 0xf,
+	0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x40, 0x22, 0xab, 0x27, 0xad, 0x30, 0xaf, 0x2f, 0x12, 0x18,
+	0x7a, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x2, 0xe7, 0x22, 0xbb,
+	0xfe, 0x2, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82,
+	0x8a, 0x83, 0xf0, 0x22, 0x50, 0x2, 0xf7, 0x22, 0xbb, 0xfe, 0x1, 0xf3, 0x22, 0xe8, 0x8f, 0xf0,
+	0xa4, 0xcc, 0x8b, 0xf0, 0xa4, 0x2c, 0xfc, 0xe9, 0x8e, 0xf0, 0xa4, 0x2c, 0xfc, 0x8a, 0xf0, 0xed,
+	0xa4, 0x2c, 0xfc, 0xea, 0x8e, 0xf0, 0xa4, 0xcd, 0xa8, 0xf0, 0x8b, 0xf0, 0xa4, 0x2d, 0xcc, 0x38,
+	0x25, 0xf0, 0xfd, 0xe9, 0x8f, 0xf0, 0xa4, 0x2c, 0xcd, 0x35, 0xf0, 0xfc, 0xeb, 0x8e, 0xf0, 0xa4,
+	0xfe, 0xa9, 0xf0, 0xeb, 0x8f, 0xf0, 0xa4, 0xcf, 0xc5, 0xf0, 0x2e, 0xcd, 0x39, 0xfe, 0xe4, 0x3c,
+	0xfc, 0xea, 0xa4, 0x2d, 0xce, 0x35, 0xf0, 0xfd, 0xe4, 0x3c, 0xfc, 0x22, 0x75, 0xf0, 0x8, 0x75,
+	0x82, 00, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xcd, 0x33, 0xcd, 0xcc, 0x33, 0xcc, 0xc5, 0x82,
+	0x33, 0xc5, 0x82, 0x9b, 0xed, 0x9a, 0xec, 0x99, 0xe5, 0x82, 0x98, 0x40, 0xc, 0xf5, 0x82, 0xee,
+	0x9b, 0xfe, 0xed, 0x9a, 0xfd, 0xec, 0x99, 0xfc, 0xf, 0xd5, 0xf0, 0xd6, 0xe4, 0xce, 0xfb, 0xe4,
+	0xcd, 0xfa, 0xe4, 0xcc, 0xf9, 0xa8, 0x82, 0x22, 0xb8, 00, 0xc1, 0xb9, 00, 0x59, 0xba, 00,
+	0x2d, 0xec, 0x8b, 0xf0, 0x84, 0xcf, 0xce, 0xcd, 0xfc, 0xe5, 0xf0, 0xcb, 0xf9, 0x78, 0x18, 0xef,
+	0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xeb, 0x33, 0xfb, 0x10, 0xd7,
+	0x3, 0x99, 0x40, 0x4, 0xeb, 0x99, 0xfb, 0xf, 0xd8, 0xe5, 0xe4, 0xf9, 0xfa, 0x22, 0x78, 0x18,
+	0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xc9, 0x33, 0xc9, 0x10,
+	0xd7, 0x5, 0x9b, 0xe9, 0x9a, 0x40, 0x7, 0xec, 0x9b, 0xfc, 0xe9, 0x9a, 0xf9, 0xf, 0xd8, 0xe0,
+	0xe4, 0xc9, 0xfa, 0xe4, 0xcc, 0xfb, 0x22, 0x75, 0xf0, 0x10, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe,
+	0xed, 0x33, 0xfd, 0xcc, 0x33, 0xcc, 0xc8, 0x33, 0xc8, 0x10, 0xd7, 0x7, 0x9b, 0xec, 0x9a, 0xe8,
+	0x99, 0x40, 0xa, 0xed, 0x9b, 0xfd, 0xec, 0x9a, 0xfc, 0xe8, 0x99, 0xf8, 0xf, 0xd5, 0xf0, 0xda,
+	0xe4, 0xcd, 0xfb, 0xe4, 0xcc, 0xfa, 0xe4, 0xc8, 0xf9, 0x22, 0xcf, 0xf4, 0xcf, 0xce, 0xf4, 0xce,
+	0xcd, 0xf4, 0xcd, 0xcc, 0xf4, 0xcc, 0x22, 0xeb, 0x9f, 0xf5, 0xf0, 0xea, 0x9e, 0x42, 0xf0, 0xe9,
+	0x9d, 0x42, 0xf0, 0xe8, 0x9c, 0x45, 0xf0, 0x22, 0xe8, 0x60, 0xf, 0xec, 0xc3, 0x13, 0xfc, 0xed,
+	0x13, 0xfd, 0xee, 0x13, 0xfe, 0xef, 0x13, 0xff, 0xd8, 0xf1, 0x22, 0xe8, 0x60, 0xf, 0xef, 0xc3,
+	0x33, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xd8, 0xf1, 0x22, 0xe6, 0xfc,
+	0x8, 0xe6, 0xfd, 0x8, 0xe6, 0xfe, 0x8, 0xe6, 0xff, 0x22, 0xe4, 0x93, 0xfc, 0x74, 0x1, 0x93,
+	0xfd, 0x74, 0x2, 0x93, 0xfe, 0x74, 0x3, 0x93, 0xff, 0x22, 0xec, 0xf6, 0x8, 0xed, 0xf6, 0x8,
+	0xee, 0xf6, 0x8, 0xef, 0xf6, 0x22, 0xef, 0x4e, 0x60, 0x12, 0xef, 0x60, 0x1, 0xe, 0xed, 0xbb,
+	0x1, 0xb, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0xa3, 0xdf, 0xfc, 0xde, 0xfa, 0x22, 0x89, 0xf0, 0x50,
+	0x7, 0xf7, 0x9, 0xdf, 0xfc, 0xa9, 0xf0, 0x22, 0xbb, 0xfe, 0xfc, 0xf3, 0x9, 0xdf, 0xfc, 0xa9,
+	0xf0, 0x22, 0xa8, 0x1a, 0xe6, 0xf5, 0x23, 0x64, 0x20, 0x60, 0x9, 0xe5, 0x23, 0x64, 0xd, 0x60,
+	0x3, 0x7f, 0x1, 0x22, 0xe4, 0xf5, 0x19, 0xfe, 0x7f, 0x10, 0x7d, 0xff, 0xfb, 0x7a, 00, 0x79,
+	0x55, 0x12, 0x5, 0x16, 0x12, 0x1e, 0x3d, 0x75, 0x24, 0xa, 0xe4, 0xf5, 0x26, 0xa8, 0x1a, 0xe6,
+	0x64, 0x30, 0x70, 0x1b, 0xe8, 0x4, 0xf8, 0xe6, 0xff, 0x12, 0x1b, 0xc0, 0xbf, 0x58, 0x10, 0x75,
+	0x24, 0x10, 0x5, 0x1a, 0x5, 0x1a, 0xa8, 0x1a, 0xe6, 0xb4, 0x20, 0x3, 0x7f, 0x1, 0x22, 0xa8,
+	0x1a, 0xe6, 0xf5, 0x23, 0x64, 0x20, 0x60, 0x6, 0xe5, 0x23, 0x64, 0xd, 0x70, 0x7c, 0xe5, 0x26,
+	0xd3, 0x94, 00, 0x40, 0x6a, 0xe4, 0xf5, 0x34, 0xf5, 0x33, 0xf5, 0x32, 0xf5, 0x31, 0xf5, 0x25,
+	0xe5, 0x25, 0xc3, 0x95, 0x26, 0x50, 0x3a, 0xaf, 0x24, 0xe4, 0xfc, 0xfd, 0xfe, 0xab, 0x34, 0xaa,
+	0x33, 0xa9, 0x32, 0xa8, 0x31, 0x12, 0x3, 0x8d, 0xc0, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7,
+	0x74, 0x27, 0x25, 0x25, 0xf8, 0xe6, 0xff, 0xe4, 0xfc, 0xfd, 0xfe, 0xd0, 00, 0xeb, 0x2f, 0xf5,
+	0x34, 0xee, 0x3a, 0xf5, 0x33, 0xed, 0x39, 0xf5, 0x32, 0xec, 0x38, 0xf5, 0x31, 0x5, 0x25, 0x80,
+	0xbf, 0xe5, 0x19, 0xc3, 0x94, 0x4, 0x50, 0x17, 0xaf, 0x34, 0xae, 0x33, 0xad, 0x32, 0xac, 0x31,
+	0xab, 0x19, 0x5, 0x19, 0xeb, 0x25, 0xe0, 0x25, 0xe0, 0x24, 0x55, 0xf8, 0x12, 0x5, 0xa, 0xe5,
+	0x23, 0x64, 0xd, 0x60, 0x3, 0x2, 0x5, 0x64, 0xff, 0x22, 0xaf, 0x23, 0x12, 0x19, 0x39, 0x8f,
+	0x23, 0xe5, 0x23, 0xf4, 0x60, 0x1d, 0xe5, 0x26, 0xc3, 0x94, 0xa, 0x50, 0x19, 0xaf, 0x26, 0x5,
+	0x26, 0x74, 0x27, 0x2f, 0xf8, 0xa6, 0x23, 0xe5, 0x23, 0xd3, 0x94, 0x9, 0x40, 0x8, 0x75, 0x24,
+	0x10, 0x80, 0x3, 0x7f, 0x1, 0x22, 0x5, 0x1a, 0x2, 0x5, 0x8f, 0xa8, 0x1a, 0xe6, 0xf5, 0x22,
+	0x5, 0x1a, 0x12, 0x5, 0x42, 0xef, 0x60, 0x3, 0x7f, 0x1, 0x22, 0xaf, 0x22, 0x12, 0x1b, 0xc0,
+	0xef, 0x24, 0xb7, 0x60, 0x64, 0x24, 0xfa, 0x60, 0x7a, 0x24, 0xfd, 0x60, 0x17, 0x24, 0xfe, 0x70,
+	0x3, 0x2, 0x7, 0xd, 0x24, 0xfd, 0x60, 0x28, 0x4, 0x60, 0x3, 0x2, 0x7, 0x48, 0x12, 0x10,
+	0xa2, 0x2, 0x7, 0x4b, 0x12, 0x1e, 0x67, 0x12, 00, 0x36, 0xc0, 0x7, 0x12, 00, 0x26, 0xc0,
+	0x5, 0x12, 00, 0x2e, 0xd0, 0x5, 0xd0, 0x7, 0x12, 0x9, 0x2c, 0x12, 0x1b, 0x8e, 0x80, 0x3e,
+	0xe5, 0x19, 0xc3, 0x94, 0x4, 0x50, 0x3, 0x2, 0x7, 0x4b, 0x12, 00, 0x36, 0xc0, 0x7, 0x12,
+	00, 0x26, 0xc0, 0x5, 0x12, 00, 0x2e, 0xd0, 0x5, 0xd0, 0x7, 0x12, 0x9, 0x40, 0x78, 0x61,
+	0x12, 0x4, 0xee, 0x12, 0x9, 0x47, 0x2, 0x7, 0x4b, 0x12, 0x1e, 0x67, 0x78, 0x55, 0x12, 0x4,
+	0xee, 0xc0, 0x7, 0x12, 00, 0x26, 0xd0, 0x7, 0x12, 0x12, 0x8a, 0x12, 0x1d, 0x71, 0x12, 0x1e,
+	0x71, 0x80, 0x68, 0xe5, 0x19, 0xc3, 0x94, 0x3, 0x40, 0x61, 0x78, 0x55, 0x12, 0x4, 0xee, 0xc0,
+	0x7, 0x12, 00, 0x26, 0xc0, 0x5, 0x12, 00, 0x2e, 0xaa, 0x6, 0x78, 0x61, 0x12, 0x4, 0xee,
+	0x8e, 0x3c, 0x8f, 0x3d, 0xd0, 0x5, 0xd0, 0x7, 0x12, 0x18, 0xed, 0x80, 0x3e, 0x78, 0x55, 0x12,
+	0x4, 0xee, 0xef, 0x24, 0xfe, 0x60, 0x17, 0x4, 0x70, 0x2b, 0x78, 0x59, 0x12, 0x4, 0xee, 0xc0,
+	0x7, 0x78, 0x5d, 0x12, 0x4, 0xee, 0xad, 0x7, 0xd0, 0x7, 0xe4, 0xfb, 0x80, 0x12, 0x78, 0x59,
+	0x12, 0x4, 0xee, 0xc0, 0x7, 0x78, 0x5d, 0x12, 0x4, 0xee, 0xad, 0x7, 0xd0, 0x7, 0x7b, 0x1,
+	0x12, 00, 0x46, 0x80, 0x6, 0x7f, 0x1, 0x22, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x8f, 0x2a,
+	0x7f, 0x1, 0xed, 0x54, 0x30, 0xfe, 0xbe, 0x30, 0x4, 0x7e, 0x1, 0x80, 0x2, 0x7e, 00, 0xed,
+	0x54, 0x3, 0xfc, 0xbc, 0x2, 0x4, 0x7c, 0x1, 0x80, 0x2, 0x7c, 00, 0x8c, 0x2c, 0xed, 0x20,
+	0xe4, 0x7, 0xef, 0x60, 0x4, 0x7d, 0x1, 0x80, 0x2, 0x7d, 00, 0xef, 0x60, 0x3, 0xee, 0x70,
+	0x3, 0xed, 0x60, 0x4, 0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x8f, 0x2b, 0x7d, 0x30, 0xaf, 0x2a,
+	0x12, 0x18, 00, 0x7b, 0x8, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9, 0x40, 0xe5, 0x31, 0xfe, 0xe5,
+	0x32, 0xff, 0xad, 0x30, 0x7c, 00, 0x12, 0x9, 0x5d, 0x12, 0x9, 0x47, 0x7b, 0xc, 0xad, 0x2a,
+	0x7f, 0x20, 0x12, 0x9, 0x40, 0xe5, 0x34, 0xfe, 0xe5, 0x35, 0xff, 0xad, 0x33, 0x7c, 00, 0x12,
+	0x9, 0x5d, 0x12, 0x9, 0x47, 0xe5, 0x2b, 0x60, 0x1e, 0x75, 0x2d, 0x17, 0x75, 0x2e, 0x5, 0x12,
+	0x8, 0x3a, 0x7f, 0xff, 0x7e, 00, 0x7d, 0x3, 0x7c, 00, 0x12, 0x9, 0x47, 0x85, 0x2a, 0x3b,
+	0xe4, 0xf5, 0x3c, 0x7b, 0x12, 0x80, 0x1d, 0x75, 0x2d, 0x16, 0x75, 0x2e, 0xed, 0x12, 0x8, 0x3a,
+	0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x47, 0x85, 0x2a, 0x3b, 0x75, 0x3c,
+	0x1, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x12, 0x16, 0xbb, 0xe4, 0xf5, 0x2f, 0xe5, 0x2f, 0x24,
+	0xde, 0xfb, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9, 0x40, 0x85, 0x2e, 0x82, 0x85, 0x2d, 0x83, 0x12,
+	0x4, 0xfa, 0x12, 0x9, 0x47, 0x74, 0x4, 0x25, 0x2e, 0xf5, 0x2e, 0xe4, 0x35, 0x2d, 0xf5, 0x2d,
+	0x5, 0x2f, 0xe5, 0x2f, 0xc3, 0x94, 0x6, 0x40, 0xd4, 0x22, 0x7b, 0x4, 0xad, 0x2a, 0x7f, 0x20,
+	0x12, 0x9, 0x40, 0x22, 0x8f, 0x2b, 0x8c, 0x2c, 0x8d, 0x2d, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70,
+	0xa, 0xf5, 0x31, 0xf5, 0x30, 0xf5, 0x2f, 0xf5, 0x2e, 0x80, 0x12, 0xe5, 0x2d, 0x54, 0x13, 0xfd,
+	0xaf, 0x2b, 0x12, 0x11, 0x6c, 0x8f, 0x31, 0x8e, 0x30, 0x8d, 0x2f, 0x8c, 0x2e, 0xe4, 0xf5, 0x39,
+	0xf5, 0x38, 0xf5, 0x37, 0x75, 0x36, 0x80, 0xf5, 0x3d, 0xf5, 0x3c, 0xf5, 0x3b, 0x75, 0x3a, 0x80,
+	0x7b, 0xdf, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0xf, 0xd5, 0x12, 0x9, 0x22, 0xe5, 0x31, 0x54, 0xf8,
+	0xff, 0xe5, 0x30, 0xfe, 0xe5, 0x2f, 0xfd, 0xe5, 0x2e, 0xfc, 0xef, 0x44, 0x31, 0xff, 0xec, 0x44,
+	0x20, 0xfc, 0x12, 0x9, 0x47, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0x23, 0xfd, 0xaf, 0x2b, 0x12,
+	0x1e, 0xf, 0x12, 0x9, 0x22, 0x7f, 0x30, 0x7e, 00, 0x7d, 00, 0x7c, 0x20, 0x12, 0x9, 0x47,
+	0x85, 0x2b, 0x3b, 0x75, 0x3c, 0x1, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x2, 0x16, 0xbb, 0xaf,
+	0x2b, 0x12, 0x1e, 0xbb, 0xe4, 0xfc, 0xfd, 0xfe, 0x78, 0x13, 0x12, 0x4, 0xdb, 0xec, 0x44, 0x8,
+	0xfc, 0xe5, 0x31, 0x4f, 0xf5, 0x31, 0xe5, 0x30, 0x4e, 0xf5, 0x30, 0xe5, 0x2f, 0x4d, 0xf5, 0x2f,
+	0xe5, 0x2e, 0x4c, 0xf5, 0x2e, 0xe4, 0xfb, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0x9, 0x40, 0xaf, 0x31,
+	0xae, 0x30, 0xad, 0x2f, 0xac, 0x2e, 0x12, 0x9, 0x47, 0xaf, 0x2b, 0x12, 0x1a, 0xd1, 0xe5, 0x2d,
+	0x54, 0x13, 0xfd, 0xaf, 0x2b, 0x12, 0x18, 0xa1, 0xe5, 0x2b, 0xb4, 0x6, 0x4, 0xff, 0x12, 0x13,
+	0xc1, 0x22, 0xe4, 0xfb, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0x9, 0x40, 0x22, 0xef, 0x2d, 0xf5, 0xf9,
+	0x8b, 0xfa, 0x30, 0xf8, 0xfd, 0xd2, 0xf8, 0xac, 0xff, 0xad, 0xfe, 0xae, 0xfd, 0xaf, 0xfc, 0x22,
+	0xef, 0x2d, 0xf5, 0x4a, 0x8b, 0x4b, 0x22, 0x8c, 0xff, 0x8d, 0xfe, 0x8e, 0xfd, 0x8f, 0xfc, 0xe5,
+	0x4a, 0xf5, 0xf9, 0xe5, 0x4b, 0xf5, 0xfb, 0x30, 0xf8, 0xfd, 0xd2, 0xf8, 0x22, 0x22, 0xec, 0xfe,
+	0xed, 0xff, 0x22, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0xe4, 0xfe, 0xcf, 0x90, 0x9,
+	0x63, 0xb4, 0x8, 00, 0x50, 0x3, 0x93, 0xff, 0x22, 0x94, 0x8, 0x93, 0xfe, 0x22, 0xef, 0x90,
+	0x9, 0x63, 0x93, 0xff, 0x22, 0x90, 0x9, 0x63, 0xef, 0x93, 0xff, 0xf4, 0xfe, 0xbb, 0x1, 0xe,
+	0x89, 0x82, 0x8a, 0x83, 0xe0, 0x5e, 0xbd, 00, 0x2, 0x80, 0x1, 0x4f, 0xf0, 0x22, 0xbb, 00,
+	0xb, 0xe9, 0xf8, 0xe6, 0x5e, 0xbd, 00, 0x2, 0x80, 0x1, 0x4f, 0xf6, 0x22, 0x74, 0x1f, 0xc3,
+	0x9f, 0x13, 0x13, 0x13, 0x54, 0x3, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x7, 0x5f, 0xff, 0x12,
+	0x9, 0x85, 0x22, 0x90, 0x9, 0x63, 0xef, 0x93, 0xff, 0xbb, 0x1, 0x7, 0x89, 0x82, 0x8a, 0x83,
+	0xe0, 0x80, 0x6, 0xbb, 00, 0x8, 0xe9, 0xf8, 0xe6, 0x5f, 0x60, 0x2, 0xd3, 0x22, 0xc3, 0x22,
+	0x74, 0x1f, 0xc3, 0x9f, 0x13, 0x13, 0x13, 0x54, 0x3, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x7,
+	0x5f, 0xff, 0x12, 0x9, 0xc3, 0x22, 0xab, 0x7, 0xaa, 0x6, 0xe4, 0xf5, 0x29, 0xf5, 0x28, 0xf5,
+	0x27, 0xf5, 0x26, 0xeb, 0x4a, 0x70, 0x8, 0xf5, 0x29, 0xf5, 0x28, 0xf5, 0x27, 0x80, 0x53, 0xeb,
+	0x64, 0x1, 0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x1, 0x80, 0x44, 0xeb, 0x64,
+	0x2, 0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x2, 0x80, 0x35, 0xeb, 0x64, 0x3,
+	0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x3, 0x80, 0x26, 0xeb, 0x64, 0x4, 0x4a,
+	0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x4, 0x80, 0x17, 0xeb, 0x64, 0x5, 0x4a, 0x70,
+	0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x5, 0x80, 0x8, 0xe4, 0xf5, 0x29, 0xf5, 0x28, 0x75,
+	0x27, 0x6, 0x75, 0x26, 0x80, 0x12, 0xa, 0x8f, 0xaf, 0x29, 0xae, 0x28, 0xad, 0x27, 0xac, 0x26,
+	0x12, 0x9, 0x47, 0x7f, 0x3, 0x7e, 00, 0x12, 0x15, 0xe9, 0x7f, 0x3, 0x7e, 00, 0x12, 0x15,
+	0xe9, 0x12, 0xa, 0x8f, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x2, 0x9, 0x47, 0x7b,
+	0x9, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x40, 0x22, 0x8f, 0x37, 0x12, 0x1e, 0xaa, 0x12, 0x17,
+	0x89, 0x12, 0xb, 0x28, 0x12, 0x1e, 0xa1, 0x7a, 0xaf, 0x12, 0xb, 0x14, 0x12, 0x17, 0x9e, 0x12,
+	0xa, 0xfe, 0x7a, 0x8f, 0x12, 0xb, 0x14, 0x7a, 0xaf, 0x12, 0xb, 0x1e, 0xe4, 0xf5, 0x3c, 0xf5,
+	0x3d, 0xfb, 0xfa, 0x7d, 0x11, 0xaf, 0x37, 0x12, 0x18, 0xed, 0x12, 0x17, 0x9e, 0x7d, 0x12, 0xaf,
+	0x37, 0x12, 0x18, 0xed, 0x7a, 0x8f, 0x12, 0xb, 0x1e, 0x7a, 0xaf, 0x12, 0xb, 0x32, 0x75, 0x3c,
+	0x1, 0x75, 0x3d, 0x80, 0x7b, 00, 0x7a, 0x1, 0x12, 0xa, 0xfe, 0x7a, 0x8f, 0x12, 0xb, 0x32,
+	0xaf, 0x37, 0x12, 0x1e, 0xaa, 0x12, 0x17, 0x94, 0x12, 0xb, 0x28, 0x2, 0x1e, 0xb3, 0x7d, 0x11,
+	0xaf, 0x37, 0x12, 0x18, 0xed, 0xe4, 0xf5, 0x3c, 0xf5, 0x3d, 0xfb, 0xfa, 0x7d, 0x12, 0xaf, 0x37,
+	0x12, 0x18, 0xed, 0x22, 0x7b, 0x8a, 0x7d, 0x10, 0xaf, 0x37, 0x12, 0x17, 0x1d, 0x22, 0x7b, 0x86,
+	0x7d, 0x10, 0xaf, 0x37, 0x12, 0x17, 0x1d, 0x22, 0x7d, 0x8, 0xaf, 0x37, 0x12, 0x18, 0xed, 0xaf,
+	0x37, 0x22, 0x7b, 0x82, 0x7d, 0x10, 0xaf, 0x37, 0x12, 0x17, 0x1d, 0x22, 0x8f, 0x35, 0xe5, 0x35,
+	0x64, 0x6, 0x70, 0x54, 0x7b, 0x22, 0x7a, 0x1a, 0x7d, 0x17, 0x12, 0x17, 0x1d, 0xaf, 0x35, 0x12,
+	0x17, 0x4d, 0x12, 0xb, 0xc9, 0x7a, 0x2, 0x12, 0xb, 0xbf, 0x7b, 0xb5, 0x7a, 0x52, 0x7d, 0x1f,
+	0xaf, 0x35, 0x12, 0x17, 0x1d, 0x7b, 0xf, 0x7a, 00, 0x7d, 0x2, 0xaf, 0x35, 0x12, 0x17, 0x1d,
+	0x7b, 0x2a, 0x7a, 0x47, 0x7d, 0x1, 0xaf, 0x35, 0x12, 0x17, 0x1d, 0x7b, 0xa4, 0x7a, 0x8f, 0xe4,
+	0xfd, 0xaf, 0x35, 0x12, 0x17, 0x1d, 0x12, 0xb, 0xc9, 0x7a, 00, 0x12, 0xb, 0xbf, 0xe4, 0xfb,
+	0xfa, 0x7d, 0x1f, 0xaf, 0x35, 0x2, 0x17, 0x1d, 0xaf, 0x35, 0x12, 0xb, 0xd5, 0xaf, 0x35, 0x12,
+	0x1c, 0x1f, 0x7b, 0x64, 0x7a, 00, 0x7d, 0x1b, 0xaf, 0x35, 0x12, 0x17, 0x1d, 0x75, 0x3c, 00,
+	0x75, 0x3d, 0xf, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x1e, 0xaf, 0x35, 0x12, 0x18, 0xed, 0x22, 0x7b,
+	0x12, 0x7d, 0x8, 0xaf, 0x35, 0x12, 0x17, 0x1d, 0x22, 0x7b, 0x30, 0x7a, 0x2a, 0x7d, 0x1f, 0xaf,
+	0x35, 0x12, 0x17, 0x1d, 0x22, 0x8f, 0x36, 0x12, 0xa, 0x99, 0xaf, 0x36, 0x12, 0x12, 0x2e, 0x75,
+	0x3c, 00, 0x75, 0x3d, 0xc0, 0x7b, 0x40, 0x7d, 0x12, 0x12, 0xc, 0x52, 0x12, 0x1e, 0xaa, 0x12,
+	0xc, 0x5c, 0x12, 0xc, 0x5c, 0xaf, 0x36, 0x12, 0x1e, 0xb3, 0xaf, 0x36, 0x12, 0x1e, 0xaa, 0x75,
+	0x3c, 0xf, 0x75, 0x3d, 0xc0, 0x7b, 0x40, 0x7a, 0x2, 0x7d, 0x16, 0xaf, 0x36, 0x12, 0x18, 0xed,
+	0x75, 0x3c, 0x60, 0x75, 0x3d, 00, 0x7b, 00, 0x7a, 0x40, 0x7d, 0x14, 0xaf, 0x36, 0x12, 0x18,
+	0xed, 0x75, 0x3c, 00, 0x75, 0x3d, 0x38, 0x7b, 0x30, 0x7d, 0x18, 0x12, 0xc, 0x52, 0x12, 0x1e,
+	0x98, 0x75, 0x3c, 0xe0, 0x12, 0x17, 0x7f, 0xaf, 0x36, 0x12, 0x18, 0xed, 0xaf, 0x36, 0x12, 0x1e,
+	0xb3, 0x75, 0x3c, 0xe0, 0x75, 0x3d, 0xe, 0x7b, 0x2, 0x7a, 0x80, 0x7d, 0x18, 0xaf, 0x36, 0x2,
+	0x18, 0xed, 0x7a, 00, 0xaf, 0x36, 0x12, 0x18, 0xed, 0xaf, 0x36, 0x22, 0x7b, 0x82, 0x7a, 0xf0,
+	0x7d, 0x3, 0xaf, 0x36, 0x12, 0x17, 0x1d, 0x22, 0x78, 0xfe, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x52,
+	00, 0x75, 0x53, 00, 0x75, 0x81, 0xaa, 0x2, 0xc, 0xb5, 0x2, 0xc, 0xfa, 0xe4, 0x93, 0xa3,
+	0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x3, 0xf6, 0x80, 0x1, 0xf2, 0x8, 0xdf, 0xf4, 0x80, 0x29, 0xe4,
+	0x93, 0xa3, 0xf8, 0x54, 0x7, 0x24, 0xc, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0xf, 0x44, 0x20, 0xc8,
+	0x83, 0x40, 0x4, 0xf4, 0x56, 0x80, 0x1, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0xb, 0x1, 0x2, 0x4,
+	0x8, 0x10, 0x20, 0x40, 0x80, 0x90, 0x17, 0xa9, 0xe4, 0x7e, 0x1, 0x93, 0x60, 0xbc, 0xa3, 0xff,
+	0x54, 0x3f, 0x30, 0xe5, 0x9, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x1, 0xe, 0xcf, 0x54,
+	0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4,
+	0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8,
+	0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 0x12, 0x1f, 0x22, 0x12, 0x18, 0x52,
+	0xd2, 0xa1, 0xc2, 0x91, 0xe4, 0xf5, 0x39, 0x75, 0x38, 0x1, 0xf5, 0x37, 0xf5, 0x36, 0xf5, 0x3d,
+	0x75, 0x3c, 0x1f, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x10, 0xfd, 0x7f, 0xe0, 0x12, 0xf, 0xd5, 0x12,
+	0x1c, 0xb0, 0x12, 0x1b, 0xf1, 0xd2, 0xaf, 0x7f, 0x14, 0x12, 0x1c, 0xc3, 0x12, 0xe, 0xa, 0x12,
+	0x1f, 0x23, 0x12, 0x1a, 0xf, 0xef, 0x70, 0x3, 0x30, 0x7, 0x3, 0x12, 0x1f, 0xb, 0x12, 0x1a,
+	0x51, 0x12, 0x1c, 0x36, 0xef, 0x60, 0x3, 0x12, 0x1f, 0xb, 0x12, 0x16, 0x53, 0x12, 0x1b, 0xa7,
+	0x30, 0x7, 0x16, 0xc2, 0x7, 0x7b, 0x16, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x40, 0x7f, 00,
+	0x7e, 00, 0x7d, 0xff, 0x7c, 0xff, 0x12, 0x9, 0x47, 0x12, 0x18, 0x2a, 0x30, 00, 0x8, 0xc2,
+	00, 0x12, 0x1d, 0x80, 0x12, 0x1b, 0x41, 0x30, 0x1, 0xd6, 0xc2, 0x1, 0x12, 0x1d, 0x42, 0x12,
+	0x1c, 0x8, 0xa2, 0x81, 0xb3, 0x92, 0x91, 0x80, 0xc7, 0x8f, 0x23, 0x74, 0xa3, 0x2f, 0xf8, 0xe6,
+	0x24, 0xfe, 0x60, 0x2a, 0x14, 0x60, 0x5c, 0x24, 0x2, 0x70, 0x6e, 0x7b, 0xe1, 0x7a, 0x5, 0x7d,
+	0x4, 0xaf, 0x23, 0x12, 0x17, 0x1d, 0x7b, 00, 0x7a, 0x6, 0x7d, 0x9, 0xaf, 0x23, 0x12, 0x17,
+	0x1d, 0xaf, 0x23, 0x12, 0x1d, 0x8f, 0x74, 0xa3, 0x25, 0x23, 0xf8, 0x76, 0x2, 0x22, 0x30, 0x9,
+	0x48, 0xaf, 0x23, 0x12, 0x1d, 0xf4, 0x50, 0x41, 0x12, 0x1e, 0xef, 0x7d, 0x1, 0xaf, 0x23, 0x12,
+	0x9, 0x85, 0xaf, 0x23, 0x12, 0x1b, 0xd9, 0x8f, 0x24, 0xad, 0x24, 0xaf, 0x23, 0x12, 0x1a, 0xee,
+	0xad, 0x24, 0xaf, 0x23, 0x12, 0x15, 0x7a, 0x74, 0xa3, 0x25, 0x23, 0xf8, 0x76, 0x3, 0xaf, 0x23,
+	0x2, 0x1f, 0x1e, 0x30, 0x9, 0x13, 0xaf, 0x23, 0x12, 0x1d, 0xf4, 0x40, 0xc, 0x74, 0xa3, 0x25,
+	0x23, 0xf8, 0x76, 0x2, 0xaf, 0x23, 0x12, 0x19, 0xcc, 0x22, 0x12, 0x1f, 0x21, 0xe4, 0x75, 0x26,
+	0xc0, 0xf5, 0x25, 0xf5, 0x24, 0xf5, 0x23, 0xf5, 0x22, 0x7b, 00, 0x7a, 00, 0x79, 0x23, 0xaf,
+	0x22, 0x12, 0x9, 0xe0, 0x40, 0x21, 0xe4, 0xfb, 0x7d, 0x2, 0x7f, 0x60, 0x12, 0x9, 0x40, 0xe4,
+	0x25, 0x22, 0xff, 0xe4, 0x34, 0x4, 0xfe, 0xe4, 0x34, 0x1, 0xfd, 0xe4, 0x34, 0x1, 0xfc, 0x12,
+	0x9, 0x47, 0x7f, 0x2, 0x12, 0x1c, 0xc3, 0x5, 0x22, 0xe5, 0x22, 0xd3, 0x94, 0xf, 0x40, 0xc9,
+	0x7f, 0x3, 0x12, 0x1e, 0x53, 0x12, 0x1e, 0xe1, 0x12, 0x1e, 0x32, 0x7f, 0x4, 0x12, 0x1e, 0x53,
+	0x75, 0x3b, 0x1, 0x75, 0x3c, 0x1, 0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x16, 0xbb, 0x7f,
+	0x14, 0x12, 0x1c, 0xc3, 0x7b, 0x4, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x40, 0x7f, 0x5f, 0x12,
+	0x1e, 0xe8, 0x12, 0x9, 0x47, 0x2, 0x14, 0x5, 0x8f, 0x34, 0x8e, 0x33, 0x8d, 0x32, 0x8c, 0x31,
+	0xe4, 0xf5, 0x3f, 0xe4, 0xff, 0xfe, 0xfd, 0xfc, 0xab, 0x34, 0xaa, 0x33, 0xa9, 0x32, 0xa8, 0x31,
+	0xd3, 0x12, 0x4, 0xb7, 0x40, 0x37, 0xe4, 0x7b, 0xa, 0xfa, 0xf9, 0xf8, 0xaf, 0x34, 0xae, 0x33,
+	0xad, 0x32, 0xac, 0x31, 0x12, 0x4, 0x18, 0xaf, 0x3, 0x74, 0x35, 0x25, 0x3f, 0xf8, 0xa6, 0x7,
+	0xaf, 0x34, 0xae, 0x33, 0xad, 0x32, 0xac, 0x31, 0xe4, 0x7b, 0xa, 0xfa, 0xf9, 0xf8, 0x12, 0x4,
+	0x18, 0x8f, 0x34, 0x8e, 0x33, 0x8d, 0x32, 0x8c, 0x31, 0x5, 0x3f, 0x80, 0xb6, 0xe5, 0x3f, 0x70,
+	0x5, 0x7f, 0x30, 0x2, 0x1c, 0xe9, 0x15, 0x3f, 0xe5, 0x3f, 0xf4, 0x60, 0x10, 0x74, 0x35, 0x25,
+	0x3f, 0xf8, 0xe6, 0x24, 0x30, 0xff, 0x12, 0x1c, 0xe9, 0x15, 0x3f, 0x80, 0xeb, 0x22, 0x8f, 0x31,
+	0x8d, 0x32, 0x7b, 0x24, 0x7f, 0x20, 0x12, 0x9, 0x40, 0x7f, 0x6, 0x12, 0x1a, 0xb5, 0x12, 0x9,
+	0x47, 0xe5, 0x31, 0x24, 0x80, 0xfb, 0x75, 0x3b, 0x1b, 0x75, 0x3c, 0x1, 0xe4, 0xfd, 0x7f, 0x40,
+	0x12, 0x16, 0xbb, 0x7f, 0x2, 0x12, 0x1e, 0x53, 0xaf, 0x32, 0x12, 0x19, 0xee, 0x7f, 0xa, 0x12,
+	0x1e, 0xd3, 0x12, 0x1e, 0x27, 0x40, 0x5, 0x12, 0x1f, 0x10, 0x50, 0xf6, 0x12, 0x1f, 0x10, 0x40,
+	0x13, 0xad, 0x32, 0xaf, 0x31, 0x12, 0x12, 0xe3, 0xef, 0x70, 0x4, 0xf5, 0x33, 0x80, 0x8, 0x75,
+	0x33, 0x1, 0x80, 0x3, 0x75, 0x33, 0x2, 0xe5, 0x31, 0x24, 0x80, 0xfb, 0x75, 0x3b, 0x1b, 0xe4,
+	0xf5, 0x3c, 0xfd, 0x7f, 0x40, 0x12, 0x16, 0xbb, 0xaf, 0x33, 0x22, 0x8f, 0xa, 0xc3, 0xed, 0x94,
+	0x40, 0xec, 0x94, 00, 0x50, 0x16, 0xc3, 0x74, 0x40, 0x9d, 0xff, 0xe4, 0x9c, 0xfe, 0xef, 0x78,
+	0x2, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0xf5, 0xb, 0x80, 0x1c, 0xed, 0x24, 0x3, 0xff,
+	0xe4, 0x3c, 0xfe, 0xef, 0x78, 0x2, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x30, 0xe0, 0x5,
+	0x75, 0xb, 0x1, 0x80, 0x3, 0xe4, 0xf5, 0xb, 0xc3, 0xed, 0x94, 0x40, 0xec, 0x94, 00, 0x40,
+	0xe, 0xae, 0x4, 0xaf, 0x5, 0xe4, 0xfc, 0xfd, 0x78, 0x10, 0x12, 0x4, 0xdb, 0x80, 0x8, 0x7f,
+	00, 0x7e, 00, 0x7d, 0x40, 0x7c, 00, 0x12, 0x14, 0xc6, 0x7f, 0x20, 0x7e, 0x5, 0x7d, 00,
+	0x7c, 00, 0x2, 0x14, 0xc6, 0x8f, 0x33, 0x8d, 0x34, 0x8b, 0x35, 0xe5, 0x39, 0x55, 0x3d, 0xf5,
+	0x39, 0xe5, 0x38, 0x55, 0x3c, 0xf5, 0x38, 0xe5, 0x37, 0x55, 0x3b, 0xf5, 0x37, 0xe5, 0x36, 0x55,
+	0x3a, 0xf5, 0x36, 0x12, 0x9, 0x2c, 0xa8, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7, 0xaf, 0x3d,
+	0xae, 0x3c, 0xad, 0x3b, 0xac, 0x3a, 0x12, 0x4, 0xaa, 0xeb, 0x5f, 0xff, 0xea, 0x5e, 0xfe, 0xe9,
+	0x5d, 0xfd, 0xe8, 0x5c, 0xfc, 0xe5, 0x39, 0x4f, 0xf5, 0x39, 0xe5, 0x38, 0x4e, 0xf5, 0x38, 0xe5,
+	0x37, 0x4d, 0xf5, 0x37, 0xe5, 0x36, 0x4c, 0xf5, 0x36, 0xab, 0x35, 0xad, 0x34, 0xaf, 0x33, 0x12,
+	0x9, 0x40, 0xaf, 0x39, 0xae, 0x38, 0xad, 0x37, 0xac, 0x36, 0x2, 0x9, 0x47, 0x8f, 0x31, 0x8d,
+	0x32, 0x7b, 0x19, 0xad, 0x31, 0x7f, 0x20, 0x12, 0x9, 0x40, 0x12, 0x1a, 0xb3, 0x12, 0x9, 0x47,
+	0xe5, 0x32, 0x44, 0x10, 0xfd, 0xaf, 0x31, 0x12, 0x11, 0x6c, 0xef, 0xf5, 0x36, 0xee, 0xf5, 0x35,
+	0xed, 0x44, 0x1, 0xf5, 0x34, 0xec, 0x44, 0x10, 0xf5, 0x33, 0x12, 0x10, 0x98, 0xe5, 0x36, 0x44,
+	0x30, 0xff, 0xe5, 0x35, 0xfe, 0xe5, 0x34, 0xfd, 0xe5, 0x33, 0x44, 0x20, 0xfc, 0x12, 0x9, 0x47,
+	0x12, 0x10, 0x98, 0xaf, 0x36, 0xae, 0x35, 0xad, 0x34, 0xac, 0x33, 0x12, 0x9, 0x47, 0xe5, 0x31,
+	0xb4, 0x6, 0x4, 0xff, 0x12, 0x13, 0xc1, 0x22, 0xe4, 0xfb, 0xad, 0x31, 0x7f, 0x20, 0x12, 0x9,
+	0x40, 0x22, 0x7b, 0xff, 0x7a, 0x1d, 0x79, 0x9e, 0x12, 0x19, 0x84, 0x12, 0x1e, 0x71, 0x7b, 0xff,
+	0x7a, 0x1d, 0x79, 0x56, 0x12, 0x19, 0x84, 0x7b, 0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x2c,
+	0x12, 0x1b, 0x8e, 0x12, 0x1e, 0x71, 0x7b, 0xff, 0x7a, 0x1d, 0x79, 0x58, 0x12, 0x19, 0x84, 0xe4,
+	0xf5, 0x23, 0xaf, 0x23, 0x12, 0x1a, 0x30, 0xaf, 0x23, 0x12, 0x1d, 0xca, 0x7f, 0x1, 0x12, 0x1c,
+	0x88, 0xaf, 0x23, 0x12, 0x1e, 0xf6, 0xe4, 0xfc, 0xfd, 0xfe, 0x12, 0xe, 0x88, 0x7f, 0x3, 0x12,
+	0x1c, 0x88, 0xaf, 0x23, 0x12, 0x1e, 0xfd, 0x12, 0x1a, 0x30, 0x12, 0x1e, 0x71, 0x5, 0x23, 0xe5,
+	0x23, 0xc3, 0x94, 0x7, 0x40, 0xcc, 0x22, 0x7f, 0xa, 0x12, 0x1c, 0x9c, 0xe4, 0xff, 0xfe, 0x12,
+	0x19, 0x13, 0xef, 0x7f, 00, 0xfe, 0xc0, 0x7, 0xc0, 0x6, 0xf, 0x7e, 00, 0x12, 0x19, 0x13,
+	0xef, 0xfd, 0xd0, 0xe0, 0xf5, 0x1b, 0xd0, 0xe0, 0x4d, 0xf5, 0x1c, 0x24, 0x1, 0xff, 0xe4, 0x35,
+	0x1b, 0xfe, 0x12, 0x19, 0x13, 0x8f, 0x1d, 0xe4, 0xff, 0x12, 0x1c, 0x9c, 0xe5, 0x1c, 0x15, 0x1c,
+	0x70, 0x2, 0x15, 0x1b, 0xe4, 0xff, 0xfe, 0xc3, 0xef, 0x95, 0x1c, 0xee, 0x95, 0x1b, 0x50, 0x11,
+	0x8f, 0x82, 0x8e, 0x83, 0xe4, 0x93, 0x25, 0x1d, 0xf5, 0x1d, 0xf, 0xbf, 00, 0x1, 0xe, 0x80,
+	0xe6, 0xe5, 0x1d, 0x70, 0x4, 0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x22, 0xef, 0x64, 0x6, 0xef,
+	0x64, 0x6, 0x70, 0x24, 0xbd, 0x10, 0x8, 0x7f, 0x43, 0x7e, 0x4, 0x7d, 0x4, 0xfc, 0x22, 0xed,
+	0x70, 0x4, 0x7f, 0x43, 0x80, 0x20, 0xbd, 0x11, 0x4, 0x7f, 0x42, 0x80, 0x24, 0xbd, 0x1, 0x4,
+	0x7f, 0x42, 0x80, 0x29, 0x7f, 0x81, 0x80, 0x2e, 0xbd, 0x10, 0x6, 0x7f, 0x44, 0x7e, 0x4, 0x80,
+	0x12, 0xed, 0x70, 0x8, 0x7f, 0x44, 0x7e, 0x4, 0xfd, 0x7c, 0x80, 0x22, 0xbd, 0x11, 0x9, 0x7f,
+	0x44, 0x7e, 0x24, 0x7d, 0x4, 0x7c, 00, 0x22, 0xbd, 0x1, 0x9, 0x7f, 0x44, 0x7e, 0x24, 0x7d,
+	00, 0x7c, 0x80, 0x22, 0x7f, 0x84, 0x7e, 0x1, 0x7d, 0x6, 0x7c, 00, 0x22, 0x8f, 0x2c, 0x7f,
+	0x32, 0x12, 0x1e, 0xd3, 0x7b, 0xd8, 0xad, 0x2c, 0x7f, 0x20, 0x12, 0x9, 0x2c, 0x78, 0x8, 0x12,
+	0x4, 0xc8, 0xef, 0x54, 0x3f, 0xff, 0xe4, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xc3, 0x12,
+	0x4, 0xb7, 0x70, 0x32, 0x7b, 0xc, 0xfd, 0x7f, 0xa0, 0x12, 0x9, 0x2c, 0xc0, 0x4, 0xc0, 0x5,
+	0xc0, 0x6, 0xc0, 0x7, 0xaf, 0x2c, 0x12, 0x9, 0x7e, 0xe4, 0xfc, 0xfd, 0xfe, 0xd0, 0x3, 0xd0,
+	0x2, 0xd0, 0x1, 0xd0, 00, 0xeb, 0x5f, 0xff, 0xe4, 0xfb, 0xfa, 0xf9, 0xf8, 0xc3, 0x12, 0x4,
+	0xb7, 0x60, 0x3, 0x7f, 0x1, 0x22, 0x12, 0x1f, 0x10, 0x50, 0xa9, 0x7f, 00, 0x22, 0x8f, 0x37,
+	0x12, 0x1e, 0xaa, 0x12, 0x17, 0x89, 0x12, 0x12, 0x76, 0x12, 0x1e, 0xa1, 0x7a, 0xb6, 0x12, 0x12,
+	0x80, 0x75, 0x3c, 0xff, 0x75, 0x3d, 0x7, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x12, 0xaf, 0x37, 0x12,
+	0x18, 0xed, 0x75, 0x3c, 00, 0x75, 0x3d, 0xff, 0x7b, 0xa2, 0x7a, 00, 0x7d, 0x11, 0xaf, 0x37,
+	0x12, 0x18, 0xed, 0x7a, 0x96, 0x12, 0x12, 0x80, 0xaf, 0x37, 0x12, 0x1e, 0xaa, 0x12, 0x17, 0x94,
+	0x12, 0x12, 0x76, 0x2, 0x1e, 0xb3, 0x7d, 0x8, 0xaf, 0x37, 0x12, 0x18, 0xed, 0xaf, 0x37, 0x22,
+	0x7b, 0x8a, 0x7d, 0x10, 0xaf, 0x37, 0x12, 0x17, 0x1d, 0x22, 0x8f, 0x3e, 0x8d, 0x3f, 0x12, 0x1e,
+	0xf6, 0x8f, 0x44, 0xaf, 0x3e, 0x12, 0x1e, 0xfd, 0x8f, 0x45, 0x7b, 0x1, 0xad, 0x44, 0x7f, 0x60,
+	0x12, 0x9, 0x40, 0xe5, 0x45, 0x75, 0xf0, 0x20, 0xa4, 0xff, 0xe5, 0xf0, 0x44, 0x4, 0xfc, 0xef,
+	0x45, 0x3f, 0xfd, 0xe4, 0xff, 0xfe, 0x12, 0x9, 0x5d, 0x12, 0x9, 0x47, 0xaf, 0x44, 0x12, 0x1a,
+	0x93, 0x7b, 0x2, 0xad, 0x44, 0x7f, 0x60, 0x12, 0x9, 0x2c, 0x8f, 0x43, 0x8e, 0x42, 0x8d, 0x41,
+	0x8c, 0x40, 0xe5, 0x41, 0x54, 0x1, 0xfd, 0xed, 0x70, 0x5, 0xae, 0x42, 0xaf, 0x43, 0x22, 0xe4,
+	0xfe, 0xff, 0x22, 0x8f, 0x34, 0x8d, 0x35, 0xe4, 0xf5, 0x37, 0xfb, 0x7a, 00, 0x79, 0x38, 0x12,
+	0x14, 0x47, 0xef, 0x64, 0x80, 0x4e, 0x60, 0x3, 0x75, 0x37, 0x1, 0xe5, 0x38, 0x65, 0x34, 0x60,
+	0x3, 0x75, 0x37, 0x1, 0xe5, 0x37, 0x70, 0x25, 0xf5, 0x36, 0x12, 0x1c, 0x60, 0xa8, 0x4, 0xa9,
+	0x5, 0xaa, 0x6, 0xab, 0x7, 0xe4, 0x25, 0x35, 0x12, 0x1a, 0xbc, 0xc3, 0x12, 0x4, 0xb7, 0x60,
+	0x3, 0x75, 0x37, 0x1, 0x5, 0x36, 0xe5, 0x36, 0xc3, 0x94, 0x1f, 0x40, 0xdd, 0x12, 0x1c, 0x74,
+	0xaf, 0x37, 0x22, 0x8f, 0x34, 0x8d, 0x35, 0xe4, 0xfb, 0xfa, 0xfd, 0x12, 0x17, 0x1d, 0xe5, 0x35,
+	0x54, 0x3, 0xff, 0x70, 0x6, 0xf5, 0x36, 0xf5, 0x37, 0x80, 0x14, 0xbf, 0x1, 0x8, 0x75, 0x36,
+	0x20, 0x75, 0x37, 00, 0x80, 0x9, 0xbf, 0x2, 0x6, 0x75, 0x36, 00, 0x75, 0x37, 0x40, 0xe5,
+	0x35, 0x30, 0xe4, 0x3, 0x43, 0x36, 0x1, 0xe5, 0x35, 0x30, 0xe7, 0x3, 0x43, 0x36, 0x40, 0xab,
+	0x37, 0xaa, 0x36, 0xe4, 0xfd, 0xaf, 0x34, 0x2, 0x17, 0x1d, 0x8f, 0x27, 0x12, 0x1e, 0xa1, 0x7b,
+	0xf0, 0x7a, 0xaf, 0x7d, 0x10, 0xaf, 0x27, 0x12, 0x17, 0x1d, 0x7d, 0x11, 0xaf, 0x27, 0x12, 0x12,
+	0x8a, 0xee, 0xc4, 0xf8, 0x54, 0xf0, 0xc8, 0xef, 0xc4, 0x54, 0xf, 0x48, 0x54, 0x1f, 0xff, 0xc3,
+	0x94, 0x10, 0x40, 0x6, 0xef, 0xd3, 0x94, 0x14, 0x40, 0x12, 0xaf, 0x27, 0x12, 0x1e, 0xaa, 0x75,
+	0x3c, 0x3, 0x12, 0x17, 0x97, 0x7d, 0xc, 0xaf, 0x27, 0x12, 0x18, 0xed, 0xaf, 0x27, 0x2, 0x1e,
+	0xb3, 0x8f, 0x37, 0x75, 0x3b, 0x5, 0x75, 0x3c, 0x1, 0x7b, 0x19, 0xad, 0x37, 0x7f, 0x20, 0x12,
+	0x16, 0xbb, 0xe5, 0x37, 0xb4, 0x6, 0x6, 0x75, 0x3b, 0x3, 0x12, 0x13, 0xf9, 0xe5, 0x37, 0xb4,
+	0x6, 0x6, 0x75, 0x3b, 0x2, 0x12, 0x13, 0xf9, 0x7b, 0x5, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9,
+	0x40, 0x7f, 0x33, 0x12, 0x1e, 0xe8, 0x2, 0x9, 0x47, 0x75, 0x3c, 0x1, 0x7b, 0x19, 0xfd, 0x7f,
+	0x20, 0x12, 0x16, 0xbb, 0x22, 0x75, 0x27, 0x1, 0x7b, 0x6, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9,
+	0x40, 0x7f, 0x80, 0x7e, 0x1, 0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x47, 0x7b, 0x7, 0xe4, 0xfd,
+	0x7f, 0x40, 0x12, 0x9, 0x40, 0xe4, 0x25, 0x27, 0xff, 0xe4, 0x33, 0xfe, 0xe4, 0x33, 0xfd, 0xe4,
+	0x34, 0xc2, 0xfc, 0x12, 0x9, 0x47, 0x7f, 0x1, 0x7e, 0x26, 0x12, 0x15, 0xe9, 0x5, 0x27, 0xe5,
+	0x27, 0xd3, 0x94, 0xf, 0x40, 0xc2, 0x22, 0x8b, 0x39, 0x8a, 0x3a, 0x89, 0x3b, 0xe4, 0xf5, 0x8,
+	0xf5, 0x9, 0x12, 0x14, 0x7b, 0xe5, 0x3c, 0x54, 0x3f, 0xf5, 0x40, 0x85, 0x3d, 0x41, 0xe5, 0x3a,
+	0x45, 0x3b, 0x45, 0x39, 0x60, 0x10, 0xe5, 0x3f, 0x54, 0x7, 0xab, 0x39, 0xaa, 0x3a, 0xa9, 0x3b,
+	0x12, 0x3, 0x7b, 0x12, 0x14, 0x7b, 0xae, 0x40, 0xaf, 0x41, 0x22, 0x12, 0x1c, 0x60, 0x8f, 0x3f,
+	0x8e, 0x3e, 0x8d, 0x3d, 0x8c, 0x3c, 0x22, 0xc0, 0xe0, 0xc0, 0xd0, 0x75, 0xd0, 0x10, 0x30, 0x98,
+	0x29, 0xaf, 0x99, 0xc2, 0x98, 0xe5, 0x1e, 0x24, 0x1, 0xfd, 0xe4, 0x33, 0xfc, 0xe5, 0x1f, 0x7a,
+	00, 0xb5, 0x15, 0x8, 0xea, 0xb5, 0x14, 0x4, 0xd2, 0x5, 0x80, 0xe, 0x74, 0x83, 0x25, 0x1e,
+	0xf8, 0xa6, 0x17, 0xe5, 0x1e, 0x4, 0x54, 0x1f, 0xf5, 0x1e, 0x30, 0x99, 0x4, 0xc2, 0x99, 0xd2,
+	0x6, 0xd0, 0xd0, 0xd0, 0xe0, 0x32, 0x8f, 0x39, 0x8e, 0x38, 0x8d, 0x37, 0x8c, 0x36, 0x20, 0x8,
+	0x30, 0x7b, 0xc0, 0xad, 0xa, 0x7f, 0x20, 0x12, 0x9, 0x40, 0xaf, 0x39, 0xae, 0x38, 0xad, 0x37,
+	0xac, 0x36, 0x12, 0x9, 0x47, 0xe4, 0x78, 0xaa, 0xf6, 0x7b, 0xc8, 0xad, 0xa, 0x7f, 0x20, 0x12,
+	0x9, 0x2c, 0xee, 0x30, 0xe0, 0xb, 0x78, 0xaa, 0x6, 0xe6, 0xd3, 0x94, 0x64, 0x40, 0xea, 0xd2,
+	0x8, 0x22, 0x12, 0x18, 0xc7, 0x8f, 0x2b, 0xe4, 0xf5, 0x2a, 0xaf, 0x2a, 0x12, 0x9, 0x7e, 0xef,
+	0xf4, 0xff, 0xef, 0x55, 0x2b, 0xff, 0xe4, 0x8f, 0x39, 0xf5, 0x38, 0xf5, 0x37, 0xf5, 0x36, 0xe5,
+	0x2a, 0x24, 0x80, 0xfb, 0xe4, 0x75, 0x3d, 0x5f, 0xf5, 0x3c, 0xf5, 0x3b, 0xf5, 0x3a, 0xfd, 0x7f,
+	0x40, 0x12, 0xf, 0xd5, 0x5, 0x2a, 0xe5, 0x2a, 0xc3, 0x94, 0x7, 0x40, 0xcd, 0x22, 0x12, 0x1e,
+	0x1c, 0x50, 0x35, 0x12, 0x1d, 0x62, 0xef, 0x64, 0xa, 0x60, 0x2d, 0xbf, 0x8, 0xb, 0xe5, 0x18,
+	0xd3, 0x94, 00, 0x40, 0x23, 0x15, 0x18, 0x80, 0x1f, 0xe5, 0x18, 0xc3, 0x94, 0x1e, 0x50, 0xa,
+	0xae, 0x18, 0x5, 0x18, 0x74, 0x65, 0x2e, 0xf8, 0xa6, 0x7, 0xbf, 0xd, 0xb, 0xe5, 0x18, 0xb4,
+	0x1e, 0x4, 0x78, 0x82, 0x76, 0xd, 0xd3, 0x22, 0xc3, 0x22, 0x8f, 0x25, 0x8d, 0x26, 0xe5, 0x25,
+	0x64, 0x6, 0x60, 0x2d, 0xe5, 0x26, 0x54, 0x3, 0xff, 0xbf, 0x2, 0x5, 0xaf, 0x25, 0x12, 0x13,
+	0x7a, 0xe5, 0x26, 0x54, 0x3, 0x70, 0x1a, 0xaf, 0x25, 0x12, 0x1e, 0xaa, 0x12, 0x17, 0x7c, 0xaf,
+	0x25, 0x12, 0x18, 0xed, 0x12, 0x17, 0x7c, 0xaf, 0x25, 0x12, 0x18, 0xed, 0xaf, 0x25, 0x12, 0x1e,
+	0xb3, 0x22, 0xaf, 0xb, 0x15, 0xb, 0xef, 0xd3, 0x94, 00, 0x40, 0xd, 0x7f, 0x55, 0x7e, 0x55,
+	0x7d, 0x55, 0x7c, 0x55, 0x12, 0x14, 0xc6, 0x80, 0xe9, 0x30, 0x8, 0x9, 0x75, 0x3b, 0x1, 0x12,
+	0x15, 0xdc, 0xc2, 0x8, 0x22, 0xe4, 0xf5, 0x3b, 0x12, 0x15, 0xdc, 0x22, 0x75, 0x3c, 0x1, 0x7b,
+	0xc4, 0xad, 0xa, 0x7f, 0x20, 0x12, 0x16, 0xbb, 0x22, 0x8e, 0x2a, 0x8f, 0x2b, 0x7b, 0xb0, 0xe4,
+	0xfd, 0x7f, 0x40, 0x12, 0x9, 0x40, 0xae, 0x2a, 0xaf, 0x2b, 0xe4, 0xfc, 0xfd, 0x12, 0x9, 0x47,
+	0x7f, 0xa, 0x12, 0x1e, 0xd3, 0x7b, 0xb0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x2c, 0xef, 0x54,
+	0x7, 0x60, 0xa, 0x12, 0x1f, 0x10, 0x50, 0xed, 0x7f, 0x4, 0x12, 0x1f, 0x18, 0x22, 0x8f, 0x28,
+	0x8d, 0x29, 0xe5, 0x29, 0xf4, 0x60, 0x29, 0x7b, 0x10, 0xad, 0x28, 0x7f, 0x20, 0x12, 0x9, 0x40,
+	0x7f, 00, 0x7e, 0x6, 0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x47, 0xad, 0x29, 0xaf, 0x28, 0x12,
+	0x7, 0x4e, 0xe4, 0xfd, 0xaf, 0x28, 0x12, 0x1b, 0x5c, 0x7d, 0x1, 0xaf, 0x28, 0x12, 0x1e, 0xf,
+	0x2, 0x15, 0x2, 0xe4, 0xf5, 0x22, 0xe5, 0x22, 0x24, 0x80, 0xfb, 0xe4, 0xfd, 0x7f, 0x40, 0x12,
+	0x9, 0x40, 0x7f, 00, 0x12, 0x1e, 0xe8, 0x12, 0x9, 0x47, 0xe5, 0x22, 0xb4, 0x6, 0x5, 0x7d,
+	0x12, 0xff, 0x80, 0x4, 0x7d, 0xff, 0xaf, 0x22, 0x12, 0x1a, 0xee, 0x5, 0x22, 0xe5, 0x22, 0xc3,
+	0x94, 0x7, 0x40, 0xd2, 0x2, 0x15, 0x2, 0x8b, 0x2a, 0x8a, 0x2b, 0x89, 0x2c, 0xe4, 0xf5, 0x2d,
+	0xab, 0x2a, 0x5, 0x2c, 0xe5, 0x2c, 0xaa, 0x2b, 0x70, 0x2, 0x5, 0x2b, 0x14, 0xf9, 0x12, 0x3,
+	0x62, 0xff, 0x12, 0x1b, 0x75, 0xe5, 0x2d, 0xc3, 0x94, 0x5, 0x50, 0x5, 0x7f, 0x2d, 0x12, 0x1f,
+	0x1b, 0x5, 0x2d, 0xe5, 0x2d, 0xc3, 0x94, 0x6, 0x40, 0xd6, 0x22, 0x8f, 0x38, 0x8d, 0x39, 0x8b,
+	0x3a, 0x12, 0x9, 0x2c, 0x8f, 0x40, 0x8e, 0x3f, 0x8d, 0x3e, 0x8c, 0x3d, 0x7b, 00, 0x7a, 00,
+	0x79, 0x3d, 0xad, 0x3c, 0xaf, 0x3b, 0x12, 0x9, 0xad, 0xab, 0x3a, 0xad, 0x39, 0xaf, 0x38, 0x12,
+	0x9, 0x40, 0xaf, 0x40, 0xae, 0x3f, 0xad, 0x3e, 0xac, 0x3d, 0x2, 0x9, 0x47, 00, 00, 0x10,
+	0x10, 0x80, 00, 00, 00, 00, 0xe, 00, 0x15, 00, 0x10, 00, 0x15, 00, 0x12, 00,
+	0x15, 00, 0x14, 00, 0x15, 00, 00, 0x10, 0xc, 0x80, 00, 00, 0x1, 00, 0xa, 00,
+	0x18, 00, 0xb, 00, 0x18, 00, 0xc, 00, 0x18, 00, 0xd, 00, 0x18, 0x8f, 0x3e, 0x8d,
+	0x3f, 0x8a, 0x40, 0x8b, 0x41, 0x12, 0x1e, 0xf6, 0x8f, 0x42, 0xaf, 0x3e, 0x12, 0x1e, 0xfd, 0x8f,
+	0x43, 0x7b, 0x1, 0xad, 0x42, 0x7f, 0x60, 0x12, 0x9, 0x40, 0xab, 0x43, 0xad, 0x3f, 0xaf, 0x41,
+	0xae, 0x40, 0x12, 0x1e, 0x5d, 0x12, 0x9, 0x47, 0xaf, 0x42, 0x2, 0x1a, 0x93, 0x8f, 0x36, 0x7b,
+	00, 0x7a, 0x80, 0xe4, 0xfd, 0x12, 0x17, 0x1d, 0x7f, 0x2, 0x12, 0x1c, 0xc3, 0xe4, 0xf5, 0x37,
+	0xe4, 0xfd, 0xaf, 0x36, 0x12, 0x12, 0x8a, 0xee, 0x30, 0xe7, 0x10, 0x5, 0x37, 0xe5, 0x37, 0xd3,
+	0x94, 0xc8, 0x50, 0x7, 0x7f, 0x1, 0x12, 0x1c, 0xc3, 0x80, 0xe5, 0x22, 0x75, 0x3c, 0x60, 0x75,
+	0x3d, 00, 0x7b, 00, 0x7a, 0x20, 0x7d, 0x14, 0x22, 0x75, 0x3c, 0x2, 0x75, 0x3d, 00, 0x7b,
+	00, 0x7a, 0x2, 0x22, 0x75, 0x3c, 0x2, 0x75, 0x3d, 00, 0xe4, 0xfb, 0xfa, 0x22, 0x75, 0x3c,
+	00, 0x75, 0x3d, 0xc, 0x7b, 0x8, 0x7a, 00, 0x22, 0xc1, 0x5, 0xc1, 0x4, 0x1, 0x1e, 00,
+	0x1, 0x1f, 00, 0xc1, 00, 0xc1, 0x1, 0x1, 0xe, 00, 0xc1, 0x2, 0xc1, 0x3, 0x1, 0xc,
+	0xa, 0x1, 0xd, 0x64, 0xc1, 0x7, 0x1, 0xf, 00, 0xc1, 0x8, 0x1, 0x18, 00, 0x1, 0x4c,
+	00, 0x1, 0x54, 00, 00, 0x8f, 0x2a, 0x8e, 0x29, 0x8d, 0x28, 0x8c, 0x27, 0x7b, 0xd0, 0xe4,
+	0xfd, 0x7f, 0x40, 0x12, 0x9, 0x40, 0xaf, 0x2a, 0xae, 0x29, 0xad, 0x28, 0xac, 0x27, 0x12, 0x9,
+	0x47, 0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x2c, 0xef, 0x54, 0x3, 0x70, 0xf2, 0x22,
+	0xe4, 0xfe, 0xee, 0x90, 00, 0x40, 0x93, 0xfc, 0xed, 0x2e, 0xf8, 0xa6, 0x4, 0xe, 0xbe, 0x6,
+	0xf1, 0xed, 0x24, 0x5, 0xf8, 0xe6, 0x2f, 0xf6, 0xc3, 0x9f, 0x50, 0xd, 0xed, 0x24, 0x4, 0xf8,
+	0x6, 0xe6, 0x70, 0x5, 0xed, 0x24, 0x3, 0xf8, 0x6, 0x22, 0x12, 0x15, 0x3e, 0x50, 0x22, 0x75,
+	0x1a, 0x65, 0x12, 0x1e, 0x3d, 0x12, 0x6, 0x4b, 0xef, 0x60, 0x13, 0x12, 0x1e, 0x1c, 0x50, 0x5,
+	0x12, 0x1d, 0x62, 0x80, 0xf6, 0x7b, 0xff, 0x7a, 0x1d, 0x79, 0x52, 0x12, 0x19, 0x84, 0xe4, 0xf5,
+	0x18, 0x22, 0x7b, 0x17, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x40, 0x7f, 0xff, 0x7e, 0xff, 0x7d,
+	0xff, 0x7c, 0xff, 0x12, 0x9, 0x47, 0x7b, 0x16, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x40, 0x7f,
+	0x14, 0x7e, 0x23, 0x7d, 00, 0x7c, 00, 0x2, 0x9, 0x47, 0x8f, 0x31, 0x8d, 0x32, 0x8b, 0x33,
+	0x12, 0x1e, 0x85, 0xaf, 0x32, 0x12, 0x1e, 0x85, 0x7f, 0x5, 0x12, 0x1e, 0x53, 0xe5, 0x33, 0x44,
+	0x10, 0xfd, 0xaf, 0x31, 0x12, 0x13, 0x33, 0xe5, 0x33, 0x44, 0x10, 0xfd, 0xaf, 0x32, 0x2, 0x13,
+	0x33, 0x8f, 0x32, 0xed, 0x70, 0x2, 0x80, 0x1, 0xe4, 0x75, 0x39, 0x86, 0x75, 0x38, 0x2, 0xf5,
+	0x37, 0xf5, 0x36, 0x75, 0x3d, 0xff, 0x75, 0x3c, 0xf, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x2, 0xad,
+	0x32, 0x7f, 0x20, 0x12, 0xf, 0xd5, 0x22, 0xe4, 0xf5, 0x2c, 0xf5, 0x2d, 0xaf, 0x2d, 0x12, 00,
+	0x3, 0xef, 0x60, 0xd, 0x7b, 00, 0x7a, 00, 0x79, 0x2c, 0x7d, 0x1, 0xaf, 0x2d, 0x12, 0x9,
+	0x85, 0x5, 0x2d, 0xe5, 0x2d, 0xc3, 0x94, 0x7, 0x40, 0xe2, 0xaf, 0x2c, 0x22, 0x8f, 0x38, 0x8d,
+	0x39, 0x8a, 0x3a, 0x8b, 0x3b, 0x12, 0x12, 0x8a, 0xe5, 0x3d, 0xf4, 0xfd, 0xe5, 0x3c, 0xf4, 0x5e,
+	0xfe, 0xef, 0x5d, 0x42, 0x3b, 0xee, 0x42, 0x3a, 0xab, 0x3b, 0xaa, 0x3a, 0xad, 0x39, 0xaf, 0x38,
+	0x2, 0x17, 0x1d, 0x8e, 0x47, 0x8f, 0x48, 0xe4, 0xff, 0x12, 0x1d, 0xd, 0x7f, 0x3, 0x12, 0x19,
+	0xa9, 0xe5, 0x47, 0xff, 0x12, 0x19, 0xa9, 0xaf, 0x48, 0x12, 0x19, 0xa9, 0x12, 0x1a, 0x72, 0x8f,
+	0x49, 0x7f, 0x1, 0x12, 0x1d, 0xd, 0xaf, 0x49, 0x22, 0x12, 0x1b, 0xc0, 0x74, 0x30, 0xd3, 0x9f,
+	0x50, 0xa, 0xef, 0x94, 0x39, 0x50, 0x5, 0xef, 0x24, 0xd0, 0xff, 0x22, 0x74, 0x41, 0xd3, 0x9f,
+	0x50, 0xa, 0xef, 0x94, 0x46, 0x50, 0x5, 0xef, 0x24, 0xc9, 0xff, 0x22, 0x7f, 0xff, 0x22, 0xc2,
+	0x8e, 0x75, 0x8b, 0x92, 0x75, 0x8d, 0xe6, 0xd2, 0x8e, 0xd2, 0x3, 0xd5, 0xc, 0x15, 0x75, 0xc,
+	0xa, 0xd2, 00, 0xd5, 0xd, 0x5, 0x75, 0xd, 0x64, 0xd2, 0x1, 0x30, 0x2, 0x5, 0xd5, 0xe,
+	0x2, 0xc2, 0x2, 0x32, 0x8b, 0x31, 0x8a, 0x32, 0x89, 0x33, 0xab, 0x31, 0xaa, 0x32, 0xa9, 0x33,
+	0x12, 0x3, 0x62, 0x60, 0x13, 0x5, 0x33, 0xe5, 0x33, 0x70, 0x2, 0x5, 0x32, 0x14, 0xf9, 0x12,
+	0x3, 0x62, 0xff, 0x12, 0x1c, 0xe9, 0x80, 0xe2, 0x22, 0x8f, 0x4e, 0xe4, 0xf5, 0x4f, 0xe5, 0x4e,
+	0x54, 0x80, 0xff, 0x12, 0x1d, 0x1f, 0xe5, 0x4e, 0x25, 0xe0, 0xf5, 0x4e, 0x12, 0x1e, 0xc3, 0x12,
+	0x1e, 0xcb, 0x5, 0x4f, 0xe5, 0x4f, 0xc3, 0x94, 0x8, 0x40, 0xe3, 0x22, 0x8f, 0x25, 0x12, 0x1e,
+	0xef, 0xe4, 0xfd, 0x12, 0x9, 0x85, 0xaf, 0x25, 0x12, 0x1d, 0xd8, 0x50, 0x5, 0xaf, 0x25, 0x12,
+	0x1e, 0x8f, 0x7d, 0xff, 0xaf, 0x25, 0x12, 0x1a, 0xee, 0xaf, 0x25, 0x2, 00, 0x1e, 0x8f, 0x34,
+	0x7d, 0x80, 0x7c, 00, 0x12, 0xf, 0x6b, 0xe4, 0xf5, 0x35, 0xe4, 0x25, 0x34, 0x12, 0x1a, 0xbc,
+	0x12, 0x14, 0xc6, 0x5, 0x35, 0xe5, 0x35, 0xc3, 0x94, 0x20, 0x40, 0xee, 0x2, 0x15, 0xb2, 0x7b,
+	0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x2c, 0xec, 0x54, 0xf, 0xfc, 0x7b, 0xe9, 0x7a, 0x50,
+	0x79, 0x39, 0x78, 0x7, 0xc3, 0x12, 0x4, 0xb7, 0x60, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22,
+	0x8f, 0x31, 0xe5, 0x31, 0xd3, 0x94, 0x9, 0x40, 0xb, 0xe5, 0x31, 0x75, 0xf0, 0xa, 0x84, 0x12,
+	0x1e, 0x7b, 0x80, 0x2, 0x7f, 0x20, 0x12, 0x1c, 0xe9, 0xe5, 0x31, 0x12, 0x1e, 0x7b, 0x2, 0x1c,
+	0xe9, 0xe4, 0xf5, 0x4d, 0x7f, 0x3, 0x12, 0x1e, 0x53, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1d,
+	0xd8, 0x50, 0x5, 0xaf, 0x22, 0x12, 0xb, 0x3c, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40,
+	0xeb, 0x22, 0xe4, 0xf5, 0x50, 0xe5, 0x51, 0x25, 0xe0, 0xf5, 0x51, 0x12, 0x1e, 0xc3, 0x12, 0x1d,
+	0x31, 0xef, 0x42, 0x51, 0x12, 0x1e, 0xcb, 0x5, 0x50, 0xe5, 0x50, 0xc3, 0x94, 0x8, 0x40, 0xe5,
+	0xaf, 0x51, 0x22, 0x8f, 0x46, 0x7f, 0x5, 0x12, 0x1e, 0xd3, 0xe4, 0xfb, 0xad, 0x46, 0x7f, 0x60,
+	0x12, 0x9, 0x2c, 0xef, 0x54, 0xb, 0x60, 0xa, 0x12, 0x1f, 0x10, 0x50, 0xed, 0x7f, 0x2, 0x12,
+	0x1f, 0x18, 0x22, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0xff, 0xe4, 0x34, 0x56,
+	0xfe, 0xe4, 0x34, 0x34, 0xfd, 0xe4, 0x34, 0x12, 0xfc, 0x22, 0xff, 0x74, 0x3, 0xa8, 0x6, 0x8,
+	0x22, 0xad, 0x7, 0xe4, 0xf5, 0x39, 0xf5, 0x38, 0x75, 0x37, 0x1, 0x75, 0x36, 0x10, 0xf5, 0x3d,
+	0xf5, 0x3c, 0x75, 0x3b, 0x1, 0x75, 0x3a, 0x18, 0xfb, 0x7f, 0x20, 0x2, 0xf, 0xd5, 0x8f, 0x26,
+	0x8d, 0x27, 0xe5, 0x26, 0x64, 0x5, 0x60, 0x11, 0xe5, 0x27, 0xfd, 0x7c, 00, 0xaf, 0x26, 0x12,
+	0x1c, 0xfb, 0xad, 0x27, 0xaf, 0x26, 0x12, 0x16, 0x1e, 0x22, 0xbf, 0x6, 0x3, 0x7f, 0x12, 0x22,
+	0x7d, 0x1c, 0x12, 0x12, 0x8a, 0xef, 0x13, 0x13, 0x13, 0x54, 0x3, 0xfe, 0xef, 0x30, 0xe5, 0x3,
+	0x43, 0x6, 0x10, 0xaf, 0x6, 0x22, 0x8f, 0x2b, 0x12, 0x1d, 0xbc, 0x7d, 0x1, 0xaf, 0x2b, 0x12,
+	0x1e, 0x2, 0xaf, 0x2b, 0x12, 0x9, 0x7e, 0x12, 0x11, 0xcd, 0xe4, 0xfd, 0xaf, 0x2b, 0x2, 0x1e,
+	0x2, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1d, 0xd8, 0x50, 0x5, 0xaf, 0x22, 0x12, 0xd, 0x89,
+	0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xeb, 0xc2, 0x9, 0x22, 0xae, 0x5, 0xad, 0x7,
+	0x75, 0x3b, 0x6, 0xee, 0x70, 0x4, 0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x8f, 0x3c, 0x7b, 0x19,
+	0x7f, 0x20, 0x2, 0x16, 0xbb, 0x8f, 0x2e, 0xe5, 0x2e, 0xc4, 0x54, 0xf, 0xff, 0x12, 0x1d, 0xad,
+	0x12, 0x1c, 0xe9, 0xe5, 0x2e, 0x54, 0xf, 0xff, 0x12, 0x1d, 0xad, 0x2, 0x1c, 0xe9, 0x8f, 0x27,
+	0x8e, 0x26, 0x8d, 0x25, 0x8c, 0x24, 0x78, 0x10, 0x12, 0x4, 0xc8, 0x12, 0x1d, 0x71, 0xe5, 0x27,
+	0xff, 0xe5, 0x26, 0xfe, 0x2, 0x1d, 0x71, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e, 0x48, 0x74,
+	0xa3, 0x25, 0x22, 0xf8, 0xa6, 0x7, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xeb, 0x22,
+	0xd3, 0xef, 0x64, 0x80, 0xf8, 0x74, 0x61, 0x64, 0x80, 0x98, 0x50, 0xc, 0xef, 0x64, 0x80, 0x94,
+	0xfa, 0x50, 0x5, 0xef, 0x24, 0xe0, 0xff, 0x22, 0x22, 0x8f, 0x25, 0x12, 0x1b, 0xa, 0x8f, 0x26,
+	0x7d, 0x5, 0xaf, 0x25, 0x12, 0x12, 0x8a, 0xee, 0x30, 0xe2, 0x3, 0x43, 0x26, 0x20, 0xaf, 0x26,
+	0x22, 0x75, 0xcb, 0xff, 0x75, 0xca, 0x2, 0x75, 0xcd, 0xff, 0x75, 0xcc, 0x2, 0x75, 0xc8, 0x34,
+	0x75, 0x98, 0x52, 0xd2, 0xbc, 0xd2, 0xac, 0x22, 0x12, 0x1a, 0xf, 0xef, 0x60, 0x5, 0x7f, 0x5,
+	0x12, 0x1f, 0x18, 0x12, 0x1c, 0x36, 0xef, 0x60, 0x5, 0x7f, 0x6, 0x12, 0x1f, 0x18, 0x22, 0x8f,
+	0x36, 0x12, 0x1e, 0xaa, 0x75, 0x3c, 0x3, 0x12, 0x17, 0x8c, 0x7d, 0xc, 0xaf, 0x36, 0x12, 0x18,
+	0xed, 0xaf, 0x36, 0x2, 0x1e, 0xb3, 0xe4, 0xf5, 0x23, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1d, 0xd8,
+	0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xf2, 0xaf, 0x23, 0x22, 0xe4, 0xf5, 0xff, 0xf5,
+	0xfe, 0xf5, 0xfd, 0x75, 0xfc, 0x1, 0x75, 0xf9, 0xe0, 0x75, 0xfb, 0x14, 0xd2, 0xf8, 0x80, 0xfe,
+	0xe5, 0x8, 0xfd, 0xe5, 0x9, 0xfb, 0x7f, 0x80, 0x12, 0x9, 0x2c, 0x5, 0x9, 0xe5, 0x9, 0x70,
+	0x2, 0x5, 0x8, 0x22, 0xe4, 0xfb, 0x7d, 0x4, 0x7f, 0x80, 0x12, 0x9, 0x40, 0x7f, 00, 0x7e,
+	00, 0x7d, 00, 0x7c, 00, 0x2, 0x9, 0x47, 0x8f, 0x24, 0xaf, 0x24, 0x15, 0x24, 0xef, 0xd3,
+	0x94, 00, 0x40, 0x7, 0x7f, 0x20, 0x12, 0x1c, 0xe9, 0x80, 0xef, 0x22, 0x8f, 0x54, 0x7b, 0x35,
+	0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x40, 0xaf, 0x54, 0xe4, 0xfc, 0xfd, 0xfe, 0x2, 0x9, 0x47,
+	0x53, 0x89, 0xf, 0x43, 0x89, 0x10, 0x75, 0x8b, 0x92, 0x75, 0x8d, 0xe6, 0xc2, 0xbb, 0xd2, 0xab,
+	0xd2, 0x8e, 0x22, 0xc2, 0x3, 0xae, 0x7, 0x1f, 0xee, 0xd3, 0x94, 00, 0x40, 0x7, 0x30, 0x3,
+	0xfd, 0xc2, 0x3, 0x80, 0xf0, 0x22, 0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x40, 0x7f,
+	0x1, 0x12, 0x1e, 0xe8, 0x12, 0x9, 0x47, 0x80, 0xfe, 0xc2, 0x6, 0x8f, 0x99, 0x7f, 0x2, 0x12,
+	0x1e, 0xd3, 0x20, 0x6, 0x5, 0x12, 0x1f, 0x10, 0x50, 0xf8, 0x22, 0x8f, 0x28, 0x8c, 0x29, 0x8d,
+	0x2a, 0x12, 0x1b, 0x26, 0xad, 0x2a, 0xac, 0x29, 0xaf, 0x28, 0x2, 0x8, 0x44, 0xef, 0x60, 0x6,
+	0xe5, 0x54, 0x44, 0x2, 0x80, 0x4, 0xe5, 0x54, 0x54, 0xfd, 0xff, 0x12, 0x1c, 0x9c, 0x22, 0xef,
+	0x60, 0x6, 0xe5, 0x54, 0x44, 0x1, 0x80, 0x4, 0xe5, 0x54, 0x54, 0xfe, 0xff, 0x12, 0x1c, 0x9c,
+	0x22, 0x7b, 0x35, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x2c, 0xef, 0x54, 0x10, 0xc4, 0x54, 0xf,
+	0xff, 0x22, 0x5, 0xf, 0xe5, 0xf, 0xc3, 0x94, 0x96, 0x40, 0x6, 0xe4, 0xf5, 0xf, 0x12, 0x1e,
+	0xda, 0x22, 0x49, 0xd, 0xa, 00, 0x69, 00, 00, 00, 00, 00, 00, 00, 00, 00,
+	00, 00, 0x74, 0x83, 0x25, 0x1f, 0xf8, 0xe6, 0xff, 0xe5, 0x1f, 0x4, 0x54, 0x1f, 0xf5, 0x1f,
+	0x22, 0x8e, 0x28, 0x8f, 0x29, 0xe5, 0x28, 0xff, 0x12, 0x1b, 0x75, 0xaf, 0x29, 0x2, 0x1b, 0x75,
+	0x5, 0x4c, 0xe5, 0x4c, 0xc3, 0x94, 0xa, 0x40, 0x5, 0xe4, 0xf5, 0x4c, 0xd2, 0x9, 0x22, 0x75,
+	0x3c, 0x12, 0x75, 0x3d, 00, 0x7b, 00, 0x7a, 0x12, 0xe4, 0xfd, 0x2, 0x18, 0xed, 0x4c, 0x20,
+	0x32, 0x2e, 0x33, 0x31, 0x41, 0x74, 0x68, 0x34, 00, 00, 00, 00, 00, 0xef, 0xc3, 0x94,
+	0xa, 0xef, 0x50, 0x4, 0x24, 0x30, 0xff, 0x22, 0x24, 0x57, 0xff, 0x22, 0xad, 0x7, 0x75, 0x3b,
+	0x10, 0xe4, 0xf5, 0x3c, 0xfb, 0x7f, 0x20, 0x2, 0x16, 0xbb, 0x7d, 0x24, 0x12, 0x18, 00, 0x7b,
+	00, 0x7a, 00, 0x79, 0x24, 0x2, 0x16, 0x87, 0xef, 0x90, 0x1d, 0xed, 0x93, 0xd3, 0x94, 0x1,
+	0x50, 0x2, 0x80, 0x1, 0xc3, 0x22, 00, 0x1, 0x2, 0x3, 0x4, 0xff, 0x6, 00, 00, 00,
+	00, 00, 0xff, 0x1, 0x7d, 0x1, 0x12, 0x12, 0x8a, 0xef, 0x30, 0xe2, 0x3, 0xd3, 0x80, 0x1,
+	0xc3, 0x22, 0x8f, 0x3b, 0x8d, 0x3c, 0x7b, 0xe, 0xe4, 0xfd, 0x7f, 0xa0, 0x2, 0x16, 0xbb, 0x8f,
+	0x3b, 0x8d, 0x3c, 0x7b, 0x10, 0xe4, 0xfd, 0x7f, 0x40, 0x2, 0x16, 0xbb, 0xe5, 0x1e, 0x65, 0x1f,
+	0x60, 0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0xe5, 0xaa, 0x54, 0x3, 0x60, 0x3, 0xd3, 0x80, 0x1,
+	0xc3, 0x22, 0x7f, 0x3, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x2, 0x17, 0xd5, 0xa8, 0x1a, 0xe6,
+	0xb4, 0x20, 0x4, 0x5, 0x1a, 0x80, 0xf6, 0x22, 0x12, 0x1d, 0xd8, 0x50, 0x3, 0x7f, 0x1, 0x22,
+	0x7f, 00, 0x22, 0xc2, 0x2, 0x8f, 0xe, 0xd2, 0x2, 0x20, 0x2, 0xfd, 0x22, 0xeb, 0x75, 0xf0,
+	0x20, 0xa4, 0x4d, 0xac, 0xf0, 0xfd, 0x22, 0x7f, 0x30, 0x12, 0x1c, 0xe9, 0x7f, 0x78, 0x2, 0x1c,
+	0xe9, 0x7f, 0xd, 0x12, 0x1c, 0xe9, 0x7f, 0xa, 0x2, 0x1c, 0xe9, 0x75, 0xf0, 0xa, 0x84, 0xe5,
+	0xf0, 0x24, 0x30, 0xff, 0x22, 0x8f, 0x34, 0x12, 0x17, 0x4d, 0xaf, 0x34, 0x2, 0xb, 0x3c, 0xef,
+	0x64, 0x6, 0x60, 0x3, 0x12, 0x1c, 0x1f, 0x22, 0x7b, 0x1, 0x7a, 00, 0x7d, 0x1f, 0x2, 0x17,
+	0x1d, 0x7b, 0xb5, 0x7a, 0x52, 0x7d, 0x1f, 0x2, 0x17, 0x1d, 0x7b, 0x30, 0x7a, 0x2a, 0x7d, 0x1f,
+	0x2, 0x17, 0x1d, 0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0x2, 0x17, 0x1d, 0x7d, 0x32, 0x12, 0x18, 00,
+	0xaf, 0x37, 0x22, 0xe5, 0x54, 0x44, 0x4, 0xff, 0x2, 0x1c, 0x9c, 0xe5, 0x54, 0x54, 0xfb, 0xff,
+	0x2, 0x1c, 0x9c, 0xc2, 0x2, 0x8f, 0xe, 0xd2, 0x2, 0x22, 0x7f, 0x3, 0x7e, 00, 0x2, 0x15,
+	0xe9, 0x7f, 0x5, 0x7e, 00, 0x2, 0x15, 0xe9, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0x7b,
+	00, 0x7a, 00, 0x79, 0x4d, 0x22, 0xef, 0x90, 0x1d, 0xed, 0x93, 0xff, 0x22, 0xef, 0x90, 0x1d,
+	0xe6, 0x93, 0xff, 0x22, 00, 0x1, 0x2, 0x3, 0x4, 0x6, 0x5, 0x75, 0x22, 0x1, 0x80, 0xfe,
+	0xa2, 0x2, 0xb3, 0x22, 0x12, 0x11, 0x7, 0x22, 0xd2, 0x7, 0x22, 0x2, 0x1c, 0xe9, 0x2, 0x15,
+	0x2, 0x22, 0x22, 0x22,
+};
diff --git a/board/ar7100/common/g5e_Plus1_2_29a_unmanaged_Atheros_v3.c b/board/ar7100/common/g5e_Plus1_2_29a_unmanaged_Atheros_v3.c
new file mode 100644
index 0000000000..15647dccc7
--- /dev/null
+++ b/board/ar7100/common/g5e_Plus1_2_29a_unmanaged_Atheros_v3.c
@@ -0,0 +1,513 @@
+static unsigned char lutonu [] = {
+	0x2, 0xb, 0x3a, 0x8f, 0x2e, 0x12, 0x1f, 0xbd, 0x12, 0x9, 0xdb, 0x50, 0x3, 0x7f, 0x1, 0x22, 
+	0xe5, 0x2e, 0xb4, 0x6, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x2, 0x19, 0xd7, 0x75, 0x22, 
+	0x1, 0x80, 0xfe, 0x2, 0x14, 0xe2, 0xae, 0x5, 0xad, 0x7, 0x75, 0x3c, 0x6, 0xee, 0x70, 0x4, 
+	0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x8f, 0x3d, 0x7b, 0x19, 0x7f, 0x20, 0x2, 0x17, 0x88, 0x22, 
+	00, 0x1, 0xc1, 00, 00, 00, 0x8f, 0x24, 0x8d, 0x25, 0x8b, 0x26, 0xe5, 0x26, 0x7b, 0xff, 
+	0x60, 0x6, 0x7a, 0x12, 0x79, 0x90, 0x80, 0x4, 0x7a, 0x12, 0x79, 0x8f, 0x12, 0x19, 0xfc, 0x7b, 
+	0xff, 0x7a, 0x12, 0x79, 0x91, 0x12, 0x19, 0xfc, 0xe5, 0x24, 0xc3, 0x94, 0x7, 0x40, 0x8, 0xe4, 
+	0xf5, 0x24, 0x75, 0x27, 0x6, 0x80, 0x11, 0xe5, 0x26, 0x60, 0xa, 0x53, 0x24, 0xfe, 0xe5, 0x24, 
+	0x4, 0xf5, 0x27, 0x80, 0x3, 0x85, 0x24, 0x27, 0xe5, 0x25, 0xb4, 0xff, 0x5, 0x75, 0x29, 0x7, 
+	0x80, 0xf, 0xaf, 0x25, 0x74, 0x1, 0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf5, 
+	0x29, 0x7b, 0xd, 0x12, 0x3, 0x2b, 0x7b, 0xe, 0x12, 0x3, 0x2b, 0x12, 0x3, 0x66, 0x12, 0x1b, 
+	0x4f, 0x12, 0x9, 0x5f, 0xe5, 0x24, 0x90, 0x1f, 0xd2, 0x93, 0xf5, 0x30, 0xe5, 0x26, 0x60, 0x1e, 
+	0xe5, 0x24, 0x24, 0x1, 0xff, 0xe4, 0x33, 0xfe, 0xc3, 0xef, 0x94, 0x7, 0xee, 0x64, 0x80, 0x94, 
+	0x80, 0x50, 0x8, 0xe5, 0x24, 0xa3, 0x93, 0xf5, 0x31, 0x80, 0x3, 0x75, 0x31, 0x7, 0x7e, 00, 
+	0x7f, 0x2, 0x7d, 0xff, 0x7b, 00, 0x7a, 00, 0x79, 0x2a, 0x12, 0x5, 0x2e, 0x75, 0x28, 0x2, 
+	0xe5, 0x28, 0xf4, 0x70, 0x3, 0x2, 0x2, 0x50, 0x74, 0x1, 0x7e, 00, 0xa8, 0x28, 0x8, 0x80, 
+	0x5, 0xc3, 0x33, 0xce, 0x33, 0xce, 0xd8, 0xf9, 0xff, 0xef, 0x55, 0x29, 0x70, 0x3, 0x2, 0x2, 
+	0x4b, 0xe5, 0x28, 0xd3, 0x94, 0x2, 0x40, 0x3, 0x2, 0x1, 0xec, 0xaf, 0x30, 0x12, 0x1e, 0x9c, 
+	0x40, 0x3, 0x2, 0x2, 0x4b, 0xaf, 0x31, 0x12, 0x1e, 0x9c, 0x50, 0x7, 0xe5, 0x31, 0xc3, 0x94, 
+	0x7, 0x40, 0x7, 0xe5, 0x26, 0x60, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x30, 0x64, 0x6, 0x70, 0x1b, 
+	0xe5, 0x28, 0x70, 0x9, 0x12, 0x3, 0x5d, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x28, 0xb4, 
+	0x1, 0x9, 0x12, 0x3, 0x5d, 0x20, 0xe6, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x26, 0x60, 0x67, 0xe5, 
+	0x28, 0xc3, 0x94, 0x2, 0x50, 0x6f, 0xe5, 0x31, 0x64, 0x6, 0x70, 0x25, 0xe5, 0x28, 0x70, 0xe, 
+	0x7d, 0x1, 0xaf, 0x31, 0x12, 0x13, 0x29, 0xee, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x28, 
+	0xb4, 0x1, 0xe, 0x7d, 0x1, 0xaf, 0x31, 0x12, 0x13, 0x29, 0xee, 0x20, 0xe6, 0x3, 0x2, 0x2, 
+	0x4b, 0x12, 0x3, 0x70, 0xe4, 0xf5, 0x2e, 0xf5, 0x2f, 0xaf, 0x30, 0x12, 0x1e, 0xb8, 0x50, 0x7, 
+	0xaf, 0x31, 0x12, 0x1e, 0xb8, 0x40, 0x2e, 0xe5, 0x2f, 0xc3, 0x94, 0x3, 0x50, 0x27, 0x7f, 0xa, 
+	0x12, 0x1d, 0x7a, 0x5, 0x2e, 0xe5, 0x2e, 0xc3, 0x94, 0xfa, 0x40, 0xdd, 0x12, 0x3, 0x70, 0x5, 
+	0x2f, 0xe4, 0xf5, 0x2e, 0x80, 0xd3, 0xe5, 0x28, 0x44, 0x90, 0xfd, 0xaf, 0x30, 0x12, 0x13, 0xd2, 
+	0x7f, 0xa, 0x12, 0x1f, 0x17, 0xad, 0x28, 0xaf, 0x30, 0x12, 0x10, 0xe4, 0xe5, 0x26, 0x60, 0x7, 
+	0xad, 0x28, 0xaf, 0x31, 0x12, 0x10, 0xe4, 0x7f, 0x5, 0x12, 0x1f, 0x17, 0xe5, 0x26, 0x60, 0x41, 
+	0xad, 0x31, 0x12, 0x3, 0x4e, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0x66, 0x80, 0x2, 
+	0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0xad, 0x30, 0xaf, 0x31, 0x12, 0xf, 
+	0x3c, 0xe5, 0x28, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x6, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 
+	0x12, 0x1b, 0x66, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2b, 0x4f, 0xf5, 0x2b, 0x80, 
+	0x1a, 0xad, 0x30, 0x12, 0x3, 0x4e, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0x66, 0x80, 
+	0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0x15, 0x28, 0x2, 00, 0xf0, 
+	0xe4, 0xf5, 0x2d, 0xe5, 0x26, 0x70, 0x7, 0xe5, 0x2d, 0xc3, 0x94, 0x1, 0x40, 0x11, 0xe5, 0x26, 
+	0x70, 0x3, 0x2, 0x2, 0xfd, 0xe5, 0x2d, 0xc3, 0x94, 0x2, 0x40, 0x3, 0x2, 0x2, 0xfd, 0x12, 
+	0x1f, 0x35, 0x7f, 0x4, 0x12, 0x1d, 0x3f, 0xaf, 0x24, 0x12, 0x1a, 0xcc, 0x7f, 0x4, 0x12, 0x1d, 
+	0x3f, 0xe4, 0xf5, 0x28, 0xe5, 0x28, 0x25, 0xe0, 0xff, 0x74, 0x2a, 0x25, 0x2d, 0xf8, 0xe6, 0xfe, 
+	0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x13, 0xd8, 0xfc, 0x54, 0x3, 0xf5, 0x2c, 0xb4, 0x3, 0x7, 
+	0x7f, 0x8, 0x12, 0x1d, 0x3f, 0x80, 0x24, 0xe5, 0x2c, 0x7b, 0xff, 0x70, 0x9, 0x7a, 0x12, 0x79, 
+	0xaa, 0x12, 0x19, 0xfc, 0x80, 0x15, 0x7a, 0x12, 0x79, 0xb3, 0x12, 0x19, 0xfc, 0xaf, 0x2c, 0xe4, 
+	0xfc, 0xfd, 0xfe, 0x12, 0xe, 0x57, 0x7f, 0x20, 0x12, 0x1f, 0xe4, 0x5, 0x28, 0xe5, 0x28, 0xc3, 
+	0x94, 0x3, 0x40, 0xb0, 0xe5, 0x2d, 0x70, 0xb, 0xaf, 0x30, 0x12, 0x1e, 0x9c, 0x50, 0x10, 0xaf, 
+	0x30, 0x80, 0x9, 0xaf, 0x31, 0x12, 0x1e, 0x9c, 0x50, 0x5, 0xaf, 0x31, 0x12, 0x1f, 0x49, 0x5, 
+	0x24, 0xe5, 0x24, 0xd3, 0x95, 0x27, 0x50, 0x5, 0x5, 0x2d, 0x2, 0x2, 0x53, 0xe5, 0x24, 0xd3, 
+	0x95, 0x27, 0x50, 0x3, 0x2, 00, 0xb4, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0xba, 0x12, 0x19, 0xfc, 
+	0x7b, 0xd, 0x12, 0x3, 0x3e, 0x12, 0x9, 0x5f, 0x7b, 0xe, 0x12, 0x3, 0x3e, 0x12, 0x9, 0x5f, 
+	0x12, 0x3, 0x66, 0x7f, 0x5f, 0x12, 0x1b, 0x51, 0x2, 0x9, 0x5f, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 
+	0x9, 0x58, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x5f, 0x22, 0xe4, 0xfd, 
+	0x7f, 0x40, 0x12, 0x9, 0x58, 0x7f, 0x5f, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0xaf, 0x30, 
+	0x12, 0xf, 0x3c, 0xe5, 0x28, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x6, 0x8, 0x22, 0x7d, 0x1, 0xaf, 
+	0x30, 0x12, 0x13, 0x29, 0xee, 0x22, 0x7b, 0xf, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x58, 0x22, 
+	0xab, 0x28, 0xad, 0x31, 0xaf, 0x30, 0x12, 0x18, 0xf2, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82, 0x8a, 
+	0x83, 0xe0, 0x22, 0x50, 0x2, 0xe7, 0x22, 0xbb, 0xfe, 0x2, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 
+	0xe4, 0x93, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0x22, 0x50, 0x2, 0xf7, 0x22, 
+	0xbb, 0xfe, 0x1, 0xf3, 0x22, 0xe8, 0x8f, 0xf0, 0xa4, 0xcc, 0x8b, 0xf0, 0xa4, 0x2c, 0xfc, 0xe9, 
+	0x8e, 0xf0, 0xa4, 0x2c, 0xfc, 0x8a, 0xf0, 0xed, 0xa4, 0x2c, 0xfc, 0xea, 0x8e, 0xf0, 0xa4, 0xcd, 
+	0xa8, 0xf0, 0x8b, 0xf0, 0xa4, 0x2d, 0xcc, 0x38, 0x25, 0xf0, 0xfd, 0xe9, 0x8f, 0xf0, 0xa4, 0x2c, 
+	0xcd, 0x35, 0xf0, 0xfc, 0xeb, 0x8e, 0xf0, 0xa4, 0xfe, 0xa9, 0xf0, 0xeb, 0x8f, 0xf0, 0xa4, 0xcf, 
+	0xc5, 0xf0, 0x2e, 0xcd, 0x39, 0xfe, 0xe4, 0x3c, 0xfc, 0xea, 0xa4, 0x2d, 0xce, 0x35, 0xf0, 0xfd, 
+	0xe4, 0x3c, 0xfc, 0x22, 0x75, 0xf0, 0x8, 0x75, 0x82, 00, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 
+	0xcd, 0x33, 0xcd, 0xcc, 0x33, 0xcc, 0xc5, 0x82, 0x33, 0xc5, 0x82, 0x9b, 0xed, 0x9a, 0xec, 0x99, 
+	0xe5, 0x82, 0x98, 0x40, 0xc, 0xf5, 0x82, 0xee, 0x9b, 0xfe, 0xed, 0x9a, 0xfd, 0xec, 0x99, 0xfc, 
+	0xf, 0xd5, 0xf0, 0xd6, 0xe4, 0xce, 0xfb, 0xe4, 0xcd, 0xfa, 0xe4, 0xcc, 0xf9, 0xa8, 0x82, 0x22, 
+	0xb8, 00, 0xc1, 0xb9, 00, 0x59, 0xba, 00, 0x2d, 0xec, 0x8b, 0xf0, 0x84, 0xcf, 0xce, 0xcd, 
+	0xfc, 0xe5, 0xf0, 0xcb, 0xf9, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 
+	0xec, 0x33, 0xfc, 0xeb, 0x33, 0xfb, 0x10, 0xd7, 0x3, 0x99, 0x40, 0x4, 0xeb, 0x99, 0xfb, 0xf, 
+	0xd8, 0xe5, 0xe4, 0xf9, 0xfa, 0x22, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 
+	0xfd, 0xec, 0x33, 0xfc, 0xc9, 0x33, 0xc9, 0x10, 0xd7, 0x5, 0x9b, 0xe9, 0x9a, 0x40, 0x7, 0xec, 
+	0x9b, 0xfc, 0xe9, 0x9a, 0xf9, 0xf, 0xd8, 0xe0, 0xe4, 0xc9, 0xfa, 0xe4, 0xcc, 0xfb, 0x22, 0x75, 
+	0xf0, 0x10, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xcc, 0x33, 0xcc, 0xc8, 0x33, 
+	0xc8, 0x10, 0xd7, 0x7, 0x9b, 0xec, 0x9a, 0xe8, 0x99, 0x40, 0xa, 0xed, 0x9b, 0xfd, 0xec, 0x9a, 
+	0xfc, 0xe8, 0x99, 0xf8, 0xf, 0xd5, 0xf0, 0xda, 0xe4, 0xcd, 0xfb, 0xe4, 0xcc, 0xfa, 0xe4, 0xc8, 
+	0xf9, 0x22, 0xcf, 0xf4, 0xcf, 0xce, 0xf4, 0xce, 0xcd, 0xf4, 0xcd, 0xcc, 0xf4, 0xcc, 0x22, 0xeb, 
+	0x9f, 0xf5, 0xf0, 0xea, 0x9e, 0x42, 0xf0, 0xe9, 0x9d, 0x42, 0xf0, 0xe8, 0x9c, 0x45, 0xf0, 0x22, 
+	0xe8, 0x60, 0xf, 0xec, 0xc3, 0x13, 0xfc, 0xed, 0x13, 0xfd, 0xee, 0x13, 0xfe, 0xef, 0x13, 0xff, 
+	0xd8, 0xf1, 0x22, 0xe8, 0x60, 0xf, 0xef, 0xc3, 0x33, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 
+	0xec, 0x33, 0xfc, 0xd8, 0xf1, 0x22, 0xe6, 0xfc, 0x8, 0xe6, 0xfd, 0x8, 0xe6, 0xfe, 0x8, 0xe6, 
+	0xff, 0x22, 0xe4, 0x93, 0xfc, 0x74, 0x1, 0x93, 0xfd, 0x74, 0x2, 0x93, 0xfe, 0x74, 0x3, 0x93, 
+	0xff, 0x22, 0xec, 0xf6, 0x8, 0xed, 0xf6, 0x8, 0xee, 0xf6, 0x8, 0xef, 0xf6, 0x22, 0xef, 0x4e, 
+	0x60, 0x12, 0xef, 0x60, 0x1, 0xe, 0xed, 0xbb, 0x1, 0xb, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0xa3, 
+	0xdf, 0xfc, 0xde, 0xfa, 0x22, 0x89, 0xf0, 0x50, 0x7, 0xf7, 0x9, 0xdf, 0xfc, 0xa9, 0xf0, 0x22, 
+	0xbb, 0xfe, 0xfc, 0xf3, 0x9, 0xdf, 0xfc, 0xa9, 0xf0, 0x22, 0xa8, 0x1a, 0xe6, 0xf5, 0x24, 0x64, 
+	0x20, 0x60, 0x9, 0xe5, 0x24, 0x64, 0xd, 0x60, 0x3, 0x7f, 0x1, 0x22, 0xe4, 0xf5, 0x19, 0xfe, 
+	0x7f, 0x10, 0x7d, 0xff, 0xfb, 0x7a, 00, 0x79, 0x52, 0x12, 0x5, 0x2e, 0x12, 0x1f, 0x1, 0x75, 
+	0x25, 0xa, 0xe4, 0xf5, 0x27, 0xa8, 0x1a, 0xe6, 0x64, 0x30, 0x70, 0x1b, 0xe8, 0x4, 0xf8, 0xe6, 
+	0xff, 0x12, 0x1c, 0x60, 0xbf, 0x58, 0x10, 0x75, 0x25, 0x10, 0x5, 0x1a, 0x5, 0x1a, 0xa8, 0x1a, 
+	0xe6, 0xb4, 0x20, 0x3, 0x7f, 0x1, 0x22, 0xa8, 0x1a, 0xe6, 0xf5, 0x24, 0x64, 0x20, 0x60, 0x6, 
+	0xe5, 0x24, 0x64, 0xd, 0x70, 0x7c, 0xe5, 0x27, 0xd3, 0x94, 00, 0x40, 0x6a, 0xe4, 0xf5, 0x35, 
+	0xf5, 0x34, 0xf5, 0x33, 0xf5, 0x32, 0xf5, 0x26, 0xe5, 0x26, 0xc3, 0x95, 0x27, 0x50, 0x3a, 0xaf, 
+	0x25, 0xe4, 0xfc, 0xfd, 0xfe, 0xab, 0x35, 0xaa, 0x34, 0xa9, 0x33, 0xa8, 0x32, 0x12, 0x3, 0xa5, 
+	0xc0, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7, 0x74, 0x28, 0x25, 0x26, 0xf8, 0xe6, 0xff, 0xe4, 
+	0xfc, 0xfd, 0xfe, 0xd0, 00, 0xeb, 0x2f, 0xf5, 0x35, 0xee, 0x3a, 0xf5, 0x34, 0xed, 0x39, 0xf5, 
+	0x33, 0xec, 0x38, 0xf5, 0x32, 0x5, 0x26, 0x80, 0xbf, 0xe5, 0x19, 0xc3, 0x94, 0x4, 0x50, 0x17, 
+	0xaf, 0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0xab, 0x19, 0x5, 0x19, 0xeb, 0x25, 0xe0, 0x25, 
+	0xe0, 0x24, 0x52, 0xf8, 0x12, 0x5, 0x22, 0xe5, 0x24, 0x64, 0xd, 0x60, 0x3, 0x2, 0x5, 0x7c, 
+	0xff, 0x22, 0xaf, 0x24, 0x12, 0x19, 0xb1, 0x8f, 0x24, 0xe5, 0x24, 0xf4, 0x60, 0x1d, 0xe5, 0x27, 
+	0xc3, 0x94, 0xa, 0x50, 0x19, 0xaf, 0x27, 0x5, 0x27, 0x74, 0x28, 0x2f, 0xf8, 0xa6, 0x24, 0xe5, 
+	0x24, 0xd3, 0x94, 0x9, 0x40, 0x8, 0x75, 0x25, 0x10, 0x80, 0x3, 0x7f, 0x1, 0x22, 0x5, 0x1a, 
+	0x2, 0x5, 0xa7, 0xa8, 0x1a, 0xe6, 0xf5, 0x23, 0x5, 0x1a, 0x12, 0x5, 0x5a, 0xef, 0x60, 0x3, 
+	0x7f, 0x1, 0x22, 0xaf, 0x23, 0x12, 0x1c, 0x60, 0xef, 0x24, 0xb7, 0x60, 0x64, 0x24, 0xfa, 0x60, 
+	0x7a, 0x24, 0xfd, 0x60, 0x17, 0x24, 0xfe, 0x70, 0x3, 0x2, 0x7, 0x25, 0x24, 0xfd, 0x60, 0x28, 
+	0x4, 0x60, 0x3, 0x2, 0x7, 0x60, 0x12, 0xe, 0xcd, 0x2, 0x7, 0x63, 0x12, 0x1f, 0x2b, 0x12, 
+	0x1a, 0x31, 0xc0, 0x7, 0x12, 0x1a, 0x21, 0xc0, 0x5, 0x12, 0x1a, 0x29, 0xd0, 0x5, 0xd0, 0x7, 
+	0x12, 0x9, 0x44, 0x12, 0x1c, 0x2e, 0x80, 0x3e, 0xe5, 0x19, 0xc3, 0x94, 0x4, 0x50, 0x3, 0x2, 
+	0x7, 0x63, 0x12, 0x1a, 0x31, 0xc0, 0x7, 0x12, 0x1a, 0x21, 0xc0, 0x5, 0x12, 0x1a, 0x29, 0xd0, 
+	0x5, 0xd0, 0x7, 0x12, 0x9, 0x58, 0x78, 0x5e, 0x12, 0x5, 0x6, 0x12, 0x9, 0x5f, 0x2, 0x7, 
+	0x63, 0x12, 0x1f, 0x2b, 0x78, 0x52, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x12, 0x1a, 0x21, 0xd0, 0x7, 
+	0x12, 0x13, 0x29, 0x12, 0x1e, 0x18, 0x12, 0x1f, 0x35, 0x80, 0x68, 0xe5, 0x19, 0xc3, 0x94, 0x3, 
+	0x40, 0x61, 0x78, 0x52, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x12, 0x1a, 0x21, 0xc0, 0x5, 0x12, 0x1a, 
+	0x29, 0xaa, 0x6, 0x78, 0x5e, 0x12, 0x5, 0x6, 0x8e, 0x3d, 0x8f, 0x3e, 0xd0, 0x5, 0xd0, 0x7, 
+	0x12, 0x19, 0x65, 0x80, 0x3e, 0x78, 0x52, 0x12, 0x5, 0x6, 0xef, 0x24, 0xfe, 0x60, 0x17, 0x4, 
+	0x70, 0x2b, 0x78, 0x56, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x78, 0x5a, 0x12, 0x5, 0x6, 0xad, 0x7, 
+	0xd0, 0x7, 0xe4, 0xfb, 0x80, 0x12, 0x78, 0x56, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x78, 0x5a, 0x12, 
+	0x5, 0x6, 0xad, 0x7, 0xd0, 0x7, 0x7b, 0x1, 0x12, 00, 0x46, 0x80, 0x6, 0x7f, 0x1, 0x22, 
+	0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x8f, 0x2a, 0x7f, 0x1, 0xed, 0x54, 0x30, 0xfe, 0xbe, 0x30, 
+	0x4, 0x7e, 0x1, 0x80, 0x2, 0x7e, 00, 0xed, 0x54, 0x3, 0xfc, 0xbc, 0x2, 0x4, 0x7c, 0x1, 
+	0x80, 0x2, 0x7c, 00, 0x8c, 0x2c, 0xed, 0x20, 0xe4, 0x7, 0xef, 0x60, 0x4, 0x7d, 0x1, 0x80, 
+	0x2, 0x7d, 00, 0xef, 0x60, 0x3, 0xee, 0x70, 0x3, 0xed, 0x60, 0x4, 0x7f, 0x1, 0x80, 0x2, 
+	0x7f, 00, 0x8f, 0x2b, 0x7d, 0x30, 0xaf, 0x2a, 0x12, 0x18, 0xa0, 0x7b, 0x8, 0xad, 0x2a, 0x7f, 
+	0x20, 0x12, 0x9, 0x58, 0xe5, 0x31, 0xfe, 0xe5, 0x32, 0xff, 0xad, 0x30, 0x7c, 00, 0x12, 0x9, 
+	0x75, 0x12, 0x9, 0x5f, 0x7b, 0xc, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9, 0x58, 0xe5, 0x34, 0xfe, 
+	0xe5, 0x35, 0xff, 0xad, 0x33, 0x7c, 00, 0x12, 0x9, 0x75, 0x12, 0x9, 0x5f, 0xe5, 0x2b, 0x60, 
+	0x1e, 0x75, 0x2d, 0x17, 0x75, 0x2e, 0xd2, 0x12, 0x8, 0x52, 0x7f, 0xff, 0x7e, 00, 0x7d, 0x3, 
+	0x7c, 00, 0x12, 0x9, 0x5f, 0x85, 0x2a, 0x3c, 0xe4, 0xf5, 0x3d, 0x7b, 0x12, 0x80, 0x1d, 0x75, 
+	0x2d, 0x17, 0x75, 0x2e, 0xba, 0x12, 0x8, 0x52, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 
+	0x12, 0x9, 0x5f, 0x85, 0x2a, 0x3c, 0x75, 0x3d, 0x1, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x12, 
+	0x17, 0x88, 0xe4, 0xf5, 0x2f, 0xe5, 0x2f, 0x24, 0xde, 0xfb, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9, 
+	0x58, 0x85, 0x2e, 0x82, 0x85, 0x2d, 0x83, 0x12, 0x5, 0x12, 0x12, 0x9, 0x5f, 0x74, 0x4, 0x25, 
+	0x2e, 0xf5, 0x2e, 0xe4, 0x35, 0x2d, 0xf5, 0x2d, 0x5, 0x2f, 0xe5, 0x2f, 0xc3, 0x94, 0x6, 0x40, 
+	0xd4, 0x22, 0x7b, 0x4, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9, 0x58, 0x22, 0x8f, 0x2b, 0x8c, 0x2c, 
+	0x8d, 0x2d, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0xa, 0xf5, 0x31, 0xf5, 0x30, 0xf5, 0x2f, 0xf5, 
+	0x2e, 0x80, 0x12, 0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf, 0x2b, 0x12, 0x11, 0xae, 0x8f, 0x31, 0x8e, 
+	0x30, 0x8d, 0x2f, 0x8c, 0x2e, 0xe4, 0xf5, 0x39, 0xf5, 0x38, 0xf5, 0x37, 0x75, 0x36, 0x80, 0xf5, 
+	0x3d, 0xf5, 0x3c, 0xf5, 0x3b, 0x75, 0x3a, 0x80, 0x7b, 0xdf, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0x10, 
+	0x7c, 0x12, 0x9, 0x3a, 0xe5, 0x31, 0x54, 0xf8, 0xff, 0xe5, 0x30, 0xfe, 0xe5, 0x2f, 0xfd, 0xe5, 
+	0x2e, 0xfc, 0xef, 0x44, 0x31, 0xff, 0xec, 0x44, 0x20, 0xfc, 0x12, 0x9, 0x5f, 0xe5, 0x2d, 0xf4, 
+	0x45, 0x2c, 0x70, 0x23, 0xfd, 0xaf, 0x2b, 0x12, 0x1e, 0xd3, 0x12, 0x9, 0x3a, 0x7f, 0x30, 0x7e, 
+	00, 0x7d, 00, 0x7c, 0x20, 0x12, 0x9, 0x5f, 0x85, 0x2b, 0x3c, 0x75, 0x3d, 0x1, 0x7b, 0x12, 
+	0xe4, 0xfd, 0x7f, 0xa0, 0x2, 0x17, 0x88, 0xaf, 0x2b, 0x12, 0x1f, 0x89, 0xe4, 0xfc, 0xfd, 0xfe, 
+	0x78, 0x13, 0x12, 0x4, 0xf3, 0xec, 0x44, 0x8, 0xfc, 0xe5, 0x31, 0x4f, 0xf5, 0x31, 0xe5, 0x30, 
+	0x4e, 0xf5, 0x30, 0xe5, 0x2f, 0x4d, 0xf5, 0x2f, 0xe5, 0x2e, 0x4c, 0xf5, 0x2e, 0xe4, 0xfb, 0xad, 
+	0x2b, 0x7f, 0x20, 0x12, 0x9, 0x58, 0xaf, 0x31, 0xae, 0x30, 0xad, 0x2f, 0xac, 0x2e, 0x12, 0x9, 
+	0x5f, 0xaf, 0x2b, 0x12, 0x1b, 0x6d, 0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf, 0x2b, 0x12, 0x19, 0x19, 
+	0xe5, 0x2b, 0xb4, 0x6, 0x4, 0xff, 0x12, 0x16, 0xeb, 0x22, 0xe4, 0xfb, 0xad, 0x2b, 0x7f, 0x20, 
+	0x12, 0x9, 0x58, 0x22, 0xef, 0x2d, 0xf5, 0xf9, 0x8b, 0xfa, 0x30, 0xf8, 0xfd, 0xd2, 0xf8, 0xac, 
+	0xff, 0xad, 0xfe, 0xae, 0xfd, 0xaf, 0xfc, 0x22, 0xef, 0x2d, 0xf5, 0x4b, 0x8b, 0x4c, 0x22, 0x8c, 
+	0xff, 0x8d, 0xfe, 0x8e, 0xfd, 0x8f, 0xfc, 0xe5, 0x4b, 0xf5, 0xf9, 0xe5, 0x4c, 0xf5, 0xfb, 0x30, 
+	0xf8, 0xfd, 0xd2, 0xf8, 0x22, 0x22, 0xec, 0xfe, 0xed, 0xff, 0x22, 0x1, 0x2, 0x4, 0x8, 0x10, 
+	0x20, 0x40, 0x80, 0xe4, 0xfe, 0xcf, 0x90, 0x9, 0x7b, 0xb4, 0x8, 00, 0x50, 0x3, 0x93, 0xff, 
+	0x22, 0x94, 0x8, 0x93, 0xfe, 0x22, 0xef, 0x90, 0x9, 0x7b, 0x93, 0xff, 0x22, 0x90, 0x9, 0x7b, 
+	0xef, 0x93, 0xff, 0xf4, 0xfe, 0xbb, 0x1, 0xe, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x5e, 0xbd, 00, 
+	0x2, 0x80, 0x1, 0x4f, 0xf0, 0x22, 0xbb, 00, 0xb, 0xe9, 0xf8, 0xe6, 0x5e, 0xbd, 00, 0x2, 
+	0x80, 0x1, 0x4f, 0xf6, 0x22, 0x74, 0x1f, 0xc3, 0x9f, 0x13, 0x13, 0x13, 0x54, 0x3, 0x29, 0xf9, 
+	0xe4, 0x3a, 0xfa, 0x74, 0x7, 0x5f, 0xff, 0x12, 0x9, 0x9d, 0x22, 0x90, 0x9, 0x7b, 0xef, 0x93, 
+	0xff, 0xbb, 0x1, 0x7, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x80, 0x6, 0xbb, 00, 0x8, 0xe9, 0xf8, 
+	0xe6, 0x5f, 0x60, 0x2, 0xd3, 0x22, 0xc3, 0x22, 0x74, 0x1f, 0xc3, 0x9f, 0x13, 0x13, 0x13, 0x54, 
+	0x3, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x7, 0x5f, 0xff, 0x12, 0x9, 0xdb, 0x22, 0x8f, 0x36, 
+	0xe5, 0x36, 0x64, 0x6, 0x70, 0x54, 0x7b, 0x22, 0x7a, 0x1a, 0x7d, 0x17, 0x12, 0x17, 0xea, 0xaf, 
+	0x36, 0x12, 0x18, 0x1a, 0x12, 0xa, 0x9b, 0x7a, 0x2, 0x12, 0xa, 0x91, 0x7b, 0xb5, 0x7a, 0x52, 
+	0x7d, 0x1f, 0xaf, 0x36, 0x12, 0x17, 0xea, 0x7b, 0xf, 0x7a, 00, 0x7d, 0x2, 0xaf, 0x36, 0x12, 
+	0x17, 0xea, 0x7b, 0x2a, 0x7a, 0x47, 0x7d, 0x1, 0xaf, 0x36, 0x12, 0x17, 0xea, 0x7b, 0xa4, 0x7a, 
+	0x8f, 0xe4, 0xfd, 0xaf, 0x36, 0x12, 0x17, 0xea, 0x12, 0xa, 0x9b, 0x7a, 00, 0x12, 0xa, 0x91, 
+	0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0xaf, 0x36, 0x2, 0x17, 0xea, 0xaf, 0x36, 0x12, 0xd, 0xe0, 0xaf, 
+	0x36, 0x12, 0x1c, 0xbf, 0x7b, 0x64, 0x7a, 00, 0x7d, 0x1b, 0xaf, 0x36, 0x12, 0x17, 0xea, 0x75, 
+	0x3d, 00, 0x75, 0x3e, 0xf, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x1e, 0xaf, 0x36, 0x12, 0x19, 0x65, 
+	0x22, 0x7b, 0x12, 0x7d, 0x8, 0xaf, 0x36, 0x12, 0x17, 0xea, 0x22, 0x7b, 0x30, 0x7a, 0x2a, 0x7d, 
+	0x1f, 0xaf, 0x36, 0x12, 0x17, 0xea, 0x22, 0x8f, 0x38, 0x12, 0x1f, 0x78, 0x12, 0x1a, 0x75, 0x12, 
+	0xb, 0x26, 0x12, 0x1f, 0x6f, 0x7a, 0xaf, 0x12, 0xb, 0x8, 0x75, 0x3d, 00, 0x75, 0x3e, 0xc, 
+	0x7d, 0x11, 0x12, 0xb, 0x1c, 0x7a, 0x8f, 0x12, 0xb, 0x8, 0x7a, 0xaf, 0x12, 0xb, 0x12, 0x75, 
+	0x3d, 00, 0x75, 0x3e, 0xc, 0x7d, 0x12, 0x12, 0xb, 0x1c, 0x7a, 0x8f, 0x12, 0xb, 0x12, 0x7a, 
+	0xaf, 0x12, 0xb, 0x30, 0x75, 0x3d, 0x1, 0x75, 0x3e, 0x80, 0x7b, 00, 0x7a, 0x1, 0x7d, 0x11, 
+	0xaf, 0x38, 0x12, 0x19, 0x65, 0x7a, 0x8f, 0x12, 0xb, 0x30, 0xaf, 0x38, 0x12, 0x1f, 0x78, 0x12, 
+	0x1a, 0x80, 0x12, 0xb, 0x26, 0x2, 0x1f, 0x81, 0x7b, 0x8a, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 
+	0xea, 0x22, 0x7b, 0x86, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xea, 0x22, 0x7b, 0x8, 0x7a, 00, 
+	0xaf, 0x38, 0x12, 0x19, 0x65, 0x22, 0x7d, 0x8, 0xaf, 0x38, 0x12, 0x19, 0x65, 0xaf, 0x38, 0x22, 
+	0x7b, 0x82, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xea, 0x22, 0x78, 0xfe, 0xe4, 0xf6, 0xd8, 0xfd, 
+	0x75, 0x4f, 00, 0x75, 0x50, 00, 0x75, 0x81, 0xa7, 0x2, 0xb, 0x87, 0x2, 0xb, 0xcc, 0xe4, 
+	0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x3, 0xf6, 0x80, 0x1, 0xf2, 0x8, 0xdf, 0xf4, 0x80, 
+	0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x7, 0x24, 0xc, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0xf, 0x44, 
+	0x20, 0xc8, 0x83, 0x40, 0x4, 0xf4, 0x56, 0x80, 0x1, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0xb, 0x1, 
+	0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x90, 0x18, 0x49, 0xe4, 0x7e, 0x1, 0x93, 0x60, 0xbc, 
+	0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x9, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x1, 0xe, 
+	0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 
+	0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 
+	0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 0x12, 0x1f, 0xea, 0x12, 
+	0x18, 0xca, 0xd2, 0xa1, 0xc2, 0x91, 0xe4, 0xf5, 0x39, 0x75, 0x38, 0x1, 0xf5, 0x37, 0xf5, 0x36, 
+	0xf5, 0x3d, 0x75, 0x3c, 0x1f, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x10, 0xfd, 0x7f, 0xe0, 0x12, 0x10, 
+	0x7c, 0x12, 0x1d, 0x67, 0x12, 0x1c, 0x91, 0xd2, 0xaf, 0x7f, 0x14, 0x12, 0x1d, 0x7a, 0x12, 0xd, 
+	0x62, 0x12, 0x1f, 0xeb, 0x12, 0x1a, 0xab, 0xef, 0x70, 0x3, 0x30, 0x7, 0x3, 0x12, 00, 0x1e, 
+	0x12, 0x1a, 0xed, 0x12, 0x1c, 0xed, 0xef, 0x60, 0x3, 0x12, 00, 0x1e, 0x12, 0x17, 0x20, 0x12, 
+	0x1c, 0x47, 0x30, 0x7, 0x16, 0xc2, 0x7, 0x7b, 0x16, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x58, 
+	0x7f, 00, 0x7e, 00, 0x7d, 0xff, 0x7c, 0xff, 0x12, 0x9, 0x5f, 0x12, 0xc, 0x5b, 0x30, 00, 
+	0x8, 0xc2, 00, 0x12, 0x1e, 0x27, 0x12, 0x1b, 0xfa, 0x30, 0x1, 0xd6, 0xc2, 0x1, 0x12, 0x1d, 
+	0xf9, 0x12, 0x1c, 0xa8, 0xa2, 0x81, 0xb3, 0x92, 0x91, 0x80, 0xc7, 0x12, 0x15, 0xd6, 0x40, 0x3, 
+	0x2, 0xc, 0xe0, 0x75, 0x1a, 0x62, 0x12, 0x1f, 0x1, 0x12, 0x1a, 0x3b, 0x75, 0x27, 0x1e, 0x75, 
+	0x28, 0x8e, 0x12, 0x15, 0x21, 0xef, 0x70, 0x4, 0xf5, 0x22, 0x80, 0x4a, 0x12, 0x1a, 0x3b, 0x75, 
+	0x27, 0x1e, 0x75, 0x28, 0x94, 0x12, 0x15, 0x21, 0xef, 0x70, 0x36, 0x74, 0x7, 0x25, 0x1a, 0xf5, 
+	0x1a, 0x12, 0x5, 0x5a, 0xef, 0x60, 0x2, 0x80, 0x6, 0xe5, 0x19, 0x64, 0x2, 0x60, 0x5, 0x75, 
+	0x22, 0x1, 0x80, 0x18, 0x78, 0x52, 0x12, 0x5, 0x6, 0xc0, 0x6, 0xc0, 0x7, 0x12, 0x1a, 0x21, 
+	0xac, 0x6, 0xd0, 0x7, 0xd0, 0x6, 0x12, 0x10, 0x13, 0x12, 0x1d, 0x8d, 0xe4, 0xf5, 0x22, 0x80, 
+	0x5, 0x12, 0x6, 0x63, 0x8f, 0x22, 0xe5, 0x22, 0x60, 0x13, 0x12, 0x1e, 0xe0, 0x50, 0x5, 0x12, 
+	0x1e, 0x9, 0x80, 0xf6, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x70, 0x12, 0x19, 0xfc, 0xe4, 0xf5, 0x18, 
+	0x22, 0x8f, 0x23, 0x74, 0xa0, 0x2f, 0xf8, 0xe6, 0x24, 0xfe, 0x60, 0x2a, 0x14, 0x60, 0x5c, 0x24, 
+	0x2, 0x70, 0x6e, 0x7b, 0xe1, 0x7a, 0x5, 0x7d, 0x4, 0xaf, 0x23, 0x12, 0x17, 0xea, 0x7b, 00, 
+	0x7a, 0x6, 0x7d, 0x9, 0xaf, 0x23, 0x12, 0x17, 0xea, 0xaf, 0x23, 0x12, 0x1e, 0x36, 0x74, 0xa0, 
+	0x25, 0x23, 0xf8, 0x76, 0x2, 0x22, 0x30, 0x9, 0x48, 0xaf, 0x23, 0x12, 0x1e, 0xb8, 0x50, 0x41, 
+	0x12, 0x1f, 0xbd, 0x7d, 0x1, 0xaf, 0x23, 0x12, 0x9, 0x9d, 0xaf, 0x23, 0x12, 0x1c, 0x79, 0x8f, 
+	0x24, 0xad, 0x24, 0xaf, 0x23, 0x12, 0x1b, 0xa7, 0xad, 0x24, 0xaf, 0x23, 0x12, 0x16, 0x12, 0x74, 
+	0xa0, 0x25, 0x23, 0xf8, 0x76, 0x3, 0xaf, 0x23, 0x2, 0x1f, 0xe7, 0x30, 0x9, 0x13, 0xaf, 0x23, 
+	0x12, 0x1e, 0xb8, 0x40, 0xc, 0x74, 0xa0, 0x25, 0x23, 0xf8, 0x76, 0x2, 0xaf, 0x23, 0x12, 0x1b, 
+	0x8a, 0x22, 0x12, 00, 0x3f, 0xe4, 0x75, 0x26, 0xc0, 0xf5, 0x25, 0xf5, 0x24, 0xf5, 0x23, 0xf5, 
+	0x22, 0x7b, 00, 0x7a, 00, 0x79, 0x23, 0xaf, 0x22, 0x12, 0x9, 0xf8, 0x40, 0x21, 0xe4, 0xfb, 
+	0x7d, 0x2, 0x7f, 0x60, 0x12, 0x9, 0x58, 0xe4, 0x25, 0x22, 0xff, 0xe4, 0x34, 0x4, 0xfe, 0xe4, 
+	0x34, 0x1, 0xfd, 0xe4, 0x34, 0x1, 0xfc, 0x12, 0x9, 0x5f, 0x7f, 0x2, 0x12, 0x1d, 0x7a, 0x5, 
+	0x22, 0xe5, 0x22, 0xd3, 0x94, 0xf, 0x40, 0xc9, 0x7f, 0x3, 0x12, 0x1f, 0x17, 0x12, 0x1f, 0xaf, 
+	0x12, 0x1e, 0xf6, 0x7f, 0x4, 0x12, 0x1f, 0x17, 0x75, 0x3c, 0x1, 0x75, 0x3d, 0x1, 0x7b, 0x14, 
+	0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x17, 0x88, 0x7f, 0x14, 0x12, 0x1d, 0x7a, 0x7b, 0x4, 0xe4, 0xfd, 
+	0x7f, 0x40, 0x12, 0x9, 0x58, 0x7f, 0x5f, 0x12, 0x1f, 0xb6, 0x12, 0x9, 0x5f, 0x2, 0x14, 0x60, 
+	0x8f, 0x37, 0x12, 0xa, 0xa7, 0xaf, 0x37, 0x12, 0x12, 0xcd, 0x75, 0x3d, 00, 0x75, 0x3e, 0x40, 
+	0x7b, 0x40, 0x7d, 0x12, 0x12, 0xe, 0x4d, 0x12, 0x1f, 0x78, 0x75, 0x3d, 0xf, 0x75, 0x3e, 0xc0, 
+	0x7b, 0x40, 0x7a, 0x2, 0x7d, 0x16, 0xaf, 0x37, 0x12, 0x19, 0x65, 0x75, 0x3d, 0x60, 0x75, 0x3e, 
+	00, 0x7b, 00, 0x7a, 0x40, 0x7d, 0x14, 0xaf, 0x37, 0x12, 0x19, 0x65, 0x75, 0x3d, 00, 0x75, 
+	0x3e, 0x38, 0x7b, 0x30, 0x7d, 0x18, 0x12, 0xe, 0x4d, 0x12, 0x1f, 0x66, 0x75, 0x3d, 0xe0, 0x12, 
+	0x1a, 0x6b, 0xaf, 0x37, 0x12, 0x19, 0x65, 0xaf, 0x37, 0x12, 0x1f, 0x81, 0x75, 0x3d, 0xe0, 0x75, 
+	0x3e, 0xe, 0x7b, 0x2, 0x7a, 0x80, 0x7d, 0x18, 0xaf, 0x37, 0x2, 0x19, 0x65, 0x7a, 00, 0xaf, 
+	0x37, 0x12, 0x19, 0x65, 0xaf, 0x37, 0x22, 0x8f, 0x35, 0x8e, 0x34, 0x8d, 0x33, 0x8c, 0x32, 0xe4, 
+	0xf5, 0x40, 0xe4, 0xff, 0xfe, 0xfd, 0xfc, 0xab, 0x35, 0xaa, 0x34, 0xa9, 0x33, 0xa8, 0x32, 0xd3, 
+	0x12, 0x4, 0xcf, 0x40, 0x37, 0xe4, 0x7b, 0xa, 0xfa, 0xf9, 0xf8, 0xaf, 0x35, 0xae, 0x34, 0xad, 
+	0x33, 0xac, 0x32, 0x12, 0x4, 0x30, 0xaf, 0x3, 0x74, 0x36, 0x25, 0x40, 0xf8, 0xa6, 0x7, 0xaf, 
+	0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0xe4, 0x7b, 0xa, 0xfa, 0xf9, 0xf8, 0x12, 0x4, 0x30, 
+	0x8f, 0x35, 0x8e, 0x34, 0x8d, 0x33, 0x8c, 0x32, 0x5, 0x40, 0x80, 0xb6, 0xe5, 0x40, 0x70, 0x5, 
+	0x7f, 0x30, 0x2, 0x1d, 0xa0, 0x15, 0x40, 0xe5, 0x40, 0xf4, 0x60, 0x10, 0x74, 0x36, 0x25, 0x40, 
+	0xf8, 0xe6, 0x24, 0x30, 0xff, 0x12, 0x1d, 0xa0, 0x15, 0x40, 0x80, 0xeb, 0x22, 0x7b, 0xff, 0x7a, 
+	0x1e, 0x79, 0x45, 0x12, 0x19, 0xfc, 0x12, 0x1f, 0x35, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x82, 0x12, 
+	0x19, 0xfc, 0x7b, 0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x44, 0x12, 0x1c, 0x2e, 0x12, 0x1f, 
+	0x35, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x87, 0x12, 0x19, 0xfc, 0xe4, 0xf5, 0x24, 0xaf, 0x24, 0x12, 
+	0x1a, 0xcc, 0x7f, 0x3, 0x12, 0x1d, 0x3f, 0xaf, 0x24, 0x12, 0x1e, 0x80, 0x7f, 0x2, 0x12, 0x1d, 
+	0x3f, 0x7f, 0x1, 0x12, 0x1d, 0x3f, 0xaf, 0x24, 0x12, 0x1f, 0xc4, 0xe4, 0xfc, 0xfd, 0xfe, 0x12, 
+	0xe, 0x57, 0x7f, 0x3, 0x12, 0x1d, 0x3f, 0xaf, 0x24, 0x12, 0x1f, 0xcb, 0x12, 0x1a, 0xcc, 0x12, 
+	0x1f, 0x35, 0x5, 0x24, 0xe5, 0x24, 0xc3, 0x94, 0x7, 0x40, 0xc2, 0x22, 0x8f, 0x32, 0x8d, 0x33, 
+	0x7b, 0x24, 0x7f, 0x20, 0x12, 0x9, 0x58, 0x7f, 0x6, 0x12, 0x1b, 0x51, 0x12, 0x9, 0x5f, 0xe5, 
+	0x32, 0x24, 0x80, 0xfb, 0x75, 0x3c, 0x1b, 0x75, 0x3d, 0x1, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x17, 
+	0x88, 0x7f, 0x2, 0x12, 0x1f, 0x17, 0xaf, 0x33, 0x12, 0x1a, 0x8a, 0x7f, 0xa, 0x12, 0x1f, 0xa1, 
+	0x12, 0x1e, 0xeb, 0x40, 0x5, 0x12, 0x1f, 0xd9, 0x50, 0xf6, 0x12, 0x1f, 0xd9, 0x40, 0x13, 0xad, 
+	0x33, 0xaf, 0x32, 0x12, 0x13, 0x82, 0xef, 0x70, 0x4, 0xf5, 0x34, 0x80, 0x8, 0x75, 0x34, 0x1, 
+	0x80, 0x3, 0x75, 0x34, 0x2, 0xe5, 0x32, 0x24, 0x80, 0xfb, 0x75, 0x3c, 0x1b, 0xe4, 0xf5, 0x3d, 
+	0xfd, 0x7f, 0x40, 0x12, 0x17, 0x88, 0xaf, 0x34, 0x22, 0x8f, 0xa, 0xc3, 0xed, 0x94, 0x40, 0xec, 
+	0x94, 00, 0x50, 0x16, 0xc3, 0x74, 0x40, 0x9d, 0xff, 0xe4, 0x9c, 0xfe, 0xef, 0x78, 0x2, 0xce, 
+	0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0xf5, 0xb, 0x80, 0x1c, 0xed, 0x24, 0x3, 0xff, 0xe4, 0x3c, 
+	0xfe, 0xef, 0x78, 0x2, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x30, 0xe0, 0x5, 0x75, 0xb, 
+	0x1, 0x80, 0x3, 0xe4, 0xf5, 0xb, 0xc3, 0xed, 0x94, 0x40, 0xec, 0x94, 00, 0x40, 0xe, 0xae, 
+	0x4, 0xaf, 0x5, 0xe4, 0xfc, 0xfd, 0x78, 0x10, 0x12, 0x4, 0xf3, 0x80, 0x8, 0x7f, 00, 0x7e, 
+	00, 0x7d, 0x40, 0x7c, 00, 0x12, 0x15, 0x5e, 0x7f, 0x20, 0x7e, 0x5, 0x7d, 00, 0x7c, 00, 
+	0x2, 0x15, 0x5e, 0x8e, 0x23, 0x8f, 0x24, 0x8c, 0x25, 0x8d, 0x26, 0x7f, 0xa, 0x12, 0x1d, 0x53, 
+	0x12, 0x1f, 0x53, 0x40, 0x52, 0x12, 0x1e, 0x54, 0xe4, 0xff, 0x12, 0x1d, 0xc4, 0x7f, 0x2, 0x12, 
+	0x1a, 0x45, 0xe5, 0x23, 0xff, 0x12, 0x1a, 0x45, 0xaf, 0x24, 0x12, 0x1a, 0x45, 0xe4, 0xf5, 0x27, 
+	0x12, 0x1f, 0x53, 0x40, 0x24, 0x12, 0x1e, 0xe0, 0x50, 0xfb, 0x12, 0x1e, 0x9, 0x12, 0x1a, 0x45, 
+	0x5, 0x24, 0xe5, 0x24, 0x70, 0x2, 0x5, 0x23, 0xe5, 0x26, 0x15, 0x26, 0x70, 0x2, 0x15, 0x25, 
+	0x5, 0x27, 0xe5, 0x27, 0xc3, 0x94, 0x20, 0x40, 0xd7, 0x7f, 0x1, 0x12, 0x1d, 0xc4, 0x12, 0x1c, 
+	0xd6, 0xef, 0x30, 0xe0, 0xab, 0x80, 0xf7, 0xe4, 0xff, 0x2, 0x1d, 0x53, 0x8f, 0x33, 0x8d, 0x34, 
+	0x8b, 0x35, 0xe5, 0x39, 0x55, 0x3d, 0xf5, 0x39, 0xe5, 0x38, 0x55, 0x3c, 0xf5, 0x38, 0xe5, 0x37, 
+	0x55, 0x3b, 0xf5, 0x37, 0xe5, 0x36, 0x55, 0x3a, 0xf5, 0x36, 0x12, 0x9, 0x44, 0xa8, 0x4, 0xa9, 
+	0x5, 0xaa, 0x6, 0xab, 0x7, 0xaf, 0x3d, 0xae, 0x3c, 0xad, 0x3b, 0xac, 0x3a, 0x12, 0x4, 0xc2, 
+	0xeb, 0x5f, 0xff, 0xea, 0x5e, 0xfe, 0xe9, 0x5d, 0xfd, 0xe8, 0x5c, 0xfc, 0xe5, 0x39, 0x4f, 0xf5, 
+	0x39, 0xe5, 0x38, 0x4e, 0xf5, 0x38, 0xe5, 0x37, 0x4d, 0xf5, 0x37, 0xe5, 0x36, 0x4c, 0xf5, 0x36, 
+	0xab, 0x35, 0xad, 0x34, 0xaf, 0x33, 0x12, 0x9, 0x58, 0xaf, 0x39, 0xae, 0x38, 0xad, 0x37, 0xac, 
+	0x36, 0x2, 0x9, 0x5f, 0x8f, 0x32, 0x8d, 0x33, 0x7b, 0x19, 0xad, 0x32, 0x7f, 0x20, 0x12, 0x9, 
+	0x58, 0x12, 0x1b, 0x4f, 0x12, 0x9, 0x5f, 0xe5, 0x33, 0x44, 0x10, 0xfd, 0xaf, 0x32, 0x12, 0x11, 
+	0xae, 0xef, 0xf5, 0x37, 0xee, 0xf5, 0x36, 0xed, 0x44, 0x1, 0xf5, 0x35, 0xec, 0x44, 0x10, 0xf5, 
+	0x34, 0x12, 0x11, 0x3f, 0xe5, 0x37, 0x44, 0x30, 0xff, 0xe5, 0x36, 0xfe, 0xe5, 0x35, 0xfd, 0xe5, 
+	0x34, 0x44, 0x20, 0xfc, 0x12, 0x9, 0x5f, 0x12, 0x11, 0x3f, 0xaf, 0x37, 0xae, 0x36, 0xad, 0x35, 
+	0xac, 0x34, 0x12, 0x9, 0x5f, 0xe5, 0x32, 0xb4, 0x6, 0x4, 0xff, 0x12, 0x16, 0xeb, 0x22, 0xe4, 
+	0xfb, 0xad, 0x32, 0x7f, 0x20, 0x12, 0x9, 0x58, 0x22, 0x7f, 0xa, 0x12, 0x1d, 0x53, 0xe4, 0xff, 
+	0xfe, 0x12, 0x19, 0x8b, 0xef, 0x7f, 00, 0xfe, 0xc0, 0x7, 0xc0, 0x6, 0xf, 0x7e, 00, 0x12, 
+	0x19, 0x8b, 0xef, 0xfd, 0xd0, 0xe0, 0xf5, 0x1b, 0xd0, 0xe0, 0x4d, 0xf5, 0x1c, 0x24, 0x1, 0xff, 
+	0xe4, 0x35, 0x1b, 0xfe, 0x12, 0x19, 0x8b, 0x8f, 0x1d, 0xe4, 0xff, 0x12, 0x1d, 0x53, 0xe5, 0x1c, 
+	0x15, 0x1c, 0x70, 0x2, 0x15, 0x1b, 0xe4, 0xff, 0xfe, 0xc3, 0xef, 0x95, 0x1c, 0xee, 0x95, 0x1b, 
+	0x50, 0x11, 0x8f, 0x82, 0x8e, 0x83, 0xe4, 0x93, 0x25, 0x1d, 0xf5, 0x1d, 0xf, 0xbf, 00, 0x1, 
+	0xe, 0x80, 0xe6, 0xe5, 0x1d, 0x70, 0x4, 0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x22, 0xef, 0x64, 
+	0x6, 0xef, 0x64, 0x6, 0x70, 0x24, 0xbd, 0x10, 0x8, 0x7f, 0x43, 0x7e, 0x4, 0x7d, 0x4, 0xfc, 
+	0x22, 0xed, 0x70, 0x4, 0x7f, 0x43, 0x80, 0x20, 0xbd, 0x11, 0x4, 0x7f, 0x42, 0x80, 0x24, 0xbd, 
+	0x1, 0x4, 0x7f, 0x42, 0x80, 0x29, 0x7f, 0x81, 0x80, 0x2e, 0xbd, 0x10, 0x6, 0x7f, 0x44, 0x7e, 
+	0x4, 0x80, 0x12, 0xed, 0x70, 0x8, 0x7f, 0x44, 0x7e, 0x4, 0xfd, 0x7c, 0x80, 0x22, 0xbd, 0x11, 
+	0x9, 0x7f, 0x44, 0x7e, 0x24, 0x7d, 0x4, 0x7c, 00, 0x22, 0xbd, 0x1, 0x9, 0x7f, 0x44, 0x7e, 
+	0x24, 0x7d, 00, 0x7c, 0x80, 0x22, 0x7f, 0x84, 0x7e, 0x1, 0x7d, 0x6, 0x7c, 00, 0x22, 0x8f, 
+	0x2c, 0x7f, 0x32, 0x12, 0x1f, 0xa1, 0x7b, 0xd8, 0xad, 0x2c, 0x7f, 0x20, 0x12, 0x9, 0x44, 0x78, 
+	0x8, 0x12, 0x4, 0xe0, 0xef, 0x54, 0x3f, 0xff, 0xe4, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 
+	0xc3, 0x12, 0x4, 0xcf, 0x70, 0x32, 0x7b, 0xc, 0xfd, 0x7f, 0xa0, 0x12, 0x9, 0x44, 0xc0, 0x4, 
+	0xc0, 0x5, 0xc0, 0x6, 0xc0, 0x7, 0xaf, 0x2c, 0x12, 0x9, 0x96, 0xe4, 0xfc, 0xfd, 0xfe, 0xd0, 
+	0x3, 0xd0, 0x2, 0xd0, 0x1, 0xd0, 00, 0xeb, 0x5f, 0xff, 0xe4, 0xfb, 0xfa, 0xf9, 0xf8, 0xc3, 
+	0x12, 0x4, 0xcf, 0x60, 0x3, 0x7f, 0x1, 0x22, 0x12, 0x1f, 0xd9, 0x50, 0xa9, 0x7f, 00, 0x22, 
+	0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0xd, 
+	0xa, 00, 0x69, 0x64, 0x3a, 0x20, 00, 00, 0x50, 00, 0x4d, 00, 0x50, 0x20, 00, 00, 
+	00, 0xd, 0xa, 0x20, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x20, 0x40, 0x31, 0x30, 0x20, 0x40, 
+	0x31, 0x30, 0x30, 0x20, 0x40, 0x31, 0x30, 0x30, 0x30, 00, 0x4f, 0x6b, 0x20, 0x20, 0x20, 0x20, 
+	0x20, 0x20, 00, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x20, 00, 0xd, 0xa, 0x54, 0x65, 0x73, 0x74, 
+	0x20, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0xd, 0xa, 00, 0x8f, 0x38, 0x12, 
+	0x1f, 0x78, 0x12, 0x1a, 0x75, 0x12, 0x13, 0x15, 0x12, 0x1f, 0x6f, 0x7a, 0xb6, 0x12, 0x13, 0x1f, 
+	0x75, 0x3d, 0xff, 0x75, 0x3e, 0x7, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x12, 0xaf, 0x38, 0x12, 0x19, 
+	0x65, 0x75, 0x3d, 00, 0x75, 0x3e, 0xff, 0x7b, 0xa2, 0x7a, 00, 0x7d, 0x11, 0xaf, 0x38, 0x12, 
+	0x19, 0x65, 0x7a, 0x96, 0x12, 0x13, 0x1f, 0xaf, 0x38, 0x12, 0x1f, 0x78, 0x12, 0x1a, 0x80, 0x12, 
+	0x13, 0x15, 0x2, 0x1f, 0x81, 0x7d, 0x8, 0xaf, 0x38, 0x12, 0x19, 0x65, 0xaf, 0x38, 0x22, 0x7b, 
+	0x8a, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xea, 0x22, 0x8f, 0x3f, 0x8d, 0x40, 0x12, 0x1f, 0xc4, 
+	0x8f, 0x45, 0xaf, 0x3f, 0x12, 0x1f, 0xcb, 0x8f, 0x46, 0x7b, 0x1, 0xad, 0x45, 0x7f, 0x60, 0x12, 
+	0x9, 0x58, 0xe5, 0x46, 0x75, 0xf0, 0x20, 0xa4, 0xff, 0xe5, 0xf0, 0x44, 0x4, 0xfc, 0xef, 0x45, 
+	0x40, 0xfd, 0xe4, 0xff, 0xfe, 0x12, 0x9, 0x75, 0x12, 0x9, 0x5f, 0xaf, 0x45, 0x12, 0x1b, 0x2f, 
+	0x7b, 0x2, 0xad, 0x45, 0x7f, 0x60, 0x12, 0x9, 0x44, 0x8f, 0x44, 0x8e, 0x43, 0x8d, 0x42, 0x8c, 
+	0x41, 0xe5, 0x42, 0x54, 0x1, 0xfd, 0xed, 0x70, 0x5, 0xae, 0x43, 0xaf, 0x44, 0x22, 0xe4, 0xfe, 
+	0xff, 0x22, 0x8f, 0x35, 0x8d, 0x36, 0xe4, 0xf5, 0x38, 0xfb, 0x7a, 00, 0x79, 0x39, 0x12, 0x14, 
+	0xa2, 0xef, 0x64, 0x80, 0x4e, 0x60, 0x3, 0x75, 0x38, 0x1, 0xe5, 0x39, 0x65, 0x35, 0x60, 0x3, 
+	0x75, 0x38, 0x1, 0xe5, 0x38, 0x70, 0x25, 0xf5, 0x37, 0x12, 0x1d, 0x17, 0xa8, 0x4, 0xa9, 0x5, 
+	0xaa, 0x6, 0xab, 0x7, 0xe4, 0x25, 0x36, 0x12, 0x1b, 0x58, 0xc3, 0x12, 0x4, 0xcf, 0x60, 0x3, 
+	0x75, 0x38, 0x1, 0x5, 0x37, 0xe5, 0x37, 0xc3, 0x94, 0x1f, 0x40, 0xdd, 0x12, 0x1d, 0x2b, 0xaf, 
+	0x38, 0x22, 0x8f, 0x35, 0x8d, 0x36, 0xe4, 0xfb, 0xfa, 0xfd, 0x12, 0x17, 0xea, 0xe5, 0x36, 0x54, 
+	0x3, 0xff, 0x70, 0x6, 0xf5, 0x37, 0xf5, 0x38, 0x80, 0x14, 0xbf, 0x1, 0x8, 0x75, 0x37, 0x20, 
+	0x75, 0x38, 00, 0x80, 0x9, 0xbf, 0x2, 0x6, 0x75, 0x37, 00, 0x75, 0x38, 0x40, 0xe5, 0x36, 
+	0x30, 0xe4, 0x3, 0x43, 0x37, 0x1, 0xe5, 0x36, 0x30, 0xe7, 0x3, 0x43, 0x37, 0x40, 0xab, 0x38, 
+	0xaa, 0x37, 0xe4, 0xfd, 0xaf, 0x35, 0x2, 0x17, 0xea, 0x8f, 0x27, 0x12, 0x1f, 0x6f, 0x7b, 0xf0, 
+	0x7a, 0xaf, 0x7d, 0x10, 0xaf, 0x27, 0x12, 0x17, 0xea, 0x7d, 0x11, 0xaf, 0x27, 0x12, 0x13, 0x29, 
+	0xee, 0xc4, 0xf8, 0x54, 0xf0, 0xc8, 0xef, 0xc4, 0x54, 0xf, 0x48, 0x54, 0x1f, 0xff, 0xc3, 0x94, 
+	0x10, 0x40, 0x6, 0xef, 0xd3, 0x94, 0x14, 0x40, 0x12, 0xaf, 0x27, 0x12, 0x1f, 0x78, 0x75, 0x3d, 
+	0x3, 0x12, 0x1a, 0x83, 0x7d, 0xc, 0xaf, 0x27, 0x12, 0x19, 0x65, 0xaf, 0x27, 0x2, 0x1f, 0x81, 
+	0x75, 0x27, 0x1, 0x7b, 0x6, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x58, 0x7f, 0x80, 0x7e, 0x1, 
+	0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x5f, 0x7b, 0x7, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x58, 
+	0xe4, 0x25, 0x27, 0xff, 0xe4, 0x33, 0xfe, 0xe4, 0x33, 0xfd, 0xe4, 0x34, 0xc2, 0xfc, 0x12, 0x9, 
+	0x5f, 0x7f, 0x1, 0x7e, 0x26, 0x12, 0x16, 0x81, 0x5, 0x27, 0xe5, 0x27, 0xd3, 0x94, 0xf, 0x40, 
+	0xc2, 0x22, 0x8b, 0x3a, 0x8a, 0x3b, 0x89, 0x3c, 0xe4, 0xf5, 0x8, 0xf5, 0x9, 0x12, 0x14, 0xd6, 
+	0xe5, 0x3d, 0x54, 0x3f, 0xf5, 0x41, 0x85, 0x3e, 0x42, 0xe5, 0x3b, 0x45, 0x3c, 0x45, 0x3a, 0x60, 
+	0x10, 0xe5, 0x40, 0x54, 0x7, 0xab, 0x3a, 0xaa, 0x3b, 0xa9, 0x3c, 0x12, 0x3, 0x93, 0x12, 0x14, 
+	0xd6, 0xae, 0x41, 0xaf, 0x42, 0x22, 0x12, 0x1d, 0x17, 0x8f, 0x40, 0x8e, 0x3f, 0x8d, 0x3e, 0x8c, 
+	0x3d, 0x22, 0xc0, 0xe0, 0xc0, 0xd0, 0x75, 0xd0, 0x10, 0x30, 0x98, 0x29, 0xaf, 0x99, 0xc2, 0x98, 
+	0xe5, 0x1e, 0x24, 0x1, 0xfd, 0xe4, 0x33, 0xfc, 0xe5, 0x1f, 0x7a, 00, 0xb5, 0x15, 0x8, 0xea, 
+	0xb5, 0x14, 0x4, 0xd2, 0x5, 0x80, 0xe, 0x74, 0x80, 0x25, 0x1e, 0xf8, 0xa6, 0x17, 0xe5, 0x1e, 
+	0x4, 0x54, 0x1f, 0xf5, 0x1e, 0x30, 0x99, 0x4, 0xc2, 0x99, 0xd2, 0x6, 0xd0, 0xd0, 0xd0, 0xe0, 
+	0x32, 0x8b, 0x23, 0x8a, 0x24, 0x89, 0x25, 0xab, 0x26, 0xaa, 0x27, 0xa9, 0x28, 0x12, 0x3, 0x7a, 
+	0xf5, 0x29, 0x70, 0x2, 0xff, 0x22, 0x74, 0x1, 0x25, 0x28, 0xf5, 0x28, 0xe4, 0x35, 0x27, 0xf5, 
+	0x27, 0xab, 0x23, 0x5, 0x25, 0xe5, 0x25, 0xaa, 0x24, 0x70, 0x2, 0x5, 0x24, 0x14, 0xf9, 0x12, 
+	0x3, 0x7a, 0xff, 0x12, 0x1c, 0x60, 0xef, 0x65, 0x29, 0x60, 0xcc, 0x7f, 0x1, 0x22, 0x8f, 0x3a, 
+	0x8e, 0x39, 0x8d, 0x38, 0x8c, 0x37, 0x20, 0x8, 0x30, 0x7b, 0xc0, 0xad, 0xa, 0x7f, 0x20, 0x12, 
+	0x9, 0x58, 0xaf, 0x3a, 0xae, 0x39, 0xad, 0x38, 0xac, 0x37, 0x12, 0x9, 0x5f, 0xe4, 0x78, 0xa7, 
+	0xf6, 0x7b, 0xc8, 0xad, 0xa, 0x7f, 0x20, 0x12, 0x9, 0x44, 0xee, 0x30, 0xe0, 0xb, 0x78, 0xa7, 
+	0x6, 0xe6, 0xd3, 0x94, 0x64, 0x40, 0xea, 0xd2, 0x8, 0x22, 0x12, 0x19, 0x3f, 0x8f, 0x2b, 0xe4, 
+	0xf5, 0x2a, 0xaf, 0x2a, 0x12, 0x9, 0x96, 0xef, 0xf4, 0xff, 0xef, 0x55, 0x2b, 0xff, 0xe4, 0x8f, 
+	0x39, 0xf5, 0x38, 0xf5, 0x37, 0xf5, 0x36, 0xe5, 0x2a, 0x24, 0x80, 0xfb, 0xe4, 0x75, 0x3d, 0x5f, 
+	0xf5, 0x3c, 0xf5, 0x3b, 0xf5, 0x3a, 0xfd, 0x7f, 0x40, 0x12, 0x10, 0x7c, 0x5, 0x2a, 0xe5, 0x2a, 
+	0xc3, 0x94, 0x7, 0x40, 0xcd, 0x22, 0x12, 0x1e, 0xe0, 0x50, 0x35, 0x12, 0x1e, 0x9, 0xef, 0x64, 
+	0xa, 0x60, 0x2d, 0xbf, 0x8, 0xb, 0xe5, 0x18, 0xd3, 0x94, 00, 0x40, 0x23, 0x15, 0x18, 0x80, 
+	0x1f, 0xe5, 0x18, 0xc3, 0x94, 0x1e, 0x50, 0xa, 0xae, 0x18, 0x5, 0x18, 0x74, 0x62, 0x2e, 0xf8, 
+	0xa6, 0x7, 0xbf, 0xd, 0xb, 0xe5, 0x18, 0xb4, 0x1e, 0x4, 0x78, 0x7f, 0x76, 0xd, 0xd3, 0x22, 
+	0xc3, 0x22, 0x8f, 0x25, 0x8d, 0x26, 0xe5, 0x25, 0x64, 0x6, 0x60, 0x2d, 0xe5, 0x26, 0x54, 0x3, 
+	0xff, 0xbf, 0x2, 0x5, 0xaf, 0x25, 0x12, 0x14, 0x19, 0xe5, 0x26, 0x54, 0x3, 0x70, 0x1a, 0xaf, 
+	0x25, 0x12, 0x1f, 0x78, 0x12, 0x1a, 0x68, 0xaf, 0x25, 0x12, 0x19, 0x65, 0x12, 0x1a, 0x68, 0xaf, 
+	0x25, 0x12, 0x19, 0x65, 0xaf, 0x25, 0x12, 0x1f, 0x81, 0x22, 0xaf, 0xb, 0x15, 0xb, 0xef, 0xd3, 
+	0x94, 00, 0x40, 0xd, 0x7f, 0x55, 0x7e, 0x55, 0x7d, 0x55, 0x7c, 0x55, 0x12, 0x15, 0x5e, 0x80, 
+	0xe9, 0x30, 0x8, 0x9, 0x75, 0x3c, 0x1, 0x12, 0x16, 0x74, 0xc2, 0x8, 0x22, 0xe4, 0xf5, 0x3c, 
+	0x12, 0x16, 0x74, 0x22, 0x75, 0x3d, 0x1, 0x7b, 0xc4, 0xad, 0xa, 0x7f, 0x20, 0x12, 0x17, 0x88, 
+	0x22, 0x8e, 0x28, 0x8f, 0x29, 0x7b, 0xb0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x58, 0xae, 0x28, 
+	0xaf, 0x29, 0xe4, 0xfc, 0xfd, 0x12, 0x9, 0x5f, 0x7f, 0xa, 0x12, 0x1f, 0xa1, 0x7b, 0xb0, 0xe4, 
+	0xfd, 0x7f, 0x40, 0x12, 0x9, 0x44, 0xef, 0x54, 0x7, 0x60, 0xa, 0x12, 0x1f, 0xd9, 0x50, 0xed, 
+	0x7f, 0x4, 0x12, 0x1f, 0xe1, 0x22, 0x8f, 0x28, 0x8d, 0x29, 0xe5, 0x29, 0xf4, 0x60, 0x29, 0x7b, 
+	0x10, 0xad, 0x28, 0x7f, 0x20, 0x12, 0x9, 0x58, 0x7f, 00, 0x7e, 0x6, 0x7d, 00, 0x7c, 00, 
+	0x12, 0x9, 0x5f, 0xad, 0x29, 0xaf, 0x28, 0x12, 0x7, 0x66, 0xe4, 0xfd, 0xaf, 0x28, 0x12, 00, 
+	0x26, 0x7d, 0x1, 0xaf, 0x28, 0x12, 0x1e, 0xd3, 0x2, 0x15, 0x9a, 0x8f, 0x38, 0x75, 0x3c, 0x5, 
+	0x75, 0x3d, 0x1, 0x7b, 0x19, 0xad, 0x38, 0x7f, 0x20, 0x12, 0x17, 0x88, 0xe5, 0x38, 0xb4, 0x6, 
+	0xe, 0x75, 0x3c, 0x2, 0x75, 0x3d, 0x1, 0x7b, 0x19, 0xfd, 0x7f, 0x20, 0x12, 0x17, 0x88, 0x7b, 
+	0x5, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x58, 0x7f, 0x22, 0x12, 0x1f, 0xb6, 0x2, 0x9, 0x5f, 
+	0xe4, 0xf5, 0x22, 0xe5, 0x22, 0x24, 0x80, 0xfb, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x58, 0x7f, 
+	00, 0x12, 0x1f, 0xb6, 0x12, 0x9, 0x5f, 0xe5, 0x22, 0xb4, 0x6, 0x5, 0x7d, 0x12, 0xff, 0x80, 
+	0x4, 0x7d, 0xff, 0xaf, 0x22, 0x12, 0x1b, 0xa7, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 
+	0xd2, 0x2, 0x15, 0x9a, 0x8b, 0x2b, 0x8a, 0x2c, 0x89, 0x2d, 0xe4, 0xf5, 0x2e, 0xab, 0x2b, 0x5, 
+	0x2d, 0xe5, 0x2d, 0xaa, 0x2c, 0x70, 0x2, 0x5, 0x2c, 0x14, 0xf9, 0x12, 0x3, 0x7a, 0xff, 0x12, 
+	0x1c, 0x15, 0xe5, 0x2e, 0xc3, 0x94, 0x5, 0x50, 0x5, 0x7f, 0x2d, 0x12, 0x1f, 0xe4, 0x5, 0x2e, 
+	0xe5, 0x2e, 0xc3, 0x94, 0x6, 0x40, 0xd6, 0x22, 0x8f, 0x39, 0x8d, 0x3a, 0x8b, 0x3b, 0x12, 0x9, 
+	0x44, 0x8f, 0x41, 0x8e, 0x40, 0x8d, 0x3f, 0x8c, 0x3e, 0x7b, 00, 0x7a, 00, 0x79, 0x3e, 0xad, 
+	0x3d, 0xaf, 0x3c, 0x12, 0x9, 0xc5, 0xab, 0x3b, 0xad, 0x3a, 0xaf, 0x39, 0x12, 0x9, 0x58, 0xaf, 
+	0x41, 0xae, 0x40, 0xad, 0x3f, 0xac, 0x3e, 0x2, 0x9, 0x5f, 00, 00, 0x10, 0x10, 0x80, 00, 
+	00, 00, 00, 0xe, 00, 0x15, 00, 0x10, 00, 0x15, 00, 0x12, 00, 0x15, 00, 0x14, 
+	00, 0x15, 00, 00, 0x10, 0xc, 0x80, 00, 00, 0x1, 00, 0xa, 00, 0x18, 00, 0xb, 
+	00, 0x18, 00, 0xc, 00, 0x18, 00, 0xd, 00, 0x18, 0x8f, 0x3f, 0x8d, 0x40, 0x8a, 0x41, 
+	0x8b, 0x42, 0x12, 0x1f, 0xc4, 0x8f, 0x43, 0xaf, 0x3f, 0x12, 0x1f, 0xcb, 0x8f, 0x44, 0x7b, 0x1, 
+	0xad, 0x43, 0x7f, 0x60, 0x12, 0x9, 0x58, 0xab, 0x44, 0xad, 0x40, 0xaf, 0x42, 0xae, 0x41, 0x12, 
+	0x1f, 0x21, 0x12, 0x9, 0x5f, 0xaf, 0x43, 0x2, 0x1b, 0x2f, 0x8f, 0x37, 0x7b, 00, 0x7a, 0x80, 
+	0xe4, 0xfd, 0x12, 0x17, 0xea, 0x7f, 0x2, 0x12, 0x1d, 0x7a, 0xe4, 0xf5, 0x38, 0xe4, 0xfd, 0xaf, 
+	0x37, 0x12, 0x13, 0x29, 0xee, 0x30, 0xe7, 0x10, 0x5, 0x38, 0xe5, 0x38, 0xd3, 0x94, 0xc8, 0x50, 
+	0x7, 0x7f, 0x1, 0x12, 0x1d, 0x7a, 0x80, 0xe5, 0x22, 0xc1, 0x5, 0xc1, 0x4, 0x1, 0x1e, 00, 
+	0x1, 0x1f, 00, 0xc1, 00, 0xc1, 0x1, 0x1, 0xe, 00, 0xc1, 0x2, 0xc1, 0x3, 0x1, 0xc, 
+	0xa, 0x1, 0xd, 0x64, 0xc1, 0x7, 0x1, 0xf, 00, 0xc1, 0x8, 0x1, 0x18, 00, 0x1, 0x4d, 
+	00, 0x1, 0x51, 00, 00, 0x8f, 0x2a, 0x8e, 0x29, 0x8d, 0x28, 0x8c, 0x27, 0x7b, 0xd0, 0xe4, 
+	0xfd, 0x7f, 0x40, 0x12, 0x9, 0x58, 0xaf, 0x2a, 0xae, 0x29, 0xad, 0x28, 0xac, 0x27, 0x12, 0x9, 
+	0x5f, 0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x44, 0xef, 0x54, 0x3, 0x70, 0xf2, 0x22, 
+	0xe4, 0xfe, 0xee, 0x90, 00, 0x40, 0x93, 0xfc, 0xed, 0x2e, 0xf8, 0xa6, 0x4, 0xe, 0xbe, 0x6, 
+	0xf1, 0xed, 0x24, 0x5, 0xf8, 0xe6, 0x2f, 0xf6, 0xc3, 0x9f, 0x50, 0xd, 0xed, 0x24, 0x4, 0xf8, 
+	0x6, 0xe6, 0x70, 0x5, 0xed, 0x24, 0x3, 0xf8, 0x6, 0x22, 0x7b, 0x17, 0xe4, 0xfd, 0x7f, 0xe0, 
+	0x12, 0x9, 0x58, 0x7f, 0xff, 0x7e, 0xff, 0x7d, 0xff, 0x7c, 0xff, 0x12, 0x9, 0x5f, 0x7b, 0x16, 
+	0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x58, 0x7f, 0x9a, 0x7e, 0x22, 0x7d, 00, 0x7c, 00, 0x2, 
+	0x9, 0x5f, 0x8f, 0x32, 0x8d, 0x33, 0x8b, 0x34, 0x12, 0x1f, 0x49, 0xaf, 0x33, 0x12, 0x1f, 0x49, 
+	0x7f, 0x5, 0x12, 0x1f, 0x17, 0xe5, 0x34, 0x44, 0x10, 0xfd, 0xaf, 0x32, 0x12, 0x13, 0xd2, 0xe5, 
+	0x34, 0x44, 0x10, 0xfd, 0xaf, 0x33, 0x2, 0x13, 0xd2, 0x8f, 0x32, 0xed, 0x70, 0x2, 0x80, 0x1, 
+	0xe4, 0x75, 0x39, 0x86, 0x75, 0x38, 0x2, 0xf5, 0x37, 0xf5, 0x36, 0x75, 0x3d, 0xff, 0x75, 0x3c, 
+	0xf, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x2, 0xad, 0x32, 0x7f, 0x20, 0x12, 0x10, 0x7c, 0x22, 0xe4, 
+	0xf5, 0x2c, 0xf5, 0x2d, 0xaf, 0x2d, 0x12, 00, 0x3, 0xef, 0x60, 0xd, 0x7b, 00, 0x7a, 00, 
+	0x79, 0x2c, 0x7d, 0x1, 0xaf, 0x2d, 0x12, 0x9, 0x9d, 0x5, 0x2d, 0xe5, 0x2d, 0xc3, 0x94, 0x7, 
+	0x40, 0xe2, 0xaf, 0x2c, 0x22, 0x8f, 0x39, 0x8d, 0x3a, 0x8a, 0x3b, 0x8b, 0x3c, 0x12, 0x13, 0x29, 
+	0xe5, 0x3e, 0xf4, 0xfd, 0xe5, 0x3d, 0xf4, 0x5e, 0xfe, 0xef, 0x5d, 0x42, 0x3c, 0xee, 0x42, 0x3b, 
+	0xab, 0x3c, 0xaa, 0x3b, 0xad, 0x3a, 0xaf, 0x39, 0x2, 0x17, 0xea, 0x8e, 0x48, 0x8f, 0x49, 0xe4, 
+	0xff, 0x12, 0x1d, 0xc4, 0x7f, 0x3, 0x12, 0x1a, 0x45, 0xe5, 0x48, 0xff, 0x12, 0x1a, 0x45, 0xaf, 
+	0x49, 0x12, 0x1a, 0x45, 0x12, 0x1b, 0xe, 0x8f, 0x4a, 0x7f, 0x1, 0x12, 0x1d, 0xc4, 0xaf, 0x4a, 
+	0x22, 0x12, 0x1c, 0x60, 0x74, 0x30, 0xd3, 0x9f, 0x50, 0xa, 0xef, 0x94, 0x39, 0x50, 0x5, 0xef, 
+	0x24, 0xd0, 0xff, 0x22, 0x74, 0x41, 0xd3, 0x9f, 0x50, 0xa, 0xef, 0x94, 0x46, 0x50, 0x5, 0xef, 
+	0x24, 0xc9, 0xff, 0x22, 0x7f, 0xff, 0x22, 0xc2, 0x8e, 0x75, 0x8b, 0x92, 0x75, 0x8d, 0xe6, 0xd2, 
+	0x8e, 0xd2, 0x3, 0xd5, 0xc, 0x15, 0x75, 0xc, 0xa, 0xd2, 00, 0xd5, 0xd, 0x5, 0x75, 0xd, 
+	0x64, 0xd2, 0x1, 0x30, 0x2, 0x5, 0xd5, 0xe, 0x2, 0xc2, 0x2, 0x32, 0x8b, 0x32, 0x8a, 0x33, 
+	0x89, 0x34, 0xab, 0x32, 0xaa, 0x33, 0xa9, 0x34, 0x12, 0x3, 0x7a, 0x60, 0x13, 0x5, 0x34, 0xe5, 
+	0x34, 0x70, 0x2, 0x5, 0x33, 0x14, 0xf9, 0x12, 0x3, 0x7a, 0xff, 0x12, 0x1d, 0xa0, 0x80, 0xe2, 
+	0x22, 0x78, 0x56, 0x12, 0x5, 0x6, 0xad, 0x7, 0x22, 0x78, 0x5a, 0x12, 0x5, 0x6, 0xab, 0x7, 
+	0x22, 0x78, 0x52, 0x12, 0x5, 0x6, 0x78, 0x5, 0x2, 0x4, 0xf3, 0xa9, 0x1a, 0x7a, 00, 0x7b, 
+	00, 0x75, 0x26, 0xff, 0x22, 0x8f, 0x29, 0xe4, 0xf5, 0x2a, 0xe5, 0x29, 0x54, 0x80, 0xff, 0x12, 
+	0x1d, 0xd6, 0xe5, 0x29, 0x25, 0xe0, 0xf5, 0x29, 0x12, 0x1f, 0x91, 0x12, 0x1f, 0x99, 0x5, 0x2a, 
+	0xe5, 0x2a, 0xc3, 0x94, 0x8, 0x40, 0xe3, 0x22, 0x75, 0x3d, 0x60, 0x75, 0x3e, 00, 0x7b, 00, 
+	0x7a, 0x20, 0x7d, 0x14, 0x22, 0x75, 0x3d, 0x2, 0x75, 0x3e, 00, 0x7b, 00, 0x7a, 0x2, 0x22, 
+	0x75, 0x3d, 0x2, 0x75, 0x3e, 00, 0xe4, 0xfb, 0xfa, 0x22, 0x8f, 0x35, 0x7d, 0x80, 0x7c, 00, 
+	0x12, 0xf, 0xa9, 0xe4, 0xf5, 0x36, 0xe4, 0x25, 0x35, 0x12, 0x1b, 0x58, 0x12, 0x15, 0x5e, 0x5, 
+	0x36, 0xe5, 0x36, 0xc3, 0x94, 0x20, 0x40, 0xee, 0x2, 0x16, 0x4a, 0x7b, 0x18, 0xe4, 0xfd, 0x7f, 
+	0xe0, 0x12, 0x9, 0x44, 0xec, 0x54, 0xf, 0xfc, 0x7b, 0xe9, 0x7a, 0x50, 0x79, 0x39, 0x78, 0x7, 
+	0xc3, 0x12, 0x4, 0xcf, 0x60, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x8f, 0x32, 0xe5, 0x32, 
+	0xd3, 0x94, 0x9, 0x40, 0xb, 0xe5, 0x32, 0x75, 0xf0, 0xa, 0x84, 0x12, 0x1f, 0x3f, 0x80, 0x2, 
+	0x7f, 0x20, 0x12, 0x1d, 0xa0, 0xe5, 0x32, 0x12, 0x1f, 0x3f, 0x2, 0x1d, 0xa0, 0xe4, 0xf5, 0x4e, 
+	0x7f, 0x3, 0x12, 0x1f, 0x17, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e, 0x9c, 0x50, 0x5, 0xaf, 
+	0x22, 0x12, 0xa, 0xe, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xeb, 0x22, 0xe4, 0xf5, 
+	0x29, 0xe5, 0x2a, 0x25, 0xe0, 0xf5, 0x2a, 0x12, 0x1f, 0x91, 0x12, 0x1d, 0xe8, 0xef, 0x42, 0x2a, 
+	0x12, 0x1f, 0x99, 0x5, 0x29, 0xe5, 0x29, 0xc3, 0x94, 0x8, 0x40, 0xe5, 0xaf, 0x2a, 0x22, 0x8f, 
+	0x47, 0x7f, 0x5, 0x12, 0x1f, 0xa1, 0xe4, 0xfb, 0xad, 0x47, 0x7f, 0x60, 0x12, 0x9, 0x44, 0xef, 
+	0x54, 0xb, 0x60, 0xa, 0x12, 0x1f, 0xd9, 0x50, 0xed, 0x7f, 0x2, 0x12, 0x1f, 0xe1, 0x22, 0x7f, 
+	00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0xff, 0xe4, 0x34, 0x56, 0xfe, 0xe4, 0x34, 0x34, 
+	0xfd, 0xe4, 0x34, 0x12, 0xfc, 0x22, 0xff, 0x74, 0x3, 0xa8, 0x6, 0x8, 0x22, 0xad, 0x7, 0xe4, 
+	0xf5, 0x39, 0xf5, 0x38, 0x75, 0x37, 0x1, 0x75, 0x36, 0x10, 0xf5, 0x3d, 0xf5, 0x3c, 0x75, 0x3b, 
+	0x1, 0x75, 0x3a, 0x18, 0xfb, 0x7f, 0x20, 0x2, 0x10, 0x7c, 0x8f, 0x25, 0x12, 0x1f, 0xbd, 0xe4, 
+	0xfd, 0x12, 0x9, 0x9d, 0xaf, 0x25, 0x12, 0x1e, 0x9c, 0x50, 0x5, 0xaf, 0x25, 0x12, 0x1f, 0x5d, 
+	0x7d, 0xff, 0xaf, 0x25, 0x2, 0x1b, 0xa7, 0x8f, 0x26, 0x8d, 0x27, 0xe5, 0x26, 0x64, 0x5, 0x60, 
+	0x11, 0xe5, 0x27, 0xfd, 0x7c, 00, 0xaf, 0x26, 0x12, 0x1d, 0xb2, 0xad, 0x27, 0xaf, 0x26, 0x12, 
+	0x16, 0xb6, 0x22, 0xbf, 0x6, 0x3, 0x7f, 0x12, 0x22, 0x7d, 0x1c, 0x12, 0x13, 0x29, 0xef, 0x13, 
+	0x13, 0x13, 0x54, 0x3, 0xfe, 0xef, 0x30, 0xe5, 0x3, 0x43, 0x6, 0x10, 0xaf, 0x6, 0x22, 0x8f, 
+	0x2b, 0x12, 0x1e, 0x72, 0x7d, 0x1, 0xaf, 0x2b, 0x12, 0x1e, 0xc6, 0xaf, 0x2b, 0x12, 0x9, 0x96, 
+	0x12, 0x12, 0xf, 0xe4, 0xfd, 0xaf, 0x2b, 0x2, 0x1e, 0xc6, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 
+	0x1e, 0x9c, 0x50, 0x5, 0xaf, 0x22, 0x12, 0xc, 0xe1, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 
+	0x40, 0xeb, 0xc2, 0x9, 0x22, 0x8f, 0x2f, 0xe5, 0x2f, 0xc4, 0x54, 0xf, 0xff, 0x12, 0x1e, 0x63, 
+	0x12, 0x1d, 0xa0, 0xe5, 0x2f, 0x54, 0xf, 0xff, 0x12, 0x1e, 0x63, 0x2, 0x1d, 0xa0, 0x8f, 0x28, 
+	0x8e, 0x27, 0x8d, 0x26, 0x8c, 0x25, 0x78, 0x10, 0x12, 0x4, 0xe0, 0x12, 0x1e, 0x18, 0xe5, 0x28, 
+	0xff, 0xe5, 0x27, 0xfe, 0x2, 0x1e, 0x18, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1f, 0xc, 0x74, 
+	0xa0, 0x25, 0x22, 0xf8, 0xa6, 0x7, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xeb, 0x22, 
+	0xd3, 0xef, 0x64, 0x80, 0xf8, 0x74, 0x61, 0x64, 0x80, 0x98, 0x50, 0xc, 0xef, 0x64, 0x80, 0x94, 
+	0xfa, 0x50, 0x5, 0xef, 0x24, 0xe0, 0xff, 0x22, 0x22, 0x8f, 0x25, 0x12, 0x1b, 0xc3, 0x8f, 0x26, 
+	0x7d, 0x5, 0xaf, 0x25, 0x12, 0x13, 0x29, 0xee, 0x30, 0xe2, 0x3, 0x43, 0x26, 0x20, 0xaf, 0x26, 
+	0x22, 0x75, 0xcb, 0xff, 0x75, 0xca, 0x2, 0x75, 0xcd, 0xff, 0x75, 0xcc, 0x2, 0x75, 0xc8, 0x34, 
+	0x75, 0x98, 0x52, 0xd2, 0xbc, 0xd2, 0xac, 0x22, 0x12, 0x1a, 0xab, 0xef, 0x60, 0x5, 0x7f, 0x5, 
+	0x12, 0x1f, 0xe1, 0x12, 0x1c, 0xed, 0xef, 0x60, 0x5, 0x7f, 0x6, 0x12, 0x1f, 0xe1, 0x22, 0x8f, 
+	0x37, 0x12, 0x1f, 0x78, 0x75, 0x3d, 0x3, 0x12, 0x1a, 0x78, 0x7d, 0xc, 0xaf, 0x37, 0x12, 0x19, 
+	0x65, 0xaf, 0x37, 0x2, 0x1f, 0x81, 0xe4, 0xff, 0x12, 0x1d, 0xc4, 0x7f, 0x5, 0x12, 0x1a, 0x45, 
+	0x12, 0x1b, 0xe, 0x8f, 0x28, 0x7f, 0x1, 0x12, 0x1d, 0xc4, 0xaf, 0x28, 0x22, 0xe4, 0xf5, 0x23, 
+	0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e, 0x9c, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xf2, 
+	0xaf, 0x23, 0x22, 0xe4, 0xf5, 0xff, 0xf5, 0xfe, 0xf5, 0xfd, 0x75, 0xfc, 0x1, 0x75, 0xf9, 0xe0, 
+	0x75, 0xfb, 0x14, 0xd2, 0xf8, 0x80, 0xfe, 0xe5, 0x8, 0xfd, 0xe5, 0x9, 0xfb, 0x7f, 0x80, 0x12, 
+	0x9, 0x44, 0x5, 0x9, 0xe5, 0x9, 0x70, 0x2, 0x5, 0x8, 0x22, 0xe4, 0xfb, 0x7d, 0x4, 0x7f, 
+	0x80, 0x12, 0x9, 0x58, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x2, 0x9, 0x5f, 0x8f, 
+	0x32, 0xaf, 0x32, 0x15, 0x32, 0xef, 0xd3, 0x94, 00, 0x40, 0x7, 0x7f, 0x20, 0x12, 0x1d, 0xa0, 
+	0x80, 0xef, 0x22, 0x8f, 0x51, 0x7b, 0x35, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x58, 0xaf, 0x51, 
+	0xe4, 0xfc, 0xfd, 0xfe, 0x2, 0x9, 0x5f, 0x53, 0x89, 0xf, 0x43, 0x89, 0x10, 0x75, 0x8b, 0x92, 
+	0x75, 0x8d, 0xe6, 0xc2, 0xbb, 0xd2, 0xab, 0xd2, 0x8e, 0x22, 0xc2, 0x3, 0xae, 0x7, 0x1f, 0xee, 
+	0xd3, 0x94, 00, 0x40, 0x7, 0x30, 0x3, 0xfd, 0xc2, 0x3, 0x80, 0xf0, 0x22, 0x7b, 0x14, 0xe4, 
+	0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x58, 0x7f, 0x1, 0x12, 0x1f, 0xb6, 0x12, 0x9, 0x5f, 0x80, 0xfe, 
+	0xc2, 0x6, 0x8f, 0x99, 0x7f, 0x2, 0x12, 0x1f, 0xa1, 0x20, 0x6, 0x5, 0x12, 0x1f, 0xd9, 0x50, 
+	0xf8, 0x22, 0x8f, 0x28, 0x8c, 0x29, 0x8d, 0x2a, 0x12, 0x1b, 0xdf, 0xad, 0x2a, 0xac, 0x29, 0xaf, 
+	0x28, 0x2, 0x8, 0x5c, 0xef, 0x60, 0x6, 0xe5, 0x51, 0x44, 0x2, 0x80, 0x4, 0xe5, 0x51, 0x54, 
+	0xfd, 0xff, 0x12, 0x1d, 0x53, 0x22, 0xef, 0x60, 0x6, 0xe5, 0x51, 0x44, 0x1, 0x80, 0x4, 0xe5, 
+	0x51, 0x54, 0xfe, 0xff, 0x12, 0x1d, 0x53, 0x22, 0x7b, 0x35, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 
+	0x44, 0xef, 0x54, 0x10, 0xc4, 0x54, 0xf, 0xff, 0x22, 0x5, 0xf, 0xe5, 0xf, 0xc3, 0x94, 0x96, 
+	0x40, 0x6, 0xe4, 0xf5, 0xf, 0x12, 0x1f, 0xa8, 0x22, 0x74, 0x80, 0x25, 0x1f, 0xf8, 0xe6, 0xff, 
+	0xe5, 0x1f, 0x4, 0x54, 0x1f, 0xf5, 0x1f, 0x22, 0x8e, 0x29, 0x8f, 0x2a, 0xe5, 0x29, 0xff, 0x12, 
+	0x1c, 0x15, 0xaf, 0x2a, 0x2, 0x1c, 0x15, 0x5, 0x4d, 0xe5, 0x4d, 0xc3, 0x94, 0xa, 0x40, 0x5, 
+	0xe4, 0xf5, 0x4d, 0xd2, 0x9, 0x22, 0x75, 0x3d, 0x12, 0x75, 0x3e, 00, 0x7b, 00, 0x7a, 0x12, 
+	0xe4, 0xfd, 0x2, 0x19, 0x65, 0x4c, 0x75, 0x74, 0x6f, 0x6e, 0x20, 0x32, 0x2e, 0x32, 0x39, 0x61, 
+	0x5f, 0x61, 0x74, 0x68, 0xe4, 0xff, 0x12, 0x1d, 0xc4, 0x7f, 0x6, 0x12, 0x1a, 0x45, 0x7f, 0x1, 
+	0x2, 0x1d, 0xc4, 0xef, 0xc3, 0x94, 0xa, 0xef, 0x50, 0x4, 0x24, 0x30, 0xff, 0x22, 0x24, 0x57, 
+	0xff, 0x22, 0xad, 0x7, 0x75, 0x3c, 0x10, 0xe4, 0xf5, 0x3d, 0xfb, 0x7f, 0x20, 0x2, 0x17, 0x88, 
+	0x7d, 0x25, 0x12, 0x18, 0xa0, 0x7b, 00, 0x7a, 00, 0x79, 0x25, 0x2, 0x17, 0x54, 0x45, 0x52, 
+	0x41, 0x53, 0x45, 00, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 00, 0xef, 0x90, 0x1e, 0xb1, 
+	0x93, 0xd3, 0x94, 0x1, 0x50, 0x2, 0x80, 0x1, 0xc3, 0x22, 00, 0x1, 0x2, 0x3, 0x4, 0xff, 
+	0x6, 00, 00, 00, 00, 00, 0xff, 0x1, 0x7d, 0x1, 0x12, 0x13, 0x29, 0xef, 0x30, 0xe2, 
+	0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0x8f, 0x3c, 0x8d, 0x3d, 0x7b, 0xe, 0xe4, 0xfd, 0x7f, 0xa0, 
+	0x2, 0x17, 0x88, 0x8f, 0x3c, 0x8d, 0x3d, 0x7b, 0x10, 0xe4, 0xfd, 0x7f, 0x40, 0x2, 0x17, 0x88, 
+	0xe5, 0x1e, 0x65, 0x1f, 0x60, 0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0xe5, 0xaa, 0x54, 0x3, 0x60, 
+	0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0x7f, 0x3, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x2, 0x18, 
+	0x75, 0xa8, 0x1a, 0xe6, 0xb4, 0x20, 0x4, 0x5, 0x1a, 0x80, 0xf6, 0x22, 0x12, 0x1e, 0x9c, 0x50, 
+	0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0xc2, 0x2, 0x8f, 0xe, 0xd2, 0x2, 0x20, 0x2, 0xfd, 
+	0x22, 0xeb, 0x75, 0xf0, 0x20, 0xa4, 0x4d, 0xac, 0xf0, 0xfd, 0x22, 0x7f, 0x30, 0x12, 0x1d, 0xa0, 
+	0x7f, 0x78, 0x2, 0x1d, 0xa0, 0x7f, 0xd, 0x12, 0x1d, 0xa0, 0x7f, 0xa, 0x2, 0x1d, 0xa0, 0x75, 
+	0xf0, 0xa, 0x84, 0xe5, 0xf0, 0x24, 0x30, 0xff, 0x22, 0x8f, 0x35, 0x12, 0x18, 0x1a, 0xaf, 0x35, 
+	0x2, 0xa, 0xe, 0xd3, 0xe5, 0x26, 0x94, 00, 0xe5, 0x25, 0x94, 00, 0x22, 0xef, 0x64, 0x6, 
+	0x60, 0x3, 0x12, 0x1c, 0xbf, 0x22, 0x7b, 0x1, 0x7a, 00, 0x7d, 0x1f, 0x2, 0x17, 0xea, 0x7b, 
+	0xb5, 0x7a, 0x52, 0x7d, 0x1f, 0x2, 0x17, 0xea, 0x7b, 0x30, 0x7a, 0x2a, 0x7d, 0x1f, 0x2, 0x17, 
+	0xea, 0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0x2, 0x17, 0xea, 0x7d, 0x32, 0x12, 0x18, 0xa0, 0xaf, 0x37, 
+	0x22, 0xe5, 0x51, 0x44, 0x4, 0xff, 0x2, 0x1d, 0x53, 0xe5, 0x51, 0x54, 0xfb, 0xff, 0x2, 0x1d, 
+	0x53, 0xc2, 0x2, 0x8f, 0xe, 0xd2, 0x2, 0x22, 0x7f, 0x3, 0x7e, 00, 0x2, 0x16, 0x81, 0x7f, 
+	0x5, 0x7e, 00, 0x2, 0x16, 0x81, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0x7b, 00, 0x7a, 
+	00, 0x79, 0x4e, 0x22, 0xef, 0x90, 0x1e, 0xb1, 0x93, 0xff, 0x22, 0xef, 0x90, 0x1e, 0xaa, 0x93, 
+	0xff, 0x22, 00, 0x1, 0x2, 0x3, 0x4, 0x6, 0x5, 0xa2, 0x2, 0xb3, 0x22, 0x12, 0x11, 0x49, 
+	0x22, 0xd2, 0x7, 0x22, 0x2, 0x1d, 0xa0, 0x2, 0x15, 0x9a, 0x22, 0x22, 
+};
diff --git a/board/ar7100/common/generic_i2c.c b/board/ar7100/common/generic_i2c.c
new file mode 100644
index 0000000000..32ef8a28e8
--- /dev/null
+++ b/board/ar7100/common/generic_i2c.c
@@ -0,0 +1,461 @@
+
+/* generic_i2c.c */
+
+#ifdef __BDI
+#include "bdi.h"
+#define protect()
+#define unprotect()
+#define generic_check_interruption() (1)
+#else
+#ifdef __ECOS
+#include <cyg/hal/ar7100_soc.h>
+#include "ag7100_ecos.h" 
+#define printk             DEBUG_PRINTF
+#define udelay             A_UDELAY
+#define protect()
+#define unprotect()
+#define generic_check_interruption() (1)
+#else
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <common.h>
+#include "ar7100_soc.h"
+#define printk printf
+
+#define protect()
+#define unprotect()
+
+#define generic_check_interruption() (1)
+
+#endif
+#endif
+
+#include "generic_i2c.h"
+
+#define GENERIC_I2C_IO_EXP            0x40
+
+#undef USE_TEST_CODE
+
+#ifndef COMPRESSED_UBOOT
+#define USE_TEST_CODE
+#endif
+
+/* ************************************************************** */
+
+static int generic_gpio_errcnt = 0;
+
+static void inline
+generic_gpio_errclr(void) 
+{
+  generic_gpio_errcnt = 0;
+}
+
+static void inline
+generic_gpio_check_rc(unsigned int rc) 
+{
+  if (rc) generic_gpio_errcnt++;
+}
+
+static int inline
+generic_gpio_errget(void) 
+{
+  return generic_gpio_errcnt;
+}
+
+/* ************************************************************** */
+
+#define GENERIC_I2C_SCL  (1<<0)
+#define GENERIC_I2C_SDA  (1<<1)
+#define GENERIC_I2C_PAUSE 2
+
+static void inline
+generic_i2c_chigh_dhigh(void)
+{
+  generic_gpio_check_rc(ar7100_gpio_float_high_test ( GENERIC_I2C_SCL | GENERIC_I2C_SDA ));
+  udelay( GENERIC_I2C_PAUSE);
+}
+
+static void inline
+generic_i2c_chigh_dlow(void)
+{
+  generic_gpio_check_rc(ar7100_gpio_float_high_test ( GENERIC_I2C_SCL ));
+  ar7100_gpio_drive_low( GENERIC_I2C_SDA );
+  udelay( GENERIC_I2C_PAUSE );
+}
+
+static void inline
+generic_i2c_clow_dlow(void)
+{
+  ar7100_gpio_drive_low( GENERIC_I2C_SCL |  GENERIC_I2C_SDA );
+  udelay( GENERIC_I2C_PAUSE );
+}
+
+static void inline
+generic_i2c_clow_dhigh(void)
+{
+  ar7100_gpio_drive_low( GENERIC_I2C_SCL );
+  generic_gpio_check_rc(ar7100_gpio_float_high_test( GENERIC_I2C_SDA ));
+  udelay( GENERIC_I2C_PAUSE );
+}
+
+static void inline
+generic_i2c_clow_dfloat(void)
+{
+  ar7100_gpio_drive_low( GENERIC_I2C_SCL );
+  ar7100_reg_rmw_clear(AR7100_GPIO_OE, GENERIC_I2C_SDA ); 
+  udelay( GENERIC_I2C_PAUSE );
+}
+
+static void inline
+generic_i2c_chigh_dfloat(void)
+{
+  ar7100_gpio_drive_high( GENERIC_I2C_SCL );
+  ar7100_reg_rmw_clear( AR7100_GPIO_OE, GENERIC_I2C_SDA ); 
+  udelay( GENERIC_I2C_PAUSE );
+}
+
+static int
+generic_i2c_chigh_dread(void)
+{
+  int d;
+
+  ar7100_gpio_float_high_test( GENERIC_I2C_SCL );
+  ar7100_reg_rmw_clear( AR7100_GPIO_OE, GENERIC_I2C_SDA ); 
+  udelay( GENERIC_I2C_PAUSE/2 );
+
+  d = (ar7100_reg_rd( AR7100_GPIO_IN ) & GENERIC_I2C_SDA) ? 1 : 0;
+  udelay ( GENERIC_I2C_PAUSE/2);
+
+  return d;
+}
+
+static void inline
+generic_i2c_start(void)
+{
+  generic_i2c_chigh_dhigh();
+  generic_i2c_chigh_dlow();
+  generic_i2c_clow_dlow();
+}
+
+static void inline
+generic_i2c_stop(void)
+{
+  generic_i2c_clow_dlow();
+  generic_i2c_chigh_dlow();
+  generic_i2c_chigh_dhigh();
+}
+
+static int
+generic_i2c_raw_write_8(unsigned char v)
+{
+  int ack;
+  int ii=7;
+  do {
+    if ((1<<ii) & v) {
+      generic_i2c_clow_dhigh();
+      generic_i2c_chigh_dhigh();
+    } else {
+      generic_i2c_clow_dlow();
+      generic_i2c_chigh_dlow();
+    }
+  } while (ii--);
+
+  generic_i2c_clow_dfloat();
+  ack=generic_i2c_chigh_dread();
+  generic_i2c_clow_dfloat();
+
+  return ack;
+} 
+
+static void
+generic_i2c_raw_read_8(char lastByte, unsigned char *v)
+{
+  int d;
+  int ii=7;
+  int jj=0;
+  do {
+    generic_i2c_clow_dfloat();
+    d=generic_i2c_chigh_dread();
+    if (d) jj |= 1<<ii;
+  } while (ii--);
+
+  if (lastByte) {
+    generic_i2c_clow_dfloat();
+    generic_i2c_chigh_dfloat();
+  } else {
+    generic_i2c_clow_dlow();
+    generic_i2c_chigh_dlow();
+  }
+  *v = jj & 0xff;
+}
+
+static int 
+generic_i2c_raw_write_bytes_to_addr(int addr, unsigned char *buffer, int count)
+{
+  volatile int ack;
+  int ii;
+  generic_gpio_errclr();
+  generic_i2c_start();
+  ack = generic_i2c_raw_write_8(addr&0xfe);
+  if (ack)
+    return 1;
+
+  for (ii=0; ii<count; ii++) { 
+    ack = generic_i2c_raw_write_8(buffer[ii]);
+  }
+  generic_i2c_stop();
+  return generic_gpio_errget();
+}
+
+static int
+generic_i2c_raw_read_bytes_from_addr(int addr, unsigned char *buffer, int count)
+{
+  int ack;
+  int ii;
+  generic_gpio_errclr();
+  generic_i2c_start();
+  ack = generic_i2c_raw_write_8((addr&0xff)|0x01);
+  for (ii=0; ii<count; ii++) generic_i2c_raw_read_8( ii==(count-1), &buffer[ii]);
+  generic_i2c_stop();  
+  return generic_gpio_errget();
+}
+
+#ifdef USE_TEST_CODE
+
+void generic_i2c_test_write_bits(void)
+{
+  printk("Writing bit stream of AA00\n");
+  generic_gpio_errclr();
+  do {
+    generic_i2c_start();
+    generic_i2c_raw_write_8(0xAA);
+    generic_i2c_raw_write_8(0x00);
+    generic_i2c_stop();  
+    udelay(1000);
+  } while generic_check_interruption();
+}
+
+void
+generic_i2c_test_addr_strapping(void)  
+{
+  int jj;
+
+  int end   = 0x7e;
+  int addr  = 0x20;
+  
+  jj=0;
+  printk("Looping through addresses %02x .. %02x\n", addr, end);
+  while (addr<end) {
+    volatile int ack;
+    generic_i2c_start();
+    ack = generic_i2c_raw_write_8(addr&0xfe);
+    generic_i2c_stop();
+    if (0==ack) {
+      jj++;
+      printk(" Found addr:  %02x\n", addr);
+    }
+    addr+=2;
+  };
+
+  if (0==jj)
+    printk(" Failed test, no i2c found\n");
+}
+
+#endif
+
+/* ************************************************************** */
+
+static unsigned short generic_i2c_shadow_of_gpio = 0;
+
+int
+generic_i2c_write_gpio(unsigned short d)
+{
+  int errcnt;
+
+  unsigned char b[2];
+  b[0] = d;
+  b[1] = d>>8;
+
+  protect();
+
+  errcnt = generic_i2c_raw_write_bytes_to_addr(GENERIC_I2C_IO_EXP, b, sizeof(b));
+  
+  if (errcnt == 0)
+    generic_i2c_shadow_of_gpio = d;
+  else
+    printk("%s failed: %d %04x\n",  __FUNCTION__, errcnt, d );
+  
+  unprotect();
+
+  return errcnt;
+}
+
+int
+generic_i2c_read_gpio(unsigned short *d)
+{
+  int errcnt;
+  unsigned char b[2];
+
+  protect();
+
+  errcnt = generic_i2c_raw_read_bytes_from_addr(GENERIC_I2C_IO_EXP, b, sizeof(b));
+  if (errcnt == 0) {
+    *d = b[1]<<8 | b[0];
+    generic_i2c_shadow_of_gpio = *d;
+  }
+  else
+    printk("%s failed: %d %04x\n",  __FUNCTION__, errcnt, *d );
+
+  unprotect();
+
+  return errcnt;
+}
+
+int
+generic_i2c_init_gpio(void)
+{
+  ar7100_gpio_enable_i2c_on_gpio_0_1();
+  generic_i2c_write_gpio(GENERIC_I2C_INIT_OUT_HIGH);
+  return 0;
+}
+
+#ifdef USE_TEST_CODE
+
+static void
+generic_i2c_val_bit_desc (unsigned int chg, unsigned short val, char *bit_descriptions[]) 
+{
+  int ii;
+  int jj;
+  char *p2;
+  
+  for (ii=0;ii<16; ii++) {
+    jj = 1<<(15-ii);
+    if ( chg & jj ) {
+      p2 = bit_descriptions[ii];
+      if (p2 && p2[0]) 
+	if (val & jj )     
+	  printk(" %s-H\n", p2);
+	else
+	  printk(" %s-L\n", p2);
+    }
+  }
+}
+
+static char *gpio_desc[16] = {
+  "tp28",      /* 15 */
+  "tp27",      /* 14 */
+  "tp26",      /* 13 */
+  "tp25",      /* 12 */
+  "tp24",      /* 11 */
+  "led2",      /* 10 */
+  "led1",      /*  9 */
+  "jump_sw",   /*  8 */
+  "7?",        /*  7 */
+  "sw_reset",  /*  6 */
+  "slic_int1", /*  5 */
+  "slic_int0", /*  4 */
+  "slic_cs1",  /*  3 */
+  "slic_cs0",  /*  2 */
+  "stereo",    /*  1 */
+  "vsc",       /*  0 */
+};
+
+void
+generic_i2c_test_read_write_gpio(void)
+{
+  unsigned short d;
+  unsigned short e;
+  unsigned short f;
+
+  printk("Looping on gpio alternately turning on LED1,TP24 and LED2,TP25 \n");
+  printk("Pressing either push button will generate an output\n");
+
+  generic_i2c_init_gpio();
+  do {
+    d= GENERIC_I2C_JUMP_LED1 | GENERIC_I2C_TP28 | GENERIC_I2C_INIT_INPUT;
+    generic_i2c_write_gpio(d);
+    generic_i2c_read_gpio (&e);
+    f = d^e;
+    if ( f & (GENERIC_I2C_INIT_OUT_HIGH|GENERIC_I2C_INIT_OUT_LOW ))
+      printk("err: wrote: %04x  expected: %04x  dif: %04x \n", d, e, f);
+
+    generic_i2c_val_bit_desc (f, e, gpio_desc); 
+    udelay(100000);
+
+    d= GENERIC_I2C_JUMP_LED2 | GENERIC_I2C_TP27;
+    generic_i2c_write_gpio(d);
+    generic_i2c_read_gpio (&e);
+    f = d^e;
+    if (f)
+      printk("err: wrote: %04x  expected: %04x  chg: %04x \n", d, e, f);
+
+    generic_i2c_val_bit_desc (f, e, gpio_desc); 
+    udelay(200000);
+
+  } while generic_check_interruption();
+}
+
+void
+generic_i2c_test_toggle(unsigned short t)
+{
+  unsigned short d=0;
+
+  printk("Toggling i2c GPIO pins %08x\n", t);
+  generic_i2c_read_gpio(&d);
+  do {
+    generic_i2c_write_gpio(d | t);
+    udelay(1000);
+    generic_i2c_write_gpio(d & ~t);
+    udelay(1000);
+  } while generic_check_interruption();
+}
+
+#endif
+
+int 
+generic_i2c_assert_cs(int cs)
+{
+  unsigned short d = generic_i2c_shadow_of_gpio;
+
+  /* We are active low, so turn on all of the bits */
+  d  |= GENERIC_I2C_VSC73XX_CS|GENERIC_I2C_STEREO_CS|GENERIC_I2C_SLIC_CS0;
+  
+  /* Depending on CS, turn a single bit off */
+  switch (cs) {
+  case GENERIC_I2C_VSC73XX_CS:
+  case GENERIC_I2C_STEREO_CS:
+  case GENERIC_I2C_SLIC_CS0:
+    d &= ~cs;
+    return generic_i2c_write_gpio(d);
+    
+  default:
+    printk("%s fail: %d\n", __FUNCTION__, cs);
+    return -1;
+  } 
+}
+
+void 
+generic_i2c_deassert_cs(void) {
+  unsigned short d = generic_i2c_shadow_of_gpio;
+
+  /* We are active low, so turn on all of the bits */
+  d  |= GENERIC_I2C_VSC73XX_CS|GENERIC_I2C_STEREO_CS|GENERIC_I2C_SLIC_CS0;
+  generic_i2c_write_gpio(d);
+}
+
+#ifdef USE_TEST_CODE
+
+void
+generic_i2c_test_cs_toggle(int cs)
+{
+  printk("Looping on CS %d \n", cs);
+
+  do {
+    generic_i2c_assert_cs(cs);
+    generic_i2c_deassert_cs();
+    udelay(1000);
+  } while generic_check_interruption();
+}
+
+#endif
+
diff --git a/board/ar7100/common/generic_i2c.h b/board/ar7100/common/generic_i2c.h
new file mode 100644
index 0000000000..7a36618541
--- /dev/null
+++ b/board/ar7100/common/generic_i2c.h
@@ -0,0 +1,84 @@
+/* generic_i2c.h
+ *
+ * History:
+ * Jan  4, 2007 wclewis initial
+ * Jan 11, 2007 wclewis ready for checkin
+ * Jan 14, 2007 wclewis common version for BDI/ECOS/Linux
+ * May 15, 2007 wclewis changed CS1 to TEST
+ */
+
+#ifndef _GENERIC_I2C_H
+#define _GENERIC_I2C_H
+
+/* OUT, ACTIVE LOW, INITIAL STATE HIGH */
+#define GENERIC_I2C_VSC73XX_CS    (1<<0)
+#define GENERIC_I2C_STEREO_CS     (1<<1)
+#define GENERIC_I2C_SLIC_CS0      (1<<2)
+#define GENERIC_I2C_SLIC_TEST     (1<<3)
+
+#define GENERIC_I2C_INIT_OUT_HIGH (GENERIC_I2C_VSC73XX_CS | GENERIC_I2C_STEREO_CS | GENERIC_I2C_SLIC_CS0 | GENERIC_I2C_TP28)
+
+/* OUT, ACTIVE HIGH, INITIAL STATE LOW */
+#define GENERIC_I2C_JUMP_LED1     (1<<9)
+#define GENERIC_I2C_JUMP_LED2     (1<<10)
+#define GENERIC_I2C_TP25          (1<<12)
+#define GENERIC_I2C_TP26          (1<<13)
+
+#define GENERIC_I2C_INIT_OUT_LOW  (GENERIC_I2C_JUMP_LED1 | GENERIC_I2C_JUMP_LED2 | GENERIC_I2C_SLIC_TEST | GENERIC_I2C_TP25 | GENERIC_I2C_TP26)
+
+/* IN */
+#define GENERIC_I2C_SLIC_INT0     (1<<4)
+#define GENERIC_I2C_SLIC_INT1     (1<<5)
+#define GENERIC_i2C_SW_RESET      (1<<6)
+#define GENERIC_I2C_JUMP_SW       (1<<8)
+#define GENERIC_I2C_TP24          (1<<11)
+#define GENERIC_I2C_TP27          (1<<14)
+#define GENERIC_I2C_TP28          (1<<15)
+
+#define GENERIC_I2C_INIT_INPUT (~(GENERIC_I2C_INIT_OUT_HIGH|GENERIC_I2C_INIT_OUT_LOW))
+
+#define GENERIC_I2C_INPUT_LOW (GENERIC_I2C_SLIC_INT0 | GENERIC_I2C_SLIC_INT1 | GENERIC_i2C_SW_RESET | GENERIC_I2C_JUMP_SW)
+
+int
+generic_i2c_init_gpio(void);
+
+int
+generic_i2c_write_gpio(unsigned short d);
+
+int
+generic_i2c_read_gpio(unsigned short *d);
+
+int 
+generic_i2c_assert_cs(int cs);
+
+void 
+generic_i2c_deassert_cs(void);
+
+#ifdef USE_TEST_CODE
+
+void
+generic_i2c_test_scl(void);
+
+void
+generic_i2c_test_sda(void);
+
+void 
+generic_i2c_test_write_bits(void);
+
+void
+generic_i2c_test_toggle(unsigned short t);
+
+void
+generic_i2c_test_addr_strapping(void);
+
+void
+generic_i2c_check_input(void);
+
+void
+generic_i2c_test_read_write_gpio(void);
+
+void
+generic_i2c_test_vs7385_toggle(void);
+
+#endif
+#endif
diff --git a/board/ar7100/common/generic_spi.c b/board/ar7100/common/generic_spi.c
new file mode 100644
index 0000000000..1ee6bba5a4
--- /dev/null
+++ b/board/ar7100/common/generic_spi.c
@@ -0,0 +1,355 @@
+
+
+/* generic_spi.c */
+
+#ifdef __BDI
+#include "bdi.h"
+
+#define protect()
+#define unprotect()
+
+#else
+#ifdef __ECOS
+#include <cyg/hal/ar7100_soc.h>
+#include "ag7100_ecos.h" 
+#define printk          DEBUG_PRINTF
+
+#define protect()
+#define unprotect()
+
+#else
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <common.h>
+#include "ar7100_soc.h"
+#define printk printf
+
+void ar7100_flash_spi_down(void);
+void ar7100_flash_spi_up(void);
+
+#define protect()   
+#define unprotect() 
+
+#endif
+#endif
+
+#include "generic_spi.h"
+//#include "generic_i2c.h"
+
+/* ************************************************************** */
+#ifdef CONFIG_AR9100
+
+extern int ap83_board_version;
+
+#define AR9100_SPI_GPIO_OE       0x18040000 /* GPIO Output Enable */
+#define AR9100_SPI_GPIO_OUT      0x18040008 /* GPIO Output Value Register */
+#define AR9100_SPI_GPIO_FUNC     0x18040028
+#define AR9100_SPI_CLK_HIGH      (1<<23)
+#define AR9100_SPI_CLK_LOW       ~(1<<23)
+#define AR9100_SPI_DO_HI         (1<<0)
+#define AR9100_SPI_CS_DISABLE_0  (1<<12)
+#define AR9100_SPI_CS_DISABLE_1  (1<<13)
+#define AR9100_SPI_CLK
+#define AR9100_SPI_GPIO_IN       0x18040004
+
+#else
+
+#define GENERIC_SPI_FS           0x1f000000 /* Function select */
+#define GENERIC_SPI_CLOCK        0x1f000004 /* Alias-disable + clock */
+
+#define GENERIC_SPI_WRITE        0x1f000008 /* SPI_IO_CTRL
+					    * spi_do    = 1<<0  (reflects pin)
+					    * spi_clk   = 1<<8  (reflects pin)
+					    * cs0/gpio  = 1<<16 (active low)
+					    * cs1/gpio  = 1<<17 (active low)
+					    * cs2gpio   = 1<<18 (active low)
+					    */
+
+#define GENERIC_SPI_RD_SHIFT_REG 0x1f00000c /* spi_di is clocked into register pos 0 every clock */
+
+#define GENERIC_SPI_CS_DISABLE_0 (1<<16)
+#define GENERIC_SPI_CS_DISABLE_1 (1<<17)
+#define GENERIC_SPI_CS_DISABLE_2 (1<<18)
+
+#define GENERIC_SPI_CS_DIS       (GENERIC_SPI_CS_DISABLE_0|GENERIC_SPI_CS_DISABLE_1|GENERIC_SPI_CS_DISABLE_2)
+
+#define GENERIC_SPI_D0_HIGH      (1<<0)
+#define GENERIC_SPI_CLK_HIGH     (1<<8)
+#endif
+#ifdef CONFIG_AR9100
+int
+generic_spi_access_enable(int cs)
+{
+  u32 val;
+
+  protect();
+  val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE)|0x02);
+  ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE,val);
+  val = (ar7100_reg_rd(AR9100_SPI_GPIO_OUT) & ~(0x0A));
+  ar7100_reg_wr_nf(AR9100_SPI_GPIO_OUT,val);
+
+  return 0;
+}
+int
+generic_spi_access_done(void)
+{
+  u32 val;
+
+  val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE)|0x02);
+  ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE,val);
+  val = (ar7100_reg_rd(AR9100_SPI_GPIO_OUT)|0x02);
+  ar7100_reg_wr_nf(AR9100_SPI_GPIO_OUT,val);
+
+  unprotect();
+
+  return 0;
+}
+int
+generic_spi_init(int cs)
+{
+        return 0;
+}
+/* Data needs to be stable on rising edge of clock */
+
+#define IN_DATA_GPIO		3
+#define OUT_DATA_GPIO		16
+#define CLK_GPIO		17
+
+void
+generic_spi_raw_output_u8_050(unsigned char val)
+{
+	int i, rd_val, wr_val;
+
+	for (i = 7; i >= 0; i--) {
+		rd_val = ar7100_reg_rd(AR9100_SPI_GPIO_OUT);
+
+		rd_val &= ~(1 << CLK_GPIO); /* lower clock */
+
+		wr_val = (((val >> i) & 1) << OUT_DATA_GPIO);
+		wr_val |= (rd_val & ~(1 << OUT_DATA_GPIO));
+
+		ar7100_reg_wr_nf(AR9100_SPI_GPIO_OUT, wr_val);
+
+		wr_val |= (1 << CLK_GPIO); /* high clock */
+		ar7100_reg_wr_nf(AR9100_SPI_GPIO_OUT, wr_val);
+	}
+}
+unsigned int
+generic_spi_raw_input_u32_050(void)
+{
+	int i, rd_val;
+	unsigned int ret_val = 0;
+
+	/* Configure GPIO as input for data */
+	rd_val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE) & ~(1 << IN_DATA_GPIO));
+	ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE, rd_val);
+
+	/* Configure GPIO as output for clock */
+	rd_val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE) | (1 << CLK_GPIO));
+	ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE, rd_val);
+
+	for (i = 31; i >= 0; i--) {
+		rd_val = ar7100_reg_rd(AR9100_SPI_GPIO_OUT);
+		rd_val &= ~(1 << CLK_GPIO); /* lower clock */
+		ar7100_reg_wr_nf(AR9100_SPI_GPIO_OUT, rd_val);
+
+		rd_val = ar7100_reg_rd(AR9100_SPI_GPIO_OUT);
+		rd_val |= (1 << CLK_GPIO); /* high clock */
+		ar7100_reg_wr_nf(AR9100_SPI_GPIO_OUT, rd_val);
+
+		rd_val = ar7100_reg_rd(AR9100_SPI_GPIO_IN);
+
+		ret_val |= ((rd_val & (1 << IN_DATA_GPIO)) >> IN_DATA_GPIO) << i;
+	}
+
+	rd_val = ar7100_reg_rd(AR9100_SPI_GPIO_OUT);
+	rd_val &= ~(1 << CLK_GPIO); /* lower clock */
+	ar7100_reg_wr_nf(AR9100_SPI_GPIO_OUT, rd_val);
+
+	return ret_val;
+}
+
+void
+gpio_clk_setup(void)
+{
+        unsigned rd_val;
+
+        rd_val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE) | (1 << OUT_DATA_GPIO));
+        ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE, rd_val);
+
+        /* Configure GPIO as output for clock */
+        rd_val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE) | (1 << CLK_GPIO));
+        ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE, rd_val);
+}
+
+void
+generic_spi_raw_output_u8_040(unsigned char val)
+{
+  int ii,rd_val, wr_val;
+
+  /* Only change GPIO 0, 1 or 2 in mask */
+  unsigned int cs0to2mask = (0xbf000000);
+
+  rd_val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE) & ~(0x08));
+  ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE,rd_val);
+
+  /* Shift out SPI values keeping GPIO bits the same */
+  for (ii = 7; ii>=0 ; ii--) {
+    u32  jj = (val >> ii) & 1;
+    /* First assert data, make sure clock is low */
+
+    if(jj)
+    wr_val = (cs0to2mask | (1 << 22));
+    else
+    wr_val = cs0to2mask;
+    /* Falling edge of the spi clk*/
+    rd_val=ar7100_reg_rd(wr_val);
+    /* Leave data there, rising edge of clock causes data to be output */
+    rd_val=ar7100_reg_rd((wr_val | AR9100_SPI_CLK_HIGH));
+  }
+}
+unsigned int
+generic_spi_raw_input_u32_040(void)
+{
+  int ii;
+  u32 val;
+  u32 rd_val = 0x0;
+  unsigned int cs0to2mask = 0xbf000000;
+
+  val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE) & ~(0x08));
+  ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE,val);
+  val=ar7100_reg_rd(cs0to2mask);
+
+  /* Only change GPIO 0, 1 or 2 in mask */
+  /* For each rising edge the data in is sampled and clocked into serial shift register */
+  for (ii = 31; ii>=0 ; ii--) {
+
+    val=ar7100_reg_rd((cs0to2mask | AR9100_SPI_CLK_HIGH));
+    val = ar7100_reg_rd(AR9100_SPI_GPIO_IN);
+    rd_val = rd_val | (((val >> 3) & 0x1)<< ii);
+    val=ar7100_reg_rd(cs0to2mask);
+  }
+
+    val=ar7100_reg_rd(cs0to2mask);
+
+  /* Shift register contains value read */
+  return rd_val;
+}
+
+void
+generic_spi_raw_output_u8(unsigned char val)
+{
+	if (ap83_board_version >= 50) {
+		generic_spi_raw_output_u8_050(val);
+	} else {
+		generic_spi_raw_output_u8_040(val);
+	}
+}
+
+unsigned int
+generic_spi_raw_input_u32(void)
+{
+	if (ap83_board_version >= 50) {
+		return generic_spi_raw_input_u32_050();
+	} else {
+		return generic_spi_raw_input_u32_040();
+	}
+}
+
+#else
+int
+generic_spi_access_enable(int cs)
+{
+
+  protect();
+  
+  ar7100_reg_wr(GENERIC_SPI_CLOCK, 0x43);
+  
+  /* Enable access to SPI bits through memory
+   * mapped registers.
+   */
+  ar7100_reg_wr_nf(GENERIC_SPI_FS, 1);
+  ar7100_reg_wr_nf(GENERIC_SPI_WRITE, GENERIC_SPI_CS_DIS);     
+  
+  {	  
+    unsigned int cs0to2mask;
+    cs0to2mask = ar7100_reg_rd(GENERIC_SPI_WRITE) & GENERIC_SPI_CS_DIS;
+    ar7100_reg_wr  (GENERIC_SPI_WRITE, cs0to2mask | GENERIC_SPI_CLK_HIGH );
+  }
+
+  generic_i2c_assert_cs(cs);
+
+  return 0;
+}
+
+int
+generic_spi_access_done(void)
+{
+  generic_i2c_deassert_cs();
+  ar7100_reg_wr_nf(GENERIC_SPI_FS, 0);
+
+  unprotect();
+
+  return 0;
+}
+
+int
+generic_spi_init(int cs)
+{
+  /* For now just initialize the i2c, this will be different for bdi/ecos/linux */
+
+  return generic_i2c_init_gpio();
+}
+
+/* Data needs to be stable on rising edge of clock */
+
+void
+generic_spi_raw_output_u8(unsigned char val) 
+{
+  int ii;
+
+  unsigned int cs0to2mask = ar7100_reg_rd(GENERIC_SPI_WRITE) & ~(GENERIC_SPI_D0_HIGH|GENERIC_SPI_CLK_HIGH);
+
+  /* Shift out SPI values keeping GPIO bits the same */
+  for (ii = 7; ii>=0 ; ii--) {
+    unsigned char  jj = (val >> ii) & 1;
+    
+    ar7100_reg_wr(GENERIC_SPI_WRITE, cs0to2mask | jj );
+    ar7100_reg_wr(GENERIC_SPI_WRITE, cs0to2mask | jj | GENERIC_SPI_CLK_HIGH );
+  }
+}
+
+unsigned int 
+generic_spi_raw_input_u32(void) 
+{
+  int ii;
+
+  unsigned int cs0to2mask = ar7100_reg_rd(GENERIC_SPI_WRITE) & ~(GENERIC_SPI_D0_HIGH|GENERIC_SPI_CLK_HIGH);
+
+  /* For each rising edge the data in is sampled and clocked into serial shift register */
+  for (ii = 31; ii>=0 ; ii--) {
+    ar7100_reg_wr(GENERIC_SPI_WRITE, cs0to2mask                            );
+    ar7100_reg_wr(GENERIC_SPI_WRITE, cs0to2mask | GENERIC_SPI_CLK_HIGH     );
+  }
+
+  /* Shift register contains value read */
+  return ar7100_reg_rd(GENERIC_SPI_RD_SHIFT_REG);
+}
+
+unsigned int 
+generic_spi_raw_input_u8(void) 
+{
+  int ii;
+
+  unsigned int cs0to2mask = ar7100_reg_rd(GENERIC_SPI_WRITE) & ~(GENERIC_SPI_D0_HIGH|GENERIC_SPI_CLK_HIGH);
+
+  /* For each rising edge the data in is sampled and clocked into serial shift register */
+  for (ii = 7; ii>=0 ; ii--) {
+    ar7100_reg_wr(GENERIC_SPI_WRITE, cs0to2mask                            );
+    ar7100_reg_wr(GENERIC_SPI_WRITE, cs0to2mask | GENERIC_SPI_CLK_HIGH     );
+  }
+
+  /* Shift register contains value read */
+  return ar7100_reg_rd(GENERIC_SPI_RD_SHIFT_REG);
+}
+#endif
diff --git a/board/ar7100/common/generic_spi.h b/board/ar7100/common/generic_spi.h
new file mode 100644
index 0000000000..34fd99403a
--- /dev/null
+++ b/board/ar7100/common/generic_spi.h
@@ -0,0 +1,48 @@
+/*****************************************************************************/
+/*! file generic_spi.h
+** /brief Generic SPI interface support
+**    
+** This interface file contains the definitions for the SPI interface functions.
+** It requires the i2c support.
+**
+**  Copyright (c) 2007-2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+
+
+/* generic_spi.h */
+
+#ifndef _GENERIC_SPI_H
+#define _GENERIC_SPI_H
+
+#ifndef CEXTERN
+#define  CEXTERN static inline
+#endif
+
+#include "generic_i2c.h"
+
+#define GENERIC_SPI_VSC73XX_CS    GENERIC_I2C_VSC73XX_CS
+#define GENERIC_SPI_STEREO_CS     GENERIC_I2C_STEREO_CS
+#define GENERIC_SPI_SLIC_CS0      GENERIC_I2C_SLIC_CS0
+#define GENERIC_SPI_SLIC_CS1      GENERIC_I2C_SLIC_CS1
+
+int
+generic_spi_init(int cs);
+
+int
+generic_spi_access_enable(int cs);
+
+int
+generic_spi_access_done(void);
+
+void
+generic_spi_raw_output_u8(unsigned char val);
+
+unsigned int 
+generic_spi_raw_input_u32(void);
+
+unsigned int 
+generic_spi_raw_input_u8(void);
+
+#endif
diff --git a/board/ar7100/common/ipPhy.c b/board/ar7100/common/ipPhy.c
new file mode 100644
index 0000000000..f69f681197
--- /dev/null
+++ b/board/ar7100/common/ipPhy.c
@@ -0,0 +1,843 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the ICPLUS ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include "ipPhy.h"
+
+#define mdelay(_x)  udelay((_x) * 1000)
+
+/* PHY selections and access functions */
+
+typedef enum {
+    PHY_SRCPORT_INFO, 
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG, 
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#ifdef DEBUG
+#define DRV_DEBUG 1
+#endif
+#define DRV_DEBUG 1
+
+#if DRV_DEBUG
+#define DRV_DEBUG_PHYERROR  0x00000001
+#define DRV_DEBUG_PHYCHANGE 0x00000002
+#define DRV_DEBUG_PHYSETUP  0x00000004
+
+int ipPhyDebug = DRV_DEBUG_PHYERROR;
+
+#define DRV_LOG(FLG, X0, X1, X2, X3, X4, X5, X6)    \
+{                                                   \
+    if (ipPhyDebug & (FLG)) {                       \
+        logMsg(X0, X1, X2, X3, X4, X5, X6);         \
+    }                                               \
+}
+
+#define DRV_MSG(x,a,b,c,d,e,f)                      \
+    logMsg(x,a,b,c,d,e,f)
+
+#define DRV_PRINT(FLG, X)                           \
+{                                                   \
+    if (ipPhyDebug & (FLG)) {                       \
+        printf X;                                   \
+    }                                               \
+}
+
+#else /* !DRV_DEBUG */
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+#endif
+
+#define IP_LAN_PORT_VLAN          1
+#define IP_WAN_PORT_VLAN          2
+
+#define ENET_UNIT_DEFAULT 0
+
+#define BOOL    uint32_t
+#define TRUE    1
+#define FALSE   0
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} ipPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+ipPhyInfo_t ipPhyInfo[] = {
+    /*
+     * On AP30/AR5312, all PHYs are associated with MAC0.
+     * AP30/AR5312's MAC1 isn't used for anything.
+     * CONFIG_VENETDEV==1 (router) configuration:
+     *    Ports 0,1,2, and 3 are "LAN ports"
+     *    Port 4 is a WAN port
+     *    Port 5 connects to MAC0 in the AR5312
+     * CONFIG_VENETDEV==0 (bridge) configuration:
+     *    Ports 0,1,2,3,4 are "LAN ports"
+     *    Port 5 connects to the MAC0 in the AR5312
+     */
+    {TRUE,   /* phy port 0 -- LAN port 0 */
+     FALSE,
+     ENET_UNIT_DEFAULT,
+     0,
+     IP_PHY0_ADDR,
+     IP_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_DEFAULT,
+     0,
+     IP_PHY1_ADDR,
+     IP_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_DEFAULT,
+     0,
+     IP_PHY2_ADDR, 
+     IP_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_DEFAULT,
+     0,
+     IP_PHY3_ADDR, 
+     IP_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+     FALSE,
+     ENET_UNIT_DEFAULT,
+     0,
+     IP_PHY4_ADDR, 
+     IP_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_DEFAULT,
+     0,
+     0x00, 
+     IP_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+#define IP_GLOBALREGBASE    0
+
+#define IP_PHY_MAX (sizeof(ipPhyInfo) / sizeof(ipPhyInfo[0]))
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define IP_ID_MIN 0
+#define IP_ID_MAX (IP_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define IP_IS_ENET_PORT(phyUnit) (ipPhyInfo[phyUnit].isEnetPort)
+#define IP_IS_PHY_ALIVE(phyUnit) (ipPhyInfo[phyUnit].isPhyAlive)
+#define IP_ETHUNIT(phyUnit) (ipPhyInfo[phyUnit].ethUnit)
+#define IP_PHYBASE(phyUnit) (ipPhyInfo[phyUnit].phyBase)
+#define IP_PHYADDR(phyUnit) (ipPhyInfo[phyUnit].phyAddr)
+#define IP_VLAN_TABLE_SETTING(phyUnit) (ipPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define IP_IS_ETHUNIT(phyUnit, ethUnit) \
+            (IP_IS_ENET_PORT(phyUnit) &&        \
+            IP_ETHUNIT(phyUnit) == (ethUnit))
+
+/* Forward references */
+BOOL       ip_phyIsLinkAlive(int phyUnit);
+static void ip_VLANInit(int ethUnit);
+static void ip_verifyReady(int ethUnit);
+#ifdef DEBUG
+void       ip_phyShow(int phyUnit);
+void       ip_phySet(int phyUnit, uint32_t regnum, uint32_t value);
+void       ip_globalSet(uint32_t phyAddr, uint32_t regnum, uint32_t value);
+#endif
+
+uint16_t
+phyRegRead(uint32_t phybase, uint16_t phyaddr, uint16_t reg)
+{
+    uint16_t val;
+
+    phy_reg_read(phybase, phyaddr, reg, &val);
+    return val;
+}
+
+void
+phyRegWrite(uint32_t phybase, uint16_t phyaddr, uint16_t reg, uint32_t val)
+{
+    phy_reg_write(phybase, phyaddr, reg, val);
+}
+
+
+/******************************************************************************
+*
+* ip_phyIsLinkAlive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+ip_phyIsLinkAlive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = IP_PHYBASE(phyUnit);
+    phyAddr = IP_PHYADDR(phyUnit);
+
+    phyHwStatus = phyRegRead(phyBase, phyAddr, IP_PHY_STATUS);
+
+    if (phyHwStatus & IP_STATUS_LINK_PASS) {
+        return TRUE;
+    } else {
+        return FALSE;
+    }
+}
+
+/******************************************************************************
+*
+* ip_VLANInit - initialize "port-based VLANs" for the specified enet unit.
+*/
+static void
+ip_VLANInit(int ethUnit)
+{
+    int     phyUnit;
+    uint32_t  phyBase;
+    uint32_t  phyReg;
+
+    phyBase = IP_GLOBALREGBASE;
+    
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (IP_ETHUNIT(phyUnit) != ethUnit) {
+            continue;
+        }
+        phyRegWrite(phyBase, IP_GLOBAL_PHY29_ADDR, 
+                    IP_GLOBAL_PHY29_24_REG + ((phyUnit == 5) ? (phyUnit + 1) : phyUnit),
+                                    IP_VLAN_TABLE_SETTING(phyUnit));
+        
+        /* Send all packets to all ports */
+        phyReg = phyRegRead(phyBase, IP_GLOBAL_PHY30_ADDR, IP_GLOBAL_PHY30_1_REG);
+        phyReg = phyReg | ((1 << phyUnit) << IP_VLAN1_OUTPUT_PORT_MASK_S);
+        phyRegWrite(phyBase, IP_GLOBAL_PHY30_ADDR, IP_GLOBAL_PHY30_1_REG, phyReg);
+    }
+    phyReg = phyRegRead(phyBase, IP_GLOBAL_PHY30_ADDR, IP_GLOBAL_PHY30_9_REG);
+    phyReg = phyReg | TAG_VLAN_ENABLE;
+    phyReg = phyReg & ~VID_INDX_SEL_M;
+    phyRegWrite(phyBase, IP_GLOBAL_PHY30_ADDR, IP_GLOBAL_PHY30_9_REG, phyReg);
+
+}
+
+
+static void
+ip_verifyReady(int ethUnit)
+{
+    int     phyUnit;
+    uint32_t  phyBase = 0;
+    uint32_t  phyAddr;
+    uint16_t  phyID1;
+    uint16_t  phyID2;
+
+    /*
+     * The first read to the Phy port registers always fails and
+     * returns 0.   So get things started with a bogus read.
+     */
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = IP_PHYBASE(phyUnit);
+        phyAddr = IP_PHYADDR(phyUnit);
+    
+        phyID1 = phyRegRead(phyBase, phyAddr, IP_PHY_ID1); /* returns 0 */
+        break;
+    }
+
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        /*******************/
+        /* Verify phy port */
+        /*******************/
+        phyBase = IP_PHYBASE(phyUnit);
+        phyAddr = IP_PHYADDR(phyUnit);
+    
+        phyID1 = phyRegRead(phyBase, phyAddr, IP_PHY_ID1);
+        if (phyID1 != IP_PHY_ID1_EXPECTATION) {
+            DRV_PRINT(DRV_DEBUG_PHYERROR,
+                      ("Invalid PHY ID1 for enet%d port%d.  Expected 0x%04x, read 0x%04x\n",
+                       ethUnit,
+                       phyUnit,
+                       IP_PHY_ID1_EXPECTATION,
+                       phyID1));
+            return;
+        }
+    
+        phyID2 = phyRegRead(phyBase, phyAddr, IP_PHY_ID2);
+        if ((phyID2 & IP_OUI_LSB_MASK) != IP_OUI_LSB_EXPECTATION) {
+            DRV_PRINT(DRV_DEBUG_PHYERROR,
+                      ("Invalid PHY ID2 for enet%d port %d.  Expected 0x%04x, read 0x%04x\n",
+                       ethUnit,
+                       phyUnit,
+                       IP_OUI_LSB_EXPECTATION,
+                       phyID2));
+            return;
+        }
+    
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                  ("Found PHY enet%d port%d: model 0x%x revision 0x%x\n",
+                   ethUnit,
+                   phyUnit,
+                   (phyID2 & IP_MODEL_NUM_MASK) >> IP_MODEL_NUM_SHIFT,
+                   (phyID2 & IP_REV_NUM_MASK) >> IP_REV_NUM_SHIFT));
+    
+    }
+}
+
+
+/******************************************************************************
+*
+* ip_phySetup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+ip_phySetup(int ethUnit)
+{
+    int     phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int     liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL    foundPhy = FALSE;
+    uint32_t  phyAddr;
+    
+    /* Reset PHYs*/
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = IP_PHYBASE(phyUnit);
+        phyAddr = IP_PHYADDR(phyUnit);
+
+        phyRegWrite(phyBase, phyAddr, IP_PHY_CONTROL,
+                    IP_CTRL_SOFTWARE_RESET);
+    }
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    mdelay(300);
+    /* Verify that the switch is what we think it is, and that it's ready */
+    ip_verifyReady(ethUnit);
+
+    /* See if there's any configuration data for this enet */
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (IP_ETHUNIT(phyUnit) != ethUnit) {
+            continue;
+        }
+
+        phyBase = IP_PHYBASE(phyUnit);
+        foundPhy = TRUE;
+        break;
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+#ifdef COBRA_TODO
+    /* Initialize global switch settings */
+
+    /* Initialize the aging time */
+
+    /* Set the learning properties */
+#endif
+
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = IP_PHYBASE(phyUnit);
+        phyAddr = IP_PHYADDR(phyUnit);
+        
+        phyRegWrite(phyBase, phyAddr, IP_AUTONEG_ADVERT,
+                                        IP_ADVERTISE_ALL);
+        phyRegWrite(phyBase, phyAddr, IP_PHY_CONTROL,
+                    IP_CTRL_AUTONEGOTIATION_ENABLE | IP_CTRL_START_AUTONEGOTIATION);
+    }
+
+    /*
+     * Wait up to .75 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    timeout=5;
+    for (phyUnit=0; (phyUnit < IP_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+        for (;;) {
+            phyBase = IP_PHYBASE(phyUnit);
+            phyAddr = IP_PHYADDR(phyUnit);
+
+            phyHwStatus = phyRegRead(phyBase, phyAddr, IP_PHY_STATUS);
+
+            if (IP_AUTONEG_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            mdelay(150);
+        }
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (ip_phyIsLinkAlive(phyUnit)) {
+            liveLinks++;
+            IP_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            IP_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Status=%4.4x\n",
+            ethUnit, 
+            phyRegRead(IP_PHYBASE(phyUnit),
+                       IP_PHYADDR(phyUnit),
+                       IP_PHY_STATUS)));
+    }
+
+    ip_VLANInit(ethUnit);
+
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* ip_phyIsDuplexFull - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1  --> FULL
+*    0 --> HALF
+*/
+int
+ip_phyIsFullDuplex(int ethUnit)
+{
+    int     phyUnit;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (ip_phyIsLinkAlive(phyUnit)) {
+
+            phyBase = IP_PHYBASE(phyUnit);
+            phyAddr = IP_PHYADDR(phyUnit);
+
+            phyHwStatus = phyRegRead(phyBase, phyAddr, IP_LINK_PARTNER_ABILITY);
+            printf("ipPhy.c: phyHwStatus 0x%x\n",phyHwStatus);
+            if ((phyHwStatus & IP_LINK_100BASETX_FULL_DUPLEX) || 
+                (phyHwStatus & IP_LINK_10BASETX_FULL_DUPLEX)) {
+                return TRUE;
+            }
+        }
+        return -1;
+    }
+
+    return FALSE;
+
+}
+
+
+/******************************************************************************
+*
+* ip_phyIsSpeed100 - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*    TRUE --> 100Mbit
+*    FALSE --> 10Mbit
+*/
+
+BOOL
+ip_phySpeed(int ethUnit)
+{
+    int     phyUnit;
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (ip_phyIsLinkAlive(phyUnit)) {
+
+            phyBase = IP_PHYBASE(phyUnit);
+            phyAddr = IP_PHYADDR(phyUnit);
+
+            phyHwStatus = phyRegRead(phyBase, phyAddr, IP_LINK_PARTNER_ABILITY);
+
+            if (phyHwStatus & IP_LINK_100BASETX) {
+                return _100BASET;
+            }
+        }
+    }
+
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* ip_phyCheckStatusChange -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+void
+ip_phyIsUp(int ethUnit)
+{
+
+    int           phyUnit;
+    uint16_t        phyHwStatus;
+    ipPhyInfo_t   *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t        phyBase;
+    uint32_t        phyAddr;
+
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = IP_PHYBASE(phyUnit);
+        phyAddr = IP_PHYADDR(phyUnit);
+
+        lastStatus = &ipPhyInfo[phyUnit];
+        phyHwStatus = phyRegRead(phyBase, phyAddr, IP_PHY_STATUS);
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            /* See if we've lost link */
+            if (phyHwStatus & IP_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+#ifdef COBRA_TODO
+                mv_flushATUDB(phyUnit);
+#endif
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for AutoNegotiation complete */
+            if (IP_AUTONEG_DONE(phyHwStatus)) {
+                gainedLinks++;
+                linkCount++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+            }
+        }
+    }
+
+    return (linkCount);
+
+#if 0
+    if (linkCount == 0) {
+        if (lostLinks) {
+            /* We just lost the last link for this MAC */
+            phyLinkLost(ethUnit);
+        }
+    } else {
+        if (gainedLinks == linkCount) {
+            /* We just gained our first link(s) for this MAC */
+            phyLinkGained(ethUnit);
+        }
+    }
+#endif
+}
+
+#ifdef DEBUG
+
+/* Define the registers of interest for a phyShow command */
+typedef struct ipRegisterTableEntry_s {
+    uint32_t regNum;
+    char  *regIdString;
+} ipRegisterTableEntry_t;
+
+ipRegisterTableEntry_t ipPhyRegisterTable[] = {
+    {IP_PHY_CONTROL,                 "PHY Control                     "},
+    {IP_PHY_STATUS,                  "PHY Status                      "},
+    {IP_PHY_ID1,                     "PHY Identifier 1                "},
+    {IP_PHY_ID2,                     "PHY Identifier 2                "},
+    {IP_AUTONEG_ADVERT,              "Auto-Negotiation Advertisement  "},
+    {IP_LINK_PARTNER_ABILITY,        "Link Partner Ability            "},
+    {IP_AUTONEG_EXPANSION,           "Auto-Negotiation Expansion      "},
+};
+int ipPhyNumRegs = sizeof(ipPhyRegisterTable) / sizeof(ipPhyRegisterTable[0]);
+
+
+ipRegisterTableEntry_t ipPhy29GlobalRegisterTable[] = {
+    {IP_GLOBAL_PHY29_18_REG,        "29_18_REG   "},
+    {IP_GLOBAL_PHY29_19_REG,        "29_19_REG   "},
+    {IP_GLOBAL_PHY29_20_REG,        "29_20_REG   "},
+    {IP_GLOBAL_PHY29_21_REG,        "29_21_REG   "},
+    {IP_GLOBAL_PHY29_22_REG,        "29_22_REG   "},
+    {IP_GLOBAL_PHY29_23_REG,        "29_23_REG   "},
+    {IP_GLOBAL_PHY29_24_REG,        "29_24_REG   "},
+    {IP_GLOBAL_PHY29_25_REG,        "29_25_REG   "},
+    {IP_GLOBAL_PHY29_26_REG,        "29_26_REG   "},
+    {IP_GLOBAL_PHY29_27_REG,        "29_27_REG   "},
+    {IP_GLOBAL_PHY29_28_REG,        "29_28_REG   "},
+    {IP_GLOBAL_PHY29_29_REG,        "29_29_REG   "},
+    {IP_GLOBAL_PHY29_30_REG,        "29_30_REG   "},
+    {IP_GLOBAL_PHY29_31_REG,        "29_31_REG   "},
+};
+int ipPhy29GlobalNumRegs =
+    sizeof(ipPhy29GlobalRegisterTable) / sizeof(ipPhy29GlobalRegisterTable[0]);
+
+
+ipRegisterTableEntry_t ipPhy30GlobalRegisterTable[] = {
+    {IP_GLOBAL_PHY30_0_REG,   "30_0_REG    "},
+    {IP_GLOBAL_PHY30_1_REG,   "30_1_REG    "},
+    {IP_GLOBAL_PHY30_2_REG,   "30_2_REG    "},
+    {IP_GLOBAL_PHY30_3_REG,   "30_3_REG    "},
+    {IP_GLOBAL_PHY30_4_REG,   "30_4_REG    "},
+    {IP_GLOBAL_PHY30_5_REG,   "30_5_REG    "},
+    {IP_GLOBAL_PHY30_6_REG,   "30_6_REG    "},
+    {IP_GLOBAL_PHY30_7_REG,   "30_7_REG    "},
+    {IP_GLOBAL_PHY30_8_REG,   "30_8_REG    "},
+    {IP_GLOBAL_PHY30_9_REG,   "30_9_REG    "},
+    {IP_GLOBAL_PHY30_10_REG,  "30_10_REG   "},
+    {IP_GLOBAL_PHY30_11_REG,  "30_11_REG   "},
+    {IP_GLOBAL_PHY30_12_REG,  "30_12_REG   "},
+    {IP_GLOBAL_PHY30_13_REG,  "30_13_REG   "},
+    {IP_GLOBAL_PHY30_16_REG,  "30_16_REG   "},
+    {IP_GLOBAL_PHY30_17_REG,  "30_17_REG   "},
+    {IP_GLOBAL_PHY30_18_REG,  "30_18_REG   "},
+    {IP_GLOBAL_PHY30_20_REG,  "30_20_REG   "},
+    {IP_GLOBAL_PHY30_21_REG,  "30_21_REG   "},
+    {IP_GLOBAL_PHY30_22_REG,  "30_22_REG   "},
+    {IP_GLOBAL_PHY30_23_REG,  "30_23_REG   "},
+    {IP_GLOBAL_PHY30_24_REG,  "30_24_REG   "},
+    {IP_GLOBAL_PHY30_25_REG,  "30_25_REG   "},
+    {IP_GLOBAL_PHY30_26_REG,  "30_26_REG   "},
+    {IP_GLOBAL_PHY30_27_REG,  "30_27_REG   "},
+    {IP_GLOBAL_PHY30_28_REG,  "30_28_REG   "},
+    {IP_GLOBAL_PHY30_29_REG,  "30_29_REG   "},
+    {IP_GLOBAL_PHY30_30_REG,  "30_30_REG   "},
+    {IP_GLOBAL_PHY30_31_REG,  "30_31_REG   "},
+};
+int ipPhy30GlobalNumRegs =
+    sizeof(ipPhy30GlobalRegisterTable) / sizeof(ipPhy30GlobalRegisterTable[0]);
+
+ipRegisterTableEntry_t ipPhy31GlobalRegisterTable[] = {
+    {IP_GLOBAL_PHY31_0_REG,   "31_0_REG    "},
+    {IP_GLOBAL_PHY31_1_REG,   "31_1_REG    "},
+    {IP_GLOBAL_PHY31_2_REG,   "31_2_REG    "},
+    {IP_GLOBAL_PHY31_3_REG,   "31_3_REG    "},
+    {IP_GLOBAL_PHY31_4_REG,   "31_4_REG    "},
+    {IP_GLOBAL_PHY31_5_REG,   "31_5_REG    "},
+    {IP_GLOBAL_PHY31_6_REG,   "31_6_REG    "},
+};
+
+int ipPhy31GlobalNumRegs =
+    sizeof(ipPhy31GlobalRegisterTable) / sizeof(ipPhy31GlobalRegisterTable[0]);
+
+
+/*****************************************************************************
+*
+* ip_phyShow - Dump the state of a PHY.
+* There are two sets of registers for each phy port:
+*  "phy registers" and
+*  "switch port registers"
+* We dump 'em all, plus the switch global registers.
+*/
+void
+ip_phyShow(int phyUnit)
+{
+    int     i;
+    uint16_t  value;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+
+    phyBase        = IP_PHYBASE(phyUnit);
+    phyAddr        = IP_PHYADDR(phyUnit);
+
+    printf("PHY state for PHY%d (enet%d, phyBase 0x%8x, phyAddr 0x%x)\n",
+           phyUnit,
+           IP_ETHUNIT(phyUnit),
+           IP_PHYBASE(phyUnit),
+           IP_PHYADDR(phyUnit));
+
+    printf("PHY Registers:\n");
+    for (i=0; i < ipPhyNumRegs; i++) {
+
+        value = phyRegRead(phyBase, phyAddr, ipPhyRegisterTable[i].regNum);
+
+        printf("Reg %02d (0x%02x) %s = 0x%08x\n",
+               ipPhyRegisterTable[i].regNum,
+               ipPhyRegisterTable[i].regNum,
+               ipPhyRegisterTable[i].regIdString,
+               value);
+    }
+
+    phyBase = IP_GLOBALREGBASE;
+
+    printf("Switch Global Registers:\n");
+    printf("Phy29 Registers:\n");
+    for (i=0; i < ipPhy29GlobalNumRegs; i++) {
+
+        value = phyRegRead(phyBase, IP_GLOBAL_PHY29_ADDR,
+                           ipPhy29GlobalRegisterTable[i].regNum);
+
+        printf("Reg %02d (0x%02x) %s = 0x%08x\n",
+               ipPhy29GlobalRegisterTable[i].regNum,
+               ipPhy29GlobalRegisterTable[i].regNum,
+               ipPhy29GlobalRegisterTable[i].regIdString,
+               value);
+    }
+
+    printf("Phy30 Registers:\n");
+    for (i=0; i < ipPhy30GlobalNumRegs; i++) {
+
+        value = phyRegRead(phyBase, IP_GLOBAL_PHY30_ADDR,
+                           ipPhy30GlobalRegisterTable[i].regNum);
+
+        printf("Reg %02d (0x%02x) %s = 0x%08x\n",
+               ipPhy30GlobalRegisterTable[i].regNum,
+               ipPhy30GlobalRegisterTable[i].regNum,
+               ipPhy30GlobalRegisterTable[i].regIdString,
+               value);
+    }
+    printf("Phy31 Registers:\n");
+    for (i=0; i < ipPhy31GlobalNumRegs; i++) {
+
+        value = phyRegRead(phyBase, IP_GLOBAL_PHY31_ADDR,
+                           ipPhy31GlobalRegisterTable[i].regNum);
+
+        printf("Reg %02d (0x%02x) %s = 0x%08x\n",
+               ipPhy31GlobalRegisterTable[i].regNum,
+               ipPhy31GlobalRegisterTable[i].regNum,
+               ipPhy31GlobalRegisterTable[i].regIdString,
+               value);
+    }
+}
+
+/*****************************************************************************
+*
+* ip_phySet - Modify the value of a PHY register (debug only).
+*/
+void
+ip_phySet(int phyUnit, uint32_t regnum, uint32_t value)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+
+
+    phyBase = IP_PHYBASE(phyUnit);
+    phyAddr = IP_PHYADDR(phyUnit);
+
+    phyRegWrite(phyBase, phyAddr, regnum, value);
+}
+
+/*****************************************************************************
+*
+* ip_globalSet - Modify the value of a global register
+* (debug only).
+*/
+void
+ip_globalSet(uint32_t phyAddr, uint32_t regnum, uint32_t value)
+{
+    uint32_t  phyBase;
+
+    phyBase = IP_GLOBALREGBASE;
+
+    phyRegWrite(phyBase, phyAddr, regnum, value);
+}
+
+
+#endif
diff --git a/board/ar7100/common/ipPhy.h b/board/ar7100/common/ipPhy.h
new file mode 100644
index 0000000000..be45fcc651
--- /dev/null
+++ b/board/ar7100/common/ipPhy.h
@@ -0,0 +1,172 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * icPhy.h - definitions for the ethernet PHY.
+ * This code supports a simple 1-port ethernet phy, ICPLUS,
+ * All definitions in this file are operating system independent!
+ */
+
+#ifndef IPPHY_H
+#define IPPHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define IP_PHY_CONTROL                 0
+#define IP_PHY_STATUS                  1
+#define IP_PHY_ID1                     2
+#define IP_PHY_ID2                     3
+#define IP_AUTONEG_ADVERT              4
+#define IP_LINK_PARTNER_ABILITY        5
+#define IP_AUTONEG_EXPANSION           6
+
+
+/* IP_PHY_CONTROL fields */
+#define IP_CTRL_SOFTWARE_RESET                    0x8000
+#define IP_CTRL_SPEED_100                         0x2000
+#define IP_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define IP_CTRL_START_AUTONEGOTIATION             0x0200
+#define IP_CTRL_SPEED_FULL_DUPLEX                 0x0100
+
+/* Phy status fields */
+#define IP_STATUS_AUTO_NEG_DONE                   0x0020
+#define IP_STATUS_LINK_PASS                       0x0004
+
+#define IP_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (IP_STATUS_AUTO_NEG_DONE)) ==                    \
+        (IP_STATUS_AUTO_NEG_DONE))
+
+/* ICPLUS_PHY_ID1 fields */
+#define IP_PHY_ID1_EXPECTATION                    0x0243 /* OUI >> 6 */
+
+/* ICPLUS_PHY_ID2 fields */
+#define IP_OUI_LSB_MASK                           0xfc00
+#define IP_OUI_LSB_EXPECTATION                    0x0c00
+#define IP_OUI_LSB_SHIFT                              10
+#define IP_MODEL_NUM_MASK                         0x03f0
+#define IP_MODEL_NUM_SHIFT                             4
+#define IP_REV_NUM_MASK                           0x000f
+#define IP_REV_NUM_SHIFT                               0
+
+/* Link Partner ability */
+#define IP_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define IP_LINK_100BASETX                   0x0080
+#define IP_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define IP_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define IP_ADVERTISE_100FULL                0x0100
+#define IP_ADVERTISE_100HALF                0x0080  
+#define IP_ADVERTISE_10FULL                 0x0040  
+#define IP_ADVERTISE_10HALF                 0x0020  
+
+#define IP_ADVERTISE_ALL (IP_ADVERTISE_10HALF | IP_ADVERTISE_10FULL | \
+                       IP_ADVERTISE_100HALF | IP_ADVERTISE_100FULL)
+               
+               
+#define IP_VLAN_TAG_VALID                   0x81
+#define IP_VLAN_TAG_SIZE                    4
+#define IP_VLAN_TAG_OFFSET                  12   /* After DA & SA */
+#define IP_SPECIAL_TAG_VALID                0x81
+              
+/****************************/
+/* Global Control Registers */
+/****************************/
+/* IP Global register doesn't have names based on functionality
+ * hence has to live with this names  for now */
+#define IP_GLOBAL_PHY29_18_REG  18
+#define IP_GLOBAL_PHY29_19_REG  19
+#define IP_GLOBAL_PHY29_20_REG  20
+#define IP_GLOBAL_PHY29_21_REG  21
+#define IP_GLOBAL_PHY29_22_REG  22
+#define IP_GLOBAL_PHY29_23_REG  23
+#define IP_GLOBAL_PHY29_24_REG  24
+#define IP_GLOBAL_PHY29_25_REG  25
+#define IP_GLOBAL_PHY29_26_REG  26
+#define IP_GLOBAL_PHY29_27_REG  27
+#define IP_GLOBAL_PHY29_28_REG  28
+#define IP_GLOBAL_PHY29_29_REG  29
+#define IP_GLOBAL_PHY29_30_REG  30
+#define IP_GLOBAL_PHY29_31_REG  31
+
+
+#define IP_GLOBAL_PHY30_0_REG   0
+#define IP_GLOBAL_PHY30_1_REG   1
+#define IP_GLOBAL_PHY30_2_REG   2
+#define IP_GLOBAL_PHY30_3_REG   3
+#define IP_GLOBAL_PHY30_4_REG   4
+#define IP_GLOBAL_PHY30_5_REG   5
+#define IP_GLOBAL_PHY30_6_REG   6
+#define IP_GLOBAL_PHY30_7_REG   7
+#define IP_GLOBAL_PHY30_8_REG   8
+#define IP_GLOBAL_PHY30_9_REG   9
+#define IP_GLOBAL_PHY30_10_REG  10
+#define IP_GLOBAL_PHY30_11_REG  11
+#define IP_GLOBAL_PHY30_12_REG  12
+#define IP_GLOBAL_PHY30_13_REG  13
+#define IP_GLOBAL_PHY30_16_REG  16
+#define IP_GLOBAL_PHY30_17_REG  17
+#define IP_GLOBAL_PHY30_18_REG  18
+#define IP_GLOBAL_PHY30_20_REG  20
+#define IP_GLOBAL_PHY30_21_REG  21
+#define IP_GLOBAL_PHY30_22_REG  22
+#define IP_GLOBAL_PHY30_23_REG  23
+#define IP_GLOBAL_PHY30_24_REG  24
+#define IP_GLOBAL_PHY30_25_REG  25
+#define IP_GLOBAL_PHY30_26_REG  26
+#define IP_GLOBAL_PHY30_27_REG  27
+#define IP_GLOBAL_PHY30_28_REG  28
+#define IP_GLOBAL_PHY30_29_REG  29
+#define IP_GLOBAL_PHY30_30_REG  30
+#define IP_GLOBAL_PHY30_31_REG  31
+
+#define IP_GLOBAL_PHY31_0_REG   0
+#define IP_GLOBAL_PHY31_1_REG   1
+#define IP_GLOBAL_PHY31_2_REG   2
+#define IP_GLOBAL_PHY31_3_REG   3
+#define IP_GLOBAL_PHY31_4_REG   4
+#define IP_GLOBAL_PHY31_5_REG   5
+#define IP_GLOBAL_PHY31_6_REG   6
+
+#define IP_GLOBAL_PHY29_31_REG  31
+
+
+#define IP_VLAN0_OUTPUT_PORT_MASK_S     0
+#define IP_VLAN1_OUTPUT_PORT_MASK_S     8
+#define IP_VLAN2_OUTPUT_PORT_MASK_S     0
+#define IP_VLAN3_OUTPUT_PORT_MASK_S     8
+
+/* Masks and shifts for 29.23 register */
+#define IP_PORTX_ADD_TAG_S               11
+#define IP_PORTX_REMOVE_TAG_S            6       
+#define IP_PORT5_ADD_TAG_S               1
+#define IP_PORT5_REMOVE_TAG_S            0
+
+/* 
+ * 30.9   Definitions 
+ */
+#define TAG_VLAN_ENABLE         0x0080
+#define VID_INDX_SEL_M          0x0070            
+#define VID_INDX_SEL_S          4            
+
+                  
+/* PHY Addresses */
+#define IP_PHY0_ADDR    0
+#define IP_PHY1_ADDR    1
+#define IP_PHY2_ADDR    2
+#define IP_PHY3_ADDR    3
+#define IP_PHY4_ADDR    4
+
+#define IP_GLOBAL_PHY29_ADDR    29
+#define IP_GLOBAL_PHY30_ADDR    30
+#define IP_GLOBAL_PHY31_ADDR    31
+
+
+#endif
diff --git a/board/ar7100/common/lowlevel_init.S b/board/ar7100/common/lowlevel_init.S
new file mode 100644
index 0000000000..dd8c5c8056
--- /dev/null
+++ b/board/ar7100/common/lowlevel_init.S
@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) 2009, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 
+ */
+
+/*****************************************************************************/
+/*! file lowlevel_init.s
+** /brief Low Level initialization routine for AP94
+**    
+**  
+*/
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7100_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define clear_mask(_reg, _mask)                     \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+#define set_val(_reg, _mask, _val)                  \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t9, _val;                                   \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+#define get_val(_reg, _mask, _shift, _res_reg)      \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, _mask;                                  \
+    and t8, t8, t9;                                 \
+    srl _res_reg, t8, _shift                        \
+
+#define pll_clr(_mask)                              \
+    clear_mask(AR7100_CPU_PLL_CONFIG, _mask)
+
+#define pll_set(_mask, _val)                        \
+    set_val(AR7100_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_get(_mask, _shift, _res_reg)            \
+    get_val(AR7100_CPU_PLL_CONFIG, _mask, _shift, _res_reg)
+
+#define clk_clr(_mask)                               \
+    clear_mask(AR7100_CPU_CLOCK_CONTROL, _mask)
+
+#define clk_set(_mask, _val)                         \
+    set_val(AR7100_CPU_CLOCK_CONTROL,  _mask, _val)
+
+#define clk_get(_mask, _shift, _res_reg)              \
+    get_val(AR7100_CPU_CLOCK_CONTROL, _mask, _shift, _res_reg)
+
+#define MEMDELAY(count, reg)	\
+	li	    reg, count;	\
+9:	addi	reg, -1;	\
+	bgtz	reg, 9b;	\
+	nop
+
+
+#define PLL_CONFIG_SW_UPDATE_VAL (1 << 31)
+#define CLOCK_CTRL_SWITCH_VAL (1 << 1)
+
+/******************************************************************************
+ * first level initialization:
+ * 
+ * 0) If clock cntrl reset switch is already set, we're recovering from 
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ * 
+ *****************************************************************************/
+
+.globl lowlevel_init
+
+lowlevel_init:
+
+    /*
+     * The code below is for the real chip. Wont work on FPGA
+     */
+    /* jr ra  */
+
+    /* 
+     * WAR for the bug#55574: Set the CKE (bit 7 in DDR_CONFIG2 register) 
+     * to low initially 
+     */
+
+    li  a1, KSEG1ADDR(AR7100_DDR_CONFIG2);
+    lw  t8, 0(a1);
+    li  t0, 0xffffff7f;
+    and t8, t8, t0;
+    sw  t8, 0(a1);
+
+    /* End of WAR for 55574 */
+
+    clk_get(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CONTROL_RST_SWITCH_SHIFT, t6)
+    bne zero, t6, initialize_pll
+    nop 
+
+    pll_set(PLL_CONFIG_CPU_DIV_MASK,    PLL_CONFIG_CPU_DIV_VAL)
+    pll_set(PLL_CONFIG_AHB_DIV_MASK,    PLL_CONFIG_AHB_DIV_VAL)
+    pll_set(PLL_CONFIG_DDR_DIV_MASK,    PLL_CONFIG_DDR_DIV_VAL)
+	pll_set(PLL_CONFIG_PLL_DIVOUT_MASK, PLL_CONFIG_PLL_DIVOUT_VAL)
+
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+
+    /*
+     * Will cause a reset
+     */
+    clk_set(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CTRL_SWITCH_VAL)
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+    
+initialize_pll:
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+    clk_clr(CLOCK_CONTROL_RST_SWITCH_MASK)
+    pll_set(PLL_CONFIG_PLL_FB_MASK, PLL_CONFIG_PLL_FB_VAL)
+    pll_set(PLL_CONFIG_PLL_LOOP_BW_MASK, PLL_CONFIG_PLL_LOOP_BW_VAL)
+
+    pll_clr(PLL_CONFIG_PLL_POWER_DOWN_MASK);
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK);
+
+wait_for_pll_lock:
+    pll_get(PLL_CONFIG_LOCKED_MASK, PLL_CONFIG_LOCKED_SHIFT, t6)
+    beq zero, t6, wait_for_pll_lock
+    nop 
+
+
+pll_locked:
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)   
+    
+    /*
+    ** Now, time to initialize memory.  We'll do the early initialization here
+    ** (taken directly from Redboot), and the later initialization will not be
+    ** performed.  Better all around.
+    **
+    ** Since AP-94 is a fixed design, we'll ensure the config value has the correct
+    ** CAS latency.
+    */
+    
+    li      a0, KSEG1ADDR(AR7100_DDR_CONFIG)
+	li	    t0, CFG_DDR_CONFIG_VAL
+	sw	    t0, 0(a0)
+	nop
+
+    MEMDELAY(900, t2)  
+  
+    /*
+    ** Load all other values
+    */
+
+	li      a1, KSEG1ADDR(AR7100_DDR_CONFIG2)
+	li	    t8, CFG_DDR_CONFIG2_VAL
+	sw	    t8, 0(a1)
+    MEMDELAY(30, t2)
+    
+    /*
+    ** Setting the mode register
+    */
+    
+    li      a0, KSEG1ADDR(AR7100_DDR_CONTROL)
+    li      a1, KSEG1ADDR(AR7100_DDR_EXT_MODE)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, CFG_DDR_EXT_MODE_VAL
+    sw      t5, 0(a1)
+    MEMDELAY(30, t2)
+
+    li      t5, 2
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+	/*
+    **  Want to set the mode value.  since AP-94 only operates at
+    ** one speed, we don't need to check the speed setting
+    */
+    
+    li      a2, KSEG1ADDR(AR7100_DDR_MODE)
+	li	    t5, CFG_DDR_MODE_VAL
+    sw	    t5, 0(a2)
+	MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    /*
+    ** Setting refresh, data this cycle, and tap words
+    */
+    
+    li      a0, KSEG1ADDR(AR7100_DDR_REFRESH)
+    li      t5, CFG_DDR_REFRESH_VAL
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      a2, KSEG1ADDR(AR7100_DDR_RD_DATA_THIS_CYCLE)
+	li	    t5, CFG_DDR_RD_DATA_THIS_CYCLE_VAL
+	sw	    t5, 0(a2)
+	
+    li      a1, 0x07
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL0)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL1)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL2)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL3)
+    sw      a1, 0(a0)
+    nop
+
+    jr ra
+
diff --git a/board/ar7100/common/lowlevel_init_ar9100.S b/board/ar7100/common/lowlevel_init_ar9100.S
new file mode 100644
index 0000000000..4f9780352f
--- /dev/null
+++ b/board/ar7100/common/lowlevel_init_ar9100.S
@@ -0,0 +1,149 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7100_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define clear_mask(_reg, _mask)                     \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+#define set_val(_reg, _mask, _val)                  \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t9, _val;                                   \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+#define get_val(_reg, _mask, _shift, _res_reg)      \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, _mask;                                  \
+    and t8, t8, t9;                                 \
+    srl _res_reg, t8, _shift                        \
+
+#define pll_clr(_mask)                              \
+    clear_mask(AR7100_CPU_PLL_CONFIG, _mask)
+
+#define pll_set(_mask, _val)                        \
+    set_val(AR7100_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_get(_mask, _shift, _res_reg)            \
+    get_val(AR7100_CPU_PLL_CONFIG, _mask, _shift, _res_reg)
+
+#define clk_clr(_mask)                               \
+    clear_mask(AR7100_CPU_CLOCK_CONTROL, _mask)
+
+#define clk_set(_mask, _val)                         \
+    set_val(AR7100_CPU_CLOCK_CONTROL,  _mask, _val)
+
+#define clk_get(_mask, _shift, _res_reg)              \
+    get_val(AR7100_CPU_CLOCK_CONTROL, _mask, _shift, _res_reg)
+
+
+/*
+#define PLL_CONFIG_CPU_DIV_VAL  (0x3 << 16)
+#define PLL_CONFIG_AHB_DIV_VAL  (0x0 << 20)
+#define PLL_CONFIG_DDR_DIV_VAL  (0x3 << 18)
+#define PLL_CONFIG_PLL_FB_VAL   (0x1d << 3)
+#define PLL_CONFIG_PLL_LOOP_BW_VAL  (0x0 << 12)
+*/
+
+#define PLL_CONFIG_SW_UPDATE_VAL (1 << 31)
+#define CLOCK_CTRL_SWITCH_VAL (1 << 1)
+
+/******************************************************************************
+ * first level initialization:
+ * 
+ * 0) If clock cntrl reset switch is already set, we're recovering from 
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ * 
+ *****************************************************************************/
+
+.globl lowlevel_init
+
+lowlevel_init:
+
+    /*
+     * The code below is for the real chip. Wont work on FPGA
+     */
+    /* jr ra  */
+
+#if 0
+    clk_get(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CONTROL_RST_SWITCH_SHIFT, t6)
+    bne zero, t6, initialize_pll
+    nop 
+
+    pll_set(PLL_CONFIG_PLL_RESET_MASK, (1 << PLL_CONFIG_PLL_RESET_SHIFT))
+    pll_clr(PLL_CONFIG_PLL_RESET_MASK)
+#if 0
+    pll_set(PLL_CONFIG_PLL_FB_MASK, PLL_CONFIG_PLL_FB_VAL)
+    pll_set(PLL_CONFIG_AHB_DIV_MASK, PLL_CONFIG_AHB_DIV_VAL)
+    pll_set(PLL_CONFIG_DDR_DIV_MASK, PLL_CONFIG_DDR_DIV_VAL)
+#else
+    pll_set(PLL_CONFIG_PLL_FB_MASK|PLL_CONFIG_AHB_DIV_MASK|PLL_CONFIG_DDR_DIV_MASK, PLL_CONFIG_PLL_FB_VAL|PLL_CONFIG_AHB_DIV_VAL|PLL_CONFIG_DDR_DIV_VAL)
+#endif
+
+wait_for_pll_update:
+    pll_get(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_SHIFT, t6)
+    bne zero, t6, wait_for_pll_update
+    nop 
+
+
+    /*
+     * Will cause a reset
+     */
+    clk_set(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CTRL_SWITCH_VAL)
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+    
+initialize_pll:
+    clk_clr(CLOCK_CONTROL_RST_SWITCH_MASK)
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK);
+
+/* Should we do this before doing clock control reset above? */
+wait_for_pll_update2:
+    pll_get(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_SHIFT, t6)
+    bne zero, t6, wait_for_pll_update2
+    nop 
+
+pll_locked:
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)   
+#else
+    pll_set(PLL_CONFIG_PLL_RESET_MASK, (1 << PLL_CONFIG_PLL_RESET_SHIFT))
+    pll_clr(PLL_CONFIG_PLL_RESET_MASK)
+    pll_clr(PLL_CONFIG_AHB_DIV_MASK)
+    pll_clr(PLL_CONFIG_DDR_DIV_MASK)
+    pll_clr(PLL_CONFIG_PLL_FB_MASK)
+    pll_set(PLL_CONFIG_PLL_FB_MASK|PLL_CONFIG_AHB_DIV_MASK|PLL_CONFIG_DDR_DIV_MASK, PLL_CONFIG_PLL_FB_VAL|PLL_CONFIG_AHB_DIV_VAL|PLL_CONFIG_DDR_DIV_VAL)
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK);
+wait_for_pll_update:
+    pll_get(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_SHIFT, t6)
+    bne zero, t6, wait_for_pll_update
+    nop 
+
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)   
+    li t9, 0xffff;
+wait_loop2:
+    addi t9, -1;
+    bgtz t9, wait_loop2;
+    nop
+
+    set_val(AR7100_DDR_RD_DATA_THIS_CYCLE, 0xffffffff, CFG_DDR_RD_DATA_THIS_CYCLE_VAL);
+#endif
+    
+    jr ra
+    nop
+
diff --git a/board/ar7100/common/phy.h b/board/ar7100/common/phy.h
new file mode 100644
index 0000000000..e885f4ef1c
--- /dev/null
+++ b/board/ar7100/common/phy.h
@@ -0,0 +1,28 @@
+#ifndef _PHY_H
+#define _PHY_H
+
+#include <config.h>
+/*
+ * This file defines the interface between MAC and various phy switches.
+ */
+#define ag7100_unit2name(_unit) _unit ?  "eth1" : "eth0"
+extern int  ag7100_miiphy_read(char *devname, unsigned char phaddr,
+		unsigned char reg, unsigned short *data);
+extern int  ag7100_miiphy_write(char *devname, unsigned char phaddr,
+		unsigned char reg, unsigned short data);
+
+#ifdef CFG_ATHRS16_PHY
+inline unsigned short s16_phy_reg_read(unsigned int base, unsigned char addr, unsigned char reg)
+{   unsigned short data;
+    ag7100_miiphy_read(ag7100_unit2name(base), addr, reg, &data);
+    return data;
+}
+#define phy_reg_read(base, addr, reg) s16_phy_reg_read(base, addr, reg)
+#else
+#define phy_reg_read(base, addr, reg, datap)                    \
+    ag7100_miiphy_read(ag7100_unit2name(base), addr, reg, datap);
+#endif
+#define phy_reg_write(base, addr, reg, data)                   \
+        ag7100_miiphy_write(ag7100_unit2name(base), addr, reg, data);
+
+#endif
diff --git a/board/ar7100/common/vsc73xx.c b/board/ar7100/common/vsc73xx.c
new file mode 100644
index 0000000000..91fce8f1f2
--- /dev/null
+++ b/board/ar7100/common/vsc73xx.c
@@ -0,0 +1,1208 @@
+/* vsc73xx.c 
+ * May 24, 2007 Tag before BSP resturcture
+ */
+ 
+#ifdef __BDI
+#include "bdi.h"
+#else
+#ifdef __ECOS
+#if defined(CYGNUM_USE_ENET_VERBOSE)
+#   undef  VERBOSE
+#   define VERBOSE CYGNUM_USE_ENET_VERBOSE
+#else
+#   define VERBOSE 0
+#endif 
+#define printk             DEBUG_PRINTF
+#define udelay             A_UDELAY
+#else
+//#include <linux/kernel.h>
+//#include <asm/delay.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <common.h>
+#include "ar7100_soc.h"
+#define printk printf
+#endif
+#endif
+
+#ifndef VERBOSE
+#define  VERBOSE           0
+#endif
+
+#include "generic_spi.h"
+#include "vsc73xx.h"
+
+#define MODULE_NAME "VSC73XX"
+#ifdef CONFIG_AR9100
+extern int ap83_board_version;
+#endif
+
+/* ************************************************************** */
+
+#define VSC73XX_SYSTEM            0x7
+#define VSC73XX_ICPU_CTRL         0x10
+#define VSC73XX_ICPU_ADDR         0x11
+#define VSC73XX_ICPU_SRAM         0x12
+#define VSC73XX_ICPU_MAILBOX_VAL  0x15
+#define VSC73XX_ICPU_MAILBOX_SET  0x16
+#define VSC73XX_ICPU_MAILBOX_CLR  0x17
+#define VSC73XX_ICPU_CHIPID       0x18
+#define VSC73XX_ICPU_SIPAD        0x01
+#define VSC73XX_ICPU_GPIO         0x34
+
+#define VSC73XX_ICPU_CLOCK_DELAY  0x05
+
+#define VSC73XX_MAC               0x1
+#define VSC73XX_MAC_CFG           0x0
+#define VSC73XX_ADVPORTM          0x19
+#define VSC73XX_RXOCT             0x50
+#define VSC73XX_TXOCT             0x51
+#define VSC73XX_C_RX0             0x52
+#define VSC73XX_C_RX1             0x53
+#define VSC73XX_C_RX2             0x54
+#define VSC73XX_C_TX0             0x55
+#define VSC73XX_C_TX1             0x56
+#define VSC73XX_C_TX2             0x57
+#define VSC73XX_C_CFG             0x58
+
+#define VSC73XX_MII               0x3
+#define VSC73XX_MII_STAT          0x0
+#define VSC73XX_MII_CMD           0x1
+#define VSC73XX_MII_DATA          0x2
+
+static void inline
+vsc73xx_force_reset(void)
+{
+  ar7100_reg_rmw_set(AR7100_RESET, AR7100_RESET_GE1_PHY);
+  udelay(10);
+  ar7100_reg_rmw_clear(AR7100_RESET, AR7100_RESET_GE1_PHY);
+}
+
+#ifdef USE_TEST_CODE
+
+void
+vsc73xx_test_reset_line(void)
+{
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": looping 10 uSec nRESET, 100Usec RESET\n");
+#endif
+  generic_spi_init(GENERIC_SPI_VSC73XX_CS);
+  do {
+    vsc73xx_force_reset();
+    udelay(100);
+  } while (1);
+}
+
+#endif
+
+static int
+vsc73xx_check_block_sublock_ok(int block, int sublock) 
+{
+  switch (block) {
+  case 1:
+    switch (sublock) {
+    case 0: case 1: case 2: case 3: case 4: case 6:
+      return (0==0);
+    }
+    break;
+  case 2: case 7:
+    switch (sublock) {
+    case 0: 
+      return (0==0);
+    }
+    break;
+  case 3: case 4: case 5:
+    switch (sublock) {
+    case 0: case 1: 
+      return (0==0);
+    }
+    break;
+  }
+  return 0;
+}
+
+int
+vsc73xx_rd(int block, int subblock, int reg, unsigned int  *value)
+{
+  int rc;
+
+  rc=vsc73xx_check_block_sublock_ok(block, subblock);
+  if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": non-supported block/subblock %d %d\n", block, subblock);
+#endif
+    return -1;
+  }
+
+  rc=generic_spi_access_enable(GENERIC_SPI_VSC73XX_CS);
+#ifdef CONFIG_AR9100
+  if (ap83_board_version >= 50) {
+    gpio_clk_setup();
+  }
+#endif
+  if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": unable to CS %08x \n", GENERIC_SPI_VSC73XX_CS);
+#endif
+    return -1;
+  }
+  
+  /* Send address */
+  generic_spi_raw_output_u8((block<<5) | (0/*READ*/<<4) | (subblock<<0));
+  generic_spi_raw_output_u8(reg);
+  
+  /* Pad based on SiPAD register ( default 2) */
+  generic_spi_raw_output_u8(0);
+  generic_spi_raw_output_u8(0);
+
+  /* Clock 32b data into serial shift register */
+  *value = generic_spi_raw_input_u32(); 
+  
+  rc=generic_spi_access_done();
+
+  if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": unable to deassert CS %08x \n", GENERIC_SPI_VSC73XX_CS);
+#endif
+    return -1;
+  }
+
+  return 0;
+}
+
+int
+vsc73xx_wr(int block, int subblock, int reg, unsigned int  value)
+{
+  int rc;
+
+  rc=vsc73xx_check_block_sublock_ok(block, subblock);
+  if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": non-supported block/subblock %d %d\n", block, subblock);
+#endif
+    return -1;
+  }
+  
+  rc=generic_spi_access_enable(GENERIC_SPI_VSC73XX_CS);
+  if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": unable to CS %08x \n", GENERIC_SPI_VSC73XX_CS);
+#endif
+    return -1;
+  }	
+
+  /* Address */
+  generic_spi_raw_output_u8((block<<5) | (1/*WRITE*/<<4) | (subblock<<0) );
+  generic_spi_raw_output_u8(reg);
+
+  /* Data */
+  generic_spi_raw_output_u8((value>>24) & 0xff);
+  generic_spi_raw_output_u8((value>>16) & 0xff);
+  generic_spi_raw_output_u8((value>>8 ) & 0xff);
+  generic_spi_raw_output_u8((value>>0 ) & 0xff);
+  
+  rc=generic_spi_access_done();
+  if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": unable to deassert CS  %08x \n", GENERIC_SPI_VSC73XX_CS);
+#endif
+    return -1;
+  }     
+
+  return 0;
+}
+
+static int
+vsc73xx_get_and_verify_chipid(void)
+{
+  int curVal;
+  int chip;
+  int ii=256;
+
+  do {
+    vsc73xx_rd(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_CHIPID, &curVal);
+    chip = (curVal >> 12)  & 0x0ffff;
+  } while ((chip != 0x7385) && (chip != 0x7395) && (chip != 0x7396) && --ii);
+
+#ifdef VSC73XX_DEBUG
+  printk(MODULE_NAME": curval = 0x%08x\n", curVal);
+#endif
+
+  if (0==ii) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": unknown chip: %08x\n", chip);
+#endif
+    return -1;
+  }
+
+#ifdef CONFIG_AR9100
+
+  /*
+   * Per Martin Olsen [martino@vitesse.com],
+   * VSC7385YV chips with 0x0 in bits 31:28 of "Block 7 Subblock 0
+   * Address 0x18" is the first revision and that have a problem
+   * with the reset. This can be the reason why this doesn't work.
+   */
+  if (!((curVal >> 28) & 0xf)) {
+#ifndef COMPRESSED_UBOOT
+    printk("\n==================================================\n"
+           "WARNING:\n"
+           "Using revision 0 of chip 0x%x. It might not work!\n"
+           "==================================================\n", chip);
+#endif
+  }
+#endif
+
+  return chip;
+}
+
+static int
+vsc73xx_reset_and_verify_chipid(void)
+{
+#ifdef CONFIG_AR9100
+  if (ap83_board_version < 50) {
+    vsc73xx_force_reset();
+  }
+#else
+  vsc73xx_force_reset();
+#endif
+  return vsc73xx_get_and_verify_chipid();
+}
+
+#ifdef USE_TEST_CODE
+
+void
+vsc73xx_test_reset_and_verify_chipid(void)
+{
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": looping on reset & verify chipid\n");
+#endif
+  generic_spi_init(GENERIC_SPI_VSC73XX_CS);
+  do {
+    vsc73xx_reset_and_verify_chipid();
+  } while (1);
+}
+
+#endif
+
+static inline int
+vsc73xx_mailbox_get(unsigned int *d)
+{
+  return vsc73xx_rd(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_MAILBOX_VAL, d);
+}
+
+static inline int
+vsc73xx_mailbox_clr(unsigned int value)
+{
+  return vsc73xx_wr(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_MAILBOX_CLR, value);
+}
+
+static inline int
+vsc73xx_mailbox_set(unsigned int value)
+{
+  return vsc73xx_wr(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_MAILBOX_SET, value);
+}
+
+static inline int 
+vsc73xx_gpio_config_output(int value)
+{
+  return vsc73xx_wr(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_GPIO, ( value & VSC73XX_GPIO_MASK ) << 4);
+}
+
+static inline int
+vsc73xx_gpio_output(int value)
+{  
+  unsigned int d;
+  int rc;
+
+  value &=VSC73XX_GPIO_MASK;
+  
+  /* 1 = high 0=low  */
+  rc=vsc73xx_rd(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_GPIO, &d);
+  if (rc<0)
+    return rc;
+
+  d &=VSC73XX_GPIO_MASK;
+  d |=value;
+  return vsc73xx_wr(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_GPIO, d);
+}
+
+static inline int 
+vsc73xx_gpio_input(unsigned int *d)
+{
+  int rc;
+  unsigned int e;
+  rc=vsc73xx_rd(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_GPIO, &e);
+  if (rc<0)
+    return rc;
+
+  *d = e & VSC73XX_GPIO_MASK;
+  return rc;
+}
+
+#ifdef USE_TEST_CODE
+
+void
+vsc73xx_test_gpio(void)
+{
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": looping on / off vsc73xx GPIO\n");
+#endif
+  generic_spi_init(GENERIC_SPI_VSC73XX_CS);
+  vsc73xx_gpio_config_output(VSC73XX_GPIO_2);
+  do {
+    vsc73xx_gpio_output(VSC73XX_GPIO_2);
+    udelay(50);
+    vsc73xx_gpio_output(0);
+    udelay(50);
+  } while (1);
+}
+
+#endif
+
+static int
+vsc73xx_get_sVersion_resetNeeded(int *sVersion, int *resetNeeded)
+{
+  unsigned int d;
+  int rc;
+
+  rc=vsc73xx_mailbox_get(&d);
+  if (rc<0)
+    return rc;
+  *sVersion    = d & 0xffff;
+  *resetNeeded = (d & 0xffff0000) == 0xffff0000;
+  return 0;
+}
+
+static inline int 
+vsc73xx_restart_firmware(void)
+{
+  int rc;
+
+  rc = vsc73xx_wr(
+		  VSC73XX_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+		  (1<<7) |          /* SOFT_RST_HOLD = 1 */
+		  (1<<3) |          /* BOOT_EN       = 1 */
+		  (1<<2) |          /* EXT_ACC_EN    = 1 */
+		  (0<<0)            /* SOFT_RST      = 0 */
+		  );
+  if (rc<0)
+    return rc;
+  
+  rc = vsc73xx_wr(		
+		  VSC73XX_SYSTEM, 0,VSC73XX_ICPU_ADDR,
+		  0x0000
+		  );
+  if (rc<0)
+    return rc;
+  
+  udelay(100);
+  
+  rc = vsc73xx_wr(
+		  VSC73XX_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+		  (1<<8) |          /* CLK_DIV  = 1 */
+		  (1<<3) |          /* BOOT_EN  = 1 */
+		  (1<<1) |          /* CLK_EN   = 1 */
+		  (1<<0)            /* SOFT_RST = 1 */
+		  );
+  return rc;
+}
+
+static int
+vsc73xx_load_firmware_raw(unsigned char *lutonuAddr, int lutonuSize) 
+{
+  int            ii;
+  unsigned char  *dp;
+  unsigned int   curVal;
+  int            diffs;
+  int            rc;
+  
+  rc = vsc73xx_wr(
+		  VSC73XX_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+		  (1<<7) |          /* SOFT_RST_HOLD = 1 */
+		  (1<<3) |          /* BOOT_EN       = 1 */
+		  (1<<2) |          /* EXT_ACC_EN    = 1 */
+		  (0<<0)            /* SOFT_RST      = 0 */
+		  );
+  if (rc<0)
+    return rc;
+  
+  rc = vsc73xx_wr(		
+		  VSC73XX_SYSTEM, 0,VSC73XX_ICPU_ADDR,
+		  0x0000
+		  );
+  if (rc<0)
+    return rc;
+  
+  dp = lutonuAddr;
+  for (ii=0; ii<lutonuSize; ii++) {
+    rc = vsc73xx_wr(
+		    VSC73XX_SYSTEM, 0, VSC73XX_ICPU_SRAM,
+		    *dp++ 
+		    );
+    if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+      printk(MODULE_NAME": could not load microcode %d\n",rc);
+#endif
+      return rc;
+    }
+  }
+
+  rc = vsc73xx_wr(		
+		  VSC73XX_SYSTEM, 0, VSC73XX_ICPU_ADDR,
+		  0x0000
+		  );
+  if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": could not reset microcode %d\n",rc);
+#endif
+    return rc;
+  }
+
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": microcode Loaded, verifying...\n");
+#endif
+  
+  dp = lutonuAddr;
+  diffs=0;
+  for (ii=0; ii<lutonuSize; ii++) {
+    rc = vsc73xx_rd(
+		    VSC73XX_SYSTEM, 0,VSC73XX_ICPU_SRAM, 
+		    &curVal
+		    );
+    if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+      printk(MODULE_NAME": could not read microcode %d\n",rc);
+#endif
+      return rc;
+    }
+    
+    if (curVal > 0xff) {
+#ifndef COMPRESSED_UBOOT
+      printk(MODULE_NAME": bad val read: %04x : %02x  %02x  \n", ii, *dp, curVal);
+#endif
+      return -1;
+    } 
+    
+    if ((curVal & 0xff) != *dp) {
+      diffs++;
+#ifndef COMPRESSED_UBOOT
+      printk(MODULE_NAME": verify error: %04x : %02x  %02x  \n", ii, *dp, curVal);
+#endif
+      
+      if (diffs > 4)
+	break;
+    } 
+    dp++;
+  }
+  
+  if (diffs) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": failed to verify\n");
+#endif
+    return -1;
+  }
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": verify OK\n");
+#endif
+  
+  rc = vsc73xx_wr(
+		  VSC73XX_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+		  (1<<8) |          /* CLK_DIV  = 1 */
+		  (1<<3) |          /* BOOT_EN  = 1 */
+		  (1<<1) |          /* CLK_EN   = 1 */
+		  (1<<0)            /* SOFT_RST = 1 */
+		  );
+  return rc;
+}
+
+#define VSC73XX_SFTW_VERSION            0x229
+#ifdef CONFIG_AR9100
+#	include "g5_Plus1_2_31_unmanaged_Atheros_v3.c"
+#	include "g5_Plus1_2_31_unmanaged_Atheros_v4.c"
+#else
+#	include "g5_Plus1_2_29b_unmanaged_Atheros_v5.c"
+#	include "g5e_Plus1_2_29a_unmanaged_Atheros_v3.c"
+#	include "g5_Plus1_2_29a_unmanaged_Atheros_v5.c"
+#endif
+static int
+vsc73xx_load_firmware(void) 
+{
+  int sVersion;
+  int resetNeeded;
+  int rc;
+
+#ifdef CONFIG_AR9100
+ ar7100_reg_rmw_set(AR9100_FLASH_CONFIG,0x3fffff);
+#endif
+  rc = vsc73xx_reset_and_verify_chipid();
+  if (rc < 0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": could not identify chip, err %d\n", rc);
+#endif
+    return rc;
+  }
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": found chip id: %04x\n", rc);
+#endif
+
+#if defined(__BDI) && defined(VSC73XX_LOAD_FROM_RAM)
+  rc = vsc73xx_load_firmware_raw(get_scratch_uncached(8192), 8192);
+#else
+  switch (rc) {
+  case 0x00007385:  
+#ifdef CONFIG_AR9100
+    rc = vsc73xx_load_firmware_raw(g5_Plus1_2_31_unmanaged_Atheros_v3,
+				   sizeof(g5_Plus1_2_31_unmanaged_Atheros_v3));
+#else
+    rc = vsc73xx_load_firmware_raw(g5_Plus1_2_29b_unmanaged_Atheros_v5,
+                                   sizeof(g5_Plus1_2_29b_unmanaged_Atheros_v5));
+#endif
+    break;
+
+  case 0x00007395:
+    /* source from vitesse uses symbol lutonu, later versions use the name of the file.  */
+#ifdef CONFIG_AR9100
+    rc = vsc73xx_load_firmware_raw(g5_Plus1_2_31_unmanaged_Atheros_v4,
+				   sizeof(g5_Plus1_2_31_unmanaged_Atheros_v4));
+#else
+    rc = vsc73xx_load_firmware_raw(lutonu,       /* g5e_Plus1_2_29a_unmanaged_Atheros_v3 */
+				   sizeof(lutonu /* g5e_Plus1_2_29a_unmanaged_Atheros_v3 */));
+#endif
+    break;
+    
+  default:
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": microcode not availale for chip id: %08x\n", rc);
+#endif
+    rc = -1;
+  }
+#endif
+
+  if (rc<0)
+    return rc;
+
+  vsc73xx_get_sVersion_resetNeeded(&sVersion, &resetNeeded);
+  if (resetNeeded) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": failed to start\n");
+#endif
+    return -1;
+  }
+  if (sVersion < VSC73XX_SFTW_VERSION) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": incorrect software version %04x\n", sVersion);
+#endif
+#ifdef CONFIG_AR9100
+    if (ap83_board_version < 50) {
+      return -1;
+    }
+#else
+    return -1;
+#endif
+  }
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": software version %08x started OK\n",sVersion);
+#endif
+
+#ifdef CONFIG_AR9100
+ ar7100_reg_rmw_set(AR9100_FLASH_CONFIG,0xf2288);
+#endif
+
+  return 0;
+}
+
+#ifdef USE_TEST_CODE
+
+void
+vsc73xx_test_load_and_reset_firmware(void)
+{
+  int rc;
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": looping on load firmware / reset firmware\n");
+#endif
+  generic_spi_init(GENERIC_SPI_VSC73XX_CS);
+  do {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": return from load firmware: %d\n", vsc73xx_load_firmware());
+#endif
+    udelay(10000);
+  } while (1);
+}
+
+#endif
+
+#ifndef COMPRESSED_UBOOT
+static void
+vsc73xx_print_val_bit_desc (unsigned int val, char *fieldName, char *bit_descriptions[]) 
+{
+  int ii;
+  char *p2;
+  
+  printk(MODULE_NAME":   %s=%04x\n", fieldName, val);
+  for (ii=0;ii<32; ii++) {
+    p2 = val & 1<<(31-ii) ? bit_descriptions[ii*2] : bit_descriptions[ii*2+1];
+    if (p2 && p2[0]) {
+      printk(MODULE_NAME":     %s\n", p2);
+    }
+  }
+}
+#endif
+
+/* Port 0..4, 6 */
+static inline int 
+vsc73xx_get_mac_cfg(int port, unsigned int *d)
+{
+  return vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_MAC_CFG, d);
+}
+
+#ifndef COMPRESSED_UBOOT
+static char *mac_cfg_desc[32*2] = {
+  "wexc_dis","", /* 31 */
+  "","", /* 30 */
+  "port_rst","", /* 29 */
+  "tx_en","", /* 28 */
+  "seed_load","", /* 27 */
+  "","", /* 26 */
+  "","", /* 25 */
+  "","", /* 24 */
+  "","", /* 23 */
+  "","", /* 22 */
+  "","", /* 21 */
+  "","", /* 20 */
+  "","", /* 19 */
+  "en-fdx","", /* 18 */
+  "gige","", /* 17 */
+  "rx_en","", /* 16 */
+  "vlan_dblawr","", /* 15 */
+  "vlan_awr","", /* 14 */
+  "100-base-T","", /* 13 */
+  "","", /* 12 */
+  "","", /* 11 */
+  "","", /* 10 */
+  "","", /*  9 */
+  "","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "mac_rx_rst","", /*  5 */
+  "mac_tx_rst","", /*  4 */
+  "","", /*  3 */
+  "","", /*  2 */
+  "","", /*  1 */
+  "","", /*  0 */
+};
+
+static inline void
+vsc73xx_print_mac_cfg_val(unsigned int val)
+{
+  vsc73xx_print_val_bit_desc (val, "mac_cfg        (01P00)", mac_cfg_desc);
+  printk(MODULE_NAME":   clk_sel: %02x\n", (val>>0)&0x3);
+  printk(MODULE_NAME":   tx_ipg:  %02x\n", (val>>6)&0x1f);
+}
+#endif
+
+static inline int 
+vsc73xx_set_mac_cfg(int port, unsigned int value)
+{
+  return vsc73xx_wr(VSC73XX_MAC, port, VSC73XX_MAC_CFG, value);
+}
+
+static inline int 
+vsc73xx_get_clock_delay_reg(unsigned int *val)
+{
+  return vsc73xx_rd(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_CLOCK_DELAY, val);
+}
+
+static inline int
+vsc73xx_set_clock_delay_reg(unsigned int val)
+{
+  return vsc73xx_wr(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_CLOCK_DELAY, val);
+}
+
+#ifndef COMPRESSED_UBOOT
+static inline int 
+vsc73xx_get_advportm(int port, unsigned int *val)
+{
+  return vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_ADVPORTM, val);
+}
+
+static char *advportm_desc[32*2] = {
+  "","", /* 31 */
+  "","", /* 30 */
+  "","", /* 29 */
+  "","", /* 28 */
+  "","", /* 27 */
+  "","", /* 26 */
+  "","", /* 25 */
+  "","", /* 24 */
+  "","", /* 23 */
+  "","", /* 22 */
+  "","", /* 21 */
+  "","", /* 20 */
+  "","", /* 19 */
+  "","", /* 18 */
+  "","", /* 17 */
+  "","", /* 16 */
+  "","", /* 15 */
+  "","", /* 14 */
+  "","", /* 13 */
+  "","", /* 12 */
+  "","", /* 11 */
+  "","", /* 10 */
+  "","", /*  9 */
+  "","", /*  8 */
+  "ifg_ppm","",       /*  7 */
+  "exc_col","",       /*  6 */
+  "ext_port","",      /*  5 */
+  "inv_gtx","",       /*  4 */
+  "ena_gtx","",       /*  3 */
+  "ddr_mode","",      /*  2 */
+  "io_loopback","",   /*  1 */
+  "host_loopback","", /*  0 */
+};
+
+static inline void
+vsc73xx_print_advportm_val(unsigned int val)
+{
+  vsc73xx_print_val_bit_desc (val, "advportm      (01P19)", advportm_desc);
+}
+#endif
+
+static inline int
+vsc73xx_set_advportm(int port, unsigned int val)
+{
+  return vsc73xx_wr(VSC73XX_MAC, port, VSC73XX_ADVPORTM, val);
+}
+
+/* HERE */
+
+static inline unsigned int 
+vsc73xx_get_c_rx0(int port)
+{
+  unsigned int d;
+  vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_C_RX0, &d);
+  return d;
+}
+
+static inline unsigned int 
+vsc73xx_get_c_rx1(int port)
+{
+  unsigned int d;
+  vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_C_RX1, &d);
+  return d;
+}
+
+static inline unsigned int 
+vsc73xx_get_c_rx2(int port)
+{
+  unsigned int d;
+  vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_C_RX2, &d);
+  return d;
+}
+
+static inline unsigned int 
+vsc73xx_get_c_tx0(int port)
+{
+  unsigned int d;
+  vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_C_TX0, &d);
+  return d;
+}
+
+static inline unsigned int 
+vsc73xx_get_c_tx1(int port)
+{
+  unsigned int d;
+  vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_C_TX1, &d);
+  return d;
+}
+
+static inline unsigned int 
+vsc73xx_get_c_tx2(int port)
+{
+  unsigned int d;
+  vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_C_TX2, &d);
+  return d;
+}
+
+static inline unsigned int 
+vsc73xx_get_c_cfg(int port)
+{
+  unsigned int d;
+  vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_C_CFG, &d);
+  return d;
+}
+
+static inline void
+vsc73xx_set_c_cfg(int port, unsigned int value)
+{
+  vsc73xx_wr(VSC73XX_MAC, port, VSC73XX_C_CFG, value);
+}
+
+#ifndef COMPRESSED_UBOOT
+void
+vsc73xx_print_counts(int port)
+{
+  printk(MODULE_NAME":counters port %d\n", port);
+  printk(MODULE_NAME":   cfg: %8x\n", vsc73xx_get_c_cfg(port));
+  printk(MODULE_NAME":   rx0: %9d\n", vsc73xx_get_c_rx0(port));
+  printk(MODULE_NAME":   rx0: %9d\n", vsc73xx_get_c_rx1(port));
+  printk(MODULE_NAME":   rx0: %9d\n", vsc73xx_get_c_tx2(port));
+  printk(MODULE_NAME":   tx0: %9d\n", vsc73xx_get_c_tx0(port));
+  printk(MODULE_NAME":   tx0: %9d\n", vsc73xx_get_c_tx1(port));
+  printk(MODULE_NAME":   tx0: %9d\n", vsc73xx_get_c_tx2(port));
+}
+
+static inline void
+vsc73xx_print_link_status_from_value(int port, int up, int fdx, int speed, unsigned int cfg)
+{
+  printk(MODULE_NAME": STATUS Port: %d  up: %d  fdx: %d  speed: %d  mac cfg: %08x\n", port, up, fdx, speed, cfg);
+  vsc73xx_print_mac_cfg_val(cfg);
+}
+#endif
+
+#if 0
+
+/* WARNING: Do not use this if the switch application is running on the 8051. This
+ *          function may be used if the switch application is on the host and the 
+ *          8051 is in reset.
+ */
+unsigned short
+vsc73xx_rw_phy(int writeFlg, int unit, int phy_addr, int reg, uint16_t value)
+{
+  /* unit 0   = mac0 and should not happen here
+   * unit 1   = mac1, PHY we connect to using MAC 1
+   * unit 2-6 = ports on switch */
+  
+  unsigned int  request;
+  unsigned int  resp;
+  int sublockA;
+  int sublockB;
+
+  /* This needs to be checked since we are at a new level of 8051 code */
+  sublockA = unit==1 ? 6:0; /* unit==1 is PHY tied to MAC using RGMII */
+  sublockB = unit==1 ? 1:0; /* unit>=1 is PHY on switch                */
+                            /* With the new 8051 code this has to be figured
+			     * out again ( that is sublock values )
+			     */
+
+  request = (writeFlg ? 0 : 1)<<26 | (phy_addr<<21) | (reg<<16) | value;
+  
+  vsc73xx_wr(VSC73XX_MII, sublockA, VSC73XX_MII_CMD, request, 0);
+  udelay(10);
+  do {
+    vsc73xx_rd(VSC73XX_MII, sublockB, VSC73XX_MII_STAT, &resp, 0);
+    udelay(10);
+  } while ( resp & 0xf );
+  
+  if (writeFlg)
+    return 0;
+  
+  udelay(1);
+  
+  vsc73xx_rd(VSC73XX_MII, sublockB, VSC73XX_MII_DATA, &resp, 0);
+  
+  if (resp & 1<<16) {
+    return 0xffff;
+  }
+
+  return resp & 0xffff;
+}
+
+#endif
+
+static int
+vsc73xx_setup_raw(void)
+{
+  int          rc;
+  int          sVersion=0;
+  int          resetNeeded=0;
+
+  unsigned int t_cfg;
+  unsigned int t_clock_delay;
+  unsigned int t_advportm;
+
+  rc = generic_spi_init(GENERIC_SPI_VSC73XX_CS);
+  if (rc < 0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": could not initialize spi interface, err %d\n", rc);
+#endif
+    return rc;
+  }
+
+  vsc73xx_get_sVersion_resetNeeded(&sVersion, &resetNeeded);
+ if ( (resetNeeded) || (sVersion < VSC73XX_SFTW_VERSION) ) {
+    rc = vsc73xx_load_firmware();
+    if (rc < 0)
+      return rc;
+  }
+
+  /* The VSC73XX does not work very well unless we setup 2 nsec delay */
+  vsc73xx_set_clock_delay_reg(VSC73XX_CLOCK_DELAY);
+  vsc73xx_get_clock_delay_reg(&t_clock_delay);  
+  
+  if ((t_clock_delay & VSC73XX_CLOCK_DELAY_MASK) != VSC73XX_CLOCK_DELAY) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME":   unable to set clock_delay %08x %08x\n",  
+		   VSC73XX_CLOCK_DELAY, 
+		   VSC73XX_CLOCK_DELAY_MASK &  t_clock_delay);
+#endif
+    return -1;
+  }
+#ifndef COMPRESSED_UBOOT
+  else {
+    printk(MODULE_NAME":  clock_delay_reg %08x\n", t_clock_delay);
+  }
+#endif
+  
+  /* We must tell the VSC73XX that it has an external interface */
+  vsc73xx_set_advportm(VSC73XX_PORT_MAC, 
+		       VSC73XX_ADVPORTM_HYDRA);
+
+#ifndef COMPRESSED_UBOOT
+  vsc73xx_get_advportm(VSC73XX_PORT_MAC, &t_advportm);
+ 
+  if ((VSC73XX_ADVPORTM_HYDRA_MASK & t_advportm) != VSC73XX_ADVPORTM_HYDRA) {
+    printk(MODULE_NAME":   unable to set advanportm for MAC port (6) %08x %08x\n", 
+		   VSC73XX_ADVPORTM_HYDRA,
+		   VSC73XX_ADVPORTM_HYDRA_MASK & t_advportm);
+  }
+  else
+    vsc73xx_print_advportm_val(t_advportm);
+#endif
+  
+  /* We must tell the VSC73XX that it can send/recieve data */
+#ifdef CONFIG_AR9100
+  vsc73xx_set_mac_cfg(VSC73XX_PORT_MAC, VSC73XX_MAC_CFG_PORT_RST |
+		VSC73XX_MAC_CFG_MAC_RX_RST | VSC73XX_MAC_CFG_MAC_TX_RST);
+  vsc73xx_set_mac_cfg(VSC73XX_PORT_MAC, VSC73XX_MAC_CFG_AR9100);
+#else
+  vsc73xx_set_mac_cfg(VSC73XX_PORT_MAC, 
+		      VSC73XX_MAC_CFG_HYDRA );
+#endif
+  vsc73xx_get_mac_cfg(VSC73XX_PORT_MAC, &t_cfg);
+
+#ifndef COMPRESSED_UBOOT
+#ifndef CONFIG_AR9100
+  if ((VSC73XX_MAC_CFG_HYDRA_MASK & t_cfg) != VSC73XX_MAC_CFG_HYDRA) {
+    printk(MODULE_NAME":   unable to set mac_cfg for port 6 %08x %08x\n", 
+		   VSC73XX_MAC_CFG_HYDRA, 
+		   VSC73XX_MAC_CFG_HYDRA_MASK & t_cfg);
+  }
+  else
+#endif
+    vsc73xx_print_mac_cfg_val(t_cfg);
+#endif
+  
+  return rc;
+}
+
+static unsigned int mac_cfg_port[7] = { 0, 0, 0, 0, 0, 0, 0 };
+
+static unsigned int
+vsc73xx_get_link_status_raw(int port, int *up, int *fdx, ag7100_phy_speed_t *speed, unsigned int *cfg)
+{
+  int rc;
+
+  int t_up;
+  int t_fdx;
+  ag7100_phy_speed_t t_speed;
+
+  unsigned int t_cfg;
+  unsigned int t_chg;
+
+  rc = vsc73xx_get_mac_cfg(port, &t_cfg);
+  if (rc<0)
+    return ~0;
+
+  /* FIXME WCL
+   * Occasionally the VSC73XX will return 0xffffffff for cfg status with no apparent error.
+   */
+  if (t_cfg == 0xffffffff) 
+    return ~0;
+
+  t_chg = mac_cfg_port[port] ^ t_cfg;
+  mac_cfg_port[port] = t_cfg;
+
+  t_up  = (t_cfg & ( VSC73XX_MAC_CFG_TX_EN | VSC73XX_MAC_CFG_RX_EN )) == ( VSC73XX_MAC_CFG_TX_EN | VSC73XX_MAC_CFG_RX_EN );
+  t_fdx = (t_cfg & VSC73XX_MAC_CFG_FDX ) != 0;
+  
+  if ( t_cfg & VSC73XX_MAC_CFG_GIGA_MODE )
+    t_speed = AG7100_PHY_SPEED_1000T;
+  else
+    if ( t_cfg & VSC73XX_MAC_CFG_100_BASE_T )
+      t_speed = AG7100_PHY_SPEED_100TX;
+    else
+      t_speed = AG7100_PHY_SPEED_10T;
+
+  if(t_speed  == AG7100_PHY_SPEED_1000T) 
+	if (speed) *speed = 1000;
+  else if (t_speed  == AG7100_PHY_SPEED_100TX)
+	if (speed) *speed = 100;
+  else if (t_speed  == AG7100_PHY_SPEED_10T)
+        if (speed) *speed = 100;
+  if (up)    *up    = t_up;
+  if (fdx)   *fdx   = t_fdx;
+  if (cfg)   *cfg   = t_cfg;
+  
+  return t_chg;
+}
+
+#ifdef USE_TEST_CODE
+
+void
+vsc73xx_test_link_status(void)
+{
+  int          port;
+  int          ii;
+
+  unsigned int t_up;
+  unsigned int t_fdx;
+  ag7100_phy_speed_t t_speed;
+  unsigned int t_cfg;
+  unsigned int t_chg;
+
+  int          rc;
+
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": looping on load firmware / reset firmware\n" );
+#endif
+  vsc73xx_setup_raw();
+  do {
+    t_chg = vsc73xx_get_link_status_raw(port, &t_up, &t_fdx, &t_speed, &t_cfg);
+#ifndef COMPRESSED_UBOOT
+    if (t_chg == ~0) {
+      printk(MODULE_NAME": bad read from switch\n");
+    }
+    else {
+      if (t_chg)
+        vsc73xx_print_link_status_from_value(port, t_up, t_fdx, t_speed, t_cfg);
+    }
+#endif
+  } while (1);
+}
+
+#endif
+
+int 
+vsc73xx_setup(int unit)
+{
+  return vsc73xx_setup_raw();
+}
+
+int
+vsc73xx_get_link_status(int unit, int *up, int *fdx, ag7100_phy_speed_t *speed, unsigned int *cfg)
+{
+  int          port;
+
+  unsigned int t_up;
+  unsigned int t_fdx;
+  ag7100_phy_speed_t t_speed;
+  unsigned int t_cfg;
+  unsigned int t_chg;
+
+  /* The VSC73XX uses a fixed numbering scheme to get to ports - rather than using PHY Address.
+   *  
+   * unit 0   == mac 0
+   * unit 1   == mac 1 
+   * unit 2-6 == ports 0-4 
+   */
+
+  switch (unit) {
+    case 1: port=VSC73XX_PORT_MAC; break;
+    case 2: port=VSC73XX_PORT_0; break;
+    case 3: port=VSC73XX_PORT_1; break;
+    case 4: port=VSC73XX_PORT_2; break;
+    case 5: port=VSC73XX_PORT_3; break;
+    case 6: port=VSC73XX_PORT_4; break;
+    default:
+#ifndef COMPRESSED_UBOOT
+      printk(MODULE_NAME": bad unit number %d\n", unit);
+#endif
+      return -1;
+  } 
+
+  t_chg = vsc73xx_get_link_status_raw(port, &t_up, &t_fdx, &t_speed, &t_cfg);
+  if (t_chg == ~0)
+    return -2;
+ 
+  if(t_fdx)
+     if(fdx) *fdx = 44;
+  else
+     if(fdx) *fdx = 22; 
+
+  if (up)    *up    = t_up;
+  if (speed) *speed = t_speed;
+  if (cfg)   *cfg   = t_cfg;
+
+#ifdef VSC73XX_DEBUG
+  printk("\t==== vsc(%d) up:%d fdx:%d speed:%d cfg=0x%08x\n", unit, t_up, t_fdx, t_speed, t_cfg);
+#endif
+  return 0;
+}
+
+#ifndef COMPRESSED_UBOOT
+#ifdef VSC73XX_DEBUG
+void
+vsc73xx_flush_mac_table_all(void)
+{
+	/* This flushes the mac table of all the ports */
+	vsc73xx_wr(2, 0, 0xB0, 0x4);
+}
+
+void
+vsc73xx_get_link_status_dbg(void)
+{
+#ifndef COMPRESSED_UBOOT
+	printk("\n");
+#endif
+	vsc73xx_get_link_status(1, 0, 0, 0, 0);
+	vsc73xx_get_link_status(2, 0, 0, 0, 0);
+	vsc73xx_get_link_status(3, 0, 0, 0, 0);
+	vsc73xx_get_link_status(4, 0, 0, 0, 0);
+	vsc73xx_get_link_status(5, 0, 0, 0, 0);
+	vsc73xx_get_link_status(6, 0, 0, 0, 0);
+}
+#endif /* VSC73XX_DEBUG */
+
+int
+vsc73xx_phy_print_link_status(int unit)
+{
+  int          port;
+
+  unsigned int t_up;
+  unsigned int t_fdx;
+  ag7100_phy_speed_t t_speed;
+  unsigned int t_cfg;
+  unsigned int t_chg;
+
+  /* The VSC73XX uses a fixed numbering scheme to get to ports - rather than using PHY Address.
+   *  
+   * unit 0   == mac 0
+   * unit 1   == mac 1 
+   * unit 2-6 == ports 0-4 
+   */
+
+  switch (unit) {
+    case 1: port=VSC73XX_PORT_MAC; break;
+    case 2: port=VSC73XX_PORT_0; break;
+    case 3: port=VSC73XX_PORT_1; break;
+    case 4: port=VSC73XX_PORT_2; break;
+    case 5: port=VSC73XX_PORT_3; break;
+    case 6: port=VSC73XX_PORT_4; break;
+    default:
+#ifndef COMPRESSED_UBOOT
+      printk(MODULE_NAME": bad unit number %d\n", unit);
+#endif
+      return -1;
+  } 
+
+  t_chg = vsc73xx_get_link_status_raw(port, &t_up, &t_fdx, &t_speed, &t_cfg);
+  if (t_chg == ~0)
+    return -2;
+  
+#ifndef COMPRESSED_UBOOT
+  vsc73xx_print_link_status_from_value(port, t_up, t_fdx, t_speed, t_cfg); 
+#endif
+  return 0;
+}
+#endif
diff --git a/board/ar7100/common/vsc73xx.h b/board/ar7100/common/vsc73xx.h
new file mode 100644
index 0000000000..09a60add55
--- /dev/null
+++ b/board/ar7100/common/vsc73xx.h
@@ -0,0 +1,168 @@
+/* vsc73xx.h 
+ *
+ * History:
+ * Jan  4, 2007 wclewis initial
+ * Jan 12, 2007 wclewis ready for checkin
+ * May 24, 2007 Tag before BSP resturcture 
+ */
+
+#ifndef _VSC73XX_H
+#define _VSC73XX_H
+
+//#include "ag7100.h"
+
+typedef enum {
+    AG7100_PHY_SPEED_10T,
+    AG7100_PHY_SPEED_100TX,
+    AG7100_PHY_SPEED_1000T,
+}ag7100_phy_speed_t;
+
+
+int
+vsc73xx_rd(int block, int subblock, int reg, unsigned int  *value);
+
+int
+vsc73xx_wr(int block, int subblock, int reg, unsigned int  value);
+
+/* Extern for heathrow.c and other vitesse provided stuff  */
+#define vtss_io_si_rd vsc73xx_rd_vsc7395
+#define vtss_io_si_wr vsc73xx_wr_vsc7395
+
+#define VSC73XX_GPIO_0          0x01
+#define VSC73XX_GPIO_1          0x02
+#define VSC73XX_GPIO_2          0x04
+#define VSC73XX_GPIO_3          0x08
+
+#define VSC73XX_GPIO_MASK       (VSC73XX_GPIO_0 | VSC73XX_GPIO_1 | VSC73XX_GPIO_2 | VSC73XX_GPIO_3 )
+
+#define VSC73XX_MAC_CFG_WEXC_DIS	(1<<31)
+#define VSC73XX_MAC_CFG_PORT_RST        (1<<29)
+#define VSC73XX_MAC_CFG_TX_EN       	(1<<28)
+#define VSC73XX_MAC_CFG_FDX	        (1<<18)
+#define VSC73XX_MAC_CFG_GIGA_MODE       (1<<17)
+#define VSC73XX_MAC_CFG_RX_EN           (1<<16)
+#define VSC73XX_MAC_CFG_100_BASE_T      (1<<13)
+#define VSC73XX_MAC_CFG_TX_IPG(y)       ((y&0x1f)<<6)
+#define VSC73XX_MAC_CFG_MAC_RX_RST      (1<<5)
+#define VSC73XX_MAC_CFG_MAC_TX_RST      (11<4)
+#define VSC73XX_MAC_CFG_CLK_SEL(y)      ((y&0x3)<<0)
+
+#define VSC73XX_MAC_CFG_HYDRA_MASK ( \
+VSC73XX_MAC_CFG_WEXC_DIS   | \
+VSC73XX_MAC_CFG_PORT_RST   | \
+VSC73XX_MAC_CFG_TX_EN      | \
+VSC73XX_MAC_CFG_FDX        | \
+VSC73XX_MAC_CFG_GIGA_MODE  | \
+VSC73XX_MAC_CFG_RX_EN      | \
+VSC73XX_MAC_CFG_100_BASE_T | \
+VSC73XX_MAC_CFG_TX_IPG(31) | \
+VSC73XX_MAC_CFG_MAC_RX_RST | \
+VSC73XX_MAC_CFG_MAC_TX_RST | \
+VSC73XX_MAC_CFG_CLK_SEL(3)   \
+)
+
+#define VSC73XX_MAC_CFG_HYDRA ( \
+VSC73XX_MAC_CFG_TX_EN      | \
+VSC73XX_MAC_CFG_FDX        | \
+VSC73XX_MAC_CFG_GIGA_MODE  | \
+VSC73XX_MAC_CFG_RX_EN      | \
+VSC73XX_MAC_CFG_TX_IPG(6)  | \
+VSC73XX_MAC_CFG_CLK_SEL(3)   \
+)
+
+#define VSC73XX_MAC_CFG_AR9100 ( \
+VSC73XX_MAC_CFG_TX_EN      | \
+VSC73XX_MAC_CFG_FDX        | \
+VSC73XX_MAC_CFG_GIGA_MODE  | \
+VSC73XX_MAC_CFG_RX_EN      | \
+VSC73XX_MAC_CFG_TX_IPG(6)  | \
+4                            \
+)
+
+#define VSC73XX_MAC_CFG_CLK_RGMI_125MHZ 1
+#define VSC73XX_MAC_CFG_CLK_RGMI_25MHZ  2
+#define VSC73XX_MAC_CFG_CLK_RGMI_2_5MHZ 3
+
+#define VSC73XX_CLOCK_DELAY       (3<<4|3)
+#define VSC73XX_CLOCK_DELAY_MASK  (3<<4|3)
+
+#define VSC73XX_ADVPORTM_IFG_PPM       (1<<7)
+#define VSC73XX_ADVPORTM_EXC_COL_CONT  (1<<6)
+#define VSC73XX_ADVPORTM_EXT_PORT      (1<<5)
+#define VSC73XX_ADVPORTM_INV_GTX       (1<<4)
+#define VSC73XX_ADVPORTM_ENA_GTX       (1<<3)
+#define VSC73XX_ADVPORTM_DDR_MODE      (1<<2)
+#define VSC73XX_ADVPORTM_IO_LOOPBACK   (1<<1)
+#define VSC73XX_ADVPORTM_HOST_LOOPBACK (1<<0)
+
+#define VSC73XX_ADVPORTM_HYDRA_MASK ( \
+VSC73XX_ADVPORTM_IFG_PPM       | \
+VSC73XX_ADVPORTM_EXC_COL_CONT  | \
+VSC73XX_ADVPORTM_EXT_PORT      | \
+VSC73XX_ADVPORTM_INV_GTX       | \
+VSC73XX_ADVPORTM_ENA_GTX       | \
+VSC73XX_ADVPORTM_DDR_MODE      | \
+VSC73XX_ADVPORTM_IO_LOOPBACK   | \
+VSC73XX_ADVPORTM_HOST_LOOPBACK   \
+)
+
+#define VSC73XX_ADVPORTM_HYDRA ( \
+VSC73XX_ADVPORTM_EXT_PORT      | \
+VSC73XX_ADVPORTM_ENA_GTX       | \
+VSC73XX_ADVPORTM_DDR_MODE        \
+)
+
+/* Port 0..4, 6 */
+
+void
+vsc73xx_print_counts(int port);
+
+#define VSC73XX_PORT_0      0
+#define VSC73XX_PORT_1      1
+#define VSC73XX_PORT_2      2
+#define VSC73XX_PORT_3      3
+#define VSC73XX_PORT_4      4
+
+#define VSC73XX_PORT_MAC    6
+
+/* ********************************** INTERFACE TO AG7100 ********************* */
+
+int 
+vsc73xx_setup(int unit);
+
+int
+vsc73xx_get_link_status(int unit, int *up, int *fdx, ag7100_phy_speed_t *speed, unsigned int *cfg);
+
+int
+vsc73xx_phy_print_link_status(int unit);
+
+/* This command may be used to read/write to the PHY in the case where the
+ * switch code is running on the host. The 8051 processor is not running.
+ *
+ * If 8051 processor on the switch is running the 'unmanaged' application than
+ * it is unwise to use the vsc73xx_rw_phy() command since the switch 8051 code
+ * is also using that interface.
+ */
+unsigned short
+vsc73xx_rw_phy(int writeFlg, int unit, int phy_addr, int reg, uint16_t value);
+
+#ifdef USE_TEST_CODE
+
+void
+vsc73xx_test_reset_line(void);
+
+void
+vsc73xx_test_reset_and_verify_chipid(void);
+
+void
+vsc73xx_test_gpio(void);
+
+void
+vsc73xx_test_load_and_reset_firmware(void);
+
+void
+vsc73xx_test_link_status(void);
+
+#endif
+
+#endif
diff --git a/board/ar7100/common/vsc8601_phy.c b/board/ar7100/common/vsc8601_phy.c
new file mode 100644
index 0000000000..bb2c9fb41e
--- /dev/null
+++ b/board/ar7100/common/vsc8601_phy.c
@@ -0,0 +1,1226 @@
+/* vsc8601.h
+ *
+ * History:
+ * Jan 14, 2007 wclewis ready common BDI/ECOS/Linux
+ *
+ *
+ * 1) Routine uses MII interface to query the specified device.
+ *
+ * 2) If the device is a VSC8201 or VSC8601 routine initializes
+ *    device using Vitesse specific routines.
+ *
+ * 3) If device is a IEEE complient device the device is 
+ *    initialized in a generic fashion.
+ *
+ * 4) During query the PHY address is captured and used to 
+ *    initialize the phy table. This has been tested for
+ *    the VSC8201, VSC8601 and ICPLUS.
+ */
+
+#ifdef __BDI
+#include "bdi.h"
+#else
+#ifdef __ECOS
+#if defined(CYGNUM_USE_ENET_VERBOSE)
+#   undef  VERBOSE
+#   define VERBOSE CYGNUM_USE_ENET_VERBOSE
+#else
+#   define VERBOSE 0
+#endif 
+#define generic_printk             DEBUG_PRINTF
+#define generic_udelay             A_UDELAY
+#else
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include "vsc8601_phy.h"
+#define generic_printk             printf
+#define generic_udelay             udelay
+#endif
+#endif
+
+#ifndef VERBOSE
+#define  VERBOSE           1
+#endif
+
+#include "vsc8601_phy.h"
+
+typedef struct {
+  uint16_t     is_enet_port;
+  uint16_t     mac_unit;
+  uint16_t     phy_addr;
+  uint32_t     id;
+  uint16_t     status;
+}vsc8601_phy_t;
+
+static uint16_t nmbr_phys = 0;
+static vsc8601_phy_t phy_info[] = {
+  {
+    is_enet_port: 0,
+    mac_unit    : 0,
+    phy_addr    : 0
+  },
+  {
+    is_enet_port: 0,
+    mac_unit    : 0,
+    phy_addr    : 0
+  },
+  {
+    is_enet_port: 0,
+    mac_unit    : 0,
+    phy_addr    : 0
+  },
+  {
+    is_enet_port: 0,
+    mac_unit    : 0,
+    phy_addr    : 0
+  },
+  {
+    is_enet_port: 0,
+    mac_unit    : 0,
+    phy_addr    : 0
+  },
+  {
+    is_enet_port: 0,
+    mac_unit    : 0,
+    phy_addr    : 0
+  }
+};
+
+static uint16_t
+ag7100_mii_read(uint32_t phybase, uint16_t phyaddr, uint16_t reg)
+{
+    uint16_t val;
+
+    phy_reg_read(phybase, phyaddr, reg, &val);
+    return val;
+}
+
+static void
+ag7100_mii_write(uint32_t phybase, uint16_t phyaddr, uint16_t reg, uint32_t val)
+{
+    phy_reg_write(phybase, phyaddr, reg, val);
+}
+
+#if 0
+static vsc8601_phy_t *
+vsc8601_phy_find(int unit)
+{
+  int i;
+  vsc8601_phy_t *phy;
+  
+  for(i = 0; i < sizeof(phy_info)/sizeof(phy_info[0]); i++) {
+    phy = &phy_info[i];
+    if (phy->is_enet_port && (phy->mac_unit == unit))
+      return phy;
+  }
+  generic_printk(" ERROR: Did not find unit %d\n", unit);
+  return NULL;
+}
+#endif
+
+/* Base read/write routines built on ag7100_mii_ macros */
+
+static inline void
+vsc8601_phy_mii_write_main(int unit, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+  ag7100_mii_write(unit, phy_addr, 31,  0);
+  ag7100_mii_write(unit, phy_addr, reg, data);
+}
+
+static inline void 
+vsc8601_phy_mii_write_ex(int unit, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+  ag7100_mii_write(unit, phy_addr, 31,  1);
+  ag7100_mii_write(unit, phy_addr, reg, data);
+}
+
+static inline uint16_t  
+vsc8601_phy_mii_read_main(int unit, uint32_t phy_addr, uint8_t reg)
+{
+  ag7100_mii_write(unit, phy_addr, 31,  0);
+  return ag7100_mii_read(unit, phy_addr, reg);
+}
+
+static inline uint16_t 
+vsc8601_phy_mii_read_ex(int unit, uint32_t phy_addr, uint8_t reg)
+{
+  uint16_t val;
+  ag7100_mii_write(unit, phy_addr, 31,  1);
+  val = ag7100_mii_read(unit, phy_addr, reg);
+  ag7100_mii_write(unit, phy_addr, 31,  0);
+  return val;
+}
+
+/* Super simple routine to make it easier to print bits */
+
+static void
+vsc8601_phy_print_val_bit_desc (uint16_t val, char *fieldName, char *bit_descriptions[]) 
+{
+  int ii;
+  char *p2;
+  
+  generic_printk(" %s=%04x ", fieldName, val);
+  for (ii=0;ii<16; ii++) {
+    p2 = val & 1<<(15-ii) ? bit_descriptions[ii*2] : bit_descriptions[ii*2+1];
+    if (p2 && p2[0])      
+        generic_printk("    %s\n", p2);
+  }
+}
+
+/* **************************************************************************** 
+ *
+ * For each register of interest:
+ * 1) register read
+ * 2) register print if there are alot of fields or bits
+ * 3) register write if there may be a need to write
+ * 4) masked write if there is a write and there are bits.
+ *
+ * **************************************************************************** */
+
+/* mode control */
+
+CEXTERN uint16_t 
+vsc8601_phy_mii_read_mode_ctrl(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 0);
+}
+
+static char *mode_ctrl_desc[16*2] = {
+  "sreset","", /* 15 */
+  "loopback", "", /* 14 */
+  "f100","", /* 13 */
+  "auto-eg","", /* 12 */
+  "pwr-dwn","", /* 11 */
+  "isolate","", /* 10 */
+  "restar-auto-neg","", /*  9 */
+  "full-duplex","half-duplex", /*  8 */
+  "ctest","", /*  7 */
+  "f1000","", /*  6 */
+  "","", /*  5 */
+  "","", /*  4 */
+  "","", /*  3 */
+  "","", /*  2 */
+  "","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void 
+vsc8601_phy_mii_print_mode_ctrl(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "mode_ctr        (00 )", mode_ctrl_desc);
+}
+
+CEXTERN void 
+vsc8601_phy_mii_write_mode_ctrl(int unit, uint32_t phy_addr, uint16_t reg )
+{
+  vsc8601_phy_mii_write_main(unit, phy_addr, 0, reg);
+}
+
+CEXTERN void 
+vsc8601_phy_mii_rmw_ctrl(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_mii_read_mode_ctrl(unit, phy_addr); 
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_mii_write_mode_ctrl(unit, phy_addr, reg);
+}
+
+/* mode status */
+
+CEXTERN uint16_t  
+vsc8601_phy_mii_read_mode_status(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 1);
+}
+
+static char *mode_status_desc[16*2] = {
+  "","", /* 15 */
+  "","", /* 14 */
+  "","", /* 13 */
+  "","", /* 12 */
+  "","", /* 11 */
+  "","", /* 10 */
+  "","", /*  9 */
+  "","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "auto-neg-cmplt","", /*  5 */
+  "rem-fault","", /*  4 */
+  "auto-neg-cap","", /*  3 */
+  "link-up","", /*  2 */
+  "jabber","", /*  1 */
+  "ex-cap","", /*  0 */
+};
+
+CEXTERN void 
+vsc8601_phy_mii_print_mode_status(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "mode_status     (01 )", mode_status_desc);
+}
+
+/* phy identification */
+
+CEXTERN uint16_t 
+vsc8601_phy_mii_read_id1(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 2);
+}
+
+CEXTERN uint16_t 
+vsc8601_phy_mii_read_id2(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 3);
+}
+
+/* gige control R/W */
+
+CEXTERN uint16_t 
+vsc8601_phy_mii_read_gige_ctrl(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 9);
+}
+
+static char *gige_ctrl_desc[16*2] = {
+  "distortion-test","", /* 15 */
+  "jitter-test","", /* 14 */
+  "waveform-test","", /* 13 */
+  "man-cfg","", /* 12 */
+  "master","", /* 11 */
+  "","", /* 10 */
+  "","", /*  9 */
+  "","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "","", /*  5 */
+  "","", /*  4 */
+  "","", /*  3 */
+  "","", /*  2 */
+  "","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void 
+vsc8601_phy_mii_print_gige_ctrl(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "gige_ctrl       (09 )", gige_ctrl_desc);
+}
+
+CEXTERN void  
+vsc8601_phy_mii_write_gige_ctrl(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_main(unit, phy_addr, 9, reg);
+}
+
+CEXTERN void 
+vsc8601_phy_rmw_gige_ctrl(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_mii_read_gige_ctrl(unit, phy_addr); 
+  if (reg == 0xffff)
+    return;
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_mii_write_gige_ctrl(unit, phy_addr, reg);
+}
+
+/* gige status RO */
+
+CEXTERN uint16_t  
+vsc8601_phy_read_gige_status(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 10);
+}
+
+static char *gige_status_desc[16*2] = {
+  "ms-fault","", /* 15 */
+  "is-master","", /* 14 */
+  "loc-rcv-ok","", /* 13 */
+  "rem-rcv-ok","", /* 12 */
+  "fdx-cap","", /* 11 */
+  "hdx-cap","", /* 10 */
+  "","", /*  9 */
+  "","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "","", /*  5 */
+  "","", /*  4 */
+  "","", /*  3 */
+  "","", /*  2 */
+  "","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void 
+vsc8601_phy_mii_print_gige_status(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, " gige_status     (10 )", gige_status_desc);
+  generic_printk("    idle-err-cnt: %02x\n", val&0xff);
+}
+
+/* gige status extension 1 todo */
+
+/* 100 base_t status extension RO */
+
+CEXTERN uint16_t  
+vsc8601_phy_read_100_status_ex(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 16);
+}
+
+static char *l00_status_ex_desc[16*2] = {
+  "descram-lock","", /* 15 */
+  "descram-err","", /* 14 */
+  "disc","", /* 13 */
+  "link-act","", /* 12 */
+  "rcv-err","", /* 11 */
+  "xmt-err","", /* 10 */
+  "sos-err","", /*  9 */
+  "","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "","", /*  5 */
+  "","", /*  4 */
+  "","", /*  3 */
+  "","", /*  2 */
+  "","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void 
+vsc8601_phy_mii_print_100_status_ex(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "100_status_ex   (16 )", l00_status_ex_desc);
+}
+
+/* gige status extention 2 RO */
+
+CEXTERN uint16_t 
+vsc8601_phy_read_gige_status_ex_2(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 17);
+}
+
+static char *gige_status_ex_2_desc[16*2] = {
+  "descram-lock","", /* 15 */
+  "descram-err","", /* 14 */
+  "disc","", /* 13 */
+  "link-up","", /* 12 */
+  "rcv-err","", /* 11 */
+  "xmt-err","", /* 10 */
+  "ssd-err","", /*  9 */
+  "esd-err","", /*  8 */
+  "ce-err","", /*  7 */
+  "bcm-det","", /*  6 */
+  "mdi-x-err","", /*  5 */
+  "","", /*  4 */
+  "","", /*  3 */
+  "","", /*  2 */
+  "","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void 
+vsc8601_phy_mii_print_gige_status_ex_2(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "gige_status_ex_2((17 )", gige_status_ex_2_desc);
+}
+
+/* Error counts of various types saturate at 0xff */
+
+CEXTERN uint16_t 
+vsc8601_phy_read_rx_error_count(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 19);
+}
+
+CEXTERN uint16_t 
+vsc8601_phy_read_false_carrier_count(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 20);
+}
+
+CEXTERN uint16_t 
+vsc8601_phy_read_disconnect_count(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 21);
+}
+
+CEXTERN uint16_t 
+vsc8601_phy_read_ex_crtl_set_1(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 23);
+}
+
+static char *ex_crtl_set_1_desc[16*2] = {
+  "","", /* 15 */
+  "","", /* 14 */
+  "","", /* 13 */
+  "","", /* 12 */
+  "","", /* 11 */
+  "","", /* 10 */
+  "","", /*  9 */
+  "skew-2ns-rx-tx","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "actiphy","", /*  5 */
+  "","", /*  4 */
+  "","", /*  3 */
+  "","", /*  2 */
+  "","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void 
+vsc8601_phy_mii_print_ex_ctrl_set_1(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "ex_crtl_set_1   (23 )", ex_crtl_set_1_desc);
+}
+
+CEXTERN void  
+vsc8601_phy_write_ex_crtl_set_1(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_main(unit, phy_addr, 23, reg);
+}
+
+CEXTERN void 
+vsc8601_phy_rmw_ex_crtl_set_1(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_read_ex_crtl_set_1(unit, phy_addr); 
+  if (reg == 0xffff)
+    return;
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_write_ex_crtl_set_1(unit, phy_addr, reg);
+}
+
+CEXTERN uint16_t 
+vsc8601_phy_read_ex_crtl_set_2(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 24);
+}
+
+CEXTERN void  
+vsc8601_phy_write_ex_crtl_set_2(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_main(unit, phy_addr, 24, reg);
+}
+
+CEXTERN void 
+vsc8601_phy_rmw_ex_crtl_set_2(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_read_ex_crtl_set_2(unit, phy_addr); 
+  if (reg == 0xffff)
+    return;
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_write_ex_crtl_set_2(unit, phy_addr, reg);
+}
+
+CEXTERN uint16_t  
+vsc8601_phy_read_irq_msk(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 25);
+}
+
+CEXTERN void 
+vsc8601_phy_write_irq_msk(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_main(unit, phy_addr, 25, reg);
+}
+
+CEXTERN uint16_t  
+vsc8601_phy_read_irq_status(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 26);
+}
+static char *irq_status_desc[16*2] = {
+  "pending","", /* 15 */
+  "speed","", /* 14 */
+  "link","", /* 13 */
+  "fdx","", /* 12 */
+  "auto-err","", /* 11 */
+  "auto-cmpl","", /* 10 */
+  "inl-pwr","", /*  9 */
+  "","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "","", /*  5 */
+  "","", /*  4 */
+  "","", /*  3 */
+  "dwn-shft","", /*  2 */
+  "ms-err","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void 
+vsc8601_phy_mii_print_irq_status(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "irq_status      (26 )", irq_status_desc);
+}
+
+#if 0
+/* RO */
+
+CEXTERN uint16_t 
+vsc8601_phy_read_aux_ctrl_status(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 28);
+}
+
+static char *aux_ctrl_status_desc[16*2] = {
+  "auto-cmplt","", /* 15 */
+  "auto-dis","", /* 14 */
+  "cross-over","", /* 13 */
+  "cd swap","", /* 12 */
+  "a-pol","", /* 11 */
+  "b-pol","", /* 10 */
+  "c-pol","", /*  9 */
+  "d-pol","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "fdx","", /*  5 */
+  "gige","", /*  4 */
+  "100-base-T","", /*  3 */
+  "","", /*  2 */
+  "sticky","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void 
+vsc8601_phy_mii_print_aux_ctrl_status(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "aux_ctrl_status (28 )", aux_ctrl_status_desc);
+}
+
+CEXTERN uint16_t 
+vsc8601_phy_read_delay_skew_status(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 29);
+}
+
+CEXTERN void 
+vsc8601_phy_mii_print_delay_skew_status(uint16_t val)
+{
+  generic_printk(" delay_skew_     (29 )=%04x\n", val);
+  generic_printk("    pair a delay: %02x\n", (val>>12)&7);
+  generic_printk("    pair b delay: %02x\n", (val>> 8)&7);
+  generic_printk("    pair c delay: %02x\n", (val>> 4)&7);
+  generic_printk("    pair d delay: %02x\n", (val>> 0)&7);
+}
+
+/* Extended registers - specific to chips? */
+
+CEXTERN uint16_t 
+vsc8601_phy_read_crc_good_counter(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_ex(unit, phy_addr, 18);
+}
+
+/* Resistor calibration */
+
+CEXTERN uint16_t 
+vsc8601_phy_read_mac_resistor_calibration(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_ex(unit, phy_addr, 19);
+}
+
+CEXTERN void 
+vsc8601_phy_write_mac_resistor_calibration(int unit, uint32_t phy_addr, uint16_t val)
+{
+  vsc8601_phy_mii_write_ex(unit, phy_addr, 19, val);
+}
+
+CEXTERN void 
+vsc8601_phy_rmw_mac_resistor_calibration(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_read_mac_resistor_calibration(unit, phy_addr); 
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_write_mac_resistor_calibration(unit, phy_addr, reg);
+}
+
+CEXTERN uint16_t 
+vsc8601_phy_read_ex_crtl_set_5(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_ex(unit, phy_addr, 27);
+}
+
+CEXTERN void 
+vsc8601_phy_mii_print_ex_crtl_set_5(uint16_t val)
+{
+  generic_printk(" ex_crtl_set_5   (27E)=%04x\n", val);
+  generic_printk("    crs:         %x\n", (val>>12)&7);
+  generic_printk("    100  tx amp: %x\n", (val>> 6)&7);
+  generic_printk("    gige tx amp: %x\n", (val>> 3)&7);
+  generic_printk("    gige edge:   %x\n", (val>> 0)&7);
+
+  if (val & 1<<10)
+    generic_printk("   FAR-END-LOOPBACK\n");
+}
+
+CEXTERN void  
+vsc8601_phy_write_ex_crtl_set_5(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_ex(unit, phy_addr, 27, reg);
+}
+
+CEXTERN void 
+vsc8601_phy_rmw_ex_crtl_set_5(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_read_ex_crtl_set_5(unit, phy_addr); 
+  if (reg == 0xffff)
+    return;
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_write_ex_crtl_set_5(unit, phy_addr, reg);
+}
+
+CEXTERN uint16_t 
+vsc8601_phy_read_skew_ctrl(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_ex(unit, phy_addr, 28);
+}
+
+CEXTERN void 
+vsc8601_phy_mii_print_skew_ctrl(uint16_t val)
+{
+  generic_printk(" skew_ctrl       (28E)=%04x\n", val);
+  generic_printk("    tx cmp: %x\n", (val>>14)&3);
+  generic_printk("    rx cmp: %x\n", (val>>12)&7);
+  generic_printk("    jumbo:  %x\n", (val>>10)&7); 
+}
+
+CEXTERN void  
+vsc8601_phy_write_skew_ctrl(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_ex(unit, phy_addr, 28, reg);
+}
+
+CEXTERN void 
+vsc8601_phy_rmw_skew_ctrl(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_read_skew_ctrl(unit, phy_addr); 
+  if (reg == 0xffff)
+    return;
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_write_skew_ctrl(unit, phy_addr, reg);
+}
+
+CEXTERN uint16_t 
+vsc8601_phy_read_epg_1(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_ex(unit, phy_addr, 29);
+}
+
+CEXTERN void  
+vsc8601_phy_write_epg_1(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_ex(unit, phy_addr, 29, reg);
+}
+
+CEXTERN void 
+vsc8601_phy_rmw_epg_1(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_read_epg_1(unit, phy_addr); 
+  if (reg == 0xffff)
+    return;
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_write_epg_1(unit, phy_addr, reg);
+}
+
+CEXTERN uint16_t 
+vsc8601_phy_read_epg_2(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_ex(unit, phy_addr, 20);
+}
+
+CEXTERN void  
+vsc8601_phy_write_epg_2(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_ex(unit, phy_addr, 30, reg);
+}
+
+CEXTERN void 
+vsc8601_phy_rmw_epg_2(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_read_epg_2(unit, phy_addr); 
+  if (reg == 0xffff)
+    return;
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_write_epg_2(unit, phy_addr, reg);
+}
+#endif
+
+/* Functions */
+
+CEXTERN void 
+vsc8601_phy_mii_soft_reset(int unit, uint32_t phy_addr) 
+{
+  vsc8601_phy_mii_rmw_ctrl(unit, phy_addr, 1<<15, 1<<15);
+  generic_udelay(10);
+}
+
+CEXTERN void  
+vsc8601_phy_mii_set_loopback(int unit, uint32_t phy_addr, int onOff) 
+{
+  uint32_t   val = onOff ? 1<<14 : 0;	      
+  vsc8601_phy_mii_rmw_ctrl(unit, phy_addr, 1<<14, val);
+}
+
+CEXTERN void 
+vsc8601_phy_mii_set_auto(int unit, uint32_t phy_addr, int onOff) 
+{
+  uint32_t   val = onOff ? 1<<12 : 0;	  
+  vsc8601_phy_mii_rmw_ctrl(unit, phy_addr, 1<<12, val);
+}
+
+CEXTERN void 
+vsc8601_phy_mii_force_speed(int unit, uint32_t phy_addr, int speed) 
+{
+  uint32_t val=0;
+  if (speed & 1<<0) val |= 1<<6;
+  if (speed & 2<<0) val |= 1<<13;
+  vsc8601_phy_mii_rmw_ctrl(unit, phy_addr, 1<<6 | 1<<13 , val);
+}
+
+CEXTERN void 
+vsc8601_phy_mii_restart_auto(int unit, uint32_t phy_addr, int onOff) 
+{
+  uint32_t   val = onOff ? 1<<9 : 0;	  
+  vsc8601_phy_mii_rmw_ctrl(unit, phy_addr, 1<<9, val);
+}
+
+CEXTERN void 
+vsc8601_phy_mii_set_duplex(int unit, uint32_t phy_addr, int onOff) 
+{
+  uint32_t   val = onOff ? 1<<8 : 0;	  
+  vsc8601_phy_mii_rmw_ctrl(unit, phy_addr, 1<<8, val);
+}
+
+/* IEEE GIGE extended control */
+
+CEXTERN void 
+vsc8601_phy_set_gige_test_normal(int unit, uint32_t phy_addr) 
+{
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 7<<13, 0<<13);
+}
+
+CEXTERN void 
+vsc8601_phy_set_gige_test_waveform(int unit, uint32_t phy_addr) 
+{
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 7<<13, 1<<13);
+}
+
+CEXTERN void 
+vsc8601_phy_set_gige_test_jitter_master(int unit, uint32_t phy_addr) 
+{
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 7<<13, 2<<13);
+}
+
+CEXTERN void 
+vsc8601_phy_set_gige_test_jitter_slave(int unit, uint32_t phy_addr) 
+{
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 7<<13, 3<<13);
+}
+
+CEXTERN void 
+vsc8601_phy_set_gige_test_distortion(int unit, uint32_t phy_addr) 
+{
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 7<<13, 4<<13);
+}
+
+CEXTERN void 
+vsc8601_phy_set_gige_test_master(int unit, uint32_t phy_addr) 
+{
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 3<<11, 3<<11);
+}
+
+CEXTERN void 
+vsc8601_phy_set_gige_test_slave(int unit, uint32_t phy_addr) 
+{
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 3<<11, 2<<11);
+}
+
+CEXTERN void 
+vsc8601_phy_set_gige_multiport(int unit, uint32_t phy_addr, int onOff) 
+{
+  uint32_t   val = onOff ? 1<<10 : 0;	  
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 1<<10, val);
+}
+
+#if 0
+CEXTERN uint16_t
+vsc8601_phy_get_speed(uint16_t unit, uint16_t phy_addr)
+{
+  uint16_t speed = (vsc8601_phy_read_aux_ctrl_status(unit, phy_addr) >> 3) & 3;
+  
+  switch(speed) {
+  case 0:
+    return AG7100_PHY_SPEED_10T;
+  case 1:
+    return AG7100_PHY_SPEED_100TX;
+  case 2:
+    return AG7100_PHY_SPEED_1000T;
+  default:
+    generic_printk("ERROR: Unkown speed read!\n");
+    return 0;
+  }
+}
+#endif
+
+static void 
+vsc8601_phy_setup_generic(uint16_t unit, uint16_t phy_addr)
+{
+  vsc8601_phy_mii_set_duplex(unit, phy_addr, 1);
+#ifdef CONFIG_AR9100
+  ag7100_mii_write(unit, phy_addr, 0x1f,  0x1);
+  ag7100_mii_write(unit, phy_addr, 0x1c,  0x3000);
+  ag7100_mii_write(unit, phy_addr, 0x1f,  0x0);
+#endif
+}
+
+static void 
+vsc8601_phy_setup_vsc8601_Rev_A(uint16_t unit, uint16_t phy_addr)
+{
+  uint16_t uu;
+  
+  /* Weird patch in vsc86-1 datasheet Errata */
+  
+  ag7100_mii_write(unit, phy_addr, 31, 0x52b5);
+
+  ag7100_mii_write(unit, phy_addr, 16, 0xaf8a);
+  
+  uu=ag7100_mii_read(unit, phy_addr, 18);
+  ag7100_mii_write(unit, phy_addr, 18, uu);
+
+  uu=ag7100_mii_read(unit, phy_addr, 17);
+  uu&=~0x000c;
+  uu|= 0x0008;
+  ag7100_mii_write(unit, phy_addr, 17, uu);
+
+  ag7100_mii_write(unit, phy_addr, 16, 0x8f8a);
+
+  ag7100_mii_write(unit, phy_addr, 16, 0xaf86);
+
+  uu=ag7100_mii_read(unit, phy_addr, 18);
+  uu&=~0x000c;
+  uu|= 0x0008;
+  ag7100_mii_write(unit, phy_addr, 18, uu);
+
+  uu=ag7100_mii_read(unit, phy_addr, 17);
+  ag7100_mii_write(unit, phy_addr, 17, uu);
+
+  ag7100_mii_write(unit, phy_addr, 16, 0x8f86);
+
+  ag7100_mii_write(unit, phy_addr, 16, 0xaf82);
+
+  uu=ag7100_mii_read(unit, phy_addr, 18);
+  ag7100_mii_write(unit, phy_addr, 18, uu);
+
+  uu=ag7100_mii_read(unit, phy_addr, 17);
+  uu&=~0x0180;
+  uu|= 0x0100;
+  ag7100_mii_write(unit, phy_addr, 17, uu);
+
+  ag7100_mii_write(unit, phy_addr, 16, 0x8f82);
+
+  ag7100_mii_write(unit, phy_addr, 31, 0);
+
+  /* Skew stuff */
+  vsc8601_phy_rmw_ex_crtl_set_1(unit, phy_addr, 1<<8, 1<<8);
+}
+
+static void 
+vsc8601_phy_setup_vsc8601_Rev_B(uint16_t unit, uint16_t phy_addr)
+{
+  vsc8601_phy_mii_set_duplex(unit, phy_addr, 1);
+#ifdef CONFIG_AR9100
+  vsc8601_phy_rmw_ex_crtl_set_1(unit, phy_addr, 1<<8, 1<<8);
+#endif
+}
+
+CEXTERN int
+vsc8601_phy_discover_and_setup_phy(int unit)
+{
+  uint16_t phy_addr;
+  uint16_t unit_cnt;  
+
+  unit_cnt=0;
+  nmbr_phys=0;
+
+  for (phy_addr=0; phy_addr<31; phy_addr++) {
+
+    uint16_t id1 = vsc8601_phy_mii_read_id1(unit, phy_addr);
+    uint32_t id2 = vsc8601_phy_mii_read_id2(unit, phy_addr);
+    uint32_t id  = id1<<16 | id2;
+
+    uint32_t id_sav = 0;
+    uint16_t phy_status = 0;
+    
+    if (id1 > 0 && id1 < 0x7ff) {
+      vsc8601_phy_mii_soft_reset( unit, phy_addr );
+      phy_status=vsc8601_phy_mii_read_mode_status(unit, phy_addr);
+#ifndef COMPRESSED_UBOOT   
+      generic_printk(" VSCXXX Found %d  unit %d:%d  phy_addr: %d  id: %08x\n",
+		     nmbr_phys, unit, unit_cnt, phy_addr, id);
+#endif      
+      phy_info[nmbr_phys].id=id;
+      phy_info[nmbr_phys].phy_addr=phy_addr;
+      phy_info[nmbr_phys].mac_unit=unit_cnt;
+      phy_info[nmbr_phys].is_enet_port=0;
+
+      if (id != id_sav) {
+	switch(id) {
+	case 0x00070420:
+#ifndef COMPRESSED_UBOOT   
+	  generic_printk(" PHY is Vitesse VSC8601 Rev A\n");
+#endif
+	  vsc8601_phy_setup_vsc8601_Rev_A(unit, phy_addr);
+	  vsc8601_phy_setup_generic(unit, phy_addr);
+	  phy_info[nmbr_phys].is_enet_port=1;
+	  unit_cnt++;
+	  break;
+
+	case 0x00070421:
+#ifndef COMPRESSED_UBOOT   
+	  generic_printk(" PHY is Vitesse VSC8601 Rev B\n");
+#endif
+	  vsc8601_phy_setup_vsc8601_Rev_B(unit, phy_addr);
+	  vsc8601_phy_setup_generic(unit, phy_addr);
+	  phy_info[nmbr_phys].is_enet_port=1;
+	  unit_cnt++;
+	  break;
+
+	case 0x000fc413:
+#ifndef COMPRESSED_UBOOT   
+	  generic_printk(" PHY is Vitesse VSC8201 Phy\n");
+#endif
+	  vsc8601_phy_setup_generic(unit, phy_addr);
+	  phy_info[nmbr_phys].is_enet_port=1;
+	  unit_cnt++;
+	  break;
+
+        case 0x02430d80:
+#ifndef COMPRESSED_UBOOT   
+          generic_printk(" PHY is ICPlus IP175B Switch\n");
+#endif
+          vsc8601_phy_setup_generic(unit, phy_addr);
+          phy_info[nmbr_phys].is_enet_port=1;
+          unit_cnt++;
+          break;
+	  
+	default:
+#ifndef COMPRESSED_UBOOT   
+	  generic_printk(" PHY is unknown, using generic IEEE interface\n");
+#endif
+	  vsc8601_phy_setup_generic(unit, phy_addr);
+	  phy_info[nmbr_phys].is_enet_port=1;
+	  unit_cnt++;
+	  break;
+	}
+	id_sav=id;
+      }
+      nmbr_phys++;
+    }
+  }
+  if (nmbr_phys == 0) {
+    generic_printk(" ERROR: No PHY IDs found \n");
+    return 1;
+  }
+  if (unit_cnt == 0) {
+    generic_printk(" ERROR: No PHY IDs assigned to unit\n");
+    return 1;
+  }
+  return 0;
+}
+
+#if 0
+CEXTERN int
+vsc8601_phy_print_status(uint16_t unit, uint16_t phy_addr)
+{ 
+
+#if ( VERBOSE > 1 )
+
+  /* Generic IEEE */
+
+  uint16_t mc  = vsc8601_phy_mii_read_mode_ctrl            (unit, phy_addr);
+  uint16_t ms  = vsc8601_phy_mii_read_mode_status          (unit, phy_addr);
+  uint16_t id1 = vsc8601_phy_mii_read_id1                  (unit, phy_addr);
+  uint32_t id2 = vsc8601_phy_mii_read_id2                  (unit, phy_addr);
+  uint32_t id  = id1<<16 | id2;
+  uint16_t rec = vsc8601_phy_read_rx_error_count           (unit, phy_addr);
+  uint16_t fcc = vsc8601_phy_read_false_carrier_count      (unit, phy_addr);
+  uint16_t dc  = vsc8601_phy_read_disconnect_count         (unit, phy_addr);
+  uint16_t cs1 = vsc8601_phy_read_ex_crtl_set_1            (unit, phy_addr);
+  uint16_t cs2 = vsc8601_phy_read_ex_crtl_set_2            (unit, phy_addr);
+  uint16_t im  = vsc8601_phy_read_irq_msk                  (unit, phy_addr);
+  uint16_t is  = vsc8601_phy_read_irq_status               (unit, phy_addr);
+  uint16_t acs = vsc8601_phy_read_aux_ctrl_status          (unit, phy_addr);
+  uint16_t dss = vsc8601_phy_read_delay_skew_status        (unit, phy_addr);
+
+  generic_printk("VSCXXX unit %d  phy_addr %d\n", unit, phy_addr);
+  vsc8601_phy_mii_print_mode_ctrl(mc);
+  vsc8601_phy_mii_print_mode_status(ms);
+  generic_printk("  id1             (02 )=%02x\n", id1 & 0xff);
+  generic_printk("  id2             (03 )=%02x\n", id2 & 0xff);
+  generic_printk("  rcv-error       (19 )=%04x\n", rec & 0xff);
+  generic_printk("  false-carrier   (20 )=%04x\n", fcc & 0xff);
+  generic_printk("  disconnect_cnt  (21 )=%04x\n", dc  & 0xff);
+  vsc8601_phy_mii_print_ex_ctrl_set_1(cs1);
+
+  generic_printk("  ex_crtl_set_2   (24 )=%04x\n", cs2);
+  generic_printk("  irq_msk         (25 )=%04x\n", im);
+  vsc8601_phy_mii_print_irq_status(is);
+  vsc8601_phy_mii_print_aux_ctrl_status(acs);
+  vsc8601_phy_mii_print_delay_skew_status(dss);
+ 
+  /* Chip specific */
+
+  switch( id ) {
+  case 0x00070420:
+    {
+      uint16_t cgc = vsc8601_phy_read_crc_good_counter         (unit, phy_addr);
+      uint16_t mcr = vsc8601_phy_read_mac_resistor_calibration (unit, phy_addr);
+      uint16_t cs5 = vsc8601_phy_read_ex_crtl_set_5            (unit, phy_addr);
+      uint16_t skc = vsc8601_phy_read_skew_ctrl                (unit, phy_addr);
+      uint16_t ep1 = vsc8601_phy_read_epg_1                    (unit, phy_addr);
+      uint16_t ep2 = vsc8601_phy_read_epg_1                    (unit, phy_addr);
+      
+      generic_printk("  crc_good        (18E)=%04x\n", cgc);
+      generic_printk("  resistor        (19E)=%04x\n", mcr);
+      vsc8601_phy_mii_print_ex_crtl_set_5(cs5);
+      vsc8601_phy_mii_print_skew_ctrl(skc);
+      generic_printk("  epg_1           (29E)=%04x\n", ep1);
+      generic_printk("  epg_2           (30E)=%04x\n", ep2);
+    }
+    break;
+  }
+
+  /* Speed specific */
+
+  switch(vsc8601_phy_get_speed(unit, phy_addr)) {
+  case AG7100_PHY_SPEED_10T:
+    generic_printk("  * current speed 10 base-t\n");
+    break;
+    
+  case AG7100_PHY_SPEED_100TX:
+    {
+      uint16_t es = vsc8601_phy_read_100_status_ex (unit, phy_addr);
+      vsc8601_phy_mii_print_100_status_ex(es);
+      generic_printk("  * current speed 100 base-t\n");
+    }
+    break;
+    
+  case AG7100_PHY_SPEED_1000T:
+    {
+      uint16_t gc  = vsc8601_phy_mii_read_gige_ctrl     (unit, phy_addr);
+      uint16_t gs  = vsc8601_phy_read_gige_status       (unit, phy_addr);
+      uint16_t gs2 = vsc8601_phy_read_gige_status_ex_2  (unit, phy_addr);
+      
+      vsc8601_phy_mii_print_gige_ctrl(gc);
+      vsc8601_phy_mii_print_gige_status(gs);
+      vsc8601_phy_mii_print_gige_status_ex_2(gs2);
+
+      generic_printk("  * current speed gige\n");
+    }
+    break;
+    
+  default:
+    generic_printk("  * current speed unknown\n");
+    break;
+  }
+  generic_printk("\n");
+
+#else
+#if ( VERBOSE > 0 )
+
+  uint16_t ms  = vsc8601_phy_mii_read_mode_status     (unit, phy_addr);
+  uint16_t mc  = vsc8601_phy_mii_read_mode_ctrl       (unit, phy_addr);
+  uint16_t rec = vsc8601_phy_read_rx_error_count      (unit, phy_addr);
+  uint16_t fcc = vsc8601_phy_read_false_carrier_count (unit, phy_addr);
+  uint16_t dc  = vsc8601_phy_read_disconnect_count    (unit, phy_addr);
+  
+  generic_printk("VSCXXX unit %d  phy_addr %d\n", unit, phy_addr);
+  vsc8601_phy_mii_print_mode_ctrl(mc);
+  vsc8601_phy_mii_print_mode_status(ms);
+  generic_printk("  rcv-error       (19 )=%04x\n", rec & 0xff);
+  generic_printk("  false-carrier   (20 )=%04x\n", fcc & 0xff);
+  generic_printk("  disconnect_cnt  (21 )=%04x\n", dc  & 0xff);
+
+#else
+
+  uint16_t ms  = vsc8601_phy_mii_read_mode_status     (unit, phy_addr);
+  generic_printk("VSCXXX unit %d  phy_addr %d\n", unit, phy_addr);
+  vsc8601_phy_mii_print_mode_status(ms);
+
+#endif
+#endif
+
+  return 0;
+}
+#endif
+
+/* ***********************************************************
+ *
+ * These are exported for use by ag7100_phy.h
+ *
+ * *********************************************************** */
+
+int 
+vsc8601_phy_setup(int unit)
+{
+  int ii;
+  vsc8601_phy_t *phy;
+
+  if (vsc8601_phy_discover_and_setup_phy(unit))
+    return -1;
+
+#if 0
+  for (ii = 0; ii < sizeof(phy_info)/sizeof(phy_info[0]); ii++) {
+    phy = &phy_info[ii];
+    if (phy->is_enet_port && (phy->mac_unit == unit))
+      vsc8601_phy_print_status(phy->mac_unit, phy->phy_addr);
+  }
+#endif
+  return 0;
+}
+
+#if 0
+unsigned int 
+vsc8601_phy_get_link_status(int unit, int *link, int *fdx, int *speed, unsigned int *cfg)
+{
+  unsigned short ms;
+  unsigned short acs;
+  unsigned int   tc;
+  vsc8601_phy_t *phy = vsc8601_phy_find(unit);
+
+  if (!phy)
+    return 0;
+  
+  ms = vsc8601_phy_mii_read_mode_status (unit, phy->phy_addr);
+  
+  if (link) *link   = (ms & 1<<2) > 0;
+  if (speed) *speed = vsc8601_phy_get_speed(unit, phy->phy_addr);
+  if (fdx) {
+    acs = vsc8601_phy_read_aux_ctrl_status(unit, phy->phy_addr);
+    *fdx = (acs & 1<<5) > 0;
+  }
+  tc = phy->status != ms;
+  phy->status = ms;
+  
+#if VERBOSE > 0
+  if (tc)
+    vsc8601_phy_print_status(unit, phy->phy_addr);
+#endif
+
+  if (cfg) 
+    *cfg=tc;
+
+  return tc;
+}
+#endif
diff --git a/board/ar7100/common/vsc8601_phy.h b/board/ar7100/common/vsc8601_phy.h
new file mode 100644
index 0000000000..fe3b2d254e
--- /dev/null
+++ b/board/ar7100/common/vsc8601_phy.h
@@ -0,0 +1,19 @@
+/* vsc8601.h
+ *
+ * History:
+ * Jan 14, 2007 wclewis ready common BDI/ECOS/Linux
+ */
+
+#ifndef _VSC8601_PHY_H
+#define _VSC8601_PHY_H
+
+#ifndef CEXTERN
+#define  CEXTERN static inline
+#endif
+
+int vsc8601_phy_setup(int unit);
+
+unsigned int 
+vsc8601_phy_get_link_status(int unit, int *link, int *fdx, int *speed, unsigned int *cfg);
+
+#endif
diff --git a/board/ar7100/common/vsc_phy.c b/board/ar7100/common/vsc_phy.c
new file mode 100644
index 0000000000..4cde4da6d5
--- /dev/null
+++ b/board/ar7100/common/vsc_phy.c
@@ -0,0 +1,15 @@
+#include <config.h>
+#include "phy.h"
+
+void
+vsc_phy_setup(int unit)
+{
+    phy_reg_write(0, CFG_PHY_ADDR, 0, 0x8000);
+    phy_reg_write(0, CFG_PHY_ADDR, 0x1c, 0x4);
+    phy_reg_write(0, CFG_PHY_ADDR, 0x17, 0x1000);
+    //ag7100_mii_write(0, CFG_PHY_ADDR, 0, 0x2100);
+    phy_reg_write(0, CFG_PHY_ADDR, 31, 0x2a30);
+    phy_reg_write(0, CFG_PHY_ADDR, 8, 0x10);
+    phy_reg_write(0, CFG_PHY_ADDR, 31, 0);
+    phy_reg_write(0, CFG_PHY_ADDR, 0x12, 0x0008);
+}
diff --git a/board/ar7100/pb42/Makefile b/board/ar7100/pb42/Makefile
new file mode 100644
index 0000000000..3bc62362bf
--- /dev/null
+++ b/board/ar7100/pb42/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7100_flash.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7100/pb42/config.mk b/board/ar7100/pb42/config.mk
new file mode 100755
index 0000000000..3c410579c0
--- /dev/null
+++ b/board/ar7100/pb42/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0xa1000000
diff --git a/board/ar7100/pb42/flash.c b/board/ar7100/pb42/flash.c
new file mode 100644
index 0000000000..3938034829
--- /dev/null
+++ b/board/ar7100/pb42/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = 8*1024*1024; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7100/pb42/pb42.c b/board/ar7100/pb42/pb42.c
new file mode 100644
index 0000000000..eb41abf5ff
--- /dev/null
+++ b/board/ar7100/pb42/pb42.c
@@ -0,0 +1,72 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include "ar7100_soc.h"
+
+int
+ar7100_mem_config()
+{
+    uint32_t  ddr_config, ddr_config2;
+    ar7100_ddr_width_t width;
+
+    ar7100_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+#if 0
+    ar7100_ddr_tap_config();
+#else
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL0, 0x7);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL1, 0x7);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL2, 0x7);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL3, 0x7);
+#endif
+#if 0
+    ddr_config   = ar7100_reg_rd(AR7100_DDR_CONFIG);
+    ddr_config2  = ar7100_reg_rd(AR7100_DDR_CONFIG2);
+    width        = ar7100_ddr_get_width();
+
+    if (width != AR7100_DDR_32B)
+        ddr_config |= AR7100_DDR_CONFIG_16BIT;
+    if (width == AR7100_DDR_16B_HIGH)
+        ddr_config2 &= ~AR7100_DDR_CONFIG2_HALF_WIDTH_L;
+
+    ddr_config2 &= ~((0x1f << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                     (0x1f << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                      0xf);
+
+    ddr_config2 |= ((CFG_DDR_TRTW_VAL << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                    (CFG_DDR_TWTR_VAL << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                    AR7100_DDR_CONFIG2_BL2);
+    /*
+     * XXX These bits are reserved...
+     */
+    ddr_config2 |= (1 << 26)|(1 << 27)|(1 << 30);
+
+    printf("programming config1 %#x, config2 %#x\n", ddr_config, ddr_config2);
+
+    ar7100_reg_wr(AR7100_DDR_CONFIG, ddr_config);
+    ar7100_reg_wr(AR7100_DDR_CONFIG2, ddr_config2);
+#endif
+    /* XXX - these don't really belong here! */
+    *(volatile unsigned int *)0xb8050004 = 0x50C0;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+    *(volatile unsigned int *)0xb805001c = 0xee;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050010 = 0x1099;
+    udelay(10);
+
+    return (ar7100_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7100_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("PB42 (ar7100) U-boot\n");
+	return 0;
+}
diff --git a/board/ar7100/pb42/u-boot.lds b/board/ar7100/pb42/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7100/pb42/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/pb44/Makefile b/board/ar7100/pb44/Makefile
new file mode 100644
index 0000000000..9c29251d04
--- /dev/null
+++ b/board/ar7100/pb44/Makefile
@@ -0,0 +1,14 @@
+
+include $(TOPDIR)/config.mk
+LIB = lib$(BOARD).a
+OBJS = $(BOARD).o ../common/ar7100_flash.o ../common/generic_i2c.o ../common/generic_spi.o ../common/vsc73xx.o ../common/vsc8601_phy.o pb44_pci.o
+SOBJS = lowlevel_init.o
+
+$(LIB): .depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+.depend: Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+	$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
diff --git a/board/ar7100/pb44/config.mk b/board/ar7100/pb44/config.mk
new file mode 100644
index 0000000000..58dff26537
--- /dev/null
+++ b/board/ar7100/pb44/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0xbf000000
+else
+TEXT_BASE = 0xbf000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0xa0010000
diff --git a/board/ar7100/pb44/lowlevel_init.S b/board/ar7100/pb44/lowlevel_init.S
new file mode 100755
index 0000000000..d0dd419449
--- /dev/null
+++ b/board/ar7100/pb44/lowlevel_init.S
@@ -0,0 +1,427 @@
+/*****************************************************************************/
+/*! file lowlevel_init.s
+** /brief Low Level initialization routine for AP94
+**    
+**  
+**
+**  Copyright (c) 200x Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7100_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define clear_mask(_reg, _mask)                     \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+#define set_val(_reg, _mask, _val)                  \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t9, _val;                                   \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+#define set_val_reg(_reg, _mask, _valreg)           \
+    li  t7, _reg;                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    or  t8, t8, _valreg;                            \
+    sw  t8, 0(t7)
+
+#define get_val(_reg, _mask, _shift, _res_reg)      \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, _mask;                                  \
+    and t8, t8, t9;                                 \
+    srl _res_reg, t8, _shift                        \
+
+#define pll_clr(_mask)                              \
+    clear_mask(AR7100_CPU_PLL_CONFIG, _mask)
+
+#define pll_set(_mask, _val)                        \
+    set_val(AR7100_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_set_reg(_mask, _reg)                    \
+    set_val_reg(AR7100_CPU_PLL_CONFIG,  _mask, _reg)
+
+#define pll_get(_mask, _shift, _res_reg)            \
+    get_val(AR7100_CPU_PLL_CONFIG, _mask, _shift, _res_reg)
+
+#define clk_clr(_mask)                               \
+    clear_mask(AR7100_CPU_CLOCK_CONTROL, _mask)
+
+#define clk_set(_mask, _val)                         \
+    set_val(AR7100_CPU_CLOCK_CONTROL,  _mask, _val)
+
+#define clk_get(_mask, _shift, _res_reg)              \
+    get_val(AR7100_CPU_CLOCK_CONTROL, _mask, _shift, _res_reg)
+
+#define MEMDELAY(count, reg)	\
+	li	    reg, count;	\
+9:	addi	reg, -1;	\
+	bgtz	reg, 9b;	\
+	nop
+
+
+#define PLL_CONFIG_SW_UPDATE_VAL (1 << 31)
+#define CLOCK_CTRL_SWITCH_VAL (1 << 1)
+
+/* at 16 bytes offset from the beginning of last sector of 8MB flash part */
+#define CFG_FLASH_PLL_SETTING_ADDR  0x1fff0010
+#define AR7100_SPI_CLOCK (AR7100_SPI_BASE + 4)
+
+/* t0 - t5 will have the return results. a0 clobbered */
+get_flash_pll_setting:
+    /* Disable SPI remap */
+    li      a0, KSEG1ADDR(AR7100_SPI_CLOCK)
+    li      t0, 0x43
+    sw      t0, 0(a0)
+
+    /* Now read pll setting fm flash */
+    li      t0, KSEG1ADDR(CFG_FLASH_PLL_SETTING_ADDR)
+    lw      t1, 0(t0)
+
+    /* Enable SPI remap */
+    li      a0, KSEG1ADDR(AR7100_SPI_CLOCK)
+    li      t0, 0x3
+    sw      t0, 0(a0)
+
+    /*
+    ** check the range of values
+    */
+
+    li      t0, CFG_PLL_200_200_100
+    blt     t1, t0, 1f
+    nop
+    li      t0, CFG_PLL_680_340_170
+    ble     t1, t0, 2f
+    nop
+
+1:
+        /* Value is bad use compiled value */
+
+#if (CFG_PLL_FREQ == CFG_PLL_680_340_170)
+    li      t1, CFG_PLL_680_340_170
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+    li      t1, CFG_PLL_400_400_100
+#elif (CFG_PLL_FREQ == CFG_PLL_360_360_180)
+    li      t1, CFG_PLL_360_360_180
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+    li      t1, CFG_PLL_400_400_200
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+    li      t1, CFG_PLL_266_266_66
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+    li      t1, CFG_PLL_266_266_133
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+    li      t1, CFG_PLL_333_333_166
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+    li      t1, CFG_PLL_300_300_150
+#elif (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+    li      t1, CFG_PLL_200_200_100
+#else
+#error: must define CFG_PLL_FREQ
+#endif
+2:
+    li      t2, CFG_PLL_680_340_170
+    beq     t1, t2, pll_680_340_170
+    nop
+    li      t2, CFG_PLL_400_400_100
+    beq     t1, t2, pll_400_400_100
+    nop
+    li      t2, CFG_PLL_360_360_180
+    beq     t1, t2, pll_360_360_180
+    nop
+    li      t2, CFG_PLL_400_400_200
+    beq     t1, t2, pll_400_400_200
+    nop
+    li      t2, CFG_PLL_266_266_66
+    beq     t1, t2, pll_266_266_66
+    nop
+    li      t2, CFG_PLL_266_266_133
+    beq     t1, t2, pll_266_266_133
+    nop
+    li      t2, CFG_PLL_333_333_166
+    beq     t1, t2, pll_333_333_166
+    nop
+    li      t2, CFG_PLL_300_300_150
+    beq     t1, t2, pll_300_300_150
+    nop
+    li      t2, CFG_PLL_200_200_100
+    b       pll_200_200_100
+    nop
+
+pll_680_340_170:
+    li      t0, (0x0  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x1  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x1  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x10 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x0  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x1  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_400_400_100:
+    li      t0, (0x1  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x1  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x1  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_360_360_180:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x1b << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x5  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop     
+
+pll_400_400_200:
+    li      t0, (0x1  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x1  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_266_266_66:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x1  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_266_266_133:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_333_333_166:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x18 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop     
+
+pll_300_300_150:
+    li      t0, (0x3  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x3  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x1d << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x0  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop     
+
+pll_200_200_100:
+    li      t0, (0x3  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x3  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+got_setting:
+    jr ra
+
+
+/******************************************************************************
+ * first level initialization:
+ * 
+ * 0) If clock cntrl reset switch is already set, we're recovering from 
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ * 
+ *****************************************************************************/
+
+.globl lowlevel_init
+
+lowlevel_init:
+
+    /*
+     * The code below is for the real chip. Wont work on FPGA
+     */
+    /* jr ra  */
+
+    clk_get(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CONTROL_RST_SWITCH_SHIFT, t6)
+    bne zero, t6, initialize_pll
+    nop 
+
+#if 1
+    /* store return address to return to caller function */
+    move s0, ra
+    /* regs t0-t5 will have the settings */
+    la   t9, get_flash_pll_setting
+    jalr t9
+    nop
+    /* restore return address */
+    move ra, s0
+    pll_set_reg(PLL_CONFIG_CPU_DIV_MASK, t0)
+    pll_set_reg(PLL_CONFIG_AHB_DIV_MASK, t2)
+    pll_set_reg(PLL_CONFIG_DDR_DIV_MASK, t1)
+    pll_set_reg(PLL_CONFIG_PLL_DIVOUT_MASK, t5)
+
+#else
+    pll_set(PLL_CONFIG_CPU_DIV_MASK,    PLL_CONFIG_CPU_DIV_VAL)
+    pll_set(PLL_CONFIG_AHB_DIV_MASK,    PLL_CONFIG_AHB_DIV_VAL)
+    pll_set(PLL_CONFIG_DDR_DIV_MASK,    PLL_CONFIG_DDR_DIV_VAL)
+    pll_set(PLL_CONFIG_PLL_DIVOUT_MASK, PLL_CONFIG_PLL_DIVOUT_VAL)
+#endif
+
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+
+    /*
+     * Will cause a reset
+     */
+    clk_set(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CTRL_SWITCH_VAL)
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+    
+initialize_pll:
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+    clk_clr(CLOCK_CONTROL_RST_SWITCH_MASK)
+#if 1
+    pll_set_reg(PLL_CONFIG_PLL_FB_MASK, t3)
+    pll_set_reg(PLL_CONFIG_PLL_LOOP_BW_MASK, t4)
+#else
+    pll_set(PLL_CONFIG_PLL_FB_MASK, PLL_CONFIG_PLL_FB_VAL)
+    pll_set(PLL_CONFIG_PLL_LOOP_BW_MASK, PLL_CONFIG_PLL_LOOP_BW_VAL)
+#endif
+
+    pll_clr(PLL_CONFIG_PLL_POWER_DOWN_MASK);
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK);
+
+wait_for_pll_lock:
+    pll_get(PLL_CONFIG_LOCKED_MASK, PLL_CONFIG_LOCKED_SHIFT, t6)
+    beq zero, t6, wait_for_pll_lock
+    nop 
+
+
+pll_locked:
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+    
+    /*
+    ** Now, time to initialize memory.  We'll do the early initialization here
+    ** (taken directly from Redboot), and the later initialization will not be
+    ** performed.  Better all around.
+    **
+    ** Since AP-94 is a fixed design, we'll ensure the config value has the correct
+    ** CAS latency.
+    */
+    
+    li      a0, KSEG1ADDR(AR7100_DDR_CONFIG)
+	li	    t0, CFG_DDR_CONFIG_VAL
+	sw	    t0, 0(a0)
+	nop
+    
+    /*
+    ** Load all other values
+    */
+
+	li      a1, KSEG1ADDR(AR7100_DDR_CONFIG2)
+	li	    t8, CFG_DDR_CONFIG2_VAL
+	sw	    t8, 0(a1)
+    MEMDELAY(30, t2)
+    
+    /*
+    ** Setting the mode register
+    */
+    
+    li      a0, KSEG1ADDR(AR7100_DDR_CONTROL)
+    li      a1, KSEG1ADDR(AR7100_DDR_EXT_MODE)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, CFG_DDR_EXT_MODE_VAL
+    sw      t5, 0(a1)
+    MEMDELAY(30, t2)
+
+    li      t5, 2
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+	/*
+    **  Want to set the mode value.  since AP-94 only operates at
+    ** one speed, we don't need to check the speed setting
+    */
+    
+    li      a2, KSEG1ADDR(AR7100_DDR_MODE)
+	li	    t5, CFG_DDR_MODE_VAL
+    sw	    t5, 0(a2)
+	MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    /*
+    ** Setting refresh, data this cycle, and tap words
+    */
+    
+    li      a0, KSEG1ADDR(AR7100_DDR_REFRESH)
+    li      t5, CFG_DDR_REFRESH_VAL
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      a2, KSEG1ADDR(AR7100_DDR_RD_DATA_THIS_CYCLE)
+	li	    t5, CFG_DDR_RD_DATA_THIS_CYCLE_VAL
+	sw	    t5, 0(a2)
+	
+    li      a1, 0x07
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL0)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL1)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL2)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL3)
+    sw      a1, 0(a0)
+    nop
+
+    jr ra
+
diff --git a/board/ar7100/pb44/pb44.c b/board/ar7100/pb44/pb44.c
new file mode 100644
index 0000000000..67c50a7dcb
--- /dev/null
+++ b/board/ar7100/pb44/pb44.c
@@ -0,0 +1,234 @@
+/*****************************************************************************/
+/*! file pb44.c
+** /brief Boot support for PB44 board. First version identical to pb45.c
+**    
+**  This provides the support code required for the AP94 board in the U-Boot
+**  environment.  This board is a Hydra based system with two Merlin WLAN
+**  interfaces.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7100_soc.h"
+
+ 
+/******************************************************************************/
+/*!
+**  \brief ar7100_mem_config
+**
+**  This is a "C" level implementation of the memory configuration interface
+**  for the PB44.  
+**
+**  \return RAM size in bytes
+*/
+
+int
+ar7100_mem_config(void)
+{
+
+    /* XXX - should be set based board configuration */
+    *(volatile unsigned int *)0xb8050004 = 0x400050C0;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+    *(volatile unsigned int *)0xb805001c = 0x76; /* 66MHz at 1GHz PLL */
+    udelay(10);
+    *(volatile unsigned int *)0xb8050010 = 0x1099;
+    udelay(10);
+
+    return (ar7100_ddr_find_size());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+long int initdram(int board_type)
+{
+#ifndef COMPRESSED_UBOOT
+    printf("b8050000: 0x%x\n",* (unsigned long *)(0xb8050000));
+#endif /* #ifndef COMPRESSED_UBOOT */
+    return (ar7100_mem_config());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "PB44 (ar7100) U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    unsigned long pll, pll_div, cpu_div, ahb_div, ddr_div, freq;
+
+    printf("PB44 (ar7100) U-boot \n");
+
+    pll = ar7100_reg_rd(AR7100_CPU_PLL_CONFIG);
+
+    pll_div  = ((pll & PLL_CONFIG_PLL_FB_MASK) >> PLL_CONFIG_PLL_FB_SHIFT) + 1;
+    freq     = pll_div * 40;
+    cpu_div  = ((pll & PLL_CONFIG_CPU_DIV_MASK) >> PLL_CONFIG_CPU_DIV_SHIFT) + 1;
+    ddr_div  = ((pll & PLL_CONFIG_DDR_DIV_MASK) >> PLL_CONFIG_DDR_DIV_SHIFT) + 1;
+    ahb_div  = (((pll & PLL_CONFIG_AHB_DIV_MASK) >> PLL_CONFIG_AHB_DIV_SHIFT) + 1)*2;
+
+    printf("Frequency: CPU %d MHz, DDR %d MHz, AHB %dMHz \n", freq/cpu_div, freq/ddr_div, (freq/cpu_div)/ahb_div);
+
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = 8*1024*1024; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+#ifndef COMPRESSED_UBOOT
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+#endif /* #ifndef COMPRESSED_UBOOT */
+    return (flash_info->size);
+
+}
+
+extern flash_info_t flash_info[];
+
+#if (CONFIG_COMMANDS & CFG_CMD_PLL)
+int do_ar7100_pll (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    char    sectorBuff[65536];
+    int     index;
+
+    /*
+    ** read the flash sector
+    */
+    memcpy(sectorBuff,(void *)BOARDCAL, 65536);
+    if (argc == 1)  {
+        printf("current PLL setting %d\n", sectorBuff[19]);
+        return 0;
+    }
+
+    /*
+    ** Argv[1] contains the value string.  Convert to binary
+    */
+
+    index = simple_strtoul(argv[1],0,10);
+
+    /*
+    ** If the serial number is less than 0, or greater than 8, it's out of range
+    */
+
+    if(index < 0 || index > 8)
+    {
+        printf("index %d out of range\n", index);
+        return 1;
+    }
+
+    /* store a u32 at offset 16. we are on big-endian arch, so ... */
+    sectorBuff[16] = 0;
+    sectorBuff[17] = 0;
+    sectorBuff[18] = 0;
+    sectorBuff[19] = index;
+
+    flash_erase(flash_info,CAL_SECTOR,CAL_SECTOR);
+    write_buff(flash_info,sectorBuff, BOARDCAL, 65536);
+    
+    return 0;
+}
+
+/* N.B.: These values should match CFG_PLL_* values in ar7100.h */
+U_BOOT_CMD(
+    ar7100_pll, 2, 0, do_ar7100_pll,
+    "ar7100_pll - Set CPU/DDR/AHB frequencies\n",
+    "ar7100_pll <index> - Set CPU/DDR/AHB frequencies based on the list below:\n"
+    "\t0 - 200/200/100\n"
+    "\t1 - 300/300/150\n"
+    "\t2 - 333/333/166\n"
+    "\t3 - 266/266/133\n"
+    "\t4 - 266/266/66\n"
+    "\t5 - 400/400/200\n"
+    "\t6 - 360/360/180\n"
+    "\t7 - 400/400/100\n"
+    "\t8 - 680/340/170\n"
+);
+#endif /* #if (CONFIG_COMMANDS & CFG_CMD_PLL) */
+
+#ifdef AG7100_DEBUG
+extern int ag7100_rxdbg;
+int do_rxdbg_ctl (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    uint16_t val;
+    if (argc != 2) {
+        printf("incorrect format\n");
+        return 1;
+    }
+    val = simple_strtoul (argv[1], NULL, 16);
+    if (val) ag7100_rxdbg = 1;
+    else ag7100_rxdbg = 0;
+    return 0;
+}
+U_BOOT_CMD(
+    rxdbg, 2, 0, do_rxdbg_ctl,
+    "rxdbg - 1 to turn on rx pkt prints, 0 to turn off\n",
+    "rxdbg - 1 to turn on rx pkt prints, 0 to turn off\n"
+);
+
+extern int ag7100_txdbg;
+int do_txdbg_ctl (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{   
+    uint16_t val;
+    if (argc != 2) {
+        printf("incorrect format\n");
+        return 1;
+    }
+    val = simple_strtoul (argv[1], NULL, 16);
+    if (val) ag7100_txdbg = 1;
+    else ag7100_txdbg = 0;
+    return 0;
+}
+U_BOOT_CMD(
+    txdbg, 2, 0, do_txdbg_ctl,
+    "txdbg - 1 to turn on rx pkt prints, 0 to turn off\n",
+    "txdbg - 1 to turn on rx pkt prints, 0 to turn off\n"
+);
+
+#endif /* AG7100_DEBUG */
+
diff --git a/board/ar7100/pb44/pb44_pci.c b/board/ar7100/pb44/pb44_pci.c
new file mode 100644
index 0000000000..27e7a4aa4c
--- /dev/null
+++ b/board/ar7100/pb44/pb44_pci.c
@@ -0,0 +1,374 @@
+/*****************************************************************************/
+/*! file ap94_pci.c
+** /brief PCI support for PB45 board derived from AP94. plat_dev_init()
+** is removed as PB45 has two mini-PCI slots and no calibration data in
+** Flash.
+**    
+**  This provides the support code required for PCI support on the PB45
+**  board in the U-Boot environment.  This board is a Hydra based system.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <pci.h>
+#include "ar7100_soc.h"
+
+/*
+** PCI controller "hose" value
+*/
+
+static struct pci_controller hose;
+
+/*
+ * Mask table, bits to mask for quantity of size 1, 2 or 4 bytes.
+ * 0 and 3 are not valid indexes...
+ */
+static uint32_t bytemask[] = {
+	/*0*/	0,
+	/*1*/	0xff,
+	/*2*/	0xffff,
+	/*3*/	0,
+	/*4*/	0xffffffff,
+};
+
+static void crp_read(uint32_t ad_cbe, uint32_t *data);
+static void crp_write(uint32_t ad_cbe, uint32_t data);
+static int  ar7100_check_error(int verbose);
+static int  ar7100_pci_read(uint32_t addr, uint32_t cmd, uint32_t* data);
+static int  ar7100_pci_write(uint32_t addr, uint32_t cmd, uint32_t data);
+static uint32_t ar7100_config_addr(uint8_t bus_num, uint16_t devfn, int where);
+static uint32_t local_byte_lane_enable_bits(uint32_t n, int size);
+static int  ar7100_local_read_config(int where, int size, uint32_t *value);
+static int  ar7100_local_write_config(int where, int size, uint32_t value);
+
+
+/*
+ * Read from PCI config space (host ctrl)
+ */
+static void crp_read(uint32_t ad_cbe, uint32_t *data)
+{
+    ar7100_reg_wr(AR7100_PCI_CRP_AD_CBE, ad_cbe);
+	*data     =  ar7100_reg_rd(AR7100_PCI_CRP_RDDATA);
+}
+
+/*
+ * Write to PCI config space (host ctrl)
+ */
+static void crp_write(uint32_t ad_cbe, uint32_t data)
+{ 
+    ar7100_reg_wr(AR7100_PCI_CRP_AD_CBE, (AR7100_CRP_CMD_WRITE | ad_cbe));
+	ar7100_reg_wr(AR7100_PCI_CRP_WRDATA, data);
+}
+
+
+/*
+ * Check for PCI errors (aborts, parity etc.), for configuration cycles
+ * PCI error reg: 1:0
+ * AHB error reg: 0
+ * Both write-back-1 to clear.
+ */
+static int 
+ar7100_check_error(int verbose)
+{
+    uint32_t error = 0, trouble = 0, status;
+
+    error = ar7100_reg_rd(AR7100_PCI_ERROR) & 3;
+
+    if (error) {
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+
+        if (verbose) {
+            printf("PCI error %d at PCI addr 0x%x status %#x\n", 
+                    error, ar7100_reg_rd(AR7100_PCI_ERROR_ADDRESS),
+                    status);
+        }
+
+        ar7100_reg_wr(AR7100_PCI_ERROR, error);
+        ar7100_local_write_config(PCI_STATUS, 2, status);
+        /*
+         * flush
+         */
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+        trouble = 1;
+    }
+
+    error = 0;
+    error = ar7100_reg_rd(AR7100_PCI_AHB_ERROR) & 1;
+
+    if (error) {
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+
+        if (verbose) {
+            printf("AHB error %d at AHB address 0x%x status %#x\n", 
+                   ar7100_reg_rd(AR7100_PCI_AHB_ERROR_ADDRESS), status);
+        }
+
+        ar7100_reg_wr(AR7100_PCI_AHB_ERROR, error);
+        trouble = 1;
+    }
+
+    return trouble;
+}
+
+static int 
+ar7100_pci_read(uint32_t addr, uint32_t cmd, uint32_t* data)
+{
+	int retval = 0;
+
+    ar7100_reg_wr(AR7100_PCI_CFG_AD, addr);
+    ar7100_reg_wr(AR7100_PCI_CFG_CBE, cmd);
+
+	/* 
+     * the result of the read is now in CFG_RDATA 
+     */
+    if (!ar7100_check_error(0))
+        *data = ar7100_reg_rd(AR7100_PCI_CFG_RDDATA);
+    else {
+        *data = 0xffffffff;
+        retval = 1;
+    }
+
+	return retval;
+}
+
+static int 
+ar7100_pci_write(uint32_t addr, uint32_t cmd, uint32_t data)
+{    
+	int retval = 0;
+
+    ar7100_reg_wr(AR7100_PCI_CFG_AD, addr);
+    ar7100_reg_wr(AR7100_PCI_CFG_CBE, cmd);
+
+	/* 
+     * execute the write by writing to CFG_WDATA 
+     */ 
+    ar7100_reg_wr(AR7100_PCI_CFG_WRDATA, data);
+
+    if (ar7100_check_error(0))
+        retval = 1;
+
+	return retval;
+}
+
+/*
+ * This is assuming idsel of device 0 is connected to Address line 17
+ * Address for type 0 config is as follows:
+ * AD: 
+ *  1:0 00 indicates type zero transaction
+ *  7:2    indicates the target config dword
+ *  10:8   indicates the target function within the physical device
+ *  31:11  are reserved (and most probably used to connect idsels)
+ */
+static uint32_t 
+ar7100_config_addr(uint8_t bus_num, uint16_t devfn, int where)
+{
+	uint32_t addr;
+
+	if (!bus_num) {
+		/* type 0 */
+		addr = (1 << (AR7100_PCI_IDSEL_ADLINE_START + PCI_DEV(devfn))) |
+               ((PCI_FUNC(devfn)) << 8)                                 |
+		       (where & ~3);	
+	} else {
+		/* type 1 */
+		addr = (bus_num << 16) | ((PCI_DEV(devfn)) << 11) | 
+			((PCI_FUNC(devfn)) << 8) | (where & ~3) | 1;
+	}
+
+	return addr;
+}
+
+
+static uint32_t 
+local_byte_lane_enable_bits(uint32_t n, int size)
+{
+	if (size == 1)
+		return (0xf & ~BIT(n)) << 20;
+	if (size == 2)
+		return (0xf & ~(BIT(n) | BIT(n+1))) << 20;
+	if (size == 4)
+		return 0;
+	return 0xffffffff;
+}
+
+static int 
+ar7100_local_read_config(int where, int size, uint32_t *value)
+{ 
+	uint32_t n, data;
+
+	/*printk("ar7100_local_read_config from %d size %d\n", where, size);*/
+	n = where % 4;
+	crp_read(where & ~3, &data);
+	*value = (data >> (8*n)) & bytemask[size];
+	/*printk("ar7100_local_read_config read %#x\n", *value);*/
+
+	return 0;
+}
+
+static int 
+ar7100_local_write_config(int where, int size, uint32_t value)
+{
+	uint32_t n, byte_enables, data;
+
+	n = where % 4;
+	byte_enables = local_byte_lane_enable_bits(n, size);
+	if (byte_enables == 0xffffffff)
+		return -1;
+	data = value << (8*n);
+	crp_write((where & ~3) | byte_enables, data);
+
+	return 0;
+}
+
+
+static int ar7100_pci_read_config(struct pci_controller *hose,
+			      pci_dev_t dev, int offset, u32* value)
+{
+	uint32_t    addr;
+	uint8_t     bus_num = PCI_BUS(dev);
+    uint16_t    devfn = dev & 0xffff;
+    
+
+	addr = ar7100_config_addr(bus_num, devfn, offset);
+	ar7100_pci_read(addr, AR7100_CFG_CMD_READ, value);
+
+	return 0;
+}
+
+
+static int 
+ar7100_pci_write_config(struct pci_controller *hose, pci_dev_t dev, int offset, u32 value)
+{
+	uint32_t    addr;
+	uint8_t     bus_num = PCI_BUS(dev);
+    uint16_t    devfn = dev & 0xffff;
+
+	addr = ar7100_config_addr(bus_num, devfn, offset);
+	ar7100_pci_write(addr, AR7100_CFG_CMD_WRITE, value);
+	return 0;
+}
+
+/******************************************************************************/
+/*!
+**  \brief pci host initialization
+**
+**  Sets up the PCI controller on the host.  For AR7100 this may not be necessary,
+**  but this function is required for board support.
+**
+** We want a 1:1 mapping between PCI and DDR for inbound and outbound.
+** The PCI<---AHB decoding works as follows:
+**
+** 8 registers in the DDR unit provide software configurable 32 bit offsets
+** for each of the eight 16MB PCI windows in the 128MB. The offsets will be 
+** added to any address in the 16MB segment before being sent to the PCI unit.
+**
+** Essentially  for any AHB address generated by the CPU,
+** 1. the MSB  four bits are stripped off, [31:28],
+** 2. Bit 27 is used to decide between the lower 128Mb (PCI) or the rest of 
+**    the AHB space
+** 3. Bits 26:24 are used to access one of the 8 window registers and are 
+**    masked off.
+** 4. If it is a PCI address, then the WINDOW offset in the WINDOW register 
+**    corresponding to the next 3 bits (bit 26:24) is ADDED to the address, 
+**    to generate the address to PCI unit.
+**
+**     eg. CPU address = 0x100000ff
+**         window 0 offset = 0x10000000
+**         This points to lowermost 16MB window in PCI space.
+**         So the resulting address would be 0x000000ff+0x10000000
+**         = 0x100000ff
+**
+**         eg2. CPU address = 0x120000ff
+**         WINDOW 2 offset = 0x12000000
+**         resulting address would be 0x000000ff+0x12000000
+**                         = 0x120000ff 
+**
+** There is no translation for inbound access (PCI device as a master)
+**
+**  \return N/A
+*/
+
+#ifdef COMPRESSED_UBOOT
+int  pci_init_board (void)
+#else
+void pci_init_board (void)
+#endif /* #ifdef COMPRESSED_UBOOT */
+{
+    uint32_t cmd, val;
+
+    ar7100_reg_rmw_set(AR7100_RESET, 
+                      (AR7100_RESET_PCI_BUS|AR7100_RESET_PCI_CORE));
+    udelay(1000 * 1000);
+
+    ar7100_reg_rmw_clear(AR7100_RESET, 
+                      (AR7100_RESET_PCI_BUS|AR7100_RESET_PCI_CORE));
+    udelay(1000 * 1000);
+
+    ar7100_write_pci_window(0);
+    ar7100_write_pci_window(1);
+    ar7100_write_pci_window(2);
+    ar7100_write_pci_window(3);
+    ar7100_write_pci_window(4);
+    ar7100_write_pci_window(5);
+    ar7100_write_pci_window(6);
+    ar7100_write_pci_window(7);
+
+    udelay(1000 * 1000);
+
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+          PCI_COMMAND_PARITY|PCI_COMMAND_SERR|PCI_COMMAND_FAST_BACK;
+
+    ar7100_local_write_config(PCI_COMMAND, 4, cmd);
+
+    /*
+     * clear any lingering errors and register core error IRQ
+     */
+    ar7100_check_error(0);
+    
+#ifndef COMPRESSED_UBOOT
+    /*
+    ** Now, configure for u-boot tools
+    */
+    
+	hose.first_busno = 0;
+	hose.last_busno = 0xff;
+
+	/* System space */
+	pci_set_region( &hose.regions[0],
+		            0x80000000,
+		            0x00000000,
+		            32 * 1024 * 1024,
+		            PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region( &hose.regions[1],
+		            0x10000000,
+		            0x10000000,
+		            128 * 1024 * 1024,
+		            PCI_REGION_MEM);
+
+	hose.region_count = 2;
+
+	pci_register_hose(&hose);
+
+	pci_set_ops(&hose,
+		pci_hose_read_config_byte_via_dword,
+		pci_hose_read_config_word_via_dword,
+		ar7100_pci_read_config,
+		pci_hose_write_config_byte_via_dword,
+		pci_hose_write_config_word_via_dword,
+		ar7100_pci_write_config);
+#else
+    return 0;
+#endif /* #ifndef COMPRESSED_UBOOT */
+}
+
+
diff --git a/board/ar7100/pb44/u-boot-bootstrap.lds b/board/ar7100/pb44/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..2f01270d05
--- /dev/null
+++ b/board/ar7100/pb44/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7100/pb44/u-boot.lds b/board/ar7100/pb44/u-boot.lds
new file mode 100644
index 0000000000..9ac25bead9
--- /dev/null
+++ b/board/ar7100/pb44/u-boot.lds
@@ -0,0 +1,40 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/pb47/Makefile b/board/ar7100/pb47/Makefile
new file mode 100644
index 0000000000..534be3709b
--- /dev/null
+++ b/board/ar7100/pb47/Makefile
@@ -0,0 +1,13 @@
+
+include $(TOPDIR)/config.mk
+LIB = lib$(BOARD).a
+OBJS = $(BOARD).o ../common/ar7100_flash.o ../common/generic_spi.o ../common/athrf1_phy.o pb47_pci.o
+SOBJS = ../common/lowlevel_init.o
+
+$(LIB): .depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+.depend: Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+	$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
diff --git a/board/ar7100/pb47/config.mk b/board/ar7100/pb47/config.mk
new file mode 100644
index 0000000000..4a032b7f0c
--- /dev/null
+++ b/board/ar7100/pb47/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0xa0010000
diff --git a/board/ar7100/pb47/lowlevel_init.S b/board/ar7100/pb47/lowlevel_init.S
new file mode 100755
index 0000000000..d0dd419449
--- /dev/null
+++ b/board/ar7100/pb47/lowlevel_init.S
@@ -0,0 +1,427 @@
+/*****************************************************************************/
+/*! file lowlevel_init.s
+** /brief Low Level initialization routine for AP94
+**    
+**  
+**
+**  Copyright (c) 200x Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7100_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define clear_mask(_reg, _mask)                     \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+#define set_val(_reg, _mask, _val)                  \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t9, _val;                                   \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+#define set_val_reg(_reg, _mask, _valreg)           \
+    li  t7, _reg;                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    or  t8, t8, _valreg;                            \
+    sw  t8, 0(t7)
+
+#define get_val(_reg, _mask, _shift, _res_reg)      \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, _mask;                                  \
+    and t8, t8, t9;                                 \
+    srl _res_reg, t8, _shift                        \
+
+#define pll_clr(_mask)                              \
+    clear_mask(AR7100_CPU_PLL_CONFIG, _mask)
+
+#define pll_set(_mask, _val)                        \
+    set_val(AR7100_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_set_reg(_mask, _reg)                    \
+    set_val_reg(AR7100_CPU_PLL_CONFIG,  _mask, _reg)
+
+#define pll_get(_mask, _shift, _res_reg)            \
+    get_val(AR7100_CPU_PLL_CONFIG, _mask, _shift, _res_reg)
+
+#define clk_clr(_mask)                               \
+    clear_mask(AR7100_CPU_CLOCK_CONTROL, _mask)
+
+#define clk_set(_mask, _val)                         \
+    set_val(AR7100_CPU_CLOCK_CONTROL,  _mask, _val)
+
+#define clk_get(_mask, _shift, _res_reg)              \
+    get_val(AR7100_CPU_CLOCK_CONTROL, _mask, _shift, _res_reg)
+
+#define MEMDELAY(count, reg)	\
+	li	    reg, count;	\
+9:	addi	reg, -1;	\
+	bgtz	reg, 9b;	\
+	nop
+
+
+#define PLL_CONFIG_SW_UPDATE_VAL (1 << 31)
+#define CLOCK_CTRL_SWITCH_VAL (1 << 1)
+
+/* at 16 bytes offset from the beginning of last sector of 8MB flash part */
+#define CFG_FLASH_PLL_SETTING_ADDR  0x1fff0010
+#define AR7100_SPI_CLOCK (AR7100_SPI_BASE + 4)
+
+/* t0 - t5 will have the return results. a0 clobbered */
+get_flash_pll_setting:
+    /* Disable SPI remap */
+    li      a0, KSEG1ADDR(AR7100_SPI_CLOCK)
+    li      t0, 0x43
+    sw      t0, 0(a0)
+
+    /* Now read pll setting fm flash */
+    li      t0, KSEG1ADDR(CFG_FLASH_PLL_SETTING_ADDR)
+    lw      t1, 0(t0)
+
+    /* Enable SPI remap */
+    li      a0, KSEG1ADDR(AR7100_SPI_CLOCK)
+    li      t0, 0x3
+    sw      t0, 0(a0)
+
+    /*
+    ** check the range of values
+    */
+
+    li      t0, CFG_PLL_200_200_100
+    blt     t1, t0, 1f
+    nop
+    li      t0, CFG_PLL_680_340_170
+    ble     t1, t0, 2f
+    nop
+
+1:
+        /* Value is bad use compiled value */
+
+#if (CFG_PLL_FREQ == CFG_PLL_680_340_170)
+    li      t1, CFG_PLL_680_340_170
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+    li      t1, CFG_PLL_400_400_100
+#elif (CFG_PLL_FREQ == CFG_PLL_360_360_180)
+    li      t1, CFG_PLL_360_360_180
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+    li      t1, CFG_PLL_400_400_200
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+    li      t1, CFG_PLL_266_266_66
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+    li      t1, CFG_PLL_266_266_133
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+    li      t1, CFG_PLL_333_333_166
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+    li      t1, CFG_PLL_300_300_150
+#elif (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+    li      t1, CFG_PLL_200_200_100
+#else
+#error: must define CFG_PLL_FREQ
+#endif
+2:
+    li      t2, CFG_PLL_680_340_170
+    beq     t1, t2, pll_680_340_170
+    nop
+    li      t2, CFG_PLL_400_400_100
+    beq     t1, t2, pll_400_400_100
+    nop
+    li      t2, CFG_PLL_360_360_180
+    beq     t1, t2, pll_360_360_180
+    nop
+    li      t2, CFG_PLL_400_400_200
+    beq     t1, t2, pll_400_400_200
+    nop
+    li      t2, CFG_PLL_266_266_66
+    beq     t1, t2, pll_266_266_66
+    nop
+    li      t2, CFG_PLL_266_266_133
+    beq     t1, t2, pll_266_266_133
+    nop
+    li      t2, CFG_PLL_333_333_166
+    beq     t1, t2, pll_333_333_166
+    nop
+    li      t2, CFG_PLL_300_300_150
+    beq     t1, t2, pll_300_300_150
+    nop
+    li      t2, CFG_PLL_200_200_100
+    b       pll_200_200_100
+    nop
+
+pll_680_340_170:
+    li      t0, (0x0  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x1  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x1  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x10 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x0  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x1  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_400_400_100:
+    li      t0, (0x1  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x1  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x1  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_360_360_180:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x1b << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x5  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop     
+
+pll_400_400_200:
+    li      t0, (0x1  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x1  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_266_266_66:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x1  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_266_266_133:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_333_333_166:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x18 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop     
+
+pll_300_300_150:
+    li      t0, (0x3  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x3  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x1d << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x0  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop     
+
+pll_200_200_100:
+    li      t0, (0x3  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x3  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+got_setting:
+    jr ra
+
+
+/******************************************************************************
+ * first level initialization:
+ * 
+ * 0) If clock cntrl reset switch is already set, we're recovering from 
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ * 
+ *****************************************************************************/
+
+.globl lowlevel_init
+
+lowlevel_init:
+
+    /*
+     * The code below is for the real chip. Wont work on FPGA
+     */
+    /* jr ra  */
+
+    clk_get(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CONTROL_RST_SWITCH_SHIFT, t6)
+    bne zero, t6, initialize_pll
+    nop 
+
+#if 1
+    /* store return address to return to caller function */
+    move s0, ra
+    /* regs t0-t5 will have the settings */
+    la   t9, get_flash_pll_setting
+    jalr t9
+    nop
+    /* restore return address */
+    move ra, s0
+    pll_set_reg(PLL_CONFIG_CPU_DIV_MASK, t0)
+    pll_set_reg(PLL_CONFIG_AHB_DIV_MASK, t2)
+    pll_set_reg(PLL_CONFIG_DDR_DIV_MASK, t1)
+    pll_set_reg(PLL_CONFIG_PLL_DIVOUT_MASK, t5)
+
+#else
+    pll_set(PLL_CONFIG_CPU_DIV_MASK,    PLL_CONFIG_CPU_DIV_VAL)
+    pll_set(PLL_CONFIG_AHB_DIV_MASK,    PLL_CONFIG_AHB_DIV_VAL)
+    pll_set(PLL_CONFIG_DDR_DIV_MASK,    PLL_CONFIG_DDR_DIV_VAL)
+    pll_set(PLL_CONFIG_PLL_DIVOUT_MASK, PLL_CONFIG_PLL_DIVOUT_VAL)
+#endif
+
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+
+    /*
+     * Will cause a reset
+     */
+    clk_set(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CTRL_SWITCH_VAL)
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+    
+initialize_pll:
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+    clk_clr(CLOCK_CONTROL_RST_SWITCH_MASK)
+#if 1
+    pll_set_reg(PLL_CONFIG_PLL_FB_MASK, t3)
+    pll_set_reg(PLL_CONFIG_PLL_LOOP_BW_MASK, t4)
+#else
+    pll_set(PLL_CONFIG_PLL_FB_MASK, PLL_CONFIG_PLL_FB_VAL)
+    pll_set(PLL_CONFIG_PLL_LOOP_BW_MASK, PLL_CONFIG_PLL_LOOP_BW_VAL)
+#endif
+
+    pll_clr(PLL_CONFIG_PLL_POWER_DOWN_MASK);
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK);
+
+wait_for_pll_lock:
+    pll_get(PLL_CONFIG_LOCKED_MASK, PLL_CONFIG_LOCKED_SHIFT, t6)
+    beq zero, t6, wait_for_pll_lock
+    nop 
+
+
+pll_locked:
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+    
+    /*
+    ** Now, time to initialize memory.  We'll do the early initialization here
+    ** (taken directly from Redboot), and the later initialization will not be
+    ** performed.  Better all around.
+    **
+    ** Since AP-94 is a fixed design, we'll ensure the config value has the correct
+    ** CAS latency.
+    */
+    
+    li      a0, KSEG1ADDR(AR7100_DDR_CONFIG)
+	li	    t0, CFG_DDR_CONFIG_VAL
+	sw	    t0, 0(a0)
+	nop
+    
+    /*
+    ** Load all other values
+    */
+
+	li      a1, KSEG1ADDR(AR7100_DDR_CONFIG2)
+	li	    t8, CFG_DDR_CONFIG2_VAL
+	sw	    t8, 0(a1)
+    MEMDELAY(30, t2)
+    
+    /*
+    ** Setting the mode register
+    */
+    
+    li      a0, KSEG1ADDR(AR7100_DDR_CONTROL)
+    li      a1, KSEG1ADDR(AR7100_DDR_EXT_MODE)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, CFG_DDR_EXT_MODE_VAL
+    sw      t5, 0(a1)
+    MEMDELAY(30, t2)
+
+    li      t5, 2
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+	/*
+    **  Want to set the mode value.  since AP-94 only operates at
+    ** one speed, we don't need to check the speed setting
+    */
+    
+    li      a2, KSEG1ADDR(AR7100_DDR_MODE)
+	li	    t5, CFG_DDR_MODE_VAL
+    sw	    t5, 0(a2)
+	MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    /*
+    ** Setting refresh, data this cycle, and tap words
+    */
+    
+    li      a0, KSEG1ADDR(AR7100_DDR_REFRESH)
+    li      t5, CFG_DDR_REFRESH_VAL
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      a2, KSEG1ADDR(AR7100_DDR_RD_DATA_THIS_CYCLE)
+	li	    t5, CFG_DDR_RD_DATA_THIS_CYCLE_VAL
+	sw	    t5, 0(a2)
+	
+    li      a1, 0x07
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL0)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL1)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL2)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL3)
+    sw      a1, 0(a0)
+    nop
+
+    jr ra
+
diff --git a/board/ar7100/pb47/pb47.c b/board/ar7100/pb47/pb47.c
new file mode 100644
index 0000000000..5358e84e6f
--- /dev/null
+++ b/board/ar7100/pb47/pb47.c
@@ -0,0 +1,221 @@
+/*****************************************************************************/
+/*! file pb47.c
+** /brief Boot support for PB47 board. First version identical to pb45.c
+**    
+**  This provides the support code required for the AP94 board in the U-Boot
+**  environment.  This board is a Hydra based system with two Merlin WLAN
+**  interfaces.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7100_soc.h"
+
+ 
+/******************************************************************************/
+/*!
+**  \brief ar7100_mem_config
+**
+**  This is a "C" level implementation of the memory configuration interface
+**  for the PB47.  
+**
+**  \return RAM size in bytes
+*/
+
+int
+ar7100_mem_config(void)
+{
+
+    /* XXX - should be set based board configuration */
+    *(volatile unsigned int *)0xb8050004 = 0x400050C0;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+    *(volatile unsigned int *)0xb805001c = 0x76; /* 66MHz at 1GHz PLL */
+    udelay(10);
+    *(volatile unsigned int *)0xb8050010 = 0x1099;
+    udelay(10);
+
+    return (ar7100_ddr_find_size());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+long int initdram(int board_type)
+{
+    printf("b8050000: 0x%x\n",* (unsigned long *)(0xb8050000));
+    return (ar7100_mem_config());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+int checkboard (void)
+{
+    unsigned long pll, pll_div, cpu_div, ahb_div, ddr_div, freq;
+
+    printf("PB47 (ar7100) U-boot \n");
+
+    pll = ar7100_reg_rd(AR7100_CPU_PLL_CONFIG);
+
+    pll_div  = ((pll & PLL_CONFIG_PLL_FB_MASK) >> PLL_CONFIG_PLL_FB_SHIFT) + 1;
+    freq     = pll_div * 40;
+    cpu_div  = ((pll & PLL_CONFIG_CPU_DIV_MASK) >> PLL_CONFIG_CPU_DIV_SHIFT) + 1;
+    ddr_div  = ((pll & PLL_CONFIG_DDR_DIV_MASK) >> PLL_CONFIG_DDR_DIV_SHIFT) + 1;
+    ahb_div  = (((pll & PLL_CONFIG_AHB_DIV_MASK) >> PLL_CONFIG_AHB_DIV_SHIFT) + 1)*2;
+
+    printf("Frequency: CPU %d MHz, DDR %d MHz, AHB %dMHz \n", freq/cpu_div, freq/ddr_div, (freq/cpu_div)/ahb_div);
+
+    return 0;
+}
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = 8*1024*1024; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
+
+extern flash_info_t flash_info[];
+
+int do_ar7100_pll (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    char    sectorBuff[65536];
+    int     index;
+
+    /*
+    ** read the flash sector
+    */
+    memcpy(sectorBuff,(void *)BOARDCAL, 65536);
+    if (argc == 1)  {
+        printf("current PLL setting %d\n", sectorBuff[19]);
+        return 0;
+    }
+
+    /*
+    ** Argv[1] contains the value string.  Convert to binary
+    */
+
+    index = simple_strtoul(argv[1],0,10);
+
+    /*
+    ** If the serial number is less than 0, or greater than 8, it's out of range
+    */
+
+    if(index < 0 || index > 8)
+    {
+        printf("index %d out of range\n", index);
+        return 1;
+    }
+
+    /* store a u32 at offset 16. we are on big-endian arch, so ... */
+    sectorBuff[16] = 0;
+    sectorBuff[17] = 0;
+    sectorBuff[18] = 0;
+    sectorBuff[19] = index;
+
+    flash_erase(flash_info,CAL_SECTOR,CAL_SECTOR);
+    write_buff(flash_info,sectorBuff, BOARDCAL, 65536);
+    
+    return 0;
+}
+
+/* N.B.: These values should match CFG_PLL_* values in ar7100.h */
+U_BOOT_CMD(
+    ar7100_pll, 2, 0, do_ar7100_pll,
+    "ar7100_pll - Set CPU/DDR/AHB frequencies\n",
+    "ar7100_pll <index> - Set CPU/DDR/AHB frequencies based on the list below:\n"
+    "\t0 - 200/200/100\n"
+    "\t1 - 300/300/150\n"
+    "\t2 - 333/333/166\n"
+    "\t3 - 266/266/133\n"
+    "\t4 - 266/266/66\n"
+    "\t5 - 400/400/200\n"
+    "\t6 - 360/360/180\n"
+    "\t7 - 400/400/100\n"
+    "\t8 - 680/340/170\n"
+);
+
+
+#ifdef AG7100_DEBUG
+extern int ag7100_rxdbg;
+int do_rxdbg_ctl (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    uint16_t val;
+    if (argc != 2) {
+        printf("incorrect format\n");
+        return 1;
+    }
+    val = simple_strtoul (argv[1], NULL, 16);
+    if (val) ag7100_rxdbg = 1;
+    else ag7100_rxdbg = 0;
+    return 0;
+}
+U_BOOT_CMD(
+    rxdbg, 2, 0, do_rxdbg_ctl,
+    "rxdbg - 1 to turn on rx pkt prints, 0 to turn off\n",
+    "rxdbg - 1 to turn on rx pkt prints, 0 to turn off\n"
+);
+
+extern int ag7100_txdbg;
+int do_txdbg_ctl (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{   
+    uint16_t val;
+    if (argc != 2) {
+        printf("incorrect format\n");
+        return 1;
+    }
+    val = simple_strtoul (argv[1], NULL, 16);
+    if (val) ag7100_txdbg = 1;
+    else ag7100_txdbg = 0;
+    return 0;
+}
+U_BOOT_CMD(
+    txdbg, 2, 0, do_txdbg_ctl,
+    "txdbg - 1 to turn on rx pkt prints, 0 to turn off\n",
+    "txdbg - 1 to turn on rx pkt prints, 0 to turn off\n"
+);
+
+#endif /* AG7100_DEBUG */
+
diff --git a/board/ar7100/pb47/pb47_pci.c b/board/ar7100/pb47/pb47_pci.c
new file mode 100644
index 0000000000..e648a3d048
--- /dev/null
+++ b/board/ar7100/pb47/pb47_pci.c
@@ -0,0 +1,368 @@
+/*****************************************************************************/
+/*! file ap94_pci.c
+** /brief PCI support for PB45 board derived from AP94. plat_dev_init()
+** is removed as PB45 has two mini-PCI slots and no calibration data in
+** Flash.
+**    
+**  This provides the support code required for PCI support on the PB45
+**  board in the U-Boot environment.  This board is a Hydra based system.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <pci.h>
+#include "ar7100_soc.h"
+
+/*
+** PCI controller "hose" value
+*/
+
+static struct pci_controller hose;
+
+/*
+ * Mask table, bits to mask for quantity of size 1, 2 or 4 bytes.
+ * 0 and 3 are not valid indexes...
+ */
+static uint32_t bytemask[] = {
+	/*0*/	0,
+	/*1*/	0xff,
+	/*2*/	0xffff,
+	/*3*/	0,
+	/*4*/	0xffffffff,
+};
+
+static void crp_read(uint32_t ad_cbe, uint32_t *data);
+static void crp_write(uint32_t ad_cbe, uint32_t data);
+static int  ar7100_check_error(int verbose);
+static int  ar7100_pci_read(uint32_t addr, uint32_t cmd, uint32_t* data);
+static int  ar7100_pci_write(uint32_t addr, uint32_t cmd, uint32_t data);
+static uint32_t ar7100_config_addr(uint8_t bus_num, uint16_t devfn, int where);
+static uint32_t local_byte_lane_enable_bits(uint32_t n, int size);
+static int  ar7100_local_read_config(int where, int size, uint32_t *value);
+static int  ar7100_local_write_config(int where, int size, uint32_t value);
+
+
+/*
+ * Read from PCI config space (host ctrl)
+ */
+static void crp_read(uint32_t ad_cbe, uint32_t *data)
+{
+    ar7100_reg_wr(AR7100_PCI_CRP_AD_CBE, ad_cbe);
+	*data     =  ar7100_reg_rd(AR7100_PCI_CRP_RDDATA);
+}
+
+/*
+ * Write to PCI config space (host ctrl)
+ */
+static void crp_write(uint32_t ad_cbe, uint32_t data)
+{ 
+    ar7100_reg_wr(AR7100_PCI_CRP_AD_CBE, (AR7100_CRP_CMD_WRITE | ad_cbe));
+	ar7100_reg_wr(AR7100_PCI_CRP_WRDATA, data);
+}
+
+
+/*
+ * Check for PCI errors (aborts, parity etc.), for configuration cycles
+ * PCI error reg: 1:0
+ * AHB error reg: 0
+ * Both write-back-1 to clear.
+ */
+static int 
+ar7100_check_error(int verbose)
+{
+    uint32_t error = 0, trouble = 0, status;
+
+    error = ar7100_reg_rd(AR7100_PCI_ERROR) & 3;
+
+    if (error) {
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+
+        if (verbose) {
+            printf("PCI error %d at PCI addr 0x%x status %#x\n", 
+                    error, ar7100_reg_rd(AR7100_PCI_ERROR_ADDRESS),
+                    status);
+        }
+
+        ar7100_reg_wr(AR7100_PCI_ERROR, error);
+        ar7100_local_write_config(PCI_STATUS, 2, status);
+        /*
+         * flush
+         */
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+        trouble = 1;
+    }
+
+    error = 0;
+    error = ar7100_reg_rd(AR7100_PCI_AHB_ERROR) & 1;
+
+    if (error) {
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+
+        if (verbose) {
+            printf("AHB error %d at AHB address 0x%x status %#x\n", 
+                   ar7100_reg_rd(AR7100_PCI_AHB_ERROR_ADDRESS), status);
+        }
+
+        ar7100_reg_wr(AR7100_PCI_AHB_ERROR, error);
+        trouble = 1;
+    }
+
+    return trouble;
+}
+
+static int 
+ar7100_pci_read(uint32_t addr, uint32_t cmd, uint32_t* data)
+{
+	int retval = 0;
+
+    ar7100_reg_wr(AR7100_PCI_CFG_AD, addr);
+    ar7100_reg_wr(AR7100_PCI_CFG_CBE, cmd);
+
+	/* 
+     * the result of the read is now in CFG_RDATA 
+     */
+    if (!ar7100_check_error(0))
+        *data = ar7100_reg_rd(AR7100_PCI_CFG_RDDATA);
+    else {
+        *data = 0xffffffff;
+        retval = 1;
+    }
+
+	return retval;
+}
+
+static int 
+ar7100_pci_write(uint32_t addr, uint32_t cmd, uint32_t data)
+{    
+	int retval = 0;
+
+    ar7100_reg_wr(AR7100_PCI_CFG_AD, addr);
+    ar7100_reg_wr(AR7100_PCI_CFG_CBE, cmd);
+
+	/* 
+     * execute the write by writing to CFG_WDATA 
+     */ 
+    ar7100_reg_wr(AR7100_PCI_CFG_WRDATA, data);
+
+    if (ar7100_check_error(0))
+        retval = 1;
+
+	return retval;
+}
+
+/*
+ * This is assuming idsel of device 0 is connected to Address line 17
+ * Address for type 0 config is as follows:
+ * AD: 
+ *  1:0 00 indicates type zero transaction
+ *  7:2    indicates the target config dword
+ *  10:8   indicates the target function within the physical device
+ *  31:11  are reserved (and most probably used to connect idsels)
+ */
+static uint32_t 
+ar7100_config_addr(uint8_t bus_num, uint16_t devfn, int where)
+{
+	uint32_t addr;
+
+	if (!bus_num) {
+		/* type 0 */
+		addr = (1 << (AR7100_PCI_IDSEL_ADLINE_START + PCI_DEV(devfn))) |
+               ((PCI_FUNC(devfn)) << 8)                                 |
+		       (where & ~3);	
+	} else {
+		/* type 1 */
+		addr = (bus_num << 16) | ((PCI_DEV(devfn)) << 11) | 
+			((PCI_FUNC(devfn)) << 8) | (where & ~3) | 1;
+	}
+
+	return addr;
+}
+
+
+static uint32_t 
+local_byte_lane_enable_bits(uint32_t n, int size)
+{
+	if (size == 1)
+		return (0xf & ~BIT(n)) << 20;
+	if (size == 2)
+		return (0xf & ~(BIT(n) | BIT(n+1))) << 20;
+	if (size == 4)
+		return 0;
+	return 0xffffffff;
+}
+
+static int 
+ar7100_local_read_config(int where, int size, uint32_t *value)
+{ 
+	uint32_t n, data;
+
+	/*printk("ar7100_local_read_config from %d size %d\n", where, size);*/
+	n = where % 4;
+	crp_read(where & ~3, &data);
+	*value = (data >> (8*n)) & bytemask[size];
+	/*printk("ar7100_local_read_config read %#x\n", *value);*/
+
+	return 0;
+}
+
+static int 
+ar7100_local_write_config(int where, int size, uint32_t value)
+{
+	uint32_t n, byte_enables, data;
+
+	n = where % 4;
+	byte_enables = local_byte_lane_enable_bits(n, size);
+	if (byte_enables == 0xffffffff)
+		return -1;
+	data = value << (8*n);
+	crp_write((where & ~3) | byte_enables, data);
+
+	return 0;
+}
+
+
+static int ar7100_pci_read_config(struct pci_controller *hose,
+			      pci_dev_t dev, int offset, u32* value)
+{
+	uint32_t    addr;
+	uint8_t     bus_num = PCI_BUS(dev);
+    uint16_t    devfn = dev & 0xffff;
+    
+
+	addr = ar7100_config_addr(bus_num, devfn, offset);
+	ar7100_pci_read(addr, AR7100_CFG_CMD_READ, value);
+
+	return 0;
+}
+
+
+static int 
+ar7100_pci_write_config(struct pci_controller *hose, pci_dev_t dev, int offset, u32 value)
+{
+	uint32_t    addr;
+	uint8_t     bus_num = PCI_BUS(dev);
+    uint16_t    devfn = dev & 0xffff;
+
+	addr = ar7100_config_addr(bus_num, devfn, offset);
+	ar7100_pci_write(addr, AR7100_CFG_CMD_WRITE, value);
+	return 0;
+}
+
+/******************************************************************************/
+/*!
+**  \brief pci host initialization
+**
+**  Sets up the PCI controller on the host.  For AR7100 this may not be necessary,
+**  but this function is required for board support.
+**
+** We want a 1:1 mapping between PCI and DDR for inbound and outbound.
+** The PCI<---AHB decoding works as follows:
+**
+** 8 registers in the DDR unit provide software configurable 32 bit offsets
+** for each of the eight 16MB PCI windows in the 128MB. The offsets will be 
+** added to any address in the 16MB segment before being sent to the PCI unit.
+**
+** Essentially  for any AHB address generated by the CPU,
+** 1. the MSB  four bits are stripped off, [31:28],
+** 2. Bit 27 is used to decide between the lower 128Mb (PCI) or the rest of 
+**    the AHB space
+** 3. Bits 26:24 are used to access one of the 8 window registers and are 
+**    masked off.
+** 4. If it is a PCI address, then the WINDOW offset in the WINDOW register 
+**    corresponding to the next 3 bits (bit 26:24) is ADDED to the address, 
+**    to generate the address to PCI unit.
+**
+**     eg. CPU address = 0x100000ff
+**         window 0 offset = 0x10000000
+**         This points to lowermost 16MB window in PCI space.
+**         So the resulting address would be 0x000000ff+0x10000000
+**         = 0x100000ff
+**
+**         eg2. CPU address = 0x120000ff
+**         WINDOW 2 offset = 0x12000000
+**         resulting address would be 0x000000ff+0x12000000
+**                         = 0x120000ff 
+**
+** There is no translation for inbound access (PCI device as a master)
+**
+**  \return N/A
+*/
+
+void pci_init_board (void)
+{
+    uint32_t cmd, val;
+
+    ar7100_reg_rmw_set(AR7100_RESET, 
+                      (AR7100_RESET_PCI_BUS|AR7100_RESET_PCI_CORE));
+    udelay(1000 * 1000);
+
+    ar7100_reg_rmw_clear(AR7100_RESET, 
+                      (AR7100_RESET_PCI_BUS|AR7100_RESET_PCI_CORE));
+    udelay(1000 * 1000);
+
+    ar7100_write_pci_window(0);
+    ar7100_write_pci_window(1);
+    ar7100_write_pci_window(2);
+    ar7100_write_pci_window(3);
+    ar7100_write_pci_window(4);
+    ar7100_write_pci_window(5);
+    ar7100_write_pci_window(6);
+    ar7100_write_pci_window(7);
+
+    udelay(1000 * 1000);
+
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+          PCI_COMMAND_PARITY|PCI_COMMAND_SERR|PCI_COMMAND_FAST_BACK;
+
+    ar7100_local_write_config(PCI_COMMAND, 4, cmd);
+
+    /*
+     * clear any lingering errors and register core error IRQ
+     */
+    ar7100_check_error(0);
+    
+    /*
+    ** Now, configure for u-boot tools
+    */
+    
+	hose.first_busno = 0;
+	hose.last_busno = 0xff;
+
+	/* System space */
+	pci_set_region( &hose.regions[0],
+		            0x80000000,
+		            0x00000000,
+		            32 * 1024 * 1024,
+		            PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region( &hose.regions[1],
+		            0x10000000,
+		            0x10000000,
+		            128 * 1024 * 1024,
+		            PCI_REGION_MEM);
+
+	hose.region_count = 2;
+
+	pci_register_hose(&hose);
+
+	pci_set_ops(&hose,
+		pci_hose_read_config_byte_via_dword,
+		pci_hose_read_config_word_via_dword,
+		ar7100_pci_read_config,
+		pci_hose_write_config_byte_via_dword,
+		pci_hose_write_config_word_via_dword,
+		ar7100_pci_write_config);
+
+    return 0;
+}
+
+
diff --git a/board/ar7100/pb47/u-boot.lds b/board/ar7100/pb47/u-boot.lds
new file mode 100644
index 0000000000..9ac25bead9
--- /dev/null
+++ b/board/ar7100/pb47/u-boot.lds
@@ -0,0 +1,40 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/tb225/Makefile b/board/ar7100/tb225/Makefile
new file mode 100644
index 0000000000..f3e8c66cf6
--- /dev/null
+++ b/board/ar7100/tb225/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/vsc_phy.o ../common/ipPhy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7100/tb225/config.mk b/board/ar7100/tb225/config.mk
new file mode 100644
index 0000000000..f834c98c11
--- /dev/null
+++ b/board/ar7100/tb225/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbfc00000
+
+# SDRAM version
+#TEXT_BASE = 0xa1000000
diff --git a/board/ar7100/tb225/flash.c b/board/ar7100/tb225/flash.c
new file mode 100644
index 0000000000..3f91d3e32f
--- /dev/null
+++ b/board/ar7100/tb225/flash.c
@@ -0,0 +1,26 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size      = (CFG_MAX_FLASH_BANKS * CFG_MAX_FLASH_SECT *
+                            CFG_FLASH_SECTOR_SIZE);
+    flash_info->sector_count = CFG_MAX_FLASH_SECT;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+	printf ("flash size %dMB\n", flash_info->size/(1024*1024));
+	return (flash_info->size);
+}
diff --git a/board/ar7100/tb225/tb225.c b/board/ar7100/tb225/tb225.c
new file mode 100644
index 0000000000..0dc0b7186b
--- /dev/null
+++ b/board/ar7100/tb225/tb225.c
@@ -0,0 +1,55 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include "ar7100_soc.h"
+
+int
+ar7100_mem_config()
+{
+    uint32_t  ddr_config, ddr_config2;
+    ar7100_ddr_width_t width;
+
+    ar7100_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+    ar7100_ddr_tap_config();
+    
+    ddr_config   = ar7100_reg_rd(AR7100_DDR_CONFIG);
+    ddr_config2  = ar7100_reg_rd(AR7100_DDR_CONFIG2);
+    width        = ar7100_ddr_get_width();
+
+    if (width != AR7100_DDR_32B)
+        ddr_config |= AR7100_DDR_CONFIG_16BIT;
+    if (width == AR7100_DDR_16B_HIGH)
+        ddr_config2 &= ~AR7100_DDR_CONFIG2_HALF_WIDTH_L;
+
+    ddr_config2 &= ~((0x1f << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                     (0x1f << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                      0xf);
+
+    ddr_config2 |= ((CFG_DDR_TRTW_VAL << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                    (CFG_DDR_TWTR_VAL << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                    AR7100_DDR_CONFIG2_BL2);
+    /*
+     * XXX These bits are reserved...
+     */
+    ddr_config2 |= (1 << 26)|(1 << 27);
+                    
+    printf("programming config1 %#x, config2 %#x\n", ddr_config, ddr_config2);
+
+    ar7100_reg_wr(AR7100_DDR_CONFIG, ddr_config);
+    ar7100_reg_wr(AR7100_DDR_CONFIG2, ddr_config2);
+
+    return (ar7100_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7100_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("TB42 (ar7100) U-boot\n");
+	return 0;
+}
diff --git a/board/ar7100/tb225/u-boot.lds b/board/ar7100/tb225/u-boot.lds
new file mode 100644
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7100/tb225/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/tb243/Makefile b/board/ar7100/tb243/Makefile
new file mode 100644
index 0000000000..e3785e760f
--- /dev/null
+++ b/board/ar7100/tb243/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7100_flash.o
+SOBJS	= ../common/lowlevel_init_ar9100.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7100/tb243/config.mk b/board/ar7100/tb243/config.mk
new file mode 100755
index 0000000000..1d06cc5eb1
--- /dev/null
+++ b/board/ar7100/tb243/config.mk
@@ -0,0 +1,6 @@
+# ROM version
+#TEXT_BASE = 0x80500000
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0xa1000000
diff --git a/board/ar7100/tb243/tb243.c b/board/ar7100/tb243/tb243.c
new file mode 100644
index 0000000000..0f23f8a593
--- /dev/null
+++ b/board/ar7100/tb243/tb243.c
@@ -0,0 +1,83 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include "ar7100_soc.h"
+
+int
+ar7100_mem_config()
+{
+    uint32_t  ddr_config, ddr_config2;
+#if 0
+    ar7100_ddr_width_t width;
+#endif
+
+    ar7100_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+#if 0
+    ar7100_ddr_tap_config();
+#else
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL0, 0x5);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL1, 0x5);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL2, 0x5);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL3, 0x5);
+#endif
+    
+#if 0
+    ddr_config   = ar7100_reg_rd(AR7100_DDR_CONFIG);
+    ddr_config2  = ar7100_reg_rd(AR7100_DDR_CONFIG2);
+    width        = ar7100_ddr_get_width();
+
+    if (width != AR7100_DDR_32B)
+        ddr_config |= AR7100_DDR_CONFIG_16BIT;
+    if (width == AR7100_DDR_16B_HIGH)
+        ddr_config2 &= ~AR7100_DDR_CONFIG2_HALF_WIDTH_L;
+
+    ddr_config2 &= ~((0x1f << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                     (0x1f << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                      0xf);
+
+    ddr_config2 |= ((CFG_DDR_TRTW_VAL << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                    (CFG_DDR_TWTR_VAL << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                    AR7100_DDR_CONFIG2_BL2);
+    /*
+     * XXX These bits are reserved...
+     */
+    ddr_config2 |= (1 << 26)|(1 << 27)|(1 << 30);
+                    
+    printf("programming config1 %#x, config2 %#x\n", ddr_config, ddr_config2);
+
+    ar7100_reg_wr(AR7100_DDR_CONFIG, ddr_config);
+    ar7100_reg_wr(AR7100_DDR_CONFIG2, ddr_config2);
+#endif
+
+    /* XXX - these don't really belong here! */
+    *(volatile unsigned int *)0xb8050004 = 0x00001032;
+    udelay(100);
+#ifndef AR9100
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+#endif
+    *(volatile unsigned int *)0xb805001c = 0x00000909;
+    udelay(100);
+
+    *(volatile unsigned int *)0xb8050014 = 0x14000044;
+    udelay(100);
+
+    /* Temp addition - check with Ravi */
+    *(volatile unsigned int *)0xb8080008 = 0x00000040;
+    udelay(100);
+    return (ar7100_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7100_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("TB243 (ar7100) U-boot\n");
+	return 0;
+}
diff --git a/board/ar7100/tb243/u-boot.lds b/board/ar7100/tb243/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7100/tb243/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap101-2.6.31/Makefile b/board/ar7240/ap101-2.6.31/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/ap101-2.6.31/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap101-2.6.31/ap101-2.6.31.c b/board/ar7240/ap101-2.6.31/ap101-2.6.31.c
new file mode 100644
index 0000000000..574c24fe9b
--- /dev/null
+++ b/board/ar7240/ap101-2.6.31/ap101-2.6.31.c
@@ -0,0 +1,71 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004); 
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP101 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP101 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap101-2.6.31/config.mk b/board/ar7240/ap101-2.6.31/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap101-2.6.31/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap101-2.6.31/flash.c b/board/ar7240/ap101-2.6.31/flash.c
new file mode 100644
index 0000000000..3884a2e528
--- /dev/null
+++ b/board/ar7240/ap101-2.6.31/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap101-2.6.31/u-boot.lds b/board/ar7240/ap101-2.6.31/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap101-2.6.31/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap101-small/Makefile b/board/ar7240/ap101-small/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/ap101-small/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap101-small/ap101-small.c b/board/ar7240/ap101-small/ap101-small.c
new file mode 100644
index 0000000000..574c24fe9b
--- /dev/null
+++ b/board/ar7240/ap101-small/ap101-small.c
@@ -0,0 +1,71 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004); 
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP101 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP101 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap101-small/config.mk b/board/ar7240/ap101-small/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap101-small/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap101-small/flash.c b/board/ar7240/ap101-small/flash.c
new file mode 100644
index 0000000000..3884a2e528
--- /dev/null
+++ b/board/ar7240/ap101-small/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap101-small/u-boot.lds b/board/ar7240/ap101-small/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap101-small/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap101/Makefile b/board/ar7240/ap101/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/ap101/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap101/ap101.c b/board/ar7240/ap101/ap101.c
new file mode 100644
index 0000000000..574c24fe9b
--- /dev/null
+++ b/board/ar7240/ap101/ap101.c
@@ -0,0 +1,71 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004); 
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP101 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP101 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap101/config.mk b/board/ar7240/ap101/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap101/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap101/flash.c b/board/ar7240/ap101/flash.c
new file mode 100644
index 0000000000..3884a2e528
--- /dev/null
+++ b/board/ar7240/ap101/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap101/u-boot.lds b/board/ar7240/ap101/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap101/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap111-2.6.31/Makefile b/board/ar7240/ap111-2.6.31/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/ap111-2.6.31/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap111-2.6.31/ap111-2.6.31.c b/board/ar7240/ap111-2.6.31/ap111-2.6.31.c
new file mode 100644
index 0000000000..14e72896d3
--- /dev/null
+++ b/board/ar7240/ap111-2.6.31/ap111-2.6.31.c
@@ -0,0 +1,71 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004); 
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP111 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP111 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap111-2.6.31/config.mk b/board/ar7240/ap111-2.6.31/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap111-2.6.31/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap111-2.6.31/flash.c b/board/ar7240/ap111-2.6.31/flash.c
new file mode 100644
index 0000000000..3884a2e528
--- /dev/null
+++ b/board/ar7240/ap111-2.6.31/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap111-2.6.31/u-boot.lds b/board/ar7240/ap111-2.6.31/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap111-2.6.31/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap111/Makefile b/board/ar7240/ap111/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/ap111/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap111/ap111.c b/board/ar7240/ap111/ap111.c
new file mode 100644
index 0000000000..14e72896d3
--- /dev/null
+++ b/board/ar7240/ap111/ap111.c
@@ -0,0 +1,71 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004); 
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP111 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP111 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap111/config.mk b/board/ar7240/ap111/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap111/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap111/flash.c b/board/ar7240/ap111/flash.c
new file mode 100644
index 0000000000..3884a2e528
--- /dev/null
+++ b/board/ar7240/ap111/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap111/u-boot.lds b/board/ar7240/ap111/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap111/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap120/Makefile b/board/ar7240/ap120/Makefile
new file mode 100644
index 0000000000..045813bfdd
--- /dev/null
+++ b/board/ar7240/ap120/Makefile
@@ -0,0 +1,68 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifeq ($(BOOT_FROM_NAND),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap120/ap120.c b/board/ar7240/ap120/ap120.c
new file mode 100644
index 0000000000..b49f632683
--- /dev/null
+++ b/board/ar7240/ap120/ap120.c
@@ -0,0 +1,177 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+	/*  Enable xLNBIAS signal on GPIO (19, 20) */
+	ar7240_reg_wr (AR7240_GPIO_FUNC4, ((ar7240_reg_rd(AR7240_GPIO_FUNC4) & 0x00ffffff)) | 0x2f000000);
+	ar7240_reg_wr (AR7240_GPIO_FUNC5, ((ar7240_reg_rd(AR7240_GPIO_FUNC5) & 0xffffff00)) | 0x2e);
+	ar7240_reg_wr (AR7240_GPIO_OE, (ar7240_reg_rd(AR7240_GPIO_OE) & 0xffe7ffff));
+
+#if 0
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+	ar7240_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ar7240_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ar7240_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ar7240_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+#ifdef CONFIG_AP123
+	extern void ath_ddr_tap_cal(void);
+#endif
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+#ifdef CONFIG_AP123
+	ath_ddr_tap_cal();
+
+#ifndef COMPRESSED_UBOOT
+	printf("Tap value selected = 0x%x [0x%x - 0x%x]\n",
+		ar7240_reg_rd(AR7240_DDR_TAP_CONTROL0),
+		ar7240_reg_rd(0xbd007f10), ar7240_reg_rd(0xbd007f14));
+#endif
+#endif
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+	ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+
+	wasp_usb_initial_config();
+
+#endif /* !defined(CONFIG_ATH_NAND_BR) */
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */ 
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot AP120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot AP120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/ap120/config.mk b/board/ar7240/ap120/config.mk
new file mode 100755
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/ap120/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/ap120/flash.c b/board/ar7240/ap120/flash.c
new file mode 100644
index 0000000000..0d511b13b4
--- /dev/null
+++ b/board/ar7240/ap120/flash.c
@@ -0,0 +1,30 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
diff --git a/board/ar7240/ap120/u-boot-bootstrap.lds b/board/ar7240/ap120/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/ap120/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap120/u-boot.lds b/board/ar7240/ap120/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/ap120/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap121/Makefile b/board/ar7240/ap121/Makefile
new file mode 100644
index 0000000000..73fe788152
--- /dev/null
+++ b/board/ar7240/ap121/Makefile
@@ -0,0 +1,22 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+ifeq ($(BOARD), ap121)
+SOBJS	+= hornet_pll_init.o
+endif
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap121/ap121.c b/board/ar7240/ap121/ap121.c
new file mode 100644
index 0000000000..717404aee2
--- /dev/null
+++ b/board/ar7240/ap121/ap121.c
@@ -0,0 +1,142 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef CONFIG_HORNET_EMU
+extern void ar7240_ddr_initial_config_for_fpga(void);
+#endif
+
+void
+ar7240_usb_initial_config(void)
+{
+#ifndef CONFIG_HORNET_EMU
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+#endif
+}
+
+void
+ar7240_usb_otp_config(void)
+{
+    unsigned int addr, reg_val, reg_usb;
+    int time_out, status, usb_valid;
+    
+    for (addr = 0xb8114014; ;addr -= 0x10) {
+        status = 0;
+        time_out = 20;
+        
+        reg_val = ar7240_reg_rd(addr);
+
+        while ((time_out > 0) && (~status)) {
+            if ((( ar7240_reg_rd(0xb8115f18)) & 0x7) == 0x4) {
+                status = 1;
+            } else {
+                status = 0;
+            }
+            time_out--;
+        }
+
+        reg_val = ar7240_reg_rd(0xb8115f1c);
+        if ((reg_val & 0x80) == 0x80){
+            usb_valid = 1;
+            reg_usb = reg_val & 0x000000ff;
+        }
+
+        if (addr == 0xb8114004) {
+            break;
+        }
+    }
+
+    if (usb_valid) {
+        reg_val = ar7240_reg_rd(0xb8116c88);
+        reg_val &= ~0x03f00000;
+        reg_val |= (reg_usb & 0xf) << 22;
+        ar7240_reg_wr(0xb8116c88, reg_val);
+    }
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs 
+     * clk_obs1(gpio13/bit8),  clk_obs2(gpio14/bit9), clk_obs3(gpio15/bit10),
+     * clk_obs4(gpio16/bit11), clk_obs5(gpio17/bit12)
+     * clk_obs0(gpio1/bit19), 6(gpio11/bit20)
+     */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, 
+        (ar7240_reg_rd(AR7240_GPIO_FUNC) & ~((0x1f<<8)|(0x3<<19))));
+
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | (0x1f<<3)));
+	
+    /* Clear AR7240_GPIO_FUNC BIT2 to ensure that software can control LED5(GPIO16) and LED6(GPIO17)  */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & ~(0x1<<2)));
+	
+    /* Set HORNET_BOOTSTRAP_STATUS BIT18 to ensure that software can control GPIO26 and GPIO27 */
+    //ar7240_reg_wr (HORNET_BOOTSTRAP_STATUS, (ar7240_reg_rd(HORNET_BOOTSTRAP_STATUS) | (0x1<<18)));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+#ifdef CONFIG_HORNET_EMU
+    ar7240_ddr_initial_config_for_fpga();
+#else
+    //ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+#endif
+
+/* Default tap values for starting the tap_init*/
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, CFG_DDR_TAP0_VAL);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, CFG_DDR_TAP1_VAL);
+
+    ar7240_gpio_config();
+
+#ifndef COMPRESSED_UBOOT
+#ifndef CONFIG_HORNET_EMU
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+#endif
+
+    //ar7240_usb_initial_config();
+    ar7240_usb_otp_config();
+    
+    hornet_ddr_tap_init();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+#if (BOARD_STRING == WAPI)
+    strcpy(board_string, "AP121 (ar9331) U-boot");
+#else
+    strcpy(board_string, "AP121-2MB (ar9330) U-boot");
+#endif
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("AP121-2MB (ar9330) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/ap121/config.mk b/board/ar7240/ap121/config.mk
new file mode 100644
index 0000000000..4e9c48e5e6
--- /dev/null
+++ b/board/ar7240/ap121/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap121/flash.c b/board/ar7240/ap121/flash.c
new file mode 100644
index 0000000000..e1b30b51d6
--- /dev/null
+++ b/board/ar7240/ap121/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap121/hornet_pll_init.S b/board/ar7240/ap121/hornet_pll_init.S
new file mode 100755
index 0000000000..b2e99a06c6
--- /dev/null
+++ b/board/ar7240/ap121/hornet_pll_init.S
@@ -0,0 +1,375 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7240_soc.h>
+
+    .globl hornet_pll_init
+	.text
+	.align 4
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */ 
+/*     or  t8, t8, t9;                                 \ */
+#define set_reg(_reg, _val)                         \
+    li  t7, KSEG1ADDR(_reg);                        \
+    lw  t8, 0(t7);                                  \
+    li  t9, _val;                                   \
+    sw  t9, 0(t7);
+
+hornet_pll_init:
+
+#if 1
+/* These three wlan reset will avoid original issue, 
+so full chip reset isn't needed here. */
+    set_reg(0xb806001c, 0x00c06b30)
+    nop
+    set_reg(0xb806001c, 0x00c06330)
+    nop    
+    set_reg(0xb806001c, 0x00c06b30)
+    nop    
+    set_reg(0xb806001c, 0x00c06330)  
+    nop  
+reset_wlan:
+    set_reg(0xb806001c, 0x00c06b30) 
+    nop    
+    set_reg(0xb806001c, 0x00c06330)
+    nop
+
+    li  t5, 0x20
+check_val:
+    beq zero, t5, reset_wlan
+    addi t5, t5, -1    
+    li  t6, 0xb80600ac
+    lw  t7, 0(t6)
+    li  t8, 0x10
+    and t7, t7, t8
+    bne zero, t7, check_val 
+    
+    set_reg(HORNET_BOOTSTRAP_STATUS, 0x0002110e)
+    nop
+#else
+/* clear wlan reset bit in RESET_Register 0x1c */
+    set_reg(AR7240_RESET, 0x00c06b30)
+    nop
+    set_reg(AR7240_RESET, 0x00c06330)
+    nop
+
+/* cleck bootstrap status, wait for bit4 on, then clear bit16 */
+wait_loop0:
+    li  t6, KSEG1ADDR(HORNET_BOOTSTRAP_STATUS)
+    lw  t7, 0(t6)
+    li  t8, 0x10
+    and t7, t7, t8
+    bne zero, t7, wait_loop0
+    nop
+    set_reg(HORNET_BOOTSTRAP_STATUS, 0x0002110e)
+    nop
+#endif    
+    
+/* RTC reset */
+    set_reg(0x1810704c, 0x00000003)
+    nop
+    nop
+    set_reg(0x18107040, 0x00000000)
+    nop
+    nop
+    set_reg(0x18107040, 0x00000001)
+    nop
+wait_loop1:
+    li  t6, KSEG1ADDR(0x18107044)
+    lw  t7, 0(t6)
+    li  t8, 0x2
+    and t7, t7, t8
+    bne t8, t7, wait_loop1
+    nop
+
+    /* AHB/APH reset */    
+    set_reg(0x18104000, 0x00000003)
+    nop
+    set_reg(0x18104000, 0x00000000)
+    nop
+
+    /* MAC reset */
+    set_reg(0x18107000, 0x0000000F)
+    nop
+    set_reg(0x18107000, 0x00000000)
+    nop
+
+#if 1  /* fetch pmu1.refv and ctrl2.tx from OTP */
+    li  t1, KSEG1ADDR(0x18114014)
+    lw  t2, 0(t1)
+otp_loop0:
+    li  t3, KSEG1ADDR(0x18115f18)
+    lw  t4, 0(t3)
+    nop
+    li  t5, 0x7
+    and t4, t4, t5
+    li  t5, 0x4
+    bne t4, t5, otp_loop0
+    nop
+
+    li  t6, KSEG1ADDR(0x18115f1c)
+    lw  t7, 0(t6)
+    nop
+    li  t8, 0x80000080
+    and t9, t7, t8
+    beq t8, t9, fetch_otp
+otp_loop0_end:
+
+    li  t1, KSEG1ADDR(0x18114004)
+    lw  t2, 0(t1)
+otp_loop1:
+    li  t3, KSEG1ADDR(0x18115f18)
+    lw  t4, 0(t3)
+    nop
+    li  t5, 0x7
+    and t4, t4, t5
+    li  t5, 0x4
+    bne t4, t5, otp_loop1
+    nop
+
+    li  t6, KSEG1ADDR(0x18115f1c)
+    lw  t7, 0(t6)
+    nop
+    li  t8, 0x80000080
+    and t9, t7, t8
+default_pmu:
+    li  t5, 0x80             /* default 0x031c4386 */
+    bne t8, t9, otp_end
+otp_loop1_end:
+
+fetch_otp:
+    srl t8, t7, 0x18
+    li  t1, 0xf
+    and t2, t1 , t7         /* USB */
+    and t5, t1 , t8         /* PMU */
+
+check_pmu:
+    li t0, 0x4                         /* PMU range should be 0x4~0xa */
+    bgt t0, t5, default_pmu
+    nop
+    li t0, 0xa                         /* PMU range should be 0x4~0xa */
+    blt t0, t5, default_pmu
+    nop
+    li  t0, 0x4
+    sll t5, t5, t0
+
+otp_end:
+#endif
+
+#if 1 /* Program PMU */
+#define PMU_TEST_NO 1000
+    li  t6, KSEG1ADDR(0x18116c40)
+    li  t9, 0xbd000010
+    li  t0, 0
+    li  t1, 0
+    li  t2, 0
+    
+    li  t3, PMU_TEST_NO
+    sw  t3, 12(t9) 
+pmu_loop0:
+    beq zero, t3, pmu_loop0_end
+    nop    
+    addi t3, t3, -1
+            
+    #li  t7, 0x10000000 /* ldo_tune 0x0 */
+    #li  t7, 0x10080000 /* ldo_tune 0x1 */
+    #li  t7, 0x10100000 /* ldo_tune 0x2 */
+    li  t7, 0x10180000  /* ldo_tune 0x3 */   
+    nop
+    sw  t7, 4(t6)
+    nop   
+    lw  t8, 4(t6)
+    nop
+    beq t8, t7, pmu_loop0_end
+    nop
+   
+    addiu  t0, t0, 1
+    b   pmu_loop0
+    nop
+pmu_loop0_end:      
+
+    li  t3, PMU_TEST_NO    
+pmu_loop1:
+    beq zero, t3, pmu_loop1_end
+    nop    
+    addi t3, t3, -1
+
+    //li  t7, 0x031c4326    /* 1.100V */
+    //li  t7, 0x031c4336    /* 1.125V */
+    //li  t7, 0x031c4346    /* 1.150V */
+    //li  t7, 0x031c4356    /* 1.175V */     
+    //li  t7, 0x031c4366    /* 1.200V */
+    //li  t7, 0x031c4376    /* 1.225V */
+    li  t7, 0x031c4386    /* 1.250V */
+    //li  t7, 0x031c4396    /* 1.275V */
+    //li  t7, 0x031c43a6    /* 1.300V */    
+    nop
+#if 1 /* from OTP */
+    li  t8, 0xffffff0f
+    and t7, t7, t8
+    or  t7, t7, t5
+#endif
+    sw  t7, 0(t6)
+    nop   
+    lw  t8, 0(t6)
+    nop
+    beq t8, t7, pmu_loop1_end
+    nop  
+    
+    addiu  t1, t1, 1
+    b   pmu_loop1    
+    nop       
+pmu_loop1_end:    
+
+    li  t3, PMU_TEST_NO
+pmu_loop2: 
+    beq zero, t3, pmu_loop2_end
+    nop    
+    addi t3, t3, -1
+    
+    #li  t7, 0x10200000 /* ldo_tune 0x0 */
+    #li  t7, 0x10280000 /* ldo_tune 0x1 */
+    #li  t7, 0x10300000 /* ldo_tune 0x2 */
+    li  t7, 0x10380000  /* ldo_tune 0x3 */
+    nop
+    sw  t7, 4(t6)
+    nop   
+    lw  t8, 4(t6)
+    nop
+    beq t8, t7, pmu_loop2_end
+    nop   
+    
+    addiu  t2, t2, 1
+    b   pmu_loop2  
+    nop       
+pmu_loop2_end:    
+
+    sw  t0, 0(t9) 
+    nop  
+    sw  t1, 4(t9) 
+    nop  
+    sw  t2, 8(t9) 
+    nop
+#endif
+
+#if 1 /* Program ki, kd */
+    /* Program ki/kd */
+#if CONFIG_40MHZ_XTAL_SUPPORT
+    set_reg(0x18116244, 0x19e82f01)
+#else
+    set_reg(0x18116244, 0x18e82f01)
+#endif
+    nop
+    
+    /* Program phase shift */
+    li  t6, KSEG1ADDR(0x18116248)
+    lw  t7, 0(t6)
+    li  t8, 0xc07fffff
+    and t7, t7, t8
+    li  t8, 0x800000
+    or  t7, t7, t8
+    sw  t7, 0(t6)    
+    nop
+#endif
+
+/* set PLL bypass(Bit 2), CPU_POST_DIV, DDR_POST_DIV, AHB_POST_DIV in CPU clock control */
+    set_reg(AR7240_CPU_CLOCK_CONTROL, 0x00018004)
+    nop
+
+/* set SETTLE_TIME in CPU PLL */
+    set_reg(AR7240_USB_PLL_CONFIG, CPU_PLL_SETTLE_TIME_VAL)
+    nop
+
+pll_unlock_handler:
+
+/* set nint, frac, refdiv, outdiv, range in CPU PLL configuration resiter */
+    set_reg(AR7240_CPU_PLL_CONFIG, CPU_PLL_CONFIG_VAL1)
+    nop
+
+wait_loop2:
+    li  t6, KSEG1ADDR(AR7240_CPU_PLL_CONFIG)
+    lw  t7, 0(t6)
+    li  t8, 0x80000000
+    and t7, t7, t8
+    bne zero, t7, wait_loop2
+    nop
+    
+/* put frac bit19:10 configuration */
+    set_reg(AR7240_PCIE_PLL_CONFIG, CPU_PLL_DITHER_FRAC_VAL)
+    nop
+
+/* clear PLL power down bit in CPU PLLl configuration */
+    set_reg(AR7240_CPU_PLL_CONFIG, CPU_PLL_CONFIG_VAL2)
+    nop
+wait_loop3:
+    li  t6, KSEG1ADDR(AR7240_CPU_PLL_CONFIG)
+    lw  t7, 0(t6)
+    li  t8, 0x80000000
+    and t7, t7, t8
+    bne zero, t7, wait_loop3
+    nop
+
+/* confirm DDR PLL lock */
+    li  t3, 100
+    li  t4, 0
+start_meas0:
+    addi t4, t4, 1
+    bgt t4, t3, pll_unlock_handler
+    nop
+    li  t5, 5
+start_meas:
+    li  t6, KSEG1ADDR(0x18116248)
+    lw  t7, 0(t6) 
+    li  t8, 0xbfffffff  
+    and t7, t7, t8
+    sw  t7, 0(t6)
+    nop
+
+/* delay */
+    li t9, 10
+delayloop0:
+    subu t9, t9, 1
+    bne t9, zero, delayloop0
+    nop
+
+    li  t8, 0x40000000  
+    or  t7, t7, t8
+    sw  t7, 0(t6)
+    nop    
+
+meas_done_statue:
+    li  t6, KSEG1ADDR(0x1811624c)
+    lw  t7, 0(t6)
+    li  t8, 0x8  
+    and t7, t7, t8
+    beq zero, t7, meas_done_statue
+    nop
+   
+meas_result:
+    li  t6, KSEG1ADDR(0x18116248)
+    lw  t7, 0(t6)
+    li  t8, 0x007ffff8
+    and t7, t7, t8
+    srl t7, t7, 3
+    li  t8, 0x4000
+    bgt t7, t8, start_meas0
+    nop
+    addi t5, t5, -1
+    bne zero, t5, start_meas
+    nop
+
+/* clear PLL bypass(Bit 2), CPU_POST_DIV, DDR_POST_DIV, AHB_POST_DIV in CPU clock control */
+    set_reg(AR7240_CPU_CLOCK_CONTROL, CPU_CLK_CONTROL_VAL2)
+    nop
+
+/* Sync mode , Set Bit 8 of DDR Tap Conrtol 3 register */
+    set_reg(AR7240_DDR_TAP_CONTROL3, 0x10105);
+    nop
+
+    jr ra
+    nop
diff --git a/board/ar7240/ap121/u-boot-bootstrap.lds b/board/ar7240/ap121/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap121/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap121/u-boot.lds b/board/ar7240/ap121/u-boot.lds
new file mode 100644
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap121/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap123/Makefile b/board/ar7240/ap123/Makefile
new file mode 100644
index 0000000000..045813bfdd
--- /dev/null
+++ b/board/ar7240/ap123/Makefile
@@ -0,0 +1,68 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifeq ($(BOOT_FROM_NAND),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap123/ap123.c b/board/ar7240/ap123/ap123.c
new file mode 100644
index 0000000000..9df940a18b
--- /dev/null
+++ b/board/ar7240/ap123/ap123.c
@@ -0,0 +1,171 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+
+int
+wasp_mem_config(void)
+{
+#ifdef CONFIG_AP123
+	extern void ath_ddr_tap_cal(void);
+#endif
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+#ifdef CONFIG_AP123
+	ath_ddr_tap_cal();
+
+#ifndef COMPRESSED_UBOOT
+	printf("Tap value selected = 0x%x [0x%x - 0x%x]\n",
+		ar7240_reg_rd(AR7240_DDR_TAP_CONTROL0),
+		ar7240_reg_rd(0xbd007f10), ar7240_reg_rd(0xbd007f14));
+#endif
+#endif
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+	ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/ap123/config.mk b/board/ar7240/ap123/config.mk
new file mode 100755
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/ap123/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/ap123/flash.c b/board/ar7240/ap123/flash.c
new file mode 100644
index 0000000000..0d511b13b4
--- /dev/null
+++ b/board/ar7240/ap123/flash.c
@@ -0,0 +1,30 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
diff --git a/board/ar7240/ap123/u-boot-bootstrap.lds b/board/ar7240/ap123/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/ap123/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap123/u-boot.lds b/board/ar7240/ap123/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/ap123/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap91-2MB/Makefile b/board/ar7240/ap91-2MB/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap91-2MB/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap91-2MB/ap91-2MB.c b/board/ar7240/ap91-2MB/ap91-2MB.c
new file mode 100644
index 0000000000..401bdc2130
--- /dev/null
+++ b/board/ar7240/ap91-2MB/ap91-2MB.c
@@ -0,0 +1,75 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+/* Default tap values for starting the tap_init*/
+#ifndef COMPRESSED_UBOOT
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#else
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x9);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0xa);
+#endif
+    ar7240_gpio_config();
+
+#ifndef COMPRESSED_UBOOT
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "AP91 (ar7240) U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("AP91 (ar7240) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/ap91-2MB/ar9285gpio.c b/board/ar7240/ap91-2MB/ar9285gpio.c
new file mode 100644
index 0000000000..b7ac12b322
--- /dev/null
+++ b/board/ar7240/ap91-2MB/ar9285gpio.c
@@ -0,0 +1,141 @@
+#include <config.h>
+#include <common.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7240_soc.h"
+
+#define AR9285_BASE     0x10000000
+
+#define AR9285_NUM_GPIO     10
+
+#define AR9285_GPIO_IN_OUT                           0x4048 // GPIO input / output register
+#define AR9285_GPIO_IN_VAL                           0x000FFC00
+#define AR9285_GPIO_IN_VAL_S                         10
+
+#define AR9285_GPIO_OE_OUT                           0x404c // GPIO output register
+#define AR9285_GPIO_OE_OUT_DRV                       0x3    // 2 bit field mask, shifted by 2*bitpos
+#define AR9285_GPIO_OE_OUT_DRV_NO                    0x0    // tristate
+#define AR9285_GPIO_OE_OUT_DRV_LOW                   0x1    // drive if low
+#define AR9285_GPIO_OE_OUT_DRV_HI                    0x2    // drive if high
+#define AR9285_GPIO_OE_OUT_DRV_ALL                   0x3    // drive always
+
+#define AR9285_GPIO_OUTPUT_MUX1                      0x4060
+#define AR9285_GPIO_OUTPUT_MUX2                      0x4064
+
+#define AR9285_GPIO_OUTPUT_MUX_AS_OUTPUT             0
+#define AR9285_GPIO_OUTPUT_MUX_AS_PCIE_ATTENTION_LED 1
+#define AR9285_GPIO_OUTPUT_MUX_AS_PCIE_POWER_LED     2
+#define AR9285_GPIO_OUTPUT_MUX_AS_TX_FRAME           3
+#define AR9285_GPIO_OUTPUT_MUX_AS_RX_CLEAR_EXTERNAL  4
+#define AR9285_GPIO_OUTPUT_MUX_AS_MAC_NETWORK_LED    5
+#define AR9285_GPIO_OUTPUT_MUX_AS_MAC_POWER_LED      6
+
+
+#define MS(_v, _f)  (((_v) & _f) >> _f##_S)
+
+#define AR9285_GPIO_BIT(_gpio)  (1 << (_gpio))
+
+#define ar9285_reg_wr(_off, _val)   ar7240_reg_wr(((_off) + AR9285_BASE), (_val))
+#define ar9285_reg_rd(_off)   (ar7240_reg_rd((_off) + AR9285_BASE))
+#define ar9285_reg_rmw(_off, _set, _clr)   do { \
+            ar7240_reg_rmw_clear(((_off) + AR9285_BASE), (_clr)); \
+            ar7240_reg_rmw_set(((_off) + AR9285_BASE), (_set)); \
+} while(0)
+
+
+/*
+ * Configure GPIO Output Mux control
+ */
+static void
+ar9285GpioCfgOutputMux(unsigned int gpio, u32 type)
+{
+    int          addr;
+    u32    gpio_shift;
+
+    // each MUX controls 6 GPIO pins
+    if (gpio > 5) {
+        addr = AR9285_GPIO_OUTPUT_MUX2;
+    } else {
+        addr = AR9285_GPIO_OUTPUT_MUX1;
+    }
+
+    // 5 bits per GPIO pin. Bits 0..4 for 1st pin in that mux, bits 5..9 for 2nd pin, etc.
+    gpio_shift = (gpio % 6) * 5;
+
+    ar9285_reg_rmw(addr, (type << gpio_shift), (0x1f << gpio_shift));
+}
+
+/*
+ * Configure GPIO Output lines
+ */
+void
+ar9285GpioCfgOutput(unsigned int gpio)
+{
+    u32    gpio_shift;
+
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return;
+    }
+    // Configure the MUX
+    ar9285GpioCfgOutputMux(gpio, AR9285_GPIO_OUTPUT_MUX_AS_OUTPUT);
+
+    // 2 bits per output mode
+    gpio_shift = 2*gpio;
+
+    ar9285_reg_rmw(AR9285_GPIO_OE_OUT, 
+               (AR9285_GPIO_OE_OUT_DRV_ALL << gpio_shift), 
+               (AR9285_GPIO_OE_OUT_DRV << gpio_shift));
+}
+
+/*
+ * Configure GPIO Input lines
+ */
+void
+ar9285GpioCfgInput(unsigned int gpio)
+{
+    u32    gpio_shift;
+
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return;
+    }
+    /* TODO: configure input mux for AR5416 */
+    /* If configured as input, set output to tristate */
+    gpio_shift = 2*gpio;
+
+    ar9285_reg_rmw(AR9285_GPIO_OE_OUT, 
+               (AR9285_GPIO_OE_OUT_DRV_NO << gpio_shift), 
+               (AR9285_GPIO_OE_OUT_DRV << gpio_shift));
+}
+
+/*
+ * Once configured for I/O - set output lines
+ */
+void
+ar9285GpioSet(unsigned int gpio, int val)
+{
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return;
+    }
+
+    ar9285_reg_rmw(AR9285_GPIO_IN_OUT, ((val&1) << gpio), AR9285_GPIO_BIT(gpio));
+}
+
+/*
+ * Once configured for I/O - get input lines
+ */
+u32
+ar9285GpioGet(unsigned int gpio)
+{
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return 0xffffffff;
+    }
+
+    // Read output value for all gpio's, shift it left, and verify whether a 
+    // specific gpio bit is set.
+    return (MS(ar9285_reg_rd(AR9285_GPIO_IN_OUT), AR9285_GPIO_IN_VAL) & AR9285_GPIO_BIT(gpio)) != 0;
+}
+
diff --git a/board/ar7240/ap91-2MB/config.mk b/board/ar7240/ap91-2MB/config.mk
new file mode 100755
index 0000000000..4e9c48e5e6
--- /dev/null
+++ b/board/ar7240/ap91-2MB/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap91-2MB/flash.c b/board/ar7240/ap91-2MB/flash.c
new file mode 100644
index 0000000000..e1b30b51d6
--- /dev/null
+++ b/board/ar7240/ap91-2MB/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap91-2MB/u-boot-bootstrap.lds b/board/ar7240/ap91-2MB/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap91-2MB/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap91-2MB/u-boot.lds b/board/ar7240/ap91-2MB/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap91-2MB/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap91-2x8/Makefile b/board/ar7240/ap91-2x8/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap91-2x8/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap91-2x8/ap91-2x8.c b/board/ar7240/ap91-2x8/ap91-2x8.c
new file mode 100644
index 0000000000..203aba32e5
--- /dev/null
+++ b/board/ar7240/ap91-2x8/ap91-2x8.c
@@ -0,0 +1,75 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+/* Default tap values for starting the tap_init*/
+#ifndef COMPRESSED_UBOOT
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#else
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x9);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0xa);
+#endif
+    ar7240_gpio_config();
+
+#ifndef COMPRESSED_UBOOT
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "AP91 (ar7240) u-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("AP91 (ar7240) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/ap91-2x8/config.mk b/board/ar7240/ap91-2x8/config.mk
new file mode 100755
index 0000000000..4e9c48e5e6
--- /dev/null
+++ b/board/ar7240/ap91-2x8/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap91-2x8/flash.c b/board/ar7240/ap91-2x8/flash.c
new file mode 100644
index 0000000000..e1b30b51d6
--- /dev/null
+++ b/board/ar7240/ap91-2x8/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap91-2x8/u-boot-bootstrap.lds b/board/ar7240/ap91-2x8/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap91-2x8/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap91-2x8/u-boot.lds b/board/ar7240/ap91-2x8/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap91-2x8/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap91-router/Makefile b/board/ar7240/ap91-router/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap91-router/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap91-router/ap91-router.c b/board/ar7240/ap91-router/ap91-router.c
new file mode 100644
index 0000000000..3bc886a94b
--- /dev/null
+++ b/board/ar7240/ap91-router/ap91-router.c
@@ -0,0 +1,58 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "AP91 Router (ar7240) U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("AP91 Router (ar7240) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/ap91-router/config.mk b/board/ar7240/ap91-router/config.mk
new file mode 100755
index 0000000000..7e602fd66a
--- /dev/null
+++ b/board/ar7240/ap91-router/config.mk
@@ -0,0 +1,13 @@
+# ROM version
+
+ifeq ($(COMPRESSED_UBOOT),1)
+# change the text base to ram address
+TEXT_BASE = 0x80010000
+# set to BOOTSTRAP text base to cached base address
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap91-router/flash.c b/board/ar7240/ap91-router/flash.c
new file mode 100644
index 0000000000..e1b30b51d6
--- /dev/null
+++ b/board/ar7240/ap91-router/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap91-router/u-boot-bootstrap.lds b/board/ar7240/ap91-router/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap91-router/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap91-router/u-boot.lds b/board/ar7240/ap91-router/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap91-router/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap91/Makefile b/board/ar7240/ap91/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap91/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap91/ap91.c b/board/ar7240/ap91/ap91.c
new file mode 100644
index 0000000000..941b59b9b4
--- /dev/null
+++ b/board/ar7240/ap91/ap91.c
@@ -0,0 +1,70 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Default tap values for starting the tap_init*/
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+
+    ar7240_gpio_config();
+#ifndef COMPRESSED_UBOOT
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "AP91 (ar7240) U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("AP91 (ar7240) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/ap91/ar9285gpio.c b/board/ar7240/ap91/ar9285gpio.c
new file mode 100644
index 0000000000..6021da5e4b
--- /dev/null
+++ b/board/ar7240/ap91/ar9285gpio.c
@@ -0,0 +1,152 @@
+#include <config.h>
+#include <common.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7240_soc.h"
+
+#define AR9285_BASE     0x10000000
+
+#define AR9285_NUM_GPIO     10
+
+#define AR9285_GPIO_IN_OUT                           0x4048 // GPIO input / output register
+#define AR9285_GPIO_IN_VAL                           0x000FFC00
+#define AR9285_GPIO_IN_VAL_S                         10
+
+#define AR9285_GPIO_OE_OUT                           0x404c // GPIO output register
+#define AR9285_GPIO_OE_OUT_DRV                       0x3    // 2 bit field mask, shifted by 2*bitpos
+#define AR9285_GPIO_OE_OUT_DRV_NO                    0x0    // tristate
+#define AR9285_GPIO_OE_OUT_DRV_LOW                   0x1    // drive if low
+#define AR9285_GPIO_OE_OUT_DRV_HI                    0x2    // drive if high
+#define AR9285_GPIO_OE_OUT_DRV_ALL                   0x3    // drive always
+
+#define AR9285_GPIO_IN_ENABLE                        (AR9285_BASE + 0x4054)
+#define AR9285_GPIO_JTAG_DISABLE                     (1u << 17)
+#define AR9285_GPIO_OUTPUT_MUX1                      0x4060
+#define AR9285_GPIO_OUTPUT_MUX2                      0x4064
+
+#define AR9285_GPIO_OUTPUT_MUX_AS_OUTPUT             0
+#define AR9285_GPIO_OUTPUT_MUX_AS_PCIE_ATTENTION_LED 1
+#define AR9285_GPIO_OUTPUT_MUX_AS_PCIE_POWER_LED     2
+#define AR9285_GPIO_OUTPUT_MUX_AS_TX_FRAME           3
+#define AR9285_GPIO_OUTPUT_MUX_AS_RX_CLEAR_EXTERNAL  4
+#define AR9285_GPIO_OUTPUT_MUX_AS_MAC_NETWORK_LED    5
+#define AR9285_GPIO_OUTPUT_MUX_AS_MAC_POWER_LED      6
+
+
+#define MS(_v, _f)  (((_v) & _f) >> _f##_S)
+
+#define AR9285_GPIO_BIT(_gpio)  (1 << (_gpio))
+
+#define ar9285_reg_wr(_off, _val)   ar7240_reg_wr(((_off) + AR9285_BASE), (_val))
+#define ar9285_reg_rd(_off)   (ar7240_reg_rd((_off) + AR9285_BASE))
+#define ar9285_reg_rmw(_off, _set, _clr)   do { \
+            ar7240_reg_rmw_clear(((_off) + AR9285_BASE), (_clr)); \
+            ar7240_reg_rmw_set(((_off) + AR9285_BASE), (_set)); \
+} while(0)
+
+
+/*
+ * Configure GPIO Output Mux control
+ */
+static void
+ar9285GpioCfgOutputMux(unsigned int gpio, u32 type)
+{
+    int          addr;
+    u32    gpio_shift;
+
+    // each MUX controls 6 GPIO pins
+    if (gpio > 5) {
+        addr = AR9285_GPIO_OUTPUT_MUX2;
+    } else {
+        addr = AR9285_GPIO_OUTPUT_MUX1;
+    }
+
+    // 5 bits per GPIO pin. Bits 0..4 for 1st pin in that mux, bits 5..9 for 2nd pin, etc.
+    gpio_shift = (gpio % 6) * 5;
+
+    ar9285_reg_rmw(addr, (type << gpio_shift), (0x1f << gpio_shift));
+}
+
+/*
+ * Configure GPIO Output lines
+ */
+void
+ar9285GpioCfgOutput(unsigned int gpio)
+{
+    u32    gpio_shift;
+
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return;
+    }
+    // Configure the MUX
+    ar9285GpioCfgOutputMux(gpio, AR9285_GPIO_OUTPUT_MUX_AS_OUTPUT);
+
+    // 2 bits per output mode
+    gpio_shift = 2*gpio;
+
+    ar9285_reg_rmw(AR9285_GPIO_OE_OUT, 
+               (AR9285_GPIO_OE_OUT_DRV_ALL << gpio_shift), 
+               (AR9285_GPIO_OE_OUT_DRV << gpio_shift));
+}
+
+/*
+ * Configure GPIO Input lines
+ */
+void
+ar9285GpioCfgInput(unsigned int gpio)
+{
+    u32    gpio_shift;
+
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return;
+    }
+    /* TODO: configure input mux for AR5416 */
+    /* If configured as input, set output to tristate */
+    gpio_shift = 2*gpio;
+
+    ar9285_reg_rmw(AR9285_GPIO_OE_OUT, 
+               (AR9285_GPIO_OE_OUT_DRV_NO << gpio_shift), 
+               (AR9285_GPIO_OE_OUT_DRV << gpio_shift));
+}
+
+/*
+ * Once configured for I/O - set output lines
+ */
+void
+ar9285GpioSet(unsigned int gpio, int val)
+{
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return;
+    }
+
+    ar9285_reg_rmw(AR9285_GPIO_IN_OUT, ((val&1) << gpio), AR9285_GPIO_BIT(gpio));
+}
+
+/*
+ * Once configured for I/O - get input lines
+ */
+u32
+ar9285GpioGet(unsigned int gpio)
+{
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return 0xffffffff;
+    }
+
+    // Read output value for all gpio's, shift it left, and verify whether a 
+    // specific gpio bit is set.
+    return (MS(ar9285_reg_rd(AR9285_GPIO_IN_OUT), AR9285_GPIO_IN_VAL) & AR9285_GPIO_BIT(gpio)) != 0;
+}
+
+u32
+ar9285DisableJtag(void)
+{
+	/*
+	 * Disable ar9285's JTAG access. Else, gpio 0 - 4 will be used
+	 * by the jtag. This does NOT affect board's JTAG interface
+	 */
+	ar7240_reg_rmw_set(AR9285_GPIO_IN_ENABLE, AR9285_GPIO_JTAG_DISABLE);
+}
diff --git a/board/ar7240/ap91/config.mk b/board/ar7240/ap91/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap91/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap91/flash.c b/board/ar7240/ap91/flash.c
new file mode 100644
index 0000000000..e1b30b51d6
--- /dev/null
+++ b/board/ar7240/ap91/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap91/u-boot-bootstrap.lds b/board/ar7240/ap91/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap91/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap91/u-boot.lds b/board/ar7240/ap91/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap91/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap93-hgw/Makefile b/board/ar7240/ap93-hgw/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap93-hgw/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap93-hgw/ap93-hgw.c b/board/ar7240/ap93-hgw/ap93-hgw.c
new file mode 100644
index 0000000000..0de5b7a357
--- /dev/null
+++ b/board/ar7240/ap93-hgw/ap93-hgw.c
@@ -0,0 +1,53 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x7);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x7);
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("AP93 Home Gateway (ar7240) U-boot\n");
+    return 0;
+}
diff --git a/board/ar7240/ap93-hgw/config.mk b/board/ar7240/ap93-hgw/config.mk
new file mode 100755
index 0000000000..f110fcb6ff
--- /dev/null
+++ b/board/ar7240/ap93-hgw/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap93-hgw/flash.c b/board/ar7240/ap93-hgw/flash.c
new file mode 100644
index 0000000000..e1b30b51d6
--- /dev/null
+++ b/board/ar7240/ap93-hgw/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap93-hgw/u-boot.lds b/board/ar7240/ap93-hgw/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap93-hgw/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap93/Makefile b/board/ar7240/ap93/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap93/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap93/ap93.c b/board/ar7240/ap93/ap93.c
new file mode 100644
index 0000000000..bf781acc77
--- /dev/null
+++ b/board/ar7240/ap93/ap93.c
@@ -0,0 +1,60 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+/* Default tap values for starting the tap_init*/
+
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x7);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x7);
+
+    ar7240_gpio_config();
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("AP93 (ar7240) U-boot\n");
+    return 0;
+}
diff --git a/board/ar7240/ap93/config.mk b/board/ar7240/ap93/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap93/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap93/flash.c b/board/ar7240/ap93/flash.c
new file mode 100644
index 0000000000..e1b30b51d6
--- /dev/null
+++ b/board/ar7240/ap93/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap93/u-boot.lds b/board/ar7240/ap93/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap93/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap98/Makefile b/board/ar7240/ap98/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap98/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap98/ap98.c b/board/ar7240/ap98/ap98.c
new file mode 100644
index 0000000000..a71c3fca33
--- /dev/null
+++ b/board/ar7240/ap98/ap98.c
@@ -0,0 +1,87 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#ifndef COMPRESSED_UBOOT
+        ar7240_ddr_tap_init();
+#endif
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+#ifndef COMPRESSED_UBOOT
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    if ((is_ar7241() || is_ar7242()))
+        strcpy(board_string, "AP98 (ar7241 - Virian) Compressed U-boot");
+    else
+        strcpy(board_string, "AP98 (ar7240 - Python) Compressed U-boot");
+    return 0;
+
+}
+#else
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP98 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP98 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
+#endif
diff --git a/board/ar7240/ap98/config.mk b/board/ar7240/ap98/config.mk
new file mode 100755
index 0000000000..e485e03667
--- /dev/null
+++ b/board/ar7240/ap98/config.mk
@@ -0,0 +1,13 @@
+# ROM version
+
+ifeq ($(COMPRESSED_UBOOT),1)
+# change the text base to ram address
+TEXT_BASE = 0x80310000
+# set to BOOTSTRAP text base to cached base address
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap98/flash.c b/board/ar7240/ap98/flash.c
new file mode 100644
index 0000000000..eec58f6b39
--- /dev/null
+++ b/board/ar7240/ap98/flash.c
@@ -0,0 +1,38 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+#ifndef COMPRESSED_UBOOT
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else 
+#endif
+    {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap98/u-boot-bootstrap.lds b/board/ar7240/ap98/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap98/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap98/u-boot.lds b/board/ar7240/ap98/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap98/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap99-2.6.31/Makefile b/board/ar7240/ap99-2.6.31/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap99-2.6.31/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap99-2.6.31/ap99-2.6.31.c b/board/ar7240/ap99-2.6.31/ap99-2.6.31.c
new file mode 100644
index 0000000000..2c03500a54
--- /dev/null
+++ b/board/ar7240/ap99-2.6.31/ap99-2.6.31.c
@@ -0,0 +1,73 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#ifndef COMPRESSED_UBOOT
+        ar7240_ddr_tap_init();
+#endif
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004); 
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP99 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP99 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap99-2.6.31/config.mk b/board/ar7240/ap99-2.6.31/config.mk
new file mode 100644
index 0000000000..b5a58d9d97
--- /dev/null
+++ b/board/ar7240/ap99-2.6.31/config.mk
@@ -0,0 +1,11 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
+
diff --git a/board/ar7240/ap99-2.6.31/flash.c b/board/ar7240/ap99-2.6.31/flash.c
new file mode 100644
index 0000000000..3884a2e528
--- /dev/null
+++ b/board/ar7240/ap99-2.6.31/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap99-2.6.31/u-boot-bootstrap.lds b/board/ar7240/ap99-2.6.31/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap99-2.6.31/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap99-2.6.31/u-boot.lds b/board/ar7240/ap99-2.6.31/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap99-2.6.31/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap99-hgw/Makefile b/board/ar7240/ap99-hgw/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap99-hgw/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap99-hgw/ap99-hgw.c b/board/ar7240/ap99-hgw/ap99-hgw.c
new file mode 100644
index 0000000000..21ec65c72a
--- /dev/null
+++ b/board/ar7240/ap99-hgw/ap99-hgw.c
@@ -0,0 +1,83 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#ifndef COMPRESSED_UBOOT
+        ar7240_ddr_tap_init();
+#endif
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+#ifndef COMPRESSED_UBOOT
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "AP99 HGW (ar7240) U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP99 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP99 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
+#endif
diff --git a/board/ar7240/ap99-hgw/config.mk b/board/ar7240/ap99-hgw/config.mk
new file mode 100755
index 0000000000..7e602fd66a
--- /dev/null
+++ b/board/ar7240/ap99-hgw/config.mk
@@ -0,0 +1,13 @@
+# ROM version
+
+ifeq ($(COMPRESSED_UBOOT),1)
+# change the text base to ram address
+TEXT_BASE = 0x80010000
+# set to BOOTSTRAP text base to cached base address
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap99-hgw/flash.c b/board/ar7240/ap99-hgw/flash.c
new file mode 100644
index 0000000000..eec58f6b39
--- /dev/null
+++ b/board/ar7240/ap99-hgw/flash.c
@@ -0,0 +1,38 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+#ifndef COMPRESSED_UBOOT
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else 
+#endif
+    {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap99-hgw/u-boot-bootstrap.lds b/board/ar7240/ap99-hgw/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap99-hgw/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap99-hgw/u-boot.lds b/board/ar7240/ap99-hgw/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap99-hgw/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap99-ivi/Makefile b/board/ar7240/ap99-ivi/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap99-ivi/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap99-ivi/ap99-ivi.c b/board/ar7240/ap99-ivi/ap99-ivi.c
new file mode 100644
index 0000000000..21ec65c72a
--- /dev/null
+++ b/board/ar7240/ap99-ivi/ap99-ivi.c
@@ -0,0 +1,83 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#ifndef COMPRESSED_UBOOT
+        ar7240_ddr_tap_init();
+#endif
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+#ifndef COMPRESSED_UBOOT
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "AP99 HGW (ar7240) U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP99 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP99 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
+#endif
diff --git a/board/ar7240/ap99-ivi/config.mk b/board/ar7240/ap99-ivi/config.mk
new file mode 100755
index 0000000000..7e602fd66a
--- /dev/null
+++ b/board/ar7240/ap99-ivi/config.mk
@@ -0,0 +1,13 @@
+# ROM version
+
+ifeq ($(COMPRESSED_UBOOT),1)
+# change the text base to ram address
+TEXT_BASE = 0x80010000
+# set to BOOTSTRAP text base to cached base address
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap99-ivi/flash.c b/board/ar7240/ap99-ivi/flash.c
new file mode 100644
index 0000000000..eec58f6b39
--- /dev/null
+++ b/board/ar7240/ap99-ivi/flash.c
@@ -0,0 +1,38 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+#ifndef COMPRESSED_UBOOT
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else 
+#endif
+    {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap99-ivi/u-boot-bootstrap.lds b/board/ar7240/ap99-ivi/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..2f01270d05
--- /dev/null
+++ b/board/ar7240/ap99-ivi/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap99-ivi/u-boot.lds b/board/ar7240/ap99-ivi/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap99-ivi/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap99-small/Makefile b/board/ar7240/ap99-small/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap99-small/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap99-small/ap99-small.c b/board/ar7240/ap99-small/ap99-small.c
new file mode 100644
index 0000000000..95c52df1a8
--- /dev/null
+++ b/board/ar7240/ap99-small/ap99-small.c
@@ -0,0 +1,71 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004); 
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP99 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP99 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap99-small/config.mk b/board/ar7240/ap99-small/config.mk
new file mode 100644
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap99-small/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap99-small/flash.c b/board/ar7240/ap99-small/flash.c
new file mode 100644
index 0000000000..3884a2e528
--- /dev/null
+++ b/board/ar7240/ap99-small/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap99-small/u-boot.lds b/board/ar7240/ap99-small/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap99-small/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap99-test/ap99-test.c b/board/ar7240/ap99-test/ap99-test.c
new file mode 100644
index 0000000000..95c52df1a8
--- /dev/null
+++ b/board/ar7240/ap99-test/ap99-test.c
@@ -0,0 +1,71 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004); 
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP99 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP99 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap99/Makefile b/board/ar7240/ap99/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap99/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap99/ap99.c b/board/ar7240/ap99/ap99.c
new file mode 100644
index 0000000000..bb726f8441
--- /dev/null
+++ b/board/ar7240/ap99/ap99.c
@@ -0,0 +1,86 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#ifndef COMPRESSED_UBOOT
+        ar7240_ddr_tap_init();
+#endif
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+#ifndef COMPRESSED_UBOOT
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    if ((is_ar7241() || is_ar7242()))
+        strcpy(board_string, "AP99 (ar7241 - Virian) Compressed U-boot");
+    else
+        strcpy(board_string, "AP99 (ar7240 - Python) Compressed U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP99 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP99 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
+#endif
diff --git a/board/ar7240/ap99/config.mk b/board/ar7240/ap99/config.mk
new file mode 100755
index 0000000000..e485e03667
--- /dev/null
+++ b/board/ar7240/ap99/config.mk
@@ -0,0 +1,13 @@
+# ROM version
+
+ifeq ($(COMPRESSED_UBOOT),1)
+# change the text base to ram address
+TEXT_BASE = 0x80310000
+# set to BOOTSTRAP text base to cached base address
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap99/flash.c b/board/ar7240/ap99/flash.c
new file mode 100644
index 0000000000..eec58f6b39
--- /dev/null
+++ b/board/ar7240/ap99/flash.c
@@ -0,0 +1,38 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+#ifndef COMPRESSED_UBOOT
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else 
+#endif
+    {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap99/u-boot-bootstrap.lds b/board/ar7240/ap99/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap99/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap99/u-boot.lds b/board/ar7240/ap99/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap99/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/aph126/Makefile b/board/ar7240/aph126/Makefile
new file mode 100644
index 0000000000..6898bc08b5
--- /dev/null
+++ b/board/ar7240/aph126/Makefile
@@ -0,0 +1,62 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifdef BOOT_FROM_NAND
+OBJS	+= ../common/ath_nand_flash.o 
+else
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif 
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/aph126/aph126.c b/board/ar7240/aph126/aph126.c
new file mode 100644
index 0000000000..e27108f88e
--- /dev/null
+++ b/board/ar7240/aph126/aph126.c
@@ -0,0 +1,163 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+	/*  Enable xLNBIAS signal on GPIO (19, 20) */
+	ar7240_reg_wr (AR7240_GPIO_FUNC4, ((ar7240_reg_rd(AR7240_GPIO_FUNC4) & 0x00ffffff)) | 0x2f000000);
+	ar7240_reg_wr (AR7240_GPIO_FUNC5, ((ar7240_reg_rd(AR7240_GPIO_FUNC5) & 0xffffff00)) | 0x2e);
+	ar7240_reg_wr (AR7240_GPIO_OE, (ar7240_reg_rd(AR7240_GPIO_OE) & 0xffe7ffff));
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+	ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */ 
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/aph126/config.mk b/board/ar7240/aph126/config.mk
new file mode 100644
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/aph126/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/aph126/flash.c b/board/ar7240/aph126/flash.c
new file mode 100644
index 0000000000..48f3df09bd
--- /dev/null
+++ b/board/ar7240/aph126/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/aph126/u-boot-bootstrap.lds b/board/ar7240/aph126/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/aph126/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/aph126/u-boot.lds b/board/ar7240/aph126/u-boot.lds
new file mode 100644
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/aph126/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/aph128/Makefile b/board/ar7240/aph128/Makefile
new file mode 100644
index 0000000000..6898bc08b5
--- /dev/null
+++ b/board/ar7240/aph128/Makefile
@@ -0,0 +1,62 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifdef BOOT_FROM_NAND
+OBJS	+= ../common/ath_nand_flash.o 
+else
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif 
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/aph128/aph128.c b/board/ar7240/aph128/aph128.c
new file mode 100644
index 0000000000..0813b313bc
--- /dev/null
+++ b/board/ar7240/aph128/aph128.c
@@ -0,0 +1,175 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+	/*  Enable xLNBIAS signal on GPIO (19, 20) */
+	ar7240_reg_wr (AR7240_GPIO_FUNC4, ((ar7240_reg_rd(AR7240_GPIO_FUNC4) & 0x00ffffff)) | 0x2f000000);
+	ar7240_reg_wr (AR7240_GPIO_FUNC5, ((ar7240_reg_rd(AR7240_GPIO_FUNC5) & 0xffffff00)) | 0x2e);
+	ar7240_reg_wr (AR7240_GPIO_OE, (ar7240_reg_rd(AR7240_GPIO_OE) & 0xffe7ffff));
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+#if !defined(CONFIG_ATH_NAND_BR)
+	if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+		if (type == 2) {
+			// ddr1
+			ar7240_reg_wr_nf(0x18116c44, 0x10000000); /* AR_PHY_PMU2 */
+		} else {
+			// ddr2 & sdram
+			ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+		}
+	} else {
+		ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+	}
+#endif
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */ 
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/aph128/config.mk b/board/ar7240/aph128/config.mk
new file mode 100644
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/aph128/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/aph128/flash.c b/board/ar7240/aph128/flash.c
new file mode 100644
index 0000000000..48f3df09bd
--- /dev/null
+++ b/board/ar7240/aph128/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/aph128/u-boot-bootstrap.lds b/board/ar7240/aph128/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/aph128/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/aph128/u-boot.lds b/board/ar7240/aph128/u-boot.lds
new file mode 100644
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/aph128/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ar7240_emu/Makefile b/board/ar7240/ar7240_emu/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ar7240_emu/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ar7240_emu/ar7240_emu.c b/board/ar7240/ar7240_emu/ar7240_emu.c
new file mode 100644
index 0000000000..d5bdfaa384
--- /dev/null
+++ b/board/ar7240/ar7240_emu/ar7240_emu.c
@@ -0,0 +1,144 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x00001030);
+}
+
+int
+ar7240_mem_config()
+{
+    uint32_t  ddr_config, ddr_config2;
+    int i;
+#if 0
+    ar7240_ddr_width_t width;
+#endif
+
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+#if 0
+    ar7240_ddr_tap_config();
+#else
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x5);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x5);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+#endif
+
+#if 0
+    ddr_config   = ar7240_reg_rd(AR7240_DDR_CONFIG);
+    ddr_config2  = ar7240_reg_rd(AR7240_DDR_CONFIG2);
+    width        = ar7240_ddr_get_width();
+
+    if (width != AR7240_DDR_32B)
+        ddr_config |= AR7240_DDR_CONFIG_16BIT;
+    if (width == AR7240_DDR_16B_HIGH)
+        ddr_config2 &= ~AR7240_DDR_CONFIG2_HALF_WIDTH_L;
+
+    ddr_config2 &= ~((0x1f << AR7240_DDR_CONFIG2_TRTW_SHIFT) |
+                     (0x1f << AR7240_DDR_CONFIG2_TWTR_SHIFT) |
+                      0xf);
+
+    ddr_config2 |= ((CFG_DDR_TRTW_VAL << AR7240_DDR_CONFIG2_TRTW_SHIFT) |
+                    (CFG_DDR_TWTR_VAL << AR7240_DDR_CONFIG2_TWTR_SHIFT) |
+                    AR7240_DDR_CONFIG2_BL2);
+    /*
+     * XXX These bits are reserved...
+     */
+    ddr_config2 |= (1 << 26)|(1 << 27)|(1 << 30);
+
+    printf("programming config1 %#x, config2 %#x\n", ddr_config, ddr_config2);
+
+    ar7240_reg_wr(AR7240_DDR_CONFIG, ddr_config);
+    ar7240_reg_wr(AR7240_DDR_CONFIG2, ddr_config2);
+#endif
+
+    /* XXX - these don't really belong here!
+    *(volatile unsigned int *)0xb8050004 = 0x00001032;
+    udelay(100);
+*/
+#if 0
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+
+    *(volatile unsigned int *)0xb805001c = 0x00000909;
+    udelay(100);
+
+    *(volatile unsigned int *)0xb8050014 = 0x14000044;
+    udelay(100);
+#endif
+#if 0
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(1 << 25));
+    *(volatile int *)0xb8050004 = i;
+    while ((*(volatile int *)0xb8050004) & (1 << 17));
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(1 << 16));
+    *(volatile int *)0xb8050004 = i;
+    while ((*(volatile int *)0xb8050004) & (1 << 17));
+
+    i = *(volatile int *)0xb8050004;
+    i = i | (0x3f << 19);
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    *(volatile int *)0xb8050014 = 0x13000a44;
+/*
+    *(volatile int *)0xb8050014 = 0x13000044;
+    *(volatile int *)0xb8050014 = 0x13111321;
+    *(volatile int *)0xb8050014 = 0x00111321;
+    *(volatile int *)0xb8050014 = 0x00001344;
+    *(volatile int *)0xb8050014 = 0x14000044;
+    *(volatile int *)0xb8050014 = 0x14000f44;
+    *(volatile int *)0xb8050014 = 0x00001044;
+    *(volatile int *)0xb8050014 = 0x14001044;
+    *(volatile int *)0xb8050014 = 0x14001f44;
+    *(volatile int *)0xb8050014 = 0x1f001044;
+    *(volatile int *)0xb8050014 = 0x1f001f44;
+*/
+
+    *(volatile int *)0xb805001c = 0x00000909;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(0x3b << 19));
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i | (0x3 << 20);
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(0x3 << 20));
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    /* Temp addition - check with Ravi */
+    *(volatile unsigned int *)0xb8080008 = 0x00000040;
+    udelay(100);
+#endif
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("Python Emulation (ar7240) U-boot\n");
+	return 0;
+}
diff --git a/board/ar7240/ar7240_emu/config.mk b/board/ar7240/ar7240_emu/config.mk
new file mode 100755
index 0000000000..f110fcb6ff
--- /dev/null
+++ b/board/ar7240/ar7240_emu/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ar7240_emu/flash.c b/board/ar7240/ar7240_emu/flash.c
new file mode 100644
index 0000000000..48f3df09bd
--- /dev/null
+++ b/board/ar7240/ar7240_emu/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ar7240_emu/u-boot.lds b/board/ar7240/ar7240_emu/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ar7240_emu/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/common/ar7240_flash.c b/board/ar7240/common/ar7240_flash.c
new file mode 100644
index 0000000000..06f234cfdf
--- /dev/null
+++ b/board/ar7240/common/ar7240_flash.c
@@ -0,0 +1,249 @@
+#include <common.h>
+#include <jffs2/jffs2.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7240_soc.h"
+#include "ar7240_flash.h"
+
+/*
+ * globals
+ */
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+#undef display
+#define display(x)  ;
+
+/*
+ * statics
+ */
+static void ar7240_spi_write_enable(void);
+static void ar7240_spi_poll(void);
+#if !defined(ATH_SST_FLASH)
+static void ar7240_spi_write_page(uint32_t addr, uint8_t * data, int len);
+#endif
+static void ar7240_spi_sector_erase(uint32_t addr);
+
+static void
+ath_spi_read_id(void)
+{
+	u32 rd = 0x777777;
+
+	ar7240_reg_wr_nf(AR7240_SPI_WRITE, AR7240_SPI_CS_DIS);
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_RDID);
+	ar7240_spi_delay_8();
+	ar7240_spi_delay_8();
+	ar7240_spi_delay_8();
+	ar7240_spi_go();
+
+	rd = ar7240_reg_rd(AR7240_SPI_RD_STATUS);
+
+	printf("Flash Manuf Id 0x%x, DeviceId0 0x%x, DeviceId1 0x%x\n",
+		(rd >> 16) & 0xff, (rd >> 8) & 0xff, (rd >> 0) & 0xff);
+}
+
+
+#ifdef ATH_SST_FLASH
+void ar7240_spi_flash_unblock(void)
+{
+	ar7240_spi_write_enable();
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_WRITE_SR);
+	ar7240_spi_bit_banger(0x0);
+	ar7240_spi_go();
+	ar7240_spi_poll();
+}
+#endif
+
+unsigned long flash_init(void)
+{
+#ifndef CONFIG_WASP
+#ifdef ATH_SST_FLASH
+	ar7240_reg_wr_nf(AR7240_SPI_CLOCK, 0x3);
+	ar7240_spi_flash_unblock();
+	ar7240_reg_wr(AR7240_SPI_FS, 0);
+#else
+	ar7240_reg_wr_nf(AR7240_SPI_CLOCK, 0x43);
+#endif
+#endif
+	ar7240_reg_rmw_set(AR7240_SPI_FS, 1);
+	ath_spi_read_id();
+	ar7240_reg_rmw_clear(AR7240_SPI_FS, 1);
+
+	/*
+	 * hook into board specific code to fill flash_info
+	 */
+	return (flash_get_geom(&flash_info[0]));
+}
+
+void
+flash_print_info(flash_info_t *info)
+{
+	printf("The hell do you want flinfo for??\n");
+}
+
+int
+flash_erase(flash_info_t *info, int s_first, int s_last)
+{
+	int i, sector_size = info->size / info->sector_count;
+
+#ifdef FLASH_DEBUG
+	printf("\nFirst %#x last %#x sector size %#x\n",
+	       s_first, s_last, sector_size);
+#endif
+
+	for (i = s_first; i <= s_last; i++) {
+#ifdef FLASH_DEBUG
+		printf("\b\b\b\b%4d", i);
+#else
+		puts(".");
+#endif
+		ar7240_spi_sector_erase(i * sector_size);
+	}
+	ar7240_spi_done();
+	printf("\n");
+
+	return 0;
+}
+
+/*
+ * Write a buffer from memory to flash:
+ * 0. Assumption: Caller has already erased the appropriate sectors.
+ * 1. call page programming for every 256 bytes
+ */
+#ifdef ATH_SST_FLASH
+void
+ar7240_spi_flash_chip_erase(void)
+{
+	ar7240_spi_write_enable();
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_CHIP_ERASE);
+	ar7240_spi_go();
+	ar7240_spi_poll();
+}
+
+int
+write_buff(flash_info_t *info, uchar *src, ulong dst, ulong len)
+{
+	uint32_t val;
+
+	dst = dst - CFG_FLASH_BASE;
+	printf("write len: %lu dst: 0x%x src: %p\n", len, dst, src);
+
+	for (; len; len--, dst++, src++) {
+		ar7240_spi_write_enable();	// dont move this above 'for'
+		ar7240_spi_bit_banger(AR7240_SPI_CMD_PAGE_PROG);
+		ar7240_spi_send_addr(dst);
+
+		val = *src & 0xff;
+		ar7240_spi_bit_banger(val);
+
+		ar7240_spi_go();
+		ar7240_spi_poll();
+	}
+	/*
+	 * Disable the Function Select
+	 * Without this we can't read from the chip again
+	 */
+	ar7240_reg_wr(AR7240_SPI_FS, 0);
+
+	if (len) {
+		// how to differentiate errors ??
+		return ERR_PROG_ERROR;
+	} else {
+		return ERR_OK;
+	}
+}
+#else
+int
+write_buff(flash_info_t *info, uchar *source, ulong addr, ulong len)
+{
+	int total = 0, len_this_lp, bytes_this_page, counter = 0;
+	ulong dst;
+	uchar *src;
+
+#ifdef FLASH_DEBUG
+	printf("write addr: %x\n", addr);
+#endif
+	addr = addr - CFG_FLASH_BASE;
+
+	while (total < len) {
+		src = source + total;
+		dst = addr + total;
+		bytes_this_page =
+		    AR7240_SPI_PAGE_SIZE - (addr & AR7240_SPI_PAGE_SIZE-1);
+		len_this_lp =
+		    ((len - total) >
+		     bytes_this_page) ? bytes_this_page : (len - total);
+		ar7240_spi_write_page(dst, src, len_this_lp);
+		total += len_this_lp;
+		if(counter>=255)
+		{
+			puts(".");
+			counter = 0;
+		}
+		else
+		{
+			counter++;
+		}
+	}
+
+	ar7240_spi_done();
+
+	return 0;
+}
+#endif
+
+static void
+ar7240_spi_write_enable()
+{
+	ar7240_reg_wr_nf(AR7240_SPI_FS, 1);
+	ar7240_reg_wr_nf(AR7240_SPI_WRITE, AR7240_SPI_CS_DIS);
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_WREN);
+	ar7240_spi_go();
+}
+
+static void
+ar7240_spi_poll()
+{
+	int rd;
+
+	do {
+		ar7240_reg_wr_nf(AR7240_SPI_WRITE, AR7240_SPI_CS_DIS);
+		ar7240_spi_bit_banger(AR7240_SPI_CMD_RD_STATUS);
+		ar7240_spi_delay_8();
+		rd = (ar7240_reg_rd(AR7240_SPI_RD_STATUS) & 1);
+	} while (rd);
+}
+
+#if !defined(ATH_SST_FLASH)
+static void
+ar7240_spi_write_page(uint32_t addr, uint8_t *data, int len)
+{
+	int i;
+	uint8_t ch;
+
+	display(0x77);
+	ar7240_spi_write_enable();
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_PAGE_PROG);
+	ar7240_spi_send_addr(addr);
+
+	for (i = 0; i < len; i++) {
+		ch = *(data + i);
+		ar7240_spi_bit_banger(ch);
+	}
+
+	ar7240_spi_go();
+	display(0x66);
+	ar7240_spi_poll();
+	display(0x6d);
+}
+#endif
+
+static void
+ar7240_spi_sector_erase(uint32_t addr)
+{
+	ar7240_spi_write_enable();
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_SECTOR_ERASE);
+	ar7240_spi_send_addr(addr);
+	ar7240_spi_go();
+	display(0x7d);
+	ar7240_spi_poll();
+}
diff --git a/board/ar7240/common/ar7240_flash.h b/board/ar7240/common/ar7240_flash.h
new file mode 100644
index 0000000000..de6aae7acf
--- /dev/null
+++ b/board/ar7240/common/ar7240_flash.h
@@ -0,0 +1,64 @@
+#ifndef _FLASH_H
+#define _FLASH_H
+
+#include "ar7240_soc.h"
+
+#define AR7240_SPI_FS           0x1f000000
+#define AR7240_SPI_CLOCK        0x1f000004
+#define AR7240_SPI_WRITE        0x1f000008
+#define AR7240_SPI_READ         0x1f000000
+#define AR7240_SPI_RD_STATUS    0x1f00000c
+
+#define AR7240_SPI_CS_DIS       0x70000
+#define AR7240_SPI_CE_LOW       0x60000
+#define AR7240_SPI_CE_HIGH      0x60100
+
+#define AR7240_SPI_CMD_WRITE_SR     0x01
+#define AR7240_SPI_CMD_WREN         0x06
+#define AR7240_SPI_CMD_RD_STATUS    0x05
+#define AR7240_SPI_CMD_FAST_READ    0x0b
+#define AR7240_SPI_CMD_PAGE_PROG    0x02
+#define AR7240_SPI_CMD_SECTOR_ERASE 0xd8
+#define AR7240_SPI_CMD_CHIP_ERASE   0xc7
+#define AR7240_SPI_CMD_RDID         0x9f
+
+#define AR7240_SPI_SECTOR_SIZE      (1024*64)
+#define AR7240_SPI_PAGE_SIZE        256
+
+
+#define display(_x)     ar7240_reg_wr_nf(0x18040008, (_x))
+
+/*
+ * primitives
+ */
+
+#define ar7240_be_msb(_val, _i) (((_val) & (1 << (7 - _i))) >> (7 - _i))
+
+#define ar7240_spi_bit_banger(_byte)  do {        \
+    int i;                                      \
+    for(i = 0; i < 8; i++) {                    \
+        ar7240_reg_wr_nf(AR7240_SPI_WRITE,      \
+                        AR7240_SPI_CE_LOW | ar7240_be_msb(_byte, i));  \
+        ar7240_reg_wr_nf(AR7240_SPI_WRITE,      \
+                        AR7240_SPI_CE_HIGH | ar7240_be_msb(_byte, i)); \
+    }       \
+}while(0);
+
+#define ar7240_spi_go() do {        \
+    ar7240_reg_wr_nf(AR7240_SPI_WRITE, AR7240_SPI_CE_LOW); \
+    ar7240_reg_wr_nf(AR7240_SPI_WRITE, AR7240_SPI_CS_DIS); \
+}while(0);
+
+
+#define ar7240_spi_send_addr(__a) do {			\
+    ar7240_spi_bit_banger(((__a & 0xff0000) >> 16));	\
+    ar7240_spi_bit_banger(((__a & 0x00ff00) >> 8));	\
+    ar7240_spi_bit_banger(__a & 0x0000ff);		\
+} while (0)
+
+#define ar7240_spi_delay_8()    ar7240_spi_bit_banger(0)
+#define ar7240_spi_done()       ar7240_reg_wr_nf(AR7240_SPI_FS, 0)
+
+extern unsigned long flash_get_geom (flash_info_t *flash_info);
+
+#endif /*_FLASH_H*/
diff --git a/board/ar7240/common/ar7240_pci.c b/board/ar7240/common/ar7240_pci.c
new file mode 100644
index 0000000000..26ead23f64
--- /dev/null
+++ b/board/ar7240/common/ar7240_pci.c
@@ -0,0 +1,584 @@
+/*****************************************************************************/
+/*! file ap93_pci.c
+** /brief PCI support for AP91/93 board
+**
+**  This provides the support code required for PCI support on the AP91/93
+**  board in the U-Boot environment.  This board is a Python based system
+**  with a Merlin WLAN interface.  This file also contains the support
+**  for initialization of the Merlin radios on the PCi bus, required for
+**  pre-configuration for use by Linux.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <pci.h>
+#include "ar7240_soc.h"
+
+/*
+** PCI controller "hose" value
+*/
+
+static struct pci_controller hose;
+
+static int  ar7240_local_read_config(int where, int size, uint32_t *value);
+static int  ar7240_local_write_config(int where, int size, uint32_t value);
+
+static int
+ar7240_local_read_config(int where, int size, uint32_t *value)
+{
+    *value = ar7240_reg_rd(AR7240_PCI_CRP + where);
+    return 0;
+}
+
+static int
+ar7240_local_write_config(int where, int size, uint32_t value)
+{
+    ar7240_reg_wr((AR7240_PCI_CRP + where),value);
+    return 0;
+}
+
+static int
+ar7240_pci_read_config(struct pci_controller *hose,
+                           pci_dev_t dev, int where, uint32_t *value)
+{
+        *value = ar7240_reg_rd(AR7240_PCI_DEV_CFGBASE + where);
+        return 0;
+}
+
+static int
+ar7240_pci_write_config(struct pci_controller *hose,
+                           pci_dev_t dev, int where,  uint32_t value)
+{
+        ar7240_reg_wr((AR7240_PCI_DEV_CFGBASE + where),value);
+        return 0;
+}
+
+/*
+** We will use the ART configuration information stored in flash to initialize
+** these devices as required.
+*/
+
+void plat_dev_init(void)
+{
+    u32     val;
+    u32     addr;
+    u32     BaseAddr = 0x10000000;
+    u32     CalAddr = WLANCAL;
+    volatile u16     *calData;
+
+    /*
+     * Copy the device ID from Flash to device config space.
+     */
+
+    calData = (u16 *)CalAddr;
+
+#ifndef CONFIG_PCI_CONFIG_DATA_IN_OTP
+    if(calData[0] != 0xa55a && calData[0] != 0x5aa5  )
+    {
+        /*
+        ** Board is not calibrated.
+        */
+#ifndef COMPRESSED_UBOOT
+        printf("BOARD IS NOT CALIBRATED!!!\n");
+#endif
+        return;
+    }
+#else
+    return;
+#endif
+    /*
+    ** Need to setup the PCI device to access the internal registers
+    */
+    if ((is_ar7241() || is_ar7242()))
+        ar7240_pci_write_config(&hose, NULL, 0x10, 0x1000ffff);
+    else
+        ar7240_pci_write_config(&hose, NULL, 0x10, 0xffff);
+
+    ar7240_pci_write_config(&hose, NULL, 0x04, 0x6);
+
+    /*
+    ** Set pointer to first reg address
+    */
+
+    calData += AR7240_ART_PCICFG_OFFSET;
+
+    while(*calData != 0xffff)
+    {
+        u16 cd;
+
+        cd = *calData++;
+        addr = BaseAddr + cd;
+        val  = *calData++;
+        val |= (*calData++) << 16;
+
+        ar7240_reg_wr_nf(addr,val);
+        udelay(100);
+    }
+
+    return;
+}
+
+
+/******************************************************************************/
+/*!
+**  \brief pci host initialization
+**
+**  Sets up the PCI controller on the host.  For AR7240 this may not be necessary,
+**  but this function is required for board support.
+**
+** We want a 1:1 mapping between PCI and DDR for inbound and outbound.
+** The PCI<---AHB decoding works as follows:
+**
+** 8 registers in the DDR unit provide software configurable 32 bit offsets
+** for each of the eight 16MB PCI windows in the 128MB. The offsets will be
+** added to any address in the 16MB segment before being sent to the PCI unit.
+**
+** Essentially  for any AHB address generated by the CPU,
+** 1. the MSB  four bits are stripped off, [31:28],
+** 2. Bit 27 is used to decide between the lower 128Mb (PCI) or the rest of
+**    the AHB space
+** 3. Bits 26:24 are used to access one of the 8 window registers and are
+**    masked off.
+** 4. If it is a PCI address, then the WINDOW offset in the WINDOW register
+**    corresponding to the next 3 bits (bit 26:24) is ADDED to the address,
+**    to generate the address to PCI unit.
+**
+**     eg. CPU address = 0x100000ff
+**         window 0 offset = 0x10000000
+**         This points to lowermost 16MB window in PCI space.
+**         So the resulting address would be 0x000000ff+0x10000000
+**         = 0x100000ff
+**
+**         eg2. CPU address = 0x120000ff
+**         WINDOW 2 offset = 0x12000000
+**         resulting address would be 0x000000ff+0x12000000
+**                         = 0x120000ff
+**
+** There is no translation for inbound access (PCI device as a master)
+**
+**  \return N/A
+*/
+
+#ifdef CONFIG_WASP_SUPPORT
+static int ar7240_pcibios_init(void)
+{
+        if (is_ar9341()) {
+                return 0;
+        }
+
+	if (((ar7240_reg_rd(AR7240_PCI_LCL_RESET)) & 0x1) == 0x0) {
+		printf("***** Warning *****: PCIe WLAN H/W not found !!!\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+#define pci_udelay(n)	do { uint32_t i; /* printf("--- %s[%d] udelay(%u)\n", __func__, __LINE__, n); */ for (i = 0; i < ((n)/10); i++) udelay(10); } while (0)
+
+char *
+__print_llx(unsigned long long u, char *num)
+{
+	char dec[] = "0123456789";
+	int i;
+
+	if (u == 0)	return "0";
+
+	memset(num, 0, 32);
+
+	for (i = 24; u; i--) {
+		num[i] = dec[u % 10];
+		u = u / 10;
+	}
+
+	return &num[i+1];
+}
+
+#define print_llx(n)	__print_llx(n, str_##n)
+
+#ifdef COMPRESSED_UBOOT
+int pci_init_board (void)
+#else
+void pci_init_board (void)
+#endif /* #ifdef COMPRESSED_UBOOT */
+{
+#ifdef CONFIG_AP123
+	return;
+#else
+	uint32_t cmd = 0, reg_val;
+
+
+	//printf("%s: PCIe PLL 0x%x\n", __func__, mips3_cp0_count_read());
+	//printf("%s: PCIe PLL 0x%x  0xb8000008 =  0x%08x\n", __func__, mips3_cp0_count_read(), ar7240_reg_rd(0xb8040008));
+
+	pci_udelay(100000);
+	//count ++;
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_PCIE_PLL_DITHER_DIV_MAX,
+			PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_SET(0) |
+			PCIE_PLL_DITHER_DIV_MAX_USE_MAX_SET(1) |
+			PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_SET(0x20) |
+			PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_SET(0));
+	} else {
+#ifndef COMPRESSED_UBOOT
+		printf("%s: PCIe PLL not set for 40MHz refclk\n", __func__);
+#endif
+	}
+
+	ar7240_reg_rmw_set(AR7240_RESET, AR7240_RESET_PCIE);	// core in reset
+	pci_udelay(10000);
+	ar7240_reg_rmw_set(AR7240_RESET, AR7240_RESET_PCIE_PHY);// phy in reset
+	pci_udelay(10000);
+	ar7240_reg_rmw_clear(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY_SET(1)); // pci phy analog in reset
+	pci_udelay(10000);
+	ar7240_reg_wr(0x180f0000, 0x1ffc0);			// ltssm is disabled
+	pci_udelay(100);
+	ar7240_reg_wr_nf(AR7240_PCI_LCL_RESET, 0);	// End point in reset
+	pci_udelay(100000);
+
+
+	//ar7240_reg_rmw_clear(AR7240_RESET, AR7240_RESET_PCIE_PHY);
+
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG,
+			PCIE_PLL_CONFIG_REFDIV_SET(1) |
+			PCIE_PLL_CONFIG_BYPASS_SET(1) |
+			PCIE_PLL_CONFIG_PLLPWD_SET(1));
+		pci_udelay(10000);
+		ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG,
+			PCIE_PLL_CONFIG_REFDIV_SET(1) |
+			PCIE_PLL_CONFIG_BYPASS_SET(1) |
+			PCIE_PLL_CONFIG_PLLPWD_SET(0));
+		pci_udelay(1000);
+		ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG,
+			ar7240_reg_rd(AR934X_PCIE_PLL_CONFIG) &
+			(~PCIE_PLL_CONFIG_BYPASS_SET(1)));
+		pci_udelay(1000);
+	} else {
+		ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG,
+			PCIE_PLL_CONFIG_REFDIV_SET(2) |
+			PCIE_PLL_CONFIG_BYPASS_SET(1) |
+			PCIE_PLL_CONFIG_PLLPWD_SET(1));
+		pci_udelay(10000);
+
+		if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+			ar7240_reg_wr_nf(0xb8116c00, (0x5 << 27) | (160 << 18) | 0);
+		} else {
+			ar7240_reg_wr_nf(0xb8116c00, (0x2 << 27) | (0x28 << 18) | 0);
+		}
+		do {
+			ar7240_reg_wr_nf(0xb8116c04, (0x1 << 30) | (0x4 << 26) | (0x32 << 19) | (1 << 16) | (3 << 13) | (0x1e << 7));
+			ar7240_reg_wr_nf(0xb8116c08, (6 << 23));
+			pci_udelay(10000);
+			ar7240_reg_wr_nf(0xb8116c04, (0x1 << 30) | (0x4 << 26) | (0x32 << 19) | (3 << 13) | (0x1e << 7));
+
+			ar7240_reg_rmw_clear(KSEG1ADDR(PCIe_DPLL3_ADDRESS), PCIe_DPLL3_DO_MEAS_SET(1));
+			ar7240_reg_rmw_set(KSEG1ADDR(PCIe_DPLL3_ADDRESS), PCIe_DPLL3_DO_MEAS_SET(1));
+
+			ar7240_reg_wr(0xb804000c, 1 << 2);
+
+			pci_udelay(1000);
+
+			while (((cmd = ar7240_reg_rd(PCIe_DPLL4_ADDRESS)) & PCIe_DPLL4_MEAS_DONE_SET(1)) == 0) {
+				printf("0x%x 0x%x 0x%x\n", KSEG1ADDR(PCIe_DPLL4_ADDRESS), cmd);
+				pci_udelay(10);
+			}
+
+			{ int i; for (i = 0; i < 100; i++) udelay(10); }
+#if 0
+			msdvc = PCIe_DPLL4_MEAN_DVC_GET(cmd);
+			cmd = PCIe_DPLL3_SQSUM_DVC_GET(ar7240_reg_rd(PCIe_DPLL3_ADDRESS));
+
+			if (msdvc & 0x400) msdvc = ((~msdvc & 0x7FF) + 1); /* 11 bit signed number , but not intentioanlly multiply by (-1), ASK VIPUL*/
+			msdvc =  cmd - (msdvc *msdvc);
+			msdvc_sq = msdvc * msdvc;
+
+			if (cmd >= 0x40000) {
+				err_count++;
+				if (sqsum_min_fail == 0)
+					sqsum_min_fail = cmd;
+				if (cmd > sqsum_max_fail)
+					sqsum_max_fail = cmd;
+				if (cmd < sqsum_min_fail)
+					sqsum_min_fail = cmd;
+				sqsum_avg_fail = (sqsum_avg_fail - (sqsum_avg_fail / err_count)) + (cmd / err_count);
+
+				if (num_pll_loops == 0)
+					err_pll1++;
+				if (num_pll_loops == 1)
+					err_pll2++;
+				if (num_pll_loops == 2)
+					err_pll3++;
+				if (num_pll_loops == 3)
+					err_pll4++;
+				if (num_pll_loops == 4) {
+					err_pll5++;
+					break;
+				}
+			} else {
+				if (sqsum_min == 0)
+					sqsum_min = cmd;
+				if (cmd < sqsum_min)
+					sqsum_min = cmd;
+				if (cmd > sqsum_max)
+					sqsum_max = cmd;
+				//sqsum_avg = (sqsum_avg - (sqsum_avg / count)) + (cmd / count);
+				sqsum_avg += cmd;
+
+				/*msdvc calc*/
+				if (msdvc_min == 0) msdvc_min = msdvc;
+				if (msdvc < msdvc_min) msdvc_min =msdvc;
+				if (msdvc > msdvc_max) msdvc_max =msdvc;
+				msdvc_avg += msdvc;
+				msdvc_sq_avg += msdvc_sq;
+
+			}
+			num_pll_loops++;
+#endif
+
+		} while ((cmd = PCIe_DPLL3_SQSUM_DVC_GET(ar7240_reg_rd(PCIe_DPLL3_ADDRESS))) >= 0x40000);
+
+		ar7240_reg_rmw_clear(AR934X_PCIE_PLL_CONFIG, PCIE_PLL_CONFIG_PLLPWD_SET(1));
+		pci_udelay(10000);
+		ar7240_reg_rmw_clear(AR934X_PCIE_PLL_CONFIG, PCIE_PLL_CONFIG_BYPASS_SET(1));
+		pci_udelay(10000);
+
+		/*
+		 * PCIe Dithering configuration
+		 */
+		if (is_ar934x_12_or_later()) {
+			ar7240_reg_wr_nf(PCIe_DPLL2_ADDRESS,
+					PCIe_DPLL2_LOCAL_PLL_SET(0) | 
+					PCIe_DPLL2_KI_SET(0x4)| 
+					PCIe_DPLL2_KD_SET(0x40));
+			ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG, 0x40010800);
+			ar7240_reg_wr_nf(AR934X_PCIE_PLL_DITHER_DIV_MAX, 0xc013fffe);
+			ar7240_reg_wr_nf(AR934X_PCIE_PLL_DITHER_DIV_MIN, 0x0013e666);
+
+			ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG, 0x00010800);  
+			ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG, 0x00000800);  
+		}
+
+		//run_command("md 0xb8116c00 4", 0);
+	}
+	ar7240_reg_rmw_set(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY_SET(1)); // pci phy analog out of reset
+	pci_udelay(10000);
+
+	ar7240_reg_rmw_clear(AR7240_RESET, AR7240_RESET_PCIE_PHY);	// phy out of reset
+	pci_udelay(10000);
+
+	ar7240_reg_rmw_clear(AR7240_RESET, AR7240_RESET_PCIE);	// core out of reset
+	pci_udelay(1000);
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+	      PCI_COMMAND_PARITY|PCI_COMMAND_SERR|PCI_COMMAND_FAST_BACK;
+
+	ar7240_local_write_config(PCI_COMMAND, 4, cmd);		// pci cmd reg init
+	ar7240_local_write_config(0x20, 4, 0x1ff01000);		// membase setting
+	ar7240_local_write_config(0x24, 4, 0x1ff01000);		// prefetch membase setting
+
+
+	if ((is_ar7241() || is_ar7242() || is_wasp())) {
+		ar7240_reg_wr(0x180f0000, 0x1ffc1);		// ltssm enable
+	} else {
+		ar7240_reg_wr(0x180f0000, 0x1);
+	}
+	pci_udelay(100000);
+
+	ar7240_reg_wr_nf(AR7240_PCI_LCL_RESET, 4);		// EP out of reset
+	pci_udelay(100000);
+
+
+#ifdef COMPRESSED_UBOOT
+	pci_udelay(100);
+#else
+	/*
+	 *  Delay increased from 100 to 1000, so as to
+	 *  get the correct status from PCI LCL RESET register
+	 */
+	pci_udelay(100000);
+
+	/*
+	 * Check if the WLAN PCI-E H/W is present, If the
+	 * WLAN H/W is not present, skip the PCI platform
+	 * initialization code and return
+	 */
+
+#ifdef CONFIG_SHUTDOWN_PCIE_USB
+    printf("Shutdown PCIE and USB!\n");
+    ar7240_reg_wr(0xb806001c, 0x2404c8f8);
+    pci_udelay(10000);
+
+    ar7240_reg_wr(0xb8030008, 0x00000001);
+    pci_udelay(10000);
+
+	ar7240_reg_wr(0xb80600bc, 0x00080000);
+	pci_udelay(10000);
+	ar7240_reg_wr(0xb8116cc0, 0x1061060e);
+	pci_udelay(10000);
+	ar7240_reg_wr(0xb8116d00, 0x1061060e);
+	pci_udelay(10000);
+	ar7240_reg_wr(0xb8116d08, 0x00005c0c);
+	pci_udelay(10000);
+#endif
+
+	if (((ar7240_reg_rd(AR7240_PCI_LCL_RESET)) & 0x1) == 0x0) {
+		printf("*** Warning *** : PCIe WLAN Module not found !!!\n");
+		return;
+	}
+#endif
+
+#ifndef COMPRESSED_UBOOT
+	/*
+	 * Now, configure for u-boot tools
+	 */
+
+	hose.first_busno = 0;
+	hose.last_busno = 0xff;
+
+	/* System space */
+	pci_set_region(	&hose.regions[0],
+			0x80000000,
+			0x00000000,
+			32 * 1024 * 1024,
+			PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region(	&hose.regions[1],
+			0x10000000,
+			0x10000000,
+			128 * 1024 * 1024,
+			PCI_REGION_MEM);
+
+	hose.region_count = 2;
+
+	pci_register_hose(&hose);
+
+	pci_set_ops(	&hose,
+			pci_hose_read_config_byte_via_dword,
+			pci_hose_read_config_word_via_dword,
+			ar7240_pci_read_config,
+			pci_hose_write_config_byte_via_dword,
+			pci_hose_write_config_word_via_dword,
+			ar7240_pci_write_config);
+#endif
+	plat_dev_init();
+#endif	// CONFIG_AP123
+#ifdef COMPRESSED_UBOOT
+	return 0;
+#endif
+}
+#else
+// For non - wasp
+#ifdef COMPRESSED_UBOOT
+int pci_init_board (void)
+#else
+void pci_init_board (void)
+#endif /* #ifdef COMPRESSED_UBOOT */
+{
+	uint32_t cmd;
+
+
+	ar7240_reg_rmw_clear(AR7240_RESET,AR7240_RESET_PCIE_PHY_SERIAL);
+	udelay(100);
+
+	ar7240_reg_rmw_clear(AR7240_RESET, AR7240_RESET_PCIE_PHY);
+
+
+	ar7240_reg_rmw_clear(AR7240_RESET, AR7240_RESET_PCIE);
+
+	ar7240_reg_wr_nf(AR7240_PCI_LCL_RESET, 0);
+	udelay(100000);
+
+	/*
+	 * Initialize PCIE PLL and get it out of RESET
+	 */
+	ar7240_reg_wr(AR7240_PCIE_PLL_CONFIG,0x02050800);
+
+	ar7240_reg_wr(AR7240_PCIE_PLL_CONFIG,0x00050800);
+	udelay(100);
+
+	ar7240_reg_wr(AR7240_PCIE_PLL_CONFIG,0x00040800);
+	udelay(100000);
+
+	ar7240_reg_wr_nf(AR7240_PCI_LCL_RESET, 4);
+	udelay(100000);
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+	      PCI_COMMAND_PARITY|PCI_COMMAND_SERR|PCI_COMMAND_FAST_BACK;
+
+	ar7240_local_write_config(PCI_COMMAND, 4, cmd);
+	ar7240_local_write_config(0x20, 4, 0x1ff01000);
+	ar7240_local_write_config(0x24, 4, 0x1ff01000);
+
+	if ((is_ar7241() || is_ar7242() || is_wasp())) {
+		ar7240_reg_wr(0x180f0000, 0x1ffc1);
+	} else {
+		ar7240_reg_wr(0x180f0000, 0x1);
+	}
+
+#ifdef COMPRESSED_UBOOT
+	udelay(100);
+#else
+	udelay(1000);
+
+	/*
+	 * Check if the WLAN PCI-E H/W is present, If the
+	 * WLAN H/W is not present, skip the PCI platform
+	 * initialization code and return
+	 */
+
+	if (((ar7240_reg_rd(AR7240_PCI_LCL_RESET)) & 0x1) == 0x0) {
+		printf("*** Warning *** : PCIe WLAN Module not found !!!\n");
+		return;
+	}
+#endif
+
+#ifndef COMPRESSED_UBOOT
+	/*
+	 * Now, configure for u-boot tools
+	 */
+
+	hose.first_busno = 0;
+	hose.last_busno = 0xff;
+
+	/* System space */
+	pci_set_region(	&hose.regions[0],
+			0x80000000,
+			0x00000000,
+			32 * 1024 * 1024,
+			PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region(	&hose.regions[1],
+			0x10000000,
+			0x10000000,
+			128 * 1024 * 1024,
+			PCI_REGION_MEM);
+
+	hose.region_count = 2;
+
+	pci_register_hose(&hose);
+
+	pci_set_ops(	&hose,
+			pci_hose_read_config_byte_via_dword,
+			pci_hose_read_config_word_via_dword,
+			ar7240_pci_read_config,
+			pci_hose_write_config_byte_via_dword,
+			pci_hose_write_config_word_via_dword,
+			ar7240_pci_write_config);
+#endif
+	plat_dev_init();
+#ifdef COMPRESSED_UBOOT
+	return 0;
+#endif
+}
+#endif /* CONFIG_WASP_SUPPORT */
diff --git a/board/ar7240/common/ar7240_s26_phy.c b/board/ar7240/common/ar7240_s26_phy.c
new file mode 100644
index 0000000000..4c5b2185b8
--- /dev/null
+++ b/board/ar7240/common/ar7240_s26_phy.c
@@ -0,0 +1,916 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "ar7240_s26_phy.h"
+
+
+/* PHY selections and access functions */
+
+typedef enum {
+    PHY_SRCPORT_INFO, 
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG, 
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+#define MODULE_NAME "ATHRS26"
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,     
+     0,
+     ATHR_PHY3_ADDR, 
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+    
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY4_ADDR, 
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+static uint8_t athr26_init_flag = 0,athr26_init_flag1 = 0;
+
+
+#define ATHR_GLOBALREGBASE    0
+
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+            
+/* Forward references */
+BOOL athrs26_phy_is_link_alive(int phyUnit);
+uint32_t athrs26_reg_read(uint32_t reg_addr);
+void athrs26_reg_write(uint32_t reg_addr, uint32_t reg_val);
+unsigned int s26_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+void s26_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data);
+
+
+void athrs26_powersave_off(int phy_addr)
+{
+    s26_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0x29);
+    s26_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x36c0);
+
+}
+void athrs26_sleep_off(int phy_addr)
+{
+    s26_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0xb);
+    s26_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x3c00);
+}
+
+void athrs26_reg_init(void)
+{
+
+#if S26_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+    uint32_t ar7240_revid;
+    /* if using header for register configuration, we have to     */
+    /* configure s26 register after frame transmission is enabled */
+
+    if (athr26_init_flag)
+        return;
+
+    ar7240_revid = ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK;
+    if(ar7240_revid == AR7240_REV_1_0) {
+#ifdef S26_FORCE_100M
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_FUNC_CONTROL,0x800);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0xa100);
+#endif
+
+#ifdef S26_FORCE_10M
+        athrs26_powersave_off(ATHR_PHY4_ADDR);
+        athrs26_sleep_off(ATHR_PHY4_ADDR);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_FUNC_CONTROL,0x800);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0x8100);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_ADDRESS,0x0);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_DATA,0x12ee);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_ADDRESS,0x3);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_DATA,0x3bf0);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0x8100);
+#endif
+    } else {
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0x9000);
+    }
+
+#if S26_PHY_DEBUG
+    rd_val = s26_rd_phy(ATHR_PHY4_ADDR,ATHR_PHY_FUNC_CONTROL);
+    printf("S26 PHY FUNC CTRL  (%d) :%x\n",ATHR_PHY4_ADDR, rd_val);
+    rd_val = s26_rd_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL);
+    printf("S26 PHY CTRL  (%d) :%x\n",ATHR_PHY4_ADDR, rd_val);
+#endif
+
+    athr26_init_flag = 1;
+}
+
+void athrs26_reg_init_lan(void)
+{
+    int i = 60;
+#if S26_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+    int       phyUnit;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+    uint32_t ar7240_revid;
+    
+    /* if using header for register configuration, we have to     */
+    /* configure s26 register after frame transmission is enabled */
+    if (athr26_init_flag1)
+        return;
+    
+    /* reset switch */
+    printf(MODULE_NAME ": resetting s26\n");
+    athrs26_reg_write(0x0, athrs26_reg_read(0x0)|0x80000000);
+
+    while(i--) {
+        if(!is_ar933x())
+    	    sysMsDelay(100);
+    	if(!(athrs26_reg_read(0x0)&0x80000000))
+    		break;
+    }
+    printf(MODULE_NAME ": s26 reset done\n");
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX - 1; phyUnit++) {
+
+    foundPhy = TRUE;
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    ar7240_revid = ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK;
+    if(ar7240_revid == AR7240_REV_1_0) {
+#ifdef S26_FORCE_100M 
+        /*
+         *  Force MDI and MDX to alternate ports 
+         *  Phy 0 and 2 -- MDI
+         *  Phy 1 and 3 -- MDX
+         */
+        if(phyUnit%2) 
+            s26_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+        else 
+            s26_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+
+        s26_wr_phy(phyAddr,ATHR_PHY_CONTROL,0xa100);
+#endif
+
+#ifdef S26_FORCE_10M
+        /*
+         *  Force MDI and MDX to alternate ports 
+         *  Phy 0 and 2 -- MDI
+         *  Phy 1 and 3 -- MDX
+         */
+        if(phyUnit%2) 
+            s26_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+        else
+            s26_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+
+        athrs26_powersave_off(phyAddr);
+        athrs26_sleep_off(phyAddr);
+
+        s26_wr_phy(phyAddr,ATHR_PHY_CONTROL,0x8100);
+        s26_wr_phy(phyAddr,ATHR_DEBUG_PORT_ADDRESS,0x0);
+        s26_wr_phy(phyAddr,ATHR_DEBUG_PORT_DATA,0x12ee);
+        s26_wr_phy(phyAddr,ATHR_DEBUG_PORT_ADDRESS,0x3);
+        s26_wr_phy(phyAddr,ATHR_DEBUG_PORT_DATA,0x3bf0);
+        s26_wr_phy(phyAddr,ATHR_PHY_CONTROL,0x8100);
+#endif
+    } else {
+        s26_wr_phy(phyAddr,ATHR_PHY_CONTROL,0x9000);
+    }
+
+#if S26_PHY_DEBUG
+    rd_val = s26_rd_phy(phyAddr,ATHR_PHY_ID1);
+    printf("S26 PHY ID  (%d) :%x\n",phyAddr,rd_val);
+    rd_val = s26_rd_phy(phyAddr,ATHR_PHY_CONTROL);
+    printf("S26 PHY CTRL  (%d) :%x\n",phyAddr,rd_val);
+    rd_val = s26_rd_phy(phyAddr,ATHR_PHY_STATUS);
+    printf("S26 ATHR PHY STATUS  (%d) :%x\n",phyAddr,rd_val);
+#endif
+    }
+    /* 
+     * CPU port Enable 
+     */
+    athrs26_reg_write(CPU_PORT_REGISTER,(1 << 8));
+
+    /* 
+     * status[1:0]=2'h2;   - (0x10 - 1000 Mbps , 0x0 - 10 Mbps)
+     * status[2]=1'h1;     - Tx Mac En
+     * status[3]=1'h1;     - Rx Mac En
+     * status[4]=1'h1;     - Tx Flow Ctrl En
+     * status[5]=1'h1;     - Rx Flow Ctrl En
+     * status[6]=1'h1;     - Duplex Mode
+     */
+#ifdef CONFIG_AR7240_EMU
+    athrs26_reg_write(PORT_STATUS_REGISTER0, 0x7e);  /* CPU Port */
+    athrs26_reg_write(PORT_STATUS_REGISTER1, 0x3c);
+    athrs26_reg_write(PORT_STATUS_REGISTER2, 0x3c);
+    athrs26_reg_write(PORT_STATUS_REGISTER3, 0x3c);
+    athrs26_reg_write(PORT_STATUS_REGISTER4, 0x3c);
+#else
+    athrs26_reg_write(PORT_STATUS_REGISTER1, 0x200);  /* LAN - 1 */
+    athrs26_reg_write(PORT_STATUS_REGISTER2, 0x200);  /* LAN - 2 */
+    athrs26_reg_write(PORT_STATUS_REGISTER3, 0x200);  /* LAN - 3 */
+    athrs26_reg_write(PORT_STATUS_REGISTER4, 0x200);  /* LAN - 4 */
+#endif
+
+    /* QM Control */
+    athrs26_reg_write(0x38, 0xc000050e);
+  
+    /*
+     * status[11]=1'h0;    - CPU Disable
+     * status[7] = 1'b1;   - Learn One Lock
+     * status[14] = 1'b0;  - Learn Enable
+     */
+#ifdef CONFIG_AR7240_EMU
+    athrs26_reg_write(PORT_CONTROL_REGISTER0, 0x04);
+    athrs26_reg_write(PORT_CONTROL_REGISTER1, 0x4004);
+#else
+   /* Atheros Header Disable */
+    athrs26_reg_write(PORT_CONTROL_REGISTER0, 0x4004);
+#endif
+
+   /* Tag Priority Mapping */
+    athrs26_reg_write(0x70, 0xfa50);
+
+   /* Enable ARP packets to CPU port */
+    athrs26_reg_write(S26_ARL_TBL_CTRL_REG,(athrs26_reg_read(S26_ARL_TBL_CTRL_REG) | 0x100000));
+
+#if S26_PHY_DEBUG
+    rd_val = athrs26_reg_read ( CPU_PORT_REGISTER );
+    printf("S26 CPU_PORT_REGISTER :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_STATUS_REGISTER0 );
+    printf("S26 PORT_STATUS_REGISTER0  :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_STATUS_REGISTER1 );
+    printf("S26 PORT_STATUS_REGISTER1  :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_STATUS_REGISTER2 );
+    printf("S26 PORT_STATUS_REGISTER2  :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_STATUS_REGISTER3 );
+    printf("S26 PORT_STATUS_REGISTER3  :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_STATUS_REGISTER4 );
+    printf("S26 PORT_STATUS_REGISTER4  :%x\n",rd_val);
+
+    rd_val = athrs26_reg_read ( PORT_CONTROL_REGISTER0 );
+    printf("S26 PORT_CONTROL_REGISTER0 :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_CONTROL_REGISTER1 );
+    printf("S26 PORT_CONTROL_REGISTER1 :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_CONTROL_REGISTER2 );
+    printf("S26 PORT_CONTROL_REGISTER2 :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_CONTROL_REGISTER3 );
+    printf("S26 PORT_CONTROL_REGISTER3 :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_CONTROL_REGISTER4 );
+    printf("S26 PORT_CONTROL_REGISTER4 :%x\n",rd_val);
+#endif
+
+    athr26_init_flag1 = 1;
+}
+static unsigned int phy_val_saved = 0;
+/******************************************************************************
+*
+* athrs26_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs26_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phyHwStatus = s26_rd_phy( phyAddr, ATHR_PHY_SPEC_STATUS);
+    
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs26_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs26_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+#if S26_PHY_DEBUG
+    uint32_t  rd_val = 0;
+#endif
+    uint32_t  ar7240_revid;
+    
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+       
+	s26_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+#if S26_PHY_DEBUG
+        rd_val = s26_rd_phy(phyAddr,ATHR_AUTONEG_ADVERT  );
+        printf("%s ATHR_AUTONEG_ADVERT %d :%x\n",__func__,phyAddr, rd_val);
+#endif
+
+    ar7240_revid = ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK;
+    if(ar7240_revid != AR7240_REV_1_0) {
+        s26_wr_phy( phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                      | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+#if S26_PHY_DEBUG
+        rd_val = s26_rd_phy(phyAddr,ATHR_AUTONEG_ADVERT  );
+        rd_val = s26_rd_phy(phyAddr,ATHR_PHY_CONTROL);
+        printf("%s ATHR_PHY_CONTROL %d :%x\n",__func__,phyAddr, rd_val);
+#endif
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+    
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    if(!is_ar933x()) {
+        if (ethUnit == ENET_UNIT_LAN)
+            sysMsDelay(1000);
+        else
+            sysMsDelay(3000);
+    }
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus =  s26_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            if(!is_ar933x())
+                sysMsDelay(150);
+        }
+
+
+#ifdef S26_VER_1_0
+        //turn off power saving
+       s26_wr_phy(phyUnit, 29, 41);
+       s26_wr_phy(phyUnit, 30, 0);
+       printf("def_ S26_VER_1_0\n");
+#endif
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit, 
+            s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS)));
+    }
+
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs26_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs26_phy_is_fdx(int ethUnit)
+{
+    int       phyUnit;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+                sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+            
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+
+/******************************************************************************
+*
+* athrs26_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               _10BASET, _100BASET;
+*               _1000BASET;
+*/
+
+int
+athrs26_phy_speed(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return _1000BASET;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+            do {
+	        phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+                sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+            
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                return _10BASET;
+            case 1:
+#ifdef CONFIG_MACH_HORNET
+                /* For IEEE 100M voltage test */
+                s26_wr_phy(phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x4);
+                s26_wr_phy(phyAddr, ATHR_DEBUG_PORT_DATA, 0xebbb);
+                s26_wr_phy(phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                s26_wr_phy(phyAddr, ATHR_DEBUG_PORT_DATA, 0x2c47);     
+#endif /* CONFIG_MACH_HORNET */
+                return _100BASET;
+            case 2:
+                return _1000BASET;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        }
+    }
+
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs26_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+
+            phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) { /* check realtime link */
+                linkCount++;
+            } else {
+                phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+            /* If realtime failed check link in latch register before
+             * asserting link down.
+             */
+                if (phyHwStatus & ATHR_LATCH_LINK_PASS)
+                   linkCount++;
+                else {
+                    lostLinks++;
+		}
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+
+            /* Check for reset complete */
+
+                phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+                phyHwControl = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_CONTROL);
+
+            /* Check for AutoNegotiation complete */ 
+           
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                    phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+                    if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                        gainedLinks++;
+                        linkCount++;
+                        DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                        lastStatus->isPhyAlive = TRUE;
+                   }  
+            }
+        }
+    }
+
+    return (linkCount);
+
+#if S26_PHY_DEBUG
+    if (linkCount == 0) {
+        if (lostLinks) {
+            /* We just lost the last link for this MAC */
+            phyLinkLost(ethUnit);
+        }
+    } else {
+        if (gainedLinks == linkCount) {
+            /* We just gained our first link(s) for this MAC */
+            phyLinkGained(ethUnit);
+        }
+    }
+#endif
+}
+
+uint32_t
+athrs26_reg_read(unsigned int s26_addr)
+{
+        unsigned int addr_temp;
+        unsigned int s26_rd_csr_low, s26_rd_csr_high, s26_rd_csr;
+        unsigned int data, unit = 0;
+        unsigned int phy_address, reg_address;
+
+        addr_temp = (s26_addr & 0xfffffffc) >>2;
+        data = addr_temp >> 7;
+
+        phy_address = 0x1f;
+        reg_address = 0x10;
+
+        if (is_ar7240()) {
+           unit = 0;
+        }
+        else if (is_ar7241() || is_ar7242() || is_ar933x()) {
+            unit = 1;
+        }
+
+        phy_reg_write(unit,phy_address, reg_address, data);
+
+        phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+        reg_address = ((addr_temp << 1) & 0x1e);
+        s26_rd_csr_low = (uint32_t) phy_reg_read(unit, phy_address, reg_address);
+
+        reg_address = reg_address | 0x1;
+        s26_rd_csr_high = (uint32_t) phy_reg_read(unit, phy_address, reg_address);
+        s26_rd_csr = (s26_rd_csr_high << 16) | s26_rd_csr_low ;
+
+        return(s26_rd_csr);
+}
+
+void
+athrs26_reg_write(unsigned int s26_addr, unsigned int s26_write_data)
+{
+        unsigned int addr_temp;
+        unsigned int data, unit = 0;
+        unsigned int phy_address, reg_address;
+
+
+        addr_temp = (s26_addr &  0xfffffffc) >>2;
+        data = addr_temp >> 7;
+
+        phy_address = 0x1f;
+        reg_address = 0x10;
+
+        if (is_ar7240()) {
+           unit = 0;
+        }
+        else if (is_ar7241() || is_ar7242()|| is_ar933x()) {
+            unit = 1;
+        }
+
+#ifdef CONFIG_MACH_HORNET
+        //The write sequence , 0x98: L->H, 0x40 H->L, 0x50 H->L , others should not care.
+        if(s26_addr!=0x98)
+        {
+            //printf("[%s:%d] unit=%d\n",__FUNCTION__,__LINE__,unit);
+            phy_reg_write(unit, phy_address, reg_address, data);
+
+            phy_address = 0x17 & ((addr_temp >> 4) | 0x10);
+            reg_address = ((addr_temp << 1) & 0x1e) | 0x1;
+            data =  s26_write_data >> 16;
+            phy_reg_write(unit, phy_address, reg_address, data);
+
+            reg_address = reg_address & 0x1e;
+            data = s26_write_data  & 0xffff;
+            phy_reg_write(unit, phy_address, reg_address, data);
+        }
+        else
+        {
+            phy_reg_write(unit, phy_address, reg_address, data);
+
+            phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+            reg_address = ((addr_temp << 1) & 0x1e);
+
+            data = s26_write_data  & 0xffff;
+            phy_reg_write(unit, phy_address, reg_address, data);
+
+            reg_address = (((addr_temp << 1) & 0x1e) | 0x1);
+            data = s26_write_data >> 16;
+            phy_reg_write(unit, phy_address, reg_address, data);
+
+        }
+#else
+        phy_reg_write(unit, phy_address, reg_address, data);
+
+        phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+        reg_address = ((addr_temp << 1) & 0x1e);
+        data = s26_write_data  & 0xffff;
+        phy_reg_write(unit, phy_address, reg_address, data);
+
+        reg_address = (((addr_temp << 1) & 0x1e) | 0x1);
+        data = s26_write_data >> 16;
+        phy_reg_write(unit, phy_address, reg_address, data);
+#endif
+}
+
+
+unsigned int s26_rd_phy(unsigned int phy_addr, unsigned int reg_addr)
+{
+
+         unsigned int rddata;
+
+        // MDIO_CMD is set for read
+
+        rddata = athrs26_reg_read(0x98);
+        rddata = (rddata & 0x0) | (reg_addr<<16) | (phy_addr<<21) | (1<<27) | (1<<30) | (1<<31) ;
+        athrs26_reg_write(0x98, rddata);
+
+        rddata = athrs26_reg_read(0x98);
+        rddata = rddata & (1<<31);
+
+        // Check MDIO_BUSY status
+        while(rddata){
+        rddata = athrs26_reg_read(0x98);
+        rddata = rddata & (1<<31);
+        }
+
+
+        // Read the data from phy
+
+        rddata = athrs26_reg_read(0x98) & 0xffff;
+
+        return(rddata);
+}
+
+void s26_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data)
+{
+         unsigned int rddata;
+
+        // MDIO_CMD is set for read
+
+      rddata = athrs26_reg_read(0x98);
+      rddata = (rddata & 0x0) | (write_data & 0xffff) | (reg_addr<<16) | (phy_addr<<21) | (0<<27) | (1<<30) | (1<<31) ;
+      athrs26_reg_write(0x98, rddata);
+
+      rddata = athrs26_reg_read(0x98);
+      rddata = rddata & (1<<31);
+
+        // Check MDIO_BUSY status
+      while(rddata){
+      rddata = athrs26_reg_read(0x98);
+      rddata = rddata & (1<<31);
+      }
+
+}
+
+int
+athrs26_mdc_check()
+{
+    int i;
+
+    for (i=0; i<4000; i++) {
+        if(athrs26_reg_read(0x10c) != 0x18007fff)
+            return -1;
+    }
+    return 0;
+}
+
diff --git a/board/ar7240/common/ar7240_s26_phy.h b/board/ar7240/common/ar7240_s26_phy.h
new file mode 100644
index 0000000000..a85ac9a461
--- /dev/null
+++ b/board/ar7240/common/ar7240_s26_phy.h
@@ -0,0 +1,121 @@
+#ifndef _ATHRS26_PHY_H
+#define _ATHRS26_PHY_H
+
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_FUNC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_LATCH_LINK_PASS                  0x0004 
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+/* S26 CSR Registers */
+
+#define PORT_STATUS_REGISTER0                0x0100 
+#define PORT_STATUS_REGISTER1                0x0200
+#define PORT_STATUS_REGISTER2                0x0300
+#define PORT_STATUS_REGISTER3                0x0400
+#define PORT_STATUS_REGISTER4                0x0500
+#define PORT_STATUS_REGISTER5                0x0600
+
+#define RATE_LIMIT_REGISTER0                 0x010C
+#define RATE_LIMIT_REGISTER1                 0x020C
+#define RATE_LIMIT_REGISTER2                 0x030C
+#define RATE_LIMIT_REGISTER3                 0x040C
+#define RATE_LIMIT_REGISTER4                 0x050C
+#define RATE_LIMIT_REGISTER5                 0x060C
+
+#define PORT_CONTROL_REGISTER0               0x0104
+#define PORT_CONTROL_REGISTER1               0x0204
+#define PORT_CONTROL_REGISTER2               0x0204
+#define PORT_CONTROL_REGISTER3               0x0204
+#define PORT_CONTROL_REGISTER4               0x0204
+#define PORT_CONTROL_REGISTER5               0x0204
+
+#define CPU_PORT_REGISTER                    0x0078
+#define MDIO_CTRL_REGISTER                   0x0098
+
+#define S26_ARL_TBL_FUNC_REG0                0x0050
+#define S26_ARL_TBL_FUNC_REG1                0x0054
+#define S26_ARL_TBL_FUNC_REG2                0x0058
+#define S26_ARL_TBL_CTRL_REG                 0x005c
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+#define mdelay(_x)      sysMsDelay(_x)
+
+#define S26_FORCE_100M 1
+
+#endif
+
+
diff --git a/board/ar7240/common/ath_nand.c b/board/ar7240/common/ath_nand.c
new file mode 100644
index 0000000000..3b3a459c63
--- /dev/null
+++ b/board/ar7240/common/ath_nand.c
@@ -0,0 +1,1597 @@
+/*
+ * linux/drivers/mtd/nand/ath_nand.c
+ * vim: tabstop=8 : noexpandtab
+ * Derived from alauda.c
+ */
+#include <common.h>
+#include <command.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <ar7240_soc.h>
+#include <malloc.h>
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/bitops.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+
+#define ENOMEM		12
+#define EINVAL		22
+
+#define writesize		oobblock
+#define ath_reg_rd		ar7240_reg_rd
+#define ath_reg_wr		ar7240_reg_wr
+#define ath_reg_rmw_set		ar7240_reg_rmw_set
+#define ath_reg_rmw_clear	ar7240_reg_rmw_clear
+
+#define DRV_NAME	"ath-nand"
+#define DRV_VERSION	"0.1"
+#define DRV_AUTHOR	"Atheros"
+#define DRV_DESC	"Atheros on-chip NAND FLash Controller Driver"
+
+#define ATH_NF_COMMAND		(ATH_NAND_FLASH_BASE + 0x200u)
+#define ATH_NF_CTRL		(ATH_NAND_FLASH_BASE + 0x204u)
+#define ATH_NF_STATUS		(ATH_NAND_FLASH_BASE + 0x208u)
+#define ATH_NF_INT_MASK		(ATH_NAND_FLASH_BASE + 0x20cu)
+#define ATH_NF_INT_STATUS	(ATH_NAND_FLASH_BASE + 0x210u)
+#define ATH_NF_ECC_CTRL		(ATH_NAND_FLASH_BASE + 0x214u)
+#define ATH_NF_ECC_OFFSET	(ATH_NAND_FLASH_BASE + 0x218u)
+#define ATH_NF_ADDR0_0		(ATH_NAND_FLASH_BASE + 0x21cu)
+#define ATH_NF_ADDR1_0		(ATH_NAND_FLASH_BASE + 0x220u)
+#define ATH_NF_ADDR0_1		(ATH_NAND_FLASH_BASE + 0x224u)
+#define ATH_NF_ADDR1_1		(ATH_NAND_FLASH_BASE + 0x228u)
+#define ATH_NF_SPARE_SIZE	(ATH_NAND_FLASH_BASE + 0x230u)
+#define ATH_NF_PROTECT		(ATH_NAND_FLASH_BASE + 0x238u)
+#define ATH_NF_LOOKUP_EN	(ATH_NAND_FLASH_BASE + 0x240u)
+#define ATH_NF_LOOKUP0		(ATH_NAND_FLASH_BASE + 0x244u)
+#define ATH_NF_LOOKUP1		(ATH_NAND_FLASH_BASE + 0x248u)
+#define ATH_NF_LOOKUP2		(ATH_NAND_FLASH_BASE + 0x24cu)
+#define ATH_NF_LOOKUP3		(ATH_NAND_FLASH_BASE + 0x250u)
+#define ATH_NF_LOOKUP4		(ATH_NAND_FLASH_BASE + 0x254u)
+#define ATH_NF_LOOKUP5		(ATH_NAND_FLASH_BASE + 0x258u)
+#define ATH_NF_LOOKUP6		(ATH_NAND_FLASH_BASE + 0x25cu)
+#define ATH_NF_LOOKUP7		(ATH_NAND_FLASH_BASE + 0x260u)
+#define ATH_NF_DMA_ADDR		(ATH_NAND_FLASH_BASE + 0x264u)
+#define ATH_NF_DMA_COUNT	(ATH_NAND_FLASH_BASE + 0x268u)
+#define ATH_NF_DMA_CTRL		(ATH_NAND_FLASH_BASE + 0x26cu)
+#define ATH_NF_MEM_CTRL		(ATH_NAND_FLASH_BASE + 0x280u)
+#define ATH_NF_PG_SIZE		(ATH_NAND_FLASH_BASE + 0x284u)
+#define ATH_NF_RD_STATUS	(ATH_NAND_FLASH_BASE + 0x288u)
+#define ATH_NF_TIME_SEQ		(ATH_NAND_FLASH_BASE + 0x28cu)
+#define ATH_NF_TIMINGS_ASYN	(ATH_NAND_FLASH_BASE + 0x290u)
+#define ATH_NF_TIMINGS_SYN	(ATH_NAND_FLASH_BASE + 0x294u)
+#define ATH_NF_FIFO_DATA	(ATH_NAND_FLASH_BASE + 0x298u)
+#define ATH_NF_TIME_MODE	(ATH_NAND_FLASH_BASE + 0x29cu)
+#define ATH_NF_DMA_ADDR_OFFSET	(ATH_NAND_FLASH_BASE + 0x2a0u)
+#define ATH_NF_FIFO_INIT	(ATH_NAND_FLASH_BASE + 0x2b0u)
+#define ATH_NF_GENERIC_SEQ_CTRL	(ATH_NAND_FLASH_BASE + 0x2b4u)
+
+#define ATH_NF_TIMING_ASYN	0x11
+#define ATH_NF_STATUS_OK	0x40	//0xc0
+#define ATH_NF_RD_STATUS_MASK	0x47	//0xc7
+
+#define ATH_NF_COMMAND_CMD_2(x)		(((x) & 0xff) << 24)	// A code of the third command in a sequence.
+#define ATH_NF_COMMAND_CMD_1(x)		(((x) & 0xff) << 16)	// A code of the second command in a sequence.
+#define ATH_NF_COMMAND_CMD_0(x)		(((x) & 0xff) <<  8)	// A code of the first command in a sequence.
+#define ATH_NF_COMMAND_ADDR_SEL		(1 << 7)		// Address register select flag:
+								// 0  the address register 0 selected
+								// 1  the address register 1 selected
+#define ATH_NF_COMMAND_INPUT_SEL_DMA	(1 << 6) 		// Input module select flag:
+								// 0  select the SIU module as input
+								// 1  select the DMA module as input
+#define ATH_NF_COMMAND_CMD_SEQ_0	0x00
+#define ATH_NF_COMMAND_CMD_SEQ_1	0x21
+#define ATH_NF_COMMAND_CMD_SEQ_2	0x22
+#define ATH_NF_COMMAND_CMD_SEQ_3	0x03
+#define ATH_NF_COMMAND_CMD_SEQ_4	0x24
+#define ATH_NF_COMMAND_CMD_SEQ_5	0x25
+#define ATH_NF_COMMAND_CMD_SEQ_6	0x26
+#define ATH_NF_COMMAND_CMD_SEQ_7	0x27
+#define ATH_NF_COMMAND_CMD_SEQ_8	0x08
+#define ATH_NF_COMMAND_CMD_SEQ_9	0x29
+#define ATH_NF_COMMAND_CMD_SEQ_10	0x2A
+#define ATH_NF_COMMAND_CMD_SEQ_11	0x2B
+#define ATH_NF_COMMAND_CMD_SEQ_12	0x0C
+#define ATH_NF_COMMAND_CMD_SEQ_13	0x0D
+#define ATH_NF_COMMAND_CMD_SEQ_14	0x0E
+#define ATH_NF_COMMAND_CMD_SEQ_15	0x2F
+#define ATH_NF_COMMAND_CMD_SEQ_16	0x30
+#define ATH_NF_COMMAND_CMD_SEQ_17	0x11
+#define ATH_NF_COMMAND_CMD_SEQ_18	0x32
+#define ATH_NF_COMMAND_CMD_SEQ_19	0x13
+
+
+#define ATH_NF_CTRL_SMALL_BLOCK_EN	(1 << 21)
+
+#define ATH_NF_CTRL_ADDR_CYCLE1_0	(0 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_1	(1 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_2	(2 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_3	(3 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_4	(4 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_5	(5 << 18)
+
+#define ATH_NF_CTRL_ADDR1_AUTO_INC_EN	(1 << 17)
+#define ATH_NF_CTRL_ADDR0_AUTO_INC_EN	(1 << 16)
+#define ATH_NF_CTRL_WORK_MODE_SYNC	(1 << 15)
+#define ATH_NF_CTRL_PROT_EN		(1 << 14)
+#define ATH_NF_CTRL_LOOKUP_EN		(1 << 13)
+#define ATH_NF_CTRL_IO_WIDTH_16BIT	(1 << 12)
+#define ATH_NF_CTRL_CUSTOM_SIZE_EN	(1 << 11)
+
+#define ATH_NF_CTRL_PAGE_SIZE_256	(0 <<  8)	/* bytes */
+#define ATH_NF_CTRL_PAGE_SIZE_512	(1 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_1024	(2 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_2048	(3 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_4096	(4 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_8192	(5 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_16384	(6 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_0		(7 <<  8)
+
+#define ATH_NF_CTRL_BLOCK_SIZE_32	(0 <<  6)	/* pages */
+#define ATH_NF_CTRL_BLOCK_SIZE_64	(1 <<  6)
+#define ATH_NF_CTRL_BLOCK_SIZE_128	(2 <<  6)
+#define ATH_NF_CTRL_BLOCK_SIZE_256	(3 <<  6)
+
+#define ATH_NF_CTRL_ECC_EN		(1 <<  5)
+#define ATH_NF_CTRL_INT_EN		(1 <<  4)
+#define ATH_NF_CTRL_SPARE_EN		(1 <<  3)
+
+#define ATH_NF_CTRL_ADDR_CYCLE0_0	(0 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_1	(1 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_2	(2 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_3	(3 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_4	(4 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_5	(5 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0(c)	((c) << 0)
+
+
+#define ATH_NF_DMA_CTRL_DMA_START	(1 << 7)
+#define ATH_NF_DMA_CTRL_DMA_DIR_WRITE	(0 << 6)
+#define ATH_NF_DMA_CTRL_DMA_DIR_READ	(1 << 6)
+#define ATH_NF_DMA_CTRL_DMA_MODE_SG	(1 << 5)
+/*
+ * 000 - incrementing precise burst of precisely four transfers
+ * 001 - stream burst (address const)
+ * 010 - single transfer (address increment)
+ * 011 - burst of unspecified length (address increment)
+ * 100 - incrementing precise burst of precisely eight transfers
+ * 101 - incrementing precise burst of precisely sixteen transfers
+ */
+#define ATH_NF_DMA_CTRL_DMA_BURST_0	(0 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_1	(1 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_2	(2 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_3	(3 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_4	(4 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_5	(5 << 2)
+#define ATH_NF_DMA_CTRL_ERR_FLAG	(1 << 1)
+#define ATH_NF_DMA_CTRL_DMA_READY	(1 << 0)
+
+#define ATH_NF_ECC_CTRL_ERR_THRESH(x)	((x << 8) & (0x1fu << 8))
+#define ATH_NF_ECC_CTRL_ECC_CAP(x)	((x << 5) & (0x07u << 5))
+#define ATH_NF_ECC_CTRL_ECC_2_BITS	ATH_NF_ECC_CTRL_ECC_CAP(0)
+#define ATH_NF_ECC_CTRL_ECC_4_BITS	ATH_NF_ECC_CTRL_ECC_CAP(1)
+#define ATH_NF_ECC_CTRL_ECC_6_BITS	ATH_NF_ECC_CTRL_ECC_CAP(2)
+#define ATH_NF_ECC_CTRL_ECC_8_BITS	ATH_NF_ECC_CTRL_ECC_CAP(3)
+#define ATH_NF_ECC_CTRL_ECC_10_BITS	ATH_NF_ECC_CTRL_ECC_CAP(4)
+#define ATH_NF_ECC_CTRL_ECC_12_BITS	ATH_NF_ECC_CTRL_ECC_CAP(5)
+#define ATH_NF_ECC_CTRL_ECC_14_BITS	ATH_NF_ECC_CTRL_ECC_CAP(6)
+#define ATH_NF_ECC_CTRL_ECC_16_BITS	ATH_NF_ECC_CTRL_ECC_CAP(7)
+
+#define ATH_NF_ECC_CTRL_ERR_OVER	(1 << 2)
+#define ATH_NF_ECC_CTRL_ERR_UNCORR	(1 << 1)
+#define ATH_NF_ECC_CTRL_ERR_CORR	(1 << 0)
+#	define ATH_NF_ECC_ERROR		(ATH_NF_ECC_CTRL_ERR_UNCORR | \
+					 ATH_NF_ECC_CTRL_ERR_OVER)
+
+#define ATH_NF_CMD_END_INT		(1 << 1)
+
+#define ATH_NF_HW_ECC		1
+#define ATH_NF_STATUS_RETRY	1000
+
+#define ath_nand_get_cmd_end_status(void)	\
+	(ath_reg_rd(ATH_NF_INT_STATUS) & ATH_NF_CMD_END_INT)
+
+#define ath_nand_clear_int_status()	ath_reg_wr(ATH_NF_INT_STATUS, 0)
+
+#define ATH_NAND_BLK_DONT_KNOW	0x0
+#define ATH_NAND_BLK_GOOD	0x1
+#define ATH_NAND_BLK_BAD	0x2
+#define ATH_NAND_BLK_ERASED	0x3
+
+#define ATH_NF_GENERIC_SEQ_CTRL_COL_ADDR	(1 << 17)
+#define ATH_NF_GENERIC_SEQ_CTRL_DATA_EN		(1 << 16)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD3_CODE(x)	(((x) & 0xff) << 8)
+#define ATH_NF_GENERIC_SEQ_CTRL_DEL_EN(x)	(((x) & 3) << 6)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD3_EN		(1 << 5)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD2_EN		(1 << 4)
+#define ATH_NF_GENERIC_SEQ_CTRL_ADDR1_EN	(1 << 3)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD1_EN		(1 << 2)
+#define ATH_NF_GENERIC_SEQ_CTRL_ADDR0_EN	(1 << 1)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD0_EN		(1 << 0)
+
+#define ATH_NAND_JFFS2_ECC_OFF	0x04	// Give 4 bytes for Factory Bad Block Marker
+#define ATH_NAND_JFFS2_ECC_LEN	0x10	// Space for JFFS2 Clean Marker
+
+/*
+ * Note: The byte positions might not match the spec.
+ * It is to handle the endianness issues.
+ */
+#define ONFI_NUM_ADDR_CYCLES	102	/* see note */
+#define ONFI_DEV_DESC		32
+#define ONFI_DEV_DESC_SZ	32
+#define ONFI_PAGE_SIZE		80
+#define ONFI_SPARE_SIZE		86	/* see note */
+#define ONFI_PAGES_PER_BLOCK	92
+#define ONFI_BLOCKS_PER_LUN	96
+#define ONFI_NUM_LUNS		103	/* see note */
+#define ONFI_RD_PARAM_PAGE_SZ	128
+#define READ_PARAM_STATUS_OK	0x40
+#define READ_PARAM_STATUS_MASK	0x41
+
+#define ATH_NAND_IO_DBG		0
+#define ATH_NAND_OOB_DBG	0
+#define ATH_NAND_IN_DBG		0
+
+#if ATH_NAND_IO_DBG
+#	define iodbg	printk
+#else
+#	define iodbg(...)
+#endif
+
+#if ATH_NAND_OOB_DBG
+#	define oobdbg	printk
+#else
+#	define oobdbg(...)
+#endif
+
+#if ATH_NAND_IN_DBG
+#	define indbg(a, ...)					\
+	do {							\
+		printk("--- %s(%d):" a "\n",			\
+			__func__, __LINE__, ## __VA_ARGS__);	\
+	} while (0)
+#else
+#	define indbg(...)
+#	define indbg1(a, ...)					\
+	do {							\
+		printk("--- %s(%d):" a "\n",			\
+			__func__, __LINE__, ## __VA_ARGS__);	\
+	} while (0)
+#endif
+
+/*
+ * Data structures for ath nand flash controller driver
+ */
+
+typedef union {
+	uint8_t			byte_id[8];
+
+	struct {
+		uint8_t		sa1	: 1,	// Serial access time (bit 1)
+				org	: 1,	// Organisation
+				bs	: 2,	// Block size
+				sa0	: 1,	// Serial access time (bit 0)
+				ss	: 1,	// Spare size per 512 bytes
+				ps	: 2,	// Page Size
+
+				wc	: 1,	// Write Cache
+				ilp	: 1, 	// Interleaved Programming
+				nsp	: 2, 	// No. of simult prog pages
+				ct	: 2,	// Cell type
+				dp	: 2,	// Die/Package
+
+				did,		// Device id
+				vid,		// Vendor id
+
+				res1	: 2,	// Reserved
+				pls	: 2,	// Plane size
+				pn	: 2,	// Plane number
+				res2	: 2;	// Reserved
+	} __details;
+} ath_nand_id_t;
+
+uint64_t ath_plane_size[] = {
+	64 << 20,
+	 1 << 30,
+	 2 << 30,
+	 4 << 30,
+	 8 << 30
+};
+
+typedef struct {
+	uint8_t		vid,
+			did,
+			b3,
+			addrcyc,
+			small,
+			spare;	// for small block;
+	uint16_t	pgsz;	// for small block
+	uint32_t	blk;	// for small block
+} ath_nand_vend_data_t;
+
+#define is_small_block_device(x)	((x)->entry && (x)->entry->small)
+
+ath_nand_vend_data_t ath_nand_arr[] = {
+	{ 0x20, 0xda, 0x10, 5, },	// NU2g3B2D
+	{ 0x20, 0xf1, 0x00, 4, },	// NU1g3B2C
+	{ 0x20, 0xdc, 0x10, 5, },	// NU4g3B2D
+	{ 0x20, 0xd3, 0x10, 5, },	// NU8g3F2A
+	{ 0x20, 0xd3, 0x14, 5, },	// NU8g3C2B
+	{ 0xad, 0xf1, 0x00, 4, },	// HY1g2b
+	{ 0xad, 0xda, 0x10, 5, },	// HY2g2b
+	{ 0xec, 0xf1, 0x00, 4, },	// Samsung 3,3V 8-bit [128MB]
+	{ 0x98, 0xd1, 0x90, 4, },	// Toshiba
+	{ 0xad, 0x76, 0xad, 5, 1, 16, 512, 16 << 10 },	// Hynix 64MB NAND Flash
+	{ 0xad, 0x36, 0xad, 5, 1, 16, 512, 16 << 10 },	// Hynix 64MB NAND Flash
+	{ 0x20, 0x76, 0x20, 5, 1, 16, 512, 16 << 10 },	// ST Micro 64MB NAND Flash
+};
+
+#define NUM_ARRAY_ENTRIES(a)	(sizeof((a)) / sizeof((a)[0]))
+#define NUM_ATH_NAND		NUM_ARRAY_ENTRIES(ath_nand_arr)
+
+/* ath nand info */
+typedef struct {
+	/* mtd info */
+	struct mtd_info		*mtd;
+
+	/* platform info */
+	unsigned short		page_size,
+				data_width;
+
+	/* NAND MTD partition information */
+	int			nr_partitions;
+	struct mtd_partition	*partitions;
+
+	unsigned		*bbt;
+
+	ath_nand_vend_data_t	*entry;
+
+	unsigned		ba0,
+				ba1,
+				cmd;	// Current command
+	ath_nand_id_t		__id;	// for readid
+	uint8_t			onfi[ONFI_RD_PARAM_PAGE_SZ];
+#if ATH_NF_HW_ECC
+	uint32_t		ecc_offset;
+#endif
+	uint32_t		nf_ctrl;
+} ath_nand_sc_t;
+
+ath_nand_sc_t ath_nand_sc;
+static int ath_nand_hw_init(ath_nand_sc_t *, void *);
+
+struct mtd_info nand_info[CFG_MAX_NAND_DEVICE];
+int nand_curr_device = 0;
+
+#define	nid	__id.__details
+#define	bid	__id.byte_id
+
+static int ath_nand_block_isbad(struct mtd_info *mtd, loff_t ofs);
+void ath_nand_dump_buf(loff_t addr, void *v, unsigned count);
+
+/* max page size (16k) + oob buf size */
+uint8_t	ath_nand_io_buf[24 << 10] __attribute__((aligned(4096)));
+#define get_ath_nand_io_buf()	ath_nand_io_buf
+
+#define	bbt_index	(sizeof(*sc->bbt) * 8 / 2)
+
+/*
+ * MTD layer assumes the NAND device as a linear array of bytes.
+ * However, the NAND devices are organised into blocks, pages,
+ * spare area etc. Hence, the address provided by Linux has to
+ * converted to format expected by the devices.
+ *
+ * [in] mtd: MTD info pointer
+ * [in] addr: Linear Address as provided by MTD layer
+ * [out] addr0: Value to be set into ADDR0_0 register
+ * [out] addr1: Value to be set into ADDR0_1 register
+ * [in] small_block_erase: Address conversion for small block
+ *	is different. Hence, special case it.
+ */
+inline void
+ath_nand_conv_addr(struct mtd_info *mtd, loff_t addr, uint32_t *addr0,
+			uint32_t *addr1, int small_block_erase)
+{
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (is_small_block_device(sc) && small_block_erase) {
+		/*
+		 * The block address loading is accomplished three
+		 * cycles. Erase is a SEQ_14 type command. Hence, the
+		 * controller starts shifting from ADDR_0[16:32] &
+		 * ADDR_1 based on the number of address cycles in our
+		 * case... The device data sheet assumes to have 3
+		 * address cycles for having page address + block
+		 * address for erase. Ideally, SMALL_BLOCK_EN in the
+		 * NF_CTRL register should help but, that doesn't seem
+		 * to work as expected. Hence, the following
+		 * conversion.
+		 */
+
+		// Get the block no.
+		uint32_t b = (addr >> mtd->erasesize_shift);
+
+		*addr0 = (b & 0xfff) << 21;
+		*addr1 = (b >> 11) & 0x1;
+	} else if (is_small_block_device(sc)) {
+		/* +-----+----+----+----+----+----+----+----+----+
+		 * |cycle|I/O7|I/O6|I/O5|I/O4|I/O3|I/O2|I/O1|I/O0|
+		 * +-----+----+----+----+----+----+----+----+----+
+		 * | 1st | A7 | A6 | A5 | A4 | A3 | A2 | A1 | A0 |
+		 * | 2nd |A16 |A15 |A14 |A13 |A12 |A11 |A10 | A9 |
+		 * | 3rd |A24 |A23 |A22 |A21 |A20 |A19 |A18 |A17 |
+		 * | 4th | x  | x  | x  | x  | x  | x  | x  |A25 |
+		 * +-----+----+----+----+----+----+----+----+----+
+		 */
+		addr &= ~(mtd->writesize_mask);
+		*addr0 = ((addr & 0xff) |
+			  ((addr >> 1) & (~0xffu))) & ((1 << 25) - 1);
+		*addr1 = 0;
+	} else {
+		/* +-----+---+---+---+---+---+---+---+---+
+		 * |Cycle|IO0|IO1|IO2|IO3|IO4|IO5|IO6|IO7|
+		 * +-----+---+---+---+---+---+---+---+---+
+		 * | 1st | A0| A1| A2| A3| A4| A5| A6| A7|
+		 * | 2nd | A8| A9|A10|A11| x | x | x | x |
+		 * | 3rd |A12|A13|A14|A15|A16|A17|A18|A19|
+		 * | 4th |A20|A21|A22|A23|A24|A25|A26|A27|
+		 * +-----+---+---+---+---+---+---+---+---+
+		 */
+		*addr0 = ((addr >> mtd->writesize_shift) << 16);
+		*addr1 = ((addr >> (mtd->writesize_shift + 16)) & 0xf);
+	}
+}
+
+inline unsigned
+ath_nand_get_blk_state(struct mtd_info *mtd, loff_t b)
+{
+	unsigned		x, y;
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (!sc->bbt)	return ATH_NAND_BLK_DONT_KNOW;
+
+	b = b >> mtd->erasesize_shift;
+
+	x = b / bbt_index;
+	y = b % bbt_index;
+
+	return (sc->bbt[x] >> (y * 2)) & 0x3;
+}
+
+inline void
+ath_nand_set_blk_state(struct mtd_info *mtd, loff_t b, unsigned state)
+{
+	unsigned		x, y;
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (!sc->bbt)	return;
+
+	b = b >> mtd->erasesize_shift;
+
+	x = b / bbt_index;
+	y = b % bbt_index;
+
+	sc->bbt[x] = (sc->bbt[x] & ~(3 << (y * 2))) | (state << (y * 2));
+}
+
+static unsigned
+ath_nand_status(ath_nand_sc_t *sc, unsigned *ecc)
+{
+	unsigned	rddata, i, j, dmastatus;
+
+	rddata = ath_reg_rd(ATH_NF_STATUS);
+	for (i = 0; i < ATH_NF_STATUS_RETRY && rddata != 0xff; i++) {
+		udelay(5);
+		rddata = ath_reg_rd(ATH_NF_STATUS);
+	}
+
+	dmastatus = ath_reg_rd(ATH_NF_DMA_CTRL);
+	for (j = 0; j < ATH_NF_STATUS_RETRY && !(dmastatus & 1); j++) {
+		udelay(5);
+		dmastatus = ath_reg_rd(ATH_NF_DMA_CTRL);
+	}
+
+	if ((i == ATH_NF_STATUS_RETRY) || (j == ATH_NF_STATUS_RETRY)) {
+		//printk("ath_nand_status: i = %u j = %u\n", i, j);
+		ath_nand_hw_init(sc, NULL);
+		return -1;
+	}
+	if (ecc) {
+		*ecc = ath_reg_rd(ATH_NF_ECC_CTRL);
+	}
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_GENERIC_SEQ_CTRL, 0);
+	ath_reg_wr(ATH_NF_COMMAND, 0x07024);	// READ STATUS
+	while (ath_nand_get_cmd_end_status() == 0);
+	rddata = ath_reg_rd(ATH_NF_RD_STATUS);
+
+	return rddata;
+}
+
+static unsigned
+ath_check_all_0xff(ath_nand_sc_t *sc, unsigned addr0, unsigned addr1, unsigned *all_0xff)
+{
+	uint8_t		*pa, *buf = ath_nand_io_buf, *end;
+	struct mtd_info	*mtd = sc->mtd;
+	unsigned	i, count = mtd->writesize + mtd->oobsize;
+
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_DMA_COUNT, count);
+	ath_reg_wr(ATH_NF_DMA_CTRL, ATH_NF_DMA_CTRL_DMA_START |
+				ATH_NF_DMA_CTRL_DMA_DIR_READ |
+				ATH_NF_DMA_CTRL_DMA_BURST_3);
+	ath_reg_wr(ATH_NF_ECC_OFFSET, 0);
+	ath_reg_wr(ATH_NF_ECC_CTRL, 0);
+	ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_CUSTOM_SIZE_EN);
+	ath_reg_wr(ATH_NF_PG_SIZE, count);
+	pa = (void *)virt_to_phys(buf);
+	ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+	ath_reg_wr(ATH_NF_COMMAND, 0x30006a);	// Read page
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	i = ath_nand_status(sc, NULL) & ATH_NF_RD_STATUS_MASK;
+	memcpy(buf, pa, count);	// cache sync equivalent
+	if (i != ATH_NF_STATUS_OK) {
+		return 0;
+	}
+	end = buf + count;
+	for (buf += sc->ecc_offset; (*buf == 0xff) && buf != end; buf ++);
+
+	*all_0xff = 1;
+
+	if (buf == end) {
+		/* This page was read without ECC. From the spare area
+		 * content we see that it a blank page (i.e. full 0xff).
+		 * To take care of bit flips if any, force 0xff on it.
+		 */
+		memset(ath_nand_io_buf, 0xff, mtd->writesize);
+	} else {
+		ath_nand_dump_buf(addr0, ath_nand_io_buf, mtd->writesize + mtd->oobsize);
+	}
+	return (buf == end);
+}
+
+static unsigned
+ath_nand_rw_page(ath_nand_sc_t *sc, int rd, unsigned addr0, unsigned addr1, unsigned count, unsigned char *buf, unsigned ecc_needed)
+{
+	unsigned	ecc, i = 0, tmp, rddata, all_0xff = 0;
+#if ATH_NF_HW_ECC
+	unsigned	mlc_retry = 0;
+#endif
+	char		*err[] = { "Write", "Read" };
+#define ATH_MAX_RETRY	25
+#define ATH_MLC_RETRY	3
+retry:
+	ecc = 0;
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)buf);
+	ath_reg_wr(ATH_NF_DMA_COUNT, count);
+
+#if ATH_NF_HW_ECC
+	if (ecc_needed && sc->ecc_offset && (count & sc->mtd->writesize_mask) == 0) {
+		/*
+		 * ECC can operate only on the device's pages.
+		 * Cannot be used for non-page-sized read/write
+		 */
+		ath_reg_wr(ATH_NF_ECC_OFFSET, sc->ecc_offset);
+		ath_reg_wr(ATH_NF_ECC_CTRL, ATH_NF_ECC_CTRL_ERR_THRESH(4) |
+						ATH_NF_ECC_CTRL_ECC_4_BITS);
+		ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_ECC_EN);
+		ath_reg_wr(ATH_NF_SPARE_SIZE, sc->mtd->oobsize);
+	} else
+#endif
+	{
+		ath_reg_wr(ATH_NF_ECC_OFFSET, 0);
+		ath_reg_wr(ATH_NF_ECC_CTRL, 0);
+		ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_CUSTOM_SIZE_EN);
+		ath_reg_wr(ATH_NF_PG_SIZE, count);
+	}
+
+	if (rd) {	// Read Page
+		if (is_small_block_device(sc)) {
+			ath_reg_wr(ATH_NF_DMA_CTRL,
+						ATH_NF_DMA_CTRL_DMA_START |
+						ATH_NF_DMA_CTRL_DMA_DIR_READ |
+						ATH_NF_DMA_CTRL_DMA_BURST_3);
+			ath_reg_wr(ATH_NF_GENERIC_SEQ_CTRL,
+						ATH_NF_GENERIC_SEQ_CTRL_COL_ADDR |
+						ATH_NF_GENERIC_SEQ_CTRL_DATA_EN |
+						ATH_NF_GENERIC_SEQ_CTRL_DEL_EN(1) |
+						ATH_NF_GENERIC_SEQ_CTRL_ADDR0_EN |
+						ATH_NF_GENERIC_SEQ_CTRL_CMD0_EN);
+			ath_reg_wr(ATH_NF_COMMAND,
+						ATH_NF_COMMAND_CMD_SEQ_18 |
+						ATH_NF_COMMAND_INPUT_SEL_DMA |
+						ATH_NF_COMMAND_CMD_0(0));
+		} else {
+			ath_reg_wr(ATH_NF_DMA_CTRL,
+						ATH_NF_DMA_CTRL_DMA_START |
+						ATH_NF_DMA_CTRL_DMA_DIR_READ |
+						ATH_NF_DMA_CTRL_DMA_BURST_3);
+			ath_reg_wr(ATH_NF_COMMAND, 0x30006a);
+		}
+	} else {	// Write Page
+		ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);	// Remove write protect
+		ath_reg_wr(ATH_NF_DMA_CTRL,
+					ATH_NF_DMA_CTRL_DMA_START |
+					ATH_NF_DMA_CTRL_DMA_DIR_WRITE |
+					ATH_NF_DMA_CTRL_DMA_BURST_3);
+		ath_reg_wr(ATH_NF_COMMAND, 0x10804c);
+	}
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	//printk(KERN_DEBUG "%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+	//	rd ? 'r' : 'w', addr0, addr1, count, buf);
+
+	rddata = (tmp = ath_nand_status(sc, &ecc)) & ATH_NF_RD_STATUS_MASK;
+	if ((rddata != ATH_NF_STATUS_OK) && (i < ATH_MAX_RETRY)) {
+		i++;
+		goto retry;
+	}
+
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0x0000);	// Enable write protect
+	ath_reg_wr(ATH_NF_FIFO_INIT, 1);
+	ath_reg_wr(ATH_NF_FIFO_INIT, 0);
+
+	if (rddata != ATH_NF_STATUS_OK) {
+		printk("%s: %s Failed. tmp = 0x%x, status = 0x%x 0x%x retries = %d\n", __func__,
+			err[rd], tmp, rddata, ath_reg_rd(ATH_NF_DMA_CTRL), i);
+	}
+#if ATH_NF_HW_ECC
+	else {
+#define DDR_WB_FLUSH_USB_ADDRESS		0x180000a4
+
+		ath_reg_wr(DDR_WB_FLUSH_USB_ADDRESS, 1);
+		while (ath_reg_rd(DDR_WB_FLUSH_USB_ADDRESS) & 1);
+		udelay(2);
+
+		if (ecc_needed && (ecc & ATH_NF_ECC_ERROR)) {
+			if (rd && all_0xff == 0) {
+				if (ath_check_all_0xff(sc, addr0, addr1, &all_0xff)) {
+					return ATH_NF_STATUS_OK;
+				}
+			}
+
+			if (mlc_retry < ATH_MLC_RETRY) {
+				mlc_retry ++;
+				i = 0;
+				goto retry;
+			} else {
+				printk("%s: %s uncorrectable errors. ecc = 0x%x\n",
+					__func__, err[rd], ecc);
+				return -1;
+			}
+		}
+	}
+#endif
+	return rddata;
+}
+
+void
+ath_nand_dump_buf(loff_t addr, void *v, unsigned count)
+{
+	unsigned	*buf = v,
+			*end = buf + (count / sizeof(*buf));
+
+	iodbg("____ Dumping %d bytes at 0x%p 0x%lx_____\n", count, buf, (ulong)addr);
+
+	for (; buf && buf < end; buf += 4, addr += 16) {
+		printk("%08lx: %08x %08x %08x %08x\n",
+			(unsigned)addr, buf[0], buf[1], buf[2], buf[3]);
+	}
+	iodbg("___________________________________\n");
+	//while(1);
+}
+
+static int
+ath_nand_rw_buff(struct mtd_info *mtd, int rd, uint8_t *buf,
+		loff_t addr, size_t len, size_t *iodone)
+{
+	unsigned	iolen, ret = ATH_NF_STATUS_OK, ecc_needed;
+	unsigned char	*pa;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	*iodone = 0;
+
+	while (len) {
+		uint32_t c, ba0, ba1;
+
+		if (ath_nand_block_isbad(mtd, addr)) {
+			printk("Skipping bad block[0x%x]\n", (unsigned)addr);
+			addr += mtd->erasesize;
+			continue;
+		}
+
+		c = (addr & mtd->writesize_mask);
+
+		ath_nand_conv_addr(mtd, addr, &ba0, &ba1, 0);
+
+		if (c) {
+			iolen = mtd->writesize - c;
+		} else {
+			iolen = mtd->writesize;
+		}
+
+		if (len < iolen) {
+			iolen = len;
+		}
+
+		if (rd) {
+			ecc_needed = (ath_nand_get_blk_state(mtd, addr) != ATH_NAND_BLK_ERASED);
+		} else {
+			int i;
+
+			for (i = 0; (i < mtd->writesize) && (buf[i] == 0xff); i++);
+			if (i == mtd->writesize) {
+				ret = ATH_NF_STATUS_OK;
+				//printk("Skipping write for 0x%x\n", (ulong)addr);
+				goto skip_write_for_all_0xff;
+			}
+
+			/* FIXME for writes FIXME */
+			memcpy(ath_nand_io_buf, buf, iolen);
+			ecc_needed = 1;
+		}
+
+		pa = (void *)virt_to_phys(ath_nand_io_buf);
+
+		flush_cache((unsigned)ath_nand_io_buf, mtd->writesize);
+
+		//printk("%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+		//	rd ? 'r' : 'w', ba0, ba1, iolen, pa);
+
+		ret = ath_nand_rw_page(sc, rd, ba0, ba1, mtd->writesize, pa, ecc_needed);
+
+		flush_cache((unsigned)ath_nand_io_buf, mtd->writesize);
+
+		if (rd) {
+			memcpy(buf, ath_nand_io_buf + c, iolen);
+		}
+skip_write_for_all_0xff:
+		//ath_nand_dump_buf(addr, buf, iolen);
+
+		if (ret != ATH_NF_STATUS_OK) {
+			return 1;
+		}
+
+		len -= iolen;
+		buf += iolen;
+		addr += iolen;
+		*iodone += iolen;
+	}
+
+	return 0;
+}
+
+#define ath_nand_write_verify	0
+
+#if ath_nand_write_verify
+uint8_t	ath_nand_rd_buf[4096 + 256] __attribute__((aligned(4096)));
+#endif
+
+static int
+ath_nand_write(struct mtd_info *mtd, loff_t to, size_t len,
+		size_t *retlen, const u_char *buf)
+{
+	int	ret;
+#if ath_nand_write_verify
+	int	r, rl;
+#endif
+
+	if (!len || !retlen) return (0);
+
+	indbg("0x%llx	%u", to, len);
+
+	ret = ath_nand_rw_buff(mtd, 0 /* write */, (u_char *)buf, to, len, retlen);
+#if ath_nand_write_verify
+	//printk("Verifying 0x%llx 0x%x\n", to, len);
+	r = ath_nand_rw_buff(mtd, 1 /* read */, ath_nand_rd_buf, to, len, &rl);
+	if (r || memcmp(ath_nand_rd_buf, buf, len)) {
+		printk("write failed at 0x%llx 0x%x\n", to, len);
+		while (1);
+	}
+#endif
+	return ret;
+}
+
+static int
+ath_nand_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	int	ret;
+
+	if (!len || !retlen) return (0);
+
+	ret = ath_nand_rw_buff(mtd, 1 /* read */, buf, from, len, retlen);
+
+	return ret;
+}
+
+static inline int
+ath_nand_block_erase(ath_nand_sc_t *sc, unsigned addr0, unsigned addr1)
+{
+	unsigned	rddata;
+
+	indbg("0x%x 0x%x", addr1, addr0);
+
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);	// Remove write protect
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_COMMAND, 0xd0600e);	// BLOCK ERASE
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	rddata = ath_nand_status(sc, NULL) & ATH_NF_RD_STATUS_MASK;
+
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0x0000);	// Enable write protect
+
+	if (rddata != ATH_NF_STATUS_OK) {
+		printk("Erase Failed. status = 0x%x\n", rddata);
+		return 1;
+	}
+	return 0;
+}
+
+
+static int
+ath_nand_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	ulong		s_first, i;
+	unsigned	n, j;
+	int		ret, bad = 0;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	if (instr->addr + instr->len > mtd->size) {
+		return (-EINVAL);
+	}
+
+	s_first = instr->addr;
+	n = instr->len >> mtd->erasesize_shift;
+
+	if (instr->len & mtd->erasesize_mask) n ++;
+
+	indbg("0x%llx 0x%x 0x%x", instr->addr, n, mtd->erasesize);
+
+	printk("%s: 0x%x %u\n", __func__, s_first, n);
+
+	for (j = 0, i = s_first; j < n; j++, i += mtd->erasesize) {
+		uint32_t ba0, ba1;
+
+		if (ath_nand_block_isbad(mtd, i)) {
+			bad ++;
+			continue;
+		}
+
+		ath_nand_conv_addr(mtd, i, &ba0, &ba1, 1);
+
+		printk("\b\b\b\b%4d", j);
+
+		if ((ret = ath_nand_block_erase(sc, ba0, ba1)) != 0) {
+			printf("%s: erase failed 0x%x 0x%x 0x%x %x "
+				"%lx %lx\n", __func__, instr->addr, n,
+				mtd->erasesize, i, ba1, ba0);
+			break;
+		}
+		ath_nand_set_blk_state(mtd, i, ATH_NAND_BLK_ERASED);
+	}
+
+	if (instr->callback) {
+		if (j < n) {
+			instr->state = MTD_ERASE_FAILED;
+		} else {
+			instr->state = MTD_ERASE_DONE;
+		}
+		mtd_erase_callback(instr);
+	}
+
+	printk("Skipped %d bad blocks\n", bad);
+
+	return ret;
+}
+
+/* lifted from linux */
+typedef enum {
+	MTD_OOB_PLACE,
+	MTD_OOB_AUTO,
+	MTD_OOB_RAW,
+} mtd_oob_mode_t;
+
+struct mtd_oob_ops {
+	mtd_oob_mode_t  mode;
+	size_t          len;
+	size_t          retlen;
+	size_t          ooblen;
+	size_t          oobretlen;
+	uint32_t        ooboffs;
+	uint8_t         *datbuf;
+	uint8_t         *oobbuf;
+};
+
+static int
+ath_nand_rw_oob(struct mtd_info *mtd, int rd, loff_t addr,
+		struct mtd_oob_ops *ops)
+{
+	unsigned	ret = ATH_NF_STATUS_OK;
+	unsigned char	*pa;
+	uint32_t	ba0, ba1;
+	uint8_t		*oob = ath_nand_io_buf + mtd->writesize;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	ath_nand_conv_addr(mtd, addr, &ba0, &ba1, 0);
+
+	if (!rd) {
+		if (ops->datbuf) {
+			/*
+			 * XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX
+			 * We assume that the caller gives us a full
+			 * page to write. We don't read the page and
+			 * update the changed portions alone.
+			 *
+			 * Hence, not checking for len < or > pgsz etc...
+			 * XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX
+			 */
+			memcpy(ath_nand_io_buf, ops->datbuf, ops->len);
+		}
+		if (ops->mode == MTD_OOB_PLACE) {
+			oob += ops->ooboffs;
+		} else if (ops->mode == MTD_OOB_AUTO) {
+			// clean markers
+			oob[0] = oob[1] = 0xff;
+			oob += 2;
+		}
+		memcpy(oob, ops->oobbuf, ops->ooblen);
+	}
+
+	pa = (void *)virt_to_phys(ath_nand_io_buf);
+	if (!rd) flush_cache(ath_nand_io_buf, mtd->writesize + mtd->oobsize);	// for writes...
+
+	//printk("%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+	//	rd ? 'r' : 'w', ba0, ba1, mtd->writesize + mtd->oobsize, pa);
+
+	ret = ath_nand_rw_page(sc, rd, ba0, ba1, mtd->writesize + mtd->oobsize, pa, 0);
+
+	if (ret != ATH_NF_STATUS_OK) {
+		return 1;
+	}
+
+	if (rd) {
+		memcpy(ath_nand_io_buf, KSEG1ADDR(pa), mtd->writesize + mtd->oobsize);	// for reads...
+
+		if (ops->datbuf) {
+			memcpy(ops->datbuf, ath_nand_io_buf, ops->len);
+		}
+		if (ops->mode == MTD_OOB_PLACE) {
+			oob += ops->ooboffs;
+		} else if (ops->mode == MTD_OOB_AUTO) {
+			// copy after clean marker
+			oob += 2;
+		}
+		memcpy(ops->oobbuf, oob, ops->ooblen);
+	}
+
+	//if (rd) {
+	//	ath_nand_dump_buf(addr, ops->datbuf, ops->len);
+	//	ath_nand_dump_buf(addr, ops->oobbuf, ops->ooblen);
+	//}
+
+	if (ops->datbuf) {
+		ops->retlen = ops->len;
+	}
+	ops->oobretlen = ops->ooblen;
+
+	return 0;
+}
+
+//static int
+//ath_nand_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
+int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen)
+{
+	struct mtd_oob_ops ops = { MTD_OOB_RAW, len, 0, ooblen, 0,
+					0, buf, buf + mtd->writesize };
+
+	oobdbg(	"%s: from: 0x%lx mode: 0x%x len: 0x%x retlen: 0x%x\n"
+		"ooblen: 0x%x oobretlen: 0x%x ooboffs: 0x%x datbuf: %p "
+		"oobbuf: %p\n", __func__, (uint32_t)from,
+		ops.mode, ops.len, ops.retlen, ops.ooblen,
+		ops.oobretlen, ops.ooboffs, ops.datbuf,
+		ops.oobbuf);
+
+	oobdbg("0x%lx %p %p %u\n", (uint32_t)from, ops.oobbuf, ops.datbuf, ops.len);
+
+	if (len == 0) {
+		ops.datbuf = 0;
+		ops.oobbuf = buf;
+	}
+	if (ooblen == 0) {
+		ops.oobbuf = NULL;
+	}
+
+	return ath_nand_rw_oob(mtd, 1 /* read */, from, &ops);
+}
+
+#if 0
+static int
+ath_nand_write_oob(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops)
+{
+	int ret;
+	unsigned char oob[128];
+	struct mtd_oob_ops	rops = {
+		.mode	= MTD_OOB_RAW,
+		.ooblen	= mtd->oobsize,
+		.oobbuf	= oob,
+	};
+
+	if (ops->mode == MTD_OOB_AUTO) {
+		/* read existing oob */
+		if (ath_nand_read_oob(mtd, to, &rops) ||
+			rops.oobretlen != rops.ooblen) {
+			printk("%s: oob read failed at 0x%llx\n", __func__, to);
+			return 1;
+		}
+		memcpy(oob + 2, ops->oobbuf, ops->ooblen);
+		rops = *ops;
+		ops->oobbuf = oob;
+		ops->ooblen = mtd->oobsize;
+		ops->mode = MTD_OOB_RAW;
+	}
+
+	oobdbg(	"%s: from: 0x%llx mode: 0x%x len: 0x%x retlen: 0x%x\n"
+		"ooblen: 0x%x oobretlen: 0x%x ooboffs: 0x%x datbuf: %p "
+		"oobbuf: %p\n", __func__, to,
+		ops->mode, ops->len, ops->retlen, ops->ooblen,
+		ops->oobretlen, ops->ooboffs, ops->datbuf,
+		ops->oobbuf);
+
+	indbg("0x%llx", to);
+
+	ret = ath_nand_rw_oob(mtd, 0 /* write */, to, ops);
+
+	if (rops.mode == MTD_OOB_AUTO) {
+		if (ret == 0) { // rw oob success
+			rops.oobretlen = rops.ooblen;
+			rops.retlen = rops.len;
+		}
+		*ops = rops;
+	}
+
+	return ret;
+}
+#endif
+
+static int
+ath_nand_block_isbad(struct mtd_info *mtd, loff_t ofs)
+{
+	unsigned char		oob[256];
+	unsigned		bs, i;
+	unsigned		*force = (unsigned *)0xbd000000;
+
+	if (*force == 0x12345678) {
+		return 0;
+	}
+
+	bs = ath_nand_get_blk_state(mtd, ofs);
+
+	if ((bs == ATH_NAND_BLK_ERASED) || (bs == ATH_NAND_BLK_GOOD)) {
+		return 0;
+	}
+
+	if (bs == ATH_NAND_BLK_BAD) {
+		return 1;
+	}
+
+	/*
+	 * H27U1G8F2B Series [1 Gbit (128 M x 8 bit) NAND Flash]
+	 *
+	 * The Bad Block Information is written prior to shipping. Any
+	 * block where the 1st Byte in the spare area of the 1st or
+	 * 2nd th page (if the 1st page is Bad) does not contain FFh
+	 * is a Bad Block. The Bad Block Information must be read
+	 * before any erase is attempted as the Bad Block Information
+	 * may be erased. For the system to be able to recognize the
+	 * Bad Blocks based on the original information it is
+	 * recommended to create a Bad Block table following the
+	 * flowchart shown in Figure 24. The 1st block, which is
+	 *                               ^^^^^^^^^^^^^
+	 * placed on 00h block address is guaranteed to be a valid
+	 * block.                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
+	 */
+
+	for (i = 0; i < 2; i++, ofs += mtd->writesize) {
+		if (nand_read_raw(mtd, oob, ofs, 0, mtd->oobsize)) {
+			printk("%s: oob read failed at 0x%lx\n", __func__, (unsigned)ofs);
+			ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_DONT_KNOW);
+			return 1;
+		}
+
+		/* First two bytes of oob data are clean markers */
+		if (oob[0] != 0xff || oob[1] != 0xff) {
+			oobdbg("%s: block is bad at 0x%lx\n", __func__, (unsigned)ofs);
+			oobdbg(	"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				0xff & oob[ 0], 0xff & oob[ 1], 0xff & oob[ 2],
+				0xff & oob[ 3], 0xff & oob[ 4], 0xff & oob[ 5],
+				0xff & oob[ 6], 0xff & oob[ 7], 0xff & oob[ 8],
+				0xff & oob[ 9], 0xff & oob[10], 0xff & oob[11],
+				0xff & oob[12], 0xff & oob[13], 0xff & oob[14],
+				0xff & oob[15], 0xff & oob[16], 0xff & oob[17],
+				0xff & oob[18], 0xff & oob[19], 0xff & oob[20],
+				0xff & oob[21], 0xff & oob[22], 0xff & oob[23],
+				0xff & oob[24], 0xff & oob[25], 0xff & oob[26],
+				0xff & oob[27], 0xff & oob[28], 0xff & oob[29],
+				0xff & oob[30], 0xff & oob[31], 0xff & oob[32],
+				0xff & oob[33], 0xff & oob[34], 0xff & oob[35],
+				0xff & oob[36], 0xff & oob[37], 0xff & oob[38],
+				0xff & oob[39], 0xff & oob[40], 0xff & oob[41],
+				0xff & oob[42], 0xff & oob[43], 0xff & oob[44],
+				0xff & oob[45], 0xff & oob[46], 0xff & oob[47],
+				0xff & oob[48], 0xff & oob[49], 0xff & oob[50],
+				0xff & oob[51], 0xff & oob[52], 0xff & oob[53],
+				0xff & oob[54], 0xff & oob[55], 0xff & oob[56],
+				0xff & oob[57], 0xff & oob[58], 0xff & oob[59],
+				0xff & oob[60], 0xff & oob[61], 0xff & oob[62],
+				0xff & oob[63]);
+			ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_BAD);
+			return 1;
+		}
+	}
+
+	for (i = 0; (i < mtd->oobsize) && (oob[i] == 0xff); i++);
+
+	if (i == mtd->oobsize) {
+		ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_ERASED);
+	} else {
+	      ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_GOOD);
+	}
+
+	return 0;
+}
+
+static int
+ath_nand_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	indbg("unimplemented 0x%llx", ofs);
+	return 0;
+}
+
+static unsigned long
+ath_parse_read_id(ath_nand_sc_t *sc)
+{
+	int	i;
+
+	extern struct nand_manufacturers nand_manuf_ids[];
+	extern struct nand_flash_dev nand_flash_ids[];
+
+	iodbg(	"____ %s _____\n"
+		"  vid did wc  ilp nsp ct  dp  sa1 org bs  sa0 ss  "
+		"ps  res1 pls pn  res2\n"
+		"0x%3x %3x %3x %3x %3x %3x %3x %3x %3x %3x %3x %3x "
+		"%3x %3x  %3x %3x %3x\n-------------\n", __func__,
+			sc->nid.vid, sc->nid.did, sc->nid.wc, sc->nid.ilp,
+			sc->nid.nsp, sc->nid.ct, sc->nid.dp, sc->nid.sa1,
+			sc->nid.org, sc->nid.bs, sc->nid.sa0, sc->nid.ss,
+			sc->nid.ps, sc->nid.res1, sc->nid.pls, sc->nid.pn,
+			sc->nid.res2);
+
+	for (i = 0; i < nand_manuf_ids[i].id; i++) {
+		if (nand_manuf_ids[i].id == sc->nid.vid) {
+			printk(nand_manuf_ids[i].name);
+			break;
+		}
+	}
+
+	for (i = 0; i < nand_flash_ids[i].id; i++) {
+		if (nand_flash_ids[i].id == sc->nid.did) {
+			printk(" %s [%uMB]\n", nand_flash_ids[i].name,
+				nand_flash_ids[i].chipsize);
+			return nand_flash_ids[i].chipsize;
+		}
+	}
+
+	return 0;
+}
+
+ath_nand_vend_data_t *
+nand_get_entry(ath_nand_id_t *nand_id, ath_nand_vend_data_t *tbl, int count)
+{
+	int     i;
+
+	for (i = 0; i < count; i++, tbl ++) {
+		if ((nand_id->__details.vid == tbl->vid) &&
+		    (nand_id->__details.did == tbl->did) &&
+		    (nand_id->byte_id[1] == tbl->b3)) {
+			return tbl;
+		}
+	}
+
+	return NULL;
+}
+
+static inline void
+ath_nand_onfi_endian_convert(uint8_t *buf)
+{
+	uint32_t	i, *u = (uint32_t *)(buf + ONFI_DEV_DESC);
+
+	for (i = 0; i < (ONFI_DEV_DESC_SZ / sizeof(*u)); i++) {
+		u[i] = __le32_to_cpu(u[i]);
+	}
+
+	// Hope nobody has a 20 character device description
+	buf[ONFI_DEV_DESC + ONFI_DEV_DESC_SZ - 1] = 0;
+}
+
+int
+nand_param_page(ath_nand_sc_t *sc, uint8_t *buf, unsigned count)
+{
+	unsigned int	tries, rddata;
+	uint8_t		*pa;
+
+	pa = virt_to_phys(buf);
+
+	for (tries = 3; tries; tries --) {
+		// ADDR0_0 Reg Settings
+		ath_reg_wr(ATH_NF_ADDR0_0, 0x0);
+
+		// ADDR0_1 Reg Settings
+		ath_reg_wr(ATH_NF_ADDR0_1, 0x0);
+
+		// DMA Start Addr
+		ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+
+		// DMA count
+		ath_reg_wr(ATH_NF_DMA_COUNT, count);
+
+		// Custom Page Size
+		ath_reg_wr(ATH_NF_PG_SIZE, count);
+
+		// DMA Control Reg
+		ath_reg_wr(ATH_NF_DMA_CTRL, 0xcc);
+
+		ath_nand_clear_int_status();
+		// READ PARAMETER PAGE
+		ath_reg_wr(ATH_NF_COMMAND, 0xec62);
+		while (ath_nand_get_cmd_end_status() == 0);
+
+		rddata = ath_nand_status(sc, NULL) & READ_PARAM_STATUS_MASK;
+		if (rddata == READ_PARAM_STATUS_OK) {
+			break;
+		} else {
+			printk("\nParam Page Failure: 0x%x", rddata);
+			ath_nand_hw_init(sc, NULL);
+		}
+	}
+
+	memcpy(buf, KSEG1ADDR(buf), count);	// get into the cache
+
+	//ath_nand_dump_buf(buf, buf, count);
+
+	if ((rddata == READ_PARAM_STATUS_OK) &&
+	    (buf[3] == 'O' && buf[2] == 'N' && buf[1] == 'F' && buf[0] == 'I')) {
+		ath_nand_onfi_endian_convert(buf);
+		printf("ONFI %s\n", buf + ONFI_DEV_DESC);
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * System initialization functions
+ */
+static int
+ath_nand_hw_init(ath_nand_sc_t *sc, void *p)
+{
+	uint8_t		id[8];
+	unsigned char	*pa;
+	unsigned	rddata, i;
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_NANDF_RESET_MASK);
+	udelay(250);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_NANDF_RESET_MASK);
+	udelay(100);
+
+	ath_reg_wr(ATH_NF_INT_MASK, ATH_NF_CMD_END_INT);
+	ath_nand_clear_int_status();
+
+	// TIMINGS_ASYN Reg Settings
+	ath_reg_wr(ATH_NF_TIMINGS_ASYN, ATH_NF_TIMING_ASYN);
+
+	// NAND Mem Control Reg
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);
+
+	// Reset Command
+	ath_reg_wr(ATH_NF_COMMAND, 0xff00);
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	udelay(1000);
+
+	rddata = ath_reg_rd(ATH_NF_STATUS);
+	for (i = 0; i < ATH_NF_STATUS_RETRY && rddata != 0xff; i++) {
+		udelay(25);
+		rddata = ath_reg_rd(ATH_NF_STATUS);
+	}
+
+	if (i == ATH_NF_STATUS_RETRY) {
+		printf("device reset failed\n");
+		while(1);
+	}
+
+	if (p) {
+		ath_nand_vend_data_t *entry;
+
+		ath_nand_clear_int_status();
+		pa = (void *)virt_to_phys(p ? p : id);
+		ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+		ath_reg_wr(ATH_NF_ADDR0_0, 0x0);
+		ath_reg_wr(ATH_NF_ADDR0_1, 0x0);
+		ath_reg_wr(ATH_NF_DMA_COUNT, 0x8);
+		ath_reg_wr(ATH_NF_PG_SIZE, 0x8);
+		ath_reg_wr(ATH_NF_DMA_CTRL, 0xcc);
+		ath_reg_wr(ATH_NF_COMMAND, 0x9061);	// READ ID
+		while (ath_nand_get_cmd_end_status() == 0);
+
+		rddata = ath_nand_status(sc, NULL);
+		if ((rddata & ATH_NF_RD_STATUS_MASK) != ATH_NF_STATUS_OK) {
+			printf("%s: ath nand status = 0x%x\n", __func__, rddata);
+		}
+
+		pa = p;
+		printk("Ath Nand ID[%p]: %02x:%02x:%02x:%02x:%02x\n",
+				pa, pa[3], pa[2], pa[1], pa[0], pa[7]);
+
+		sc->onfi[0] = 0;
+
+		entry = nand_get_entry((ath_nand_id_t *)p, ath_nand_arr, NUM_ATH_NAND);
+		if (entry) {
+			//sc->entry = entry;
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(entry->addrcyc);
+		} else if (nand_param_page(sc, sc->onfi, sizeof(sc->onfi)) == 0) {
+			rddata = sc->onfi[ONFI_NUM_ADDR_CYCLES];
+			rddata = ((rddata >> 4) & 0xf) + (rddata & 0xf);
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(rddata);
+		} else {
+			printk("Attempting to use unknown device\n");
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(5);
+		}
+
+		iodbg("******* %s done ******\n", __func__);
+	}
+
+	return 0;
+}
+
+/*
+ * Copied from drivers/mtd/nand/nand_base.c
+ * http://ptgmedia.pearsoncmg.com/images/chap17_9780132396554/elementLinks/17fig04.gif
+ *
+ * +---...---+--+----------+---------+
+ * |  2048   |  |          |         |
+ * | File    |cm| FS spare | ecc data|
+ * | data    |  |          |         |
+ * +---...---+--+----------+---------+
+ * cm -> clean marker (2 bytes)
+ * FS Spare -> bytes available for jffs2
+ */
+
+static void
+ath_nand_ecc_init(struct mtd_info *mtd)
+{
+#if ATH_NF_HW_ECC
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (is_small_block_device(sc)) {
+		// ECC cannot be supported...
+		sc->ecc_offset = 0;
+	} else {
+		sc->ecc_offset = mtd->writesize + ATH_NAND_JFFS2_ECC_OFF +
+						ATH_NAND_JFFS2_ECC_LEN;
+	}
+#else
+	sc->ecc_offset = 0;
+#endif
+}
+
+void
+ath_nand_set_ns(struct mtd_info *mtd)
+{
+#define ATH_DEF_PAGE_SIZE	(2u << 10)
+#define ATH_DEF_BLK_SIZE	(128u << 10)
+#define ATH_NAND_SPEC		"ns"
+
+	char ns[64], *p;
+
+	if ((p = getenv(ATH_NAND_SPEC))) {
+		/* don't override user setting */
+		return;
+	}
+
+	if (mtd->writesize == ATH_DEF_PAGE_SIZE &&
+	    mtd->erasesize == ATH_DEF_BLK_SIZE) {
+		return;
+	}
+
+	sprintf(ns, "-0x%x-0x%x", mtd->erasesize, mtd->writesize);
+	setenv(ATH_NAND_SPEC, ns);
+	printf("set " ATH_NAND_SPEC " %s\n", ns);
+}
+
+/*
+ * ath_nand_probe
+ *
+ * called by device layer when it finds a device matching
+ * one our driver can handled. This code checks to see if
+ * it can allocate all necessary resources then calls the
+ * nand layer to look for devices
+ */
+static ulong ath_nand_probe(void)
+{
+	ath_nand_sc_t	*sc = NULL;
+	struct mtd_info	*mtd = NULL;
+	int		i, err = 0, bbt_size;
+	unsigned	nf_ctrl_pg[][2] = {
+		/* page size in bytes, register val */
+		{   256, ATH_NF_CTRL_PAGE_SIZE_256	},
+		{   512, ATH_NF_CTRL_PAGE_SIZE_512	},
+		{  1024, ATH_NF_CTRL_PAGE_SIZE_1024	},
+		{  2048, ATH_NF_CTRL_PAGE_SIZE_2048	},
+		{  4096, ATH_NF_CTRL_PAGE_SIZE_4096	},
+		{  8192, ATH_NF_CTRL_PAGE_SIZE_8192	},
+		{ 16384, ATH_NF_CTRL_PAGE_SIZE_16384	},
+		{     0, ATH_NF_CTRL_PAGE_SIZE_0	},
+		};
+	unsigned	nf_ctrl_blk[][2] = {
+		/* no. of pages, register val */
+		{  32, ATH_NF_CTRL_BLOCK_SIZE_32	},
+		{  64, ATH_NF_CTRL_BLOCK_SIZE_64	},
+		{ 128, ATH_NF_CTRL_BLOCK_SIZE_128	},
+		{ 256, ATH_NF_CTRL_BLOCK_SIZE_256	},
+		{   0, 0				},
+		};
+
+	sc = &ath_nand_sc;
+	sc->mtd = &nand_info[nand_curr_device];
+
+	/* initialise the hardware */
+	err = ath_nand_hw_init(sc, &sc->nid);
+	if (err) {
+		goto out_err_hw_init;
+	}
+
+	/* initialise mtd sc data struct */
+	mtd = sc->mtd;
+	mtd->size = ath_parse_read_id(sc) << 20;
+
+	mtd->name		= DRV_NAME;
+	if (mtd->size == 0) {
+		mtd->size	= ath_plane_size[sc->nid.pls] << sc->nid.pn;
+	}
+
+	if (is_small_block_device(sc)) {
+		mtd->writesize		= sc->entry->pgsz;
+		mtd->writesize_shift	= ffs(mtd->writesize) - 1;
+		mtd->writesize_mask	= mtd->writesize - 1;
+
+		mtd->erasesize		= sc->entry->blk;
+		mtd->erasesize_shift	= ffs(mtd->erasesize) - 1;
+		mtd->erasesize_mask	= mtd->erasesize - 1;
+
+		mtd->oobsize		= sc->entry->spare;
+		mtd->oobavail		= mtd->oobsize;
+	} else if (!sc->onfi[0]) {
+		mtd->writesize_shift	= 10 + sc->nid.ps;
+		mtd->writesize		= (1 << mtd->writesize_shift);
+		mtd->writesize_mask	= (mtd->writesize - 1);
+
+		mtd->erasesize_shift	= 16 + sc->nid.bs;
+		mtd->erasesize		= (1 << mtd->erasesize_shift);
+		mtd->erasesize_mask	= (mtd->erasesize - 1);
+
+		mtd->oobsize		= (mtd->writesize / 512) * (8 << sc->nid.ss);
+		mtd->oobavail		= mtd->oobsize;
+	} else {
+		mtd->writesize		= *(uint32_t *)(&sc->onfi[ONFI_PAGE_SIZE]);
+		mtd->writesize_shift	= ffs(mtd->writesize) - 1;
+		mtd->writesize_mask	= (mtd->writesize - 1);
+
+		mtd->erasesize		= *(uint32_t *)(&sc->onfi[ONFI_PAGES_PER_BLOCK]) *
+					  mtd->writesize;
+		mtd->erasesize_shift	= ffs(mtd->erasesize) - 1;
+		mtd->erasesize_mask	= (mtd->erasesize - 1);
+
+		mtd->oobsize		= *(uint16_t *)(&sc->onfi[ONFI_SPARE_SIZE]);
+		mtd->oobavail		= mtd->oobsize;
+
+		mtd->size		= mtd->erasesize *
+					  (*(uint32_t *)(&sc->onfi[ONFI_BLOCKS_PER_LUN])) *
+					  sc->onfi[ONFI_NUM_LUNS];
+	}
+
+	for (i = 0; nf_ctrl_pg[i][0]; i++) {
+		if (nf_ctrl_pg[i][0] == mtd->writesize) {
+			sc->nf_ctrl |= nf_ctrl_pg[i][1];
+			break;
+		}
+	}
+
+	for (i = 0; nf_ctrl_blk[i][0]; i++) {
+		if (nf_ctrl_blk[i][0] == (mtd->erasesize / mtd->writesize)) {
+			sc->nf_ctrl |= nf_ctrl_blk[i][1];
+			break;
+		}
+	}
+
+	ath_nand_set_ns(mtd);
+
+	mtd->type		= MTD_NANDFLASH;
+	mtd->flags		= MTD_CAP_NANDFLASH;
+
+	mtd->read		= ath_nand_read;
+	mtd->write		= ath_nand_write;
+	mtd->erase		= ath_nand_erase;
+
+	//mtd->read_oob		= ath_nand_read_oob;
+	//mtd->write_oob		= ath_nand_write_oob;
+
+	mtd->block_isbad	= ath_nand_block_isbad;
+	mtd->block_markbad	= ath_nand_block_markbad;
+
+	mtd->priv		= sc;
+
+	ath_nand_ecc_init(mtd);
+
+	// bbt has 2 bits per block
+	bbt_size = ((mtd->size >> mtd->erasesize_shift) * 2) / 8;
+	sc->bbt = malloc(bbt_size);
+
+	if (sc->bbt) {
+		memset(sc->bbt, 0, bbt_size);
+	}
+
+	printf(	"====== NAND Parameters ======\n"
+		"sc = 0x%p bbt = 0x%p bbt_size = 0x%x nf_ctrl = 0x%x\n"
+		"page = 0x%x block = 0x%x oob = 0x%x\nsize = %uMB\n", sc, sc->bbt, bbt_size,
+		sc->nf_ctrl, mtd->writesize, mtd->erasesize, mtd->oobsize, mtd->size >> 20);
+
+	return mtd->size;
+
+out_err_hw_init:
+	return 0;
+}
+
+#if 0
+static struct platform_driver ath_nand_driver = {
+	//.probe		= ath_nand_probe,
+	.remove		= __exit_p(ath_nand_remove),
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+#endif
+
+ulong ath_nand_init(void)
+{
+	printk(DRV_DESC ", Version " DRV_VERSION
+		" (c) 2010 Atheros Communications, Ltd.\n");
+
+	//return platform_driver_register(&ath_nand_driver);
+	//return platform_driver_probe(&ath_nand_driver, ath_nand_probe);
+	return ath_nand_probe();
+}
diff --git a/board/ar7240/common/athr_s27_phy.c b/board/ar7240/common/athr_s27_phy.c
new file mode 100644
index 0000000000..225abe2f91
--- /dev/null
+++ b/board/ar7240/common/athr_s27_phy.c
@@ -0,0 +1,878 @@
+
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athr_s27_phy.h"
+
+/* PHY selections and access functions */
+
+typedef enum {
+    PHY_SRCPORT_INFO,
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG,
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+#define MODULE_NAME "ATHRS27"
+
+/*
+ * Track per-PHY port information.
+ */
+
+
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+
+   {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY4_ADDR,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+
+#define ATHR_GLOBALREGBASE    0
+
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+
+/* Forward references */
+BOOL athrs27_phy_is_link_alive(int phyUnit);
+uint32_t athrs27_reg_read(uint32_t reg_addr);
+void athrs27_reg_write(uint32_t reg_addr, uint32_t reg_val);
+unsigned int s27_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+void s27_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data);
+
+
+void athrs27_powersave_off(int phy_addr)
+{
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0x29);
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x36c0);
+
+}
+void athrs27_sleep_off(int phy_addr)
+{
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0xb);
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x3c00);
+}
+
+void athrs27_force_100M(int phyAddr,int duplex)
+{
+   /*
+    *  Force MDI and MDX to alternate ports 
+    *  Phy 0,2 and 4 -- MDI
+    *  Phy 1 and 3 -- MDX
+    */
+
+    if(phyAddr%2) {
+        s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+    }
+    else {
+        s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+    }
+
+    s27_wr_phy(phyAddr,0x1d,0x29);
+    s27_wr_phy(phyAddr,0x1e,0x0);
+    s27_wr_phy(phyAddr,0x10,0xc60);
+    s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,(0xa000|(duplex << 8)));
+}
+
+void athrs27_force_10M(int phyAddr,int duplex)
+{
+
+    athrs27_powersave_off(phyAddr);
+    athrs27_sleep_off(phyAddr);
+
+    s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,(0x8000 |(duplex << 8)));
+}
+
+int athrs27_reg_init(void)
+{
+#if S27_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+
+    /* if using header for register configuration, we have to     */
+    /* configure s27 register after frame transmission is enabled */
+    athrs27_reg_rmw(0x8,(1<<28));  /* Set WAN port is connected to GE0 */
+
+#if defined(S27_FORCE_100M)
+    athrs27_force_100M(ATHR_PHY4_ADDR,1);
+#elif  defined(S27_FORCE_10M)
+    athrs27_force_10M(ATHR_PHY4_ADDR,1);
+#else
+    s27_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0x9000);
+
+#endif
+#ifdef S27_PHY_DEBUG
+    printf(MODULE_NAME":OPERATIONAL_MODE_REG0:%x\n",athrs27_reg_read(OPERATIONAL_MODE_REG0));
+    printf(MODULE_NAME":REG 0x4-->:%x\n",athrs27_reg_read(0x4));
+    printf(MODULE_NAME":REG 0x2c-->:%x\n",athrs27_reg_read(0x2c));
+    printf(MODULE_NAME":REG 0x8-->:%x\n",athrs27_reg_read(0x8));
+#endif
+
+    return 0;
+}
+ 
+int athrs27_reg_init_lan(void)
+{
+    int i = 60;
+#if S26_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+    int       phyUnit;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+
+
+    /* reset switch */
+    printf(MODULE_NAME ": resetting s27\n");
+    athrs27_reg_write(0x0, athrs27_reg_read(0x0)|0x80000000);
+
+    while(i--) {
+        sysMsDelay(100);
+        if(!(athrs27_reg_read(0x0)&0x80000000))
+            break;
+    }
+    printf(MODULE_NAME ": s27 reset done\n");
+    athrs27_reg_write(PORT_STATUS_REGISTER0,0x4e);
+
+    athrs27_reg_rmw(OPERATIONAL_MODE_REG0,(1<<6));  /* Set GMII mode */
+
+    if (is_emu() || is_wasp()) {
+       athrs27_reg_rmw(0x2c,((1<<26)| (1<<16) | 0x1)); /* FiX ME: EBU debug */
+    }
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+#if defined(S27_FORCE_100M)
+        athrs27_force_100M(phyAddr,1);
+#elif defined(S27_FORCE_10M)
+        athrs27_force_10M(phyAddr,1);
+#else
+        s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,0x9000);
+#endif
+
+#if S27_PHY_DEBUG
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_FUNC_CONTROL);
+        printf("S27 ATHR_PHY_FUNC_CONTROL (%d):%x\n",phyAddr,rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_ID1);
+        printf("S27 PHY ID  (%d) :%x\n",phyAddr, rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_SPEC_STATUS);
+        printf("S27 PHY CTRL  (%d) :%x\n",phyAddr, rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_STATUS);
+        printf("S27 ATHR PHY STATUS  (%d) :%x\n",phyAddr, rd_val);
+#endif
+    }
+
+    /* 
+     * status[1:0]=2'h2;   - (0x10 - 1000 Mbps , 0x01 - 100Mbps, 0x0 - 10 Mbps)
+     * status[2]=1'h1;     - Tx Mac En
+     * status[3]=1'h1;     - Rx Mac En
+     * status[4]=1'h1;     - Tx Flow Ctrl En
+     * status[5]=1'h1;     - Rx Flow Ctrl En
+     * status[6]=1'h1;     - Duplex Mode
+     */
+    athrs27_reg_write(PORT_STATUS_REGISTER1, 0x200);  /* LAN - 1 */
+    athrs27_reg_write(PORT_STATUS_REGISTER2, 0x200);  /* LAN - 2 */
+    athrs27_reg_write(PORT_STATUS_REGISTER3, 0x200);  /* LAN - 3 */
+    athrs27_reg_write(PORT_STATUS_REGISTER4, 0x200);  /* LAN - 4 */
+
+    if (is_emu()) {
+        athrs27_reg_write(PORT_STATUS_REGISTER1, 0x4C);  /* LAN - 1 */
+        athrs27_reg_write(PORT_STATUS_REGISTER2, 0x4c);  /* LAN - 2 */
+        athrs27_reg_write(PORT_STATUS_REGISTER3, 0x4c);  /* LAN - 3 */
+        athrs27_reg_write(PORT_STATUS_REGISTER4, 0x4c);  /* LAN - 4 */
+    }
+
+    /* QM Control */
+    athrs27_reg_write(0x38, 0xc000050e);
+
+    /*
+     * status[11]=1'h0;    - CPU Disable
+     * status[7] = 1'b1;   - Learn One Lock
+     * status[14] = 1'b0;  - Learn Enable
+     */
+#ifdef ATHEROS_HEADER_EN
+    athrs27_reg_write(PORT_CONTROL_REGISTER0, 0x4804);
+#else
+   /* Atheros Header Disable */
+    athrs27_reg_write(PORT_CONTROL_REGISTER0, 0x4004);
+#endif
+
+    /* Tag Priority Mapping */
+    athrs27_reg_write(0x70, 0xfa50);
+
+    /* Enable ARP packets to CPU port */
+    athrs27_reg_write(S27_ARL_TBL_CTRL_REG,(athrs27_reg_read(S27_ARL_TBL_CTRL_REG) | 0x100000));
+
+   /* Enable Broadcast packets to CPU port */
+    athrs27_reg_write(S27_FLD_MASK_REG,(athrs27_reg_read(S27_FLD_MASK_REG) |
+                           S27_ENABLE_CPU_BROADCAST | S27_ENABLE_CPU_BCAST_FWD ));
+
+    return 0;
+}
+
+/******************************************************************************
+*
+* athrs27_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs27_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+    phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs27_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*   
+* Resets the associated PHY port.
+*   
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+BOOL
+athrs27_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+//#if S27_PHY_DEBUG
+    uint32_t  rd_val = 0;
+//#endif
+    uint32_t  ar7240_revid;
+
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+        if (!is_emu()) {
+           s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+
+           s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+        }
+        else  {
+		printf("############ is emulation ############\n");
+
+           if(ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN) {
+               s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+               s27_wr_phy(phyAddr,0x9, 0x0); //donot advertise 1000Mbps mode
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,0x0);
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+           }
+           else { 
+
+               s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,(ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE |
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL));
+               s27_wr_phy(phyAddr,0x9, 0x0); //donot advertise 1000Mbps mode
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,0x0);
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+           }
+       }
+       rd_val = s27_rd_phy(phyAddr,ATHR_PHY_CONTROL);
+       printf("%s ATHR_PHY_CONTROL %d :%x\n",__func__,phyAddr,rd_val);
+       rd_val = s27_rd_phy(phyAddr,ATHR_PHY_SPEC_STATUS);
+       printf("%s ATHR_PHY_SPEC_STAUS %d :%x\n",__func__,phyAddr,rd_val);
+    }
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    if (ethUnit == ENET_UNIT_LAN)
+        sysMsDelay(100);// changed by lsz, sysMsDelay(1000);
+    else
+        sysMsDelay(300);// changed by lsz, sysMsDelay(3000);
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN)
+            continue;
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus =  s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+        /* extend the cable length */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x14);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xf52);
+
+       /* Force Class A setting phys */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 4);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xebbb);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 5);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0x2c47);
+
+        /* fine-tune PHYs */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x3c);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0x1c1);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x37);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xd600);
+
+
+#ifdef S27_VER_1_0
+        /* turn off power saving */
+        s27_wr_phy(phyUnit, 29, 41);
+        s27_wr_phy(phyUnit, 30, 0);
+        printf("def_ S27_VER_1_0\n");
+#endif
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit,
+            s27_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS)));
+    }
+
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs27_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs27_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = s27_rd_phy (phyAddr, ATHR_PHY_SPEC_STATUS);
+                        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+                                break;
+                sysMsDelay(10);
+            } while(--ii);
+            if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+            }
+        }
+    }
+
+    return FALSE;
+}
+/******************************************************************************
+*
+* athrs27_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               ATHR_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               ATHR_PHY_SPEED_1000T;
+*/
+
+int
+athrs27_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+    int       phySpeed;
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        phySpeed = _10BASET;
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+
+            do {
+                phyHwStatus = s27_rd_phy(phyAddr,
+                                              ATHR_PHY_SPEC_STATUS);
+                        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+                                break;
+                sysMsDelay(10);
+            }while(--ii);
+
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                phySpeed = _10BASET;
+		break;
+            case 1:
+                phySpeed = _100BASET;
+		break;
+            case 2:
+                phySpeed = _1000BASET;
+		break;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        }
+
+        phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x18);
+
+        if(phySpeed == _100BASET) {
+            phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_DATA, 0xba8);
+        } else {
+            phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_DATA, 0x2ea);
+        }
+    }
+
+    if (ethUnit == ENET_UNIT_LAN)
+         phySpeed = _1000BASET;
+
+    return phySpeed;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs27_phy_is_up(int ethUnit)
+{
+
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+    int           phyUnit;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                printf("enet%d port%d down\n",ethUnit, phyUnit);
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            if(is_emu())
+            {
+                phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_STATUS);
+                if(phyAddr%2) {
+                    s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+                }
+                else {
+                    s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+                }
+
+                if((phyHwStatus & 0x4)==0)
+                {
+                   s27_wr_phy(phyAddr,0x9,0x0);
+                   if(phyAddr !=0x4)
+                       s27_wr_phy(phyAddr,0x4,0x41);
+                   s27_wr_phy(phyAddr,0x0,0x9000);
+                }
+            }
+
+            phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+             phyHwControl = s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+             phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_STATUS);
+
+            /* Check for AutoNegotiation complete */
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = s27_rd_phy(phyAddr,
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                printf("enet%d port%d up\n",ethUnit, phyUnit);
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+    return (linkCount);
+}
+
+unsigned int athrs27_reg_read(unsigned int s27_addr)
+{
+    unsigned int addr_temp;
+    unsigned int s27_rd_csr_low, s27_rd_csr_high, s27_rd_csr;
+    unsigned int data,unit = 0;
+    unsigned int phy_address, reg_address;
+
+    addr_temp = s27_addr >>2;
+    data = addr_temp >> 7;
+
+    phy_address = 0x1f;
+    reg_address = 0x10;
+
+    if (is_ar7240()) {
+        unit = 0;
+    }
+    else if(is_ar7241() || is_ar7242() || is_wasp()) {
+        unit = 1;
+    }
+
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+    reg_address = ((addr_temp << 1) & 0x1e);
+    s27_rd_csr_low = (uint32_t) phy_reg_read(unit,phy_address, reg_address);
+
+    reg_address = reg_address | 0x1;
+    s27_rd_csr_high = (uint32_t) phy_reg_read(unit,phy_address, reg_address);
+    s27_rd_csr = (s27_rd_csr_high << 16) | s27_rd_csr_low ;
+	
+    return(s27_rd_csr);
+}
+
+void athrs27_reg_write(unsigned int s27_addr, unsigned int s27_write_data)
+{
+    unsigned int addr_temp;
+    unsigned int data;
+    unsigned int phy_address, reg_address,unit = 0;
+
+    addr_temp = (s27_addr ) >>2;
+    data = addr_temp >> 7;
+
+    phy_address = 0x1f;
+    reg_address = 0x10;
+
+    if (is_ar7240()) {
+        unit = 0;
+    }
+    else if(is_ar7241() || is_ar7242() || is_wasp()) {
+        unit = 1;
+    }
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+
+    reg_address = (((addr_temp << 1) & 0x1e) | 0x1);
+    data = (s27_write_data >> 16) & 0xffff;
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    reg_address = ((addr_temp << 1) & 0x1e);
+    data = s27_write_data  & 0xffff;
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+}
+
+void athrs27_reg_rmw(unsigned int s27_addr, unsigned int s27_write_data)
+{
+    int val = athrs27_reg_read(s27_addr);
+    athrs27_reg_write(s27_addr,(val | s27_write_data));
+}
+
+unsigned int s27_rd_phy(unsigned int phy_addr, unsigned int reg_addr)
+{
+
+     unsigned int rddata, i = 100;
+
+
+    /* MDIO_CMD is set for read */
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = (rddata & 0x0) | (reg_addr<<16)
+              | (phy_addr<<21) | (1<<27)
+              | (1<<30) | (1<<31) ;
+
+    athrs27_reg_write(0x98, rddata);
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = rddata & (1<<31);
+
+    /* Check MDIO_BUSY status */
+    while(rddata && --i){
+        rddata = athrs27_reg_read(0x98);
+        rddata = rddata & (1<<31);
+    }
+
+    if(i <= 0)
+      printf("ERROR:%s failed:phy:%d reg:%X rddata:%X\n",
+                __func__,phy_addr,reg_addr,rddata);
+    /* Read the data from phy */
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = rddata & 0xffff;
+    return(rddata);
+}
+void s27_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data)
+{
+    unsigned int rddata,i = 100;
+
+    /* MDIO_CMD is set for read */
+
+    rddata = athrs27_reg_read(0x98);
+
+    rddata = (rddata & 0x0) | (write_data & 0xffff)
+               | (reg_addr<<16) | (phy_addr<<21)
+               | (0<<27) | (1<<30) | (1<<31) ;
+
+    athrs27_reg_write(0x98, rddata);
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = rddata & (1<<31);
+
+    /* Check MDIO_BUSY status */
+    while(rddata && --i){
+        rddata = athrs27_reg_read(0x98);
+        rddata = rddata & (1<<31);
+    }
+    if(i <= 0)
+      printf("ERROR:%s failed:phy:%d reg%X\n",__func__,phy_addr,reg_addr);
+
+}
+
+int athrs27_mdc_check()
+{
+    int i;
+
+    for (i=0; i<4000; i++) {
+        if(athrs27_reg_read(0x10c) != 0x18007fff)
+            return -1;
+    }
+    return 0;
+}
+
diff --git a/board/ar7240/common/athr_s27_phy.h b/board/ar7240/common/athr_s27_phy.h
new file mode 100644
index 0000000000..9846a4f0a3
--- /dev/null
+++ b/board/ar7240/common/athr_s27_phy.h
@@ -0,0 +1,208 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ATHRS27_PHY_H
+#define _ATHRS27_PHY_H
+
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_FUNC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+#define ATHR_PHY_INTR_ENABLE             0x12
+#define ATHR_PHY_INTR_STATUS             0x13
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+#define ATHR_ADVERTISE_1000HALF		      0x0100
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DUPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_LATCH_LINK_PASS                  0x0004 
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+#define OPERATIONAL_MODE_REG0                0x4
+
+/* S27 CSR Registers */
+
+#define PORT_STATUS_REGISTER0                0x0100 
+#define PORT_STATUS_REGISTER1                0x0200
+#define PORT_STATUS_REGISTER2                0x0300
+#define PORT_STATUS_REGISTER3                0x0400
+#define PORT_STATUS_REGISTER4                0x0500
+#define PORT_STATUS_REGISTER5                0x0600
+
+#define RATE_LIMIT_REGISTER0                 0x010C
+#define RATE_LIMIT_REGISTER1                 0x020C
+#define RATE_LIMIT_REGISTER2                 0x030C
+#define RATE_LIMIT_REGISTER3                 0x040C
+#define RATE_LIMIT_REGISTER4                 0x050C
+#define RATE_LIMIT_REGISTER5                 0x060C
+
+#define PORT_CONTROL_REGISTER0               0x0104
+#define PORT_CONTROL_REGISTER1               0x0204
+#define PORT_CONTROL_REGISTER2               0x0304
+#define PORT_CONTROL_REGISTER3               0x0404
+#define PORT_CONTROL_REGISTER4               0x0504
+#define PORT_CONTROL_REGISTER5               0x0604
+
+#define CPU_PORT_REGISTER                    0x0078
+#define MDIO_CTRL_REGISTER                   0x0098
+
+#define S27_ARL_TBL_FUNC_REG0                0x0050
+#define S27_ARL_TBL_FUNC_REG1                0x0054
+#define S27_ARL_TBL_FUNC_REG2                0x0058
+#define S27_FLD_MASK_REG                     0x002c
+#define S27_ARL_TBL_CTRL_REG                 0x005c
+#define S27_GLOBAL_INTR_REG                  0x10
+#define S27_GLOBAL_INTR_MASK_REG             0x14
+
+
+#define S27_ENABLE_CPU_BROADCAST             (1 << 26)
+#define S27_ENABLE_CPU_BCAST_FWD             (1 << 25)
+
+#define PHY_LINK_CHANGE_REG 		     0x4
+#define PHY_LINK_UP 		             0x400
+#define PHY_LINK_DOWN 		             0x800
+#define PHY_LINK_DUPLEX_CHANGE 		     0x2000
+#define PHY_LINK_SPEED_CHANGE		     0x4000
+#define PHY_LINK_INTRS			     (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+/* SWITCH QOS REGISTERS */
+
+#define ATHR_QOS_PORT_0			0x110 /* CPU PORT */
+#define ATHR_QOS_PORT_1			0x210
+#define ATHR_QOS_PORT_2			0x310
+#define ATHR_QOS_PORT_3			0x410
+#define ATHR_QOS_PORT_4			0x510
+
+#define ATHR_ENABLE_TOS                 (1 << 16)
+
+#define ATHR_QOS_MODE_REGISTER          0x030
+#define ATHR_QOS_FIXED_PRIORITY        ((0 << 31) | (0 << 28))
+#define ATHR_QOS_WEIGHTED              ((1 << 31) | (0 << 28)) /* Fixed weight 8,4,2,1 */
+#define ATHR_QOS_MIXED                 ((1 << 31) | (1 << 28)) /* Q3 for managment; Q2,Q1,Q0 - 4,2,1 */
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+#define mdelay(_x)      sysMsDelay(_x)
+
+#undef S27_VER_1_0
+
+/*
+ *  Atheros header defines
+ */
+#ifndef _ATH_HEADER_CONF
+#define _ATH_HEADER_CONF
+
+typedef enum {
+    NORMAL_PACKET,
+    RESERVED0,
+    MIB_1ST,
+    RESERVED1,
+    RESERVED2,
+    READ_WRITE_REG,
+    READ_WRITE_REG_ACK,
+    RESERVED3
+} AT_HEADER_TYPE;
+
+typedef struct {
+    uint16_t    reserved0  :2;
+    uint16_t    priority   :2;
+    uint16_t    type       :4;
+    uint16_t    broadcast  :1;
+    uint16_t    from_cpu   :1;
+    uint16_t    reserved1  :2;
+    uint16_t    port_num   :4;
+}at_header_t;
+
+#define ATHR_HEADER_LEN 2
+
+#endif // _ATH_HEADER_CONF
+
+typedef enum {
+    PORT_EG_UNMODIFIED = 0,  /**<  egress transmit packets unmodified */
+    PORT_EG_UNTAGGED,        /**<  egress transmit packets without vlan tag */
+    PORT_EG_TAGGED,          /**<  egress transmit packets with vlan tag */
+} port_1q_egmode_t;
+
+extern void set_packet_inspection_flag(int flag);
+
+#endif
diff --git a/board/ar7240/common/athrs16_phy.c b/board/ar7240/common/athrs16_phy.c
new file mode 100644
index 0000000000..3a68d7a8c6
--- /dev/null
+++ b/board/ar7240/common/athrs16_phy.c
@@ -0,0 +1,687 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athrs16_phy.h"
+
+/* PHY selections and access functions */
+typedef enum {
+    PHY_SRCPORT_INFO, 
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG, 
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+
+/*depend on connection between cpu mac and s16 mac*/
+#if defined (CONFIG_PORT0_AS_SWITCH)
+#define ENET_UNIT_LAN 0  
+#define ENET_UNIT_WAN 1
+#define CFG_BOARD_AP96 1
+
+#elif defined (CONFIG_AG7240_GE0_IS_CONNECTED)
+#define ENET_UNIT_LAN 0  
+#define CFG_BOARD_PB45 0
+#define CFG_BOARD_AP96 1
+#else
+#define ENET_UNIT_LAN 1  
+#define ENET_UNIT_WAN 0
+#define CFG_BOARD_PB45 1
+#endif
+
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+#define ATHR_IND_PHY 4
+
+#define MODULE_NAME "ATHRS16"
+#define S16_PHY_DEBUG 1
+extern int xmii_val;
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* phy port 0 -- LAN port 0 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,//ENET_UNIT_WAN,
+     0,
+     ATHR_PHY4_ADDR, 
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+    
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00, 
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+static uint8_t athr16_init_flag = 0;
+
+//#define ATHR_PHY_MAX (sizeof(ipPhyInfo) / sizeof(ipPhyInfo[0]))
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+            
+/* Forward references */
+BOOL athrs16_phy_is_link_alive(int phyUnit);
+uint32_t athrs16_reg_read(uint32_t reg_addr);
+void athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val);
+static void phy_mode_setup(void);
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+
+static void phy_mode_setup(void) 
+{
+#ifdef ATHRS16_VER_1_0
+    /*work around for phy4 rgmii mode*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);    
+
+    /*rx delay*/ 
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 0);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x824e);  
+
+    /*tx delay*/ 
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 5);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x3d47);    
+#endif
+}
+
+void athrs16_reg_init()
+{
+    /* if using header for register configuration, we have to     */
+    /* configure s16 register after frame transmission is enabled */
+    if (athr16_init_flag)
+        return;
+
+    /*Power on strip mode setup*/
+#if CFG_BOARD_PB45
+    athrs16_reg_write(0x208, 0x2fd0001);  /*tx delay*/   
+    athrs16_reg_write(0x108, 0x2be0001);  /*mac0 rgmii mode*/ 
+#elif CFG_BOARD_AP96
+    //athrs16_reg_write(0x8, 0x012e1bea);
+    athrs16_reg_write(0x8, 0x01261be2);
+#endif
+    
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER0, 0x7e);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER1, 0x200);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER2, 0x200);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER3, 0x200);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER4, 0x200);
+#if CFG_BOARD_PB45
+    athrs16_reg_write(0x600, 0x200);
+#elif CFG_BOARD_AP96
+    //athrs16_reg_write(0x600, 0x0);
+    athrs16_reg_write(0x600, 0x200);
+#endif
+
+//    athrs16_reg_write(S16_FLD_MASK_REG, 0x003f003f);
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)        
+#ifdef HEADER_EN        
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x6804);
+#else
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x6004);
+#endif
+
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER1, 0x6004);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER2, 0x6004);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER3, 0x6004);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER4, 0x6004);    
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER5, 0x6004);    
+#else
+#ifdef HEADER_EN        
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x4804);
+#else
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x4004);
+#endif
+#endif
+
+#ifdef FULL_FEATURE
+	hsl_dev_init(0, 2);
+#endif
+
+   /* Enable ARP packets to CPU port */
+    athrs16_reg_write(S16_ARL_TBL_CTRL_REG,(athrs16_reg_read(S16_ARL_TBL_CTRL_REG) | 0x100000));
+
+   /* Enable Broadcast packets to CPU port */
+    athrs16_reg_write(S16_FLD_MASK_REG,(athrs16_reg_read(S16_FLD_MASK_REG) | S16_ENABLE_CPU_BROADCAST ));
+
+    athrs16_reg_write(0x80,0x40000000);
+
+    athr16_init_flag = 1;
+#ifdef S16_PHY_DEBUG
+    printf("S16 CPU_PORT_REGISTER :%x\n", athrs16_reg_read ( S16_CPU_PORT_REGISTER ));
+    printf("S16 PORT_STATUS_REGISTER0  :%x\n", athrs16_reg_read ( S16_PORT_STATUS_REGISTER0 ));
+    printf("S16 PORT_STATUS_REGISTER1  :%x\n", athrs16_reg_read ( S16_PORT_STATUS_REGISTER1 ));
+    printf("S16 PORT_STATUS_REGISTER2  :%x\n", athrs16_reg_read ( S16_PORT_STATUS_REGISTER2 ));
+    printf("S16 PORT_STATUS_REGISTER3  :%x\n", athrs16_reg_read ( S16_PORT_STATUS_REGISTER3 ));
+    printf("S16 PORT_STATUS_REGISTER4  :%x\n", athrs16_reg_read ( S16_PORT_STATUS_REGISTER4 ));
+
+    printf("S16 PORT_CONTROL_REGISTER0 :%x\n", athrs16_reg_read ( S16_PORT_CONTROL_REGISTER0 ));
+    printf("S16 PORT_CONTROL_REGISTER1 :%x\n", athrs16_reg_read ( S16_PORT_CONTROL_REGISTER1 ));
+    printf("S16 PORT_CONTROL_REGISTER2 :%x\n", athrs16_reg_read ( S16_PORT_CONTROL_REGISTER2 ));
+    printf("S16 PORT_CONTROL_REGISTER3 :%x\n", athrs16_reg_read ( S16_PORT_CONTROL_REGISTER3 ));
+    printf("S16 PORT_CONTROL_REGISTER4 :%x\n", athrs16_reg_read ( S16_PORT_CONTROL_REGISTER4 ));
+#endif
+
+    printf("%s: complete\n",__func__);
+}
+
+/******************************************************************************
+*
+* athrs16_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs16_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs16_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs16_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+    
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        
+        phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,
+                      ATHR_ADVERTISE_ALL);
+
+        phy_reg_write(phyBase, phyAddr, ATHR_1000BASET_CONTROL,
+                      ATHR_ADVERTISE_1000FULL);
+
+        /* Reset PHYs*/
+        phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+                      ATHR_CTRL_AUTONEGOTIATION_ENABLE 
+                      | ATHR_CTRL_SOFTWARE_RESET);
+
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    sysMsDelay(1000);
+
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+#if 0
+	/* Enable RGMII */
+	phy_reg_write(0,phyUnit,0x1d,0x12);
+	phy_reg_write(0,phyUnit,0x1e,0x8);
+	/* Tx delay on PHY */
+	phy_reg_write(0,phyUnit,0x1d,0x5);
+	phy_reg_write(0,phyUnit,0x1e,0x100);
+        
+	/* Rx delay on PHY */
+	phy_reg_write(0,phyUnit,0x1d,0x0);
+	phy_reg_write(0,phyUnit,0x1e,0x8000);
+#endif
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+        ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit, 
+            phy_reg_read(ATHR_PHYBASE(phyUnit),
+                         ATHR_PHYADDR(phyUnit),
+                         ATHR_PHY_SPEC_STATUS)));
+    }
+    phy_mode_setup();    
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs16_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs16_phy_is_fdx(int ethUnit)
+{
+    int       phyUnit;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read (phyBase, phyAddr, 
+                                               ATHR_PHY_SPEC_STATUS);
+		if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			break;
+                sysMsDelay(10);
+            } while(--ii);
+            
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs16_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100TX;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athrs16_phy_speed(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return _1000BASET;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
+                                              ATHR_PHY_SPEC_STATUS);
+		        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			        break;
+                sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+            
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                return _10BASET;
+            case 1:
+                return _100BASET;
+                break;
+            case 2:
+                return _1000BASET;
+                break;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        } 
+
+    }
+
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs16_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS);
+            if (!ATHR_RESET_DONE(phyHwStatus)) {
+                continue;
+            }
+
+            phyHwControl = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+            /* Check for AutoNegotiation complete */            
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+
+    return (linkCount);
+
+}
+
+uint32_t
+athrs16_reg_read(uint32_t reg_addr)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr, tmp_val, reg_val;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as MIBs, since it is read/clear, we should */
+    /* read the lower 16-bit register then the higher one */
+
+    /* read register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    reg_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    tmp_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+    reg_val |= (tmp_val << 16);
+
+    return reg_val;   
+}
+
+void
+athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as ARL and VLAN, since they include BUSY bit */
+    /* in lower address, we should write the higher 16-bit register then the */
+    /* lower one */
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) ((reg_val >> 16) & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* write register in lower address */
+    reg_word_addr--;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) (reg_val & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val); 
+}
+
+
+
diff --git a/board/ar7240/common/athrs16_phy.h b/board/ar7240/common/athrs16_phy.h
new file mode 100644
index 0000000000..3f1844afc0
--- /dev/null
+++ b/board/ar7240/common/athrs16_phy.h
@@ -0,0 +1,143 @@
+#ifndef _ATHRS16_PHY_H
+#define _ATHRS16_PHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+/* S16 CSR Registers */
+
+#define S16_PORT_STATUS_REGISTER0                0x0100 
+#define S16_PORT_STATUS_REGISTER1                0x0200
+#define S16_PORT_STATUS_REGISTER2                0x0300
+#define S16_PORT_STATUS_REGISTER3                0x0400
+#define S16_PORT_STATUS_REGISTER4                0x0500
+#define S16_PORT_STATUS_REGISTER5                0x0600
+
+#define S16_RATE_LIMIT_REGISTER0                 0x010C
+#define S16_RATE_LIMIT_REGISTER1                 0x020C
+#define S16_RATE_LIMIT_REGISTER2                 0x030C
+#define S16_RATE_LIMIT_REGISTER3                 0x040C
+#define S16_RATE_LIMIT_REGISTER4                 0x050C
+#define S16_RATE_LIMIT_REGISTER5                 0x060C
+
+#define S16_PORT_CONTROL_REGISTER0               0x0104
+#define S16_PORT_CONTROL_REGISTER1               0x0204
+#define S16_PORT_CONTROL_REGISTER2               0x0304
+#define S16_PORT_CONTROL_REGISTER3               0x0404
+#define S16_PORT_CONTROL_REGISTER4               0x0504
+#define S16_PORT_CONTROL_REGISTER5               0x0604
+
+#define S16_CPU_PORT_REGISTER                    0x0078
+#define S16_MDIO_CTRL_REGISTER                   0x0098
+
+#define S16_ARL_TBL_FUNC_REG0                0x0050
+#define S16_ARL_TBL_FUNC_REG1                0x0054
+#define S16_ARL_TBL_FUNC_REG2                0x0058
+#define S16_FLD_MASK_REG                     0x002c
+#define S16_ARL_TBL_CTRL_REG                 0x005c
+#define S16_GLOBAL_INTR_REG                  0x10
+#define S16_GLOBAL_INTR_MASK_REG             0x14
+#define S16_PWR_ON_STRAP_REG                 0x8
+
+
+#define S16_ENABLE_CPU_BROADCAST             (1 << 26)
+
+#define S16_PHY_LINK_CHANGE_REG 		     0x4
+#define S16_PHY_LINK_UP 		             0x400
+#define S16_PHY_LINK_DOWN 		             0x800
+#define S16_PHY_LINK_DUPLEX_CHANGE 		     0x2000
+#define S16_PHY_LINK_SPEED_CHANGE		     0x4000
+#define S16_PHY_LINK_INTRS			     (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+/*add feature define here*/
+//#define FULL_FEATURE
+
+#ifdef CONFIG_AR7242_S16_PHY
+#undef HEADER_REG_CONF
+#undef HEADER_EN
+#endif
+
+void athrs16_reg_init(void);
+int athrs16_phy_is_up(int unit);
+int athrs16_phy_is_fdx(int unit);
+int athrs16_phy_speed(int unit);
+BOOL athrs16_phy_setup(int unit);
+
+#endif
+
+
diff --git a/board/ar7240/common/athrs17_phy.c b/board/ar7240/common/athrs17_phy.c
new file mode 100644
index 0000000000..d276a5d1a1
--- /dev/null
+++ b/board/ar7240/common/athrs17_phy.c
@@ -0,0 +1,628 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athrs17_phy.h"
+
+/* PHY selections and access functions */
+typedef enum {
+    PHY_SRCPORT_INFO, 
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG, 
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+#define ENET_UNIT_GE0 0
+#define ENET_UNIT_GE1 1
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+#define ATHR_IND_PHY 4
+
+#define MODULE_NAME "ATHRS17"
+#define S17_PHY_DEBUG 1
+extern int xmii_val;
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* phy port 0 -- LAN port 0 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     ATHR_PHY2_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     ATHR_PHY3_ADDR, 
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+     FALSE,
+     ENET_UNIT_GE0,//ENET_UNIT_GE1,
+     0,
+     ATHR_PHY4_ADDR, 
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+    
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_GE0,
+     0,
+     0x00, 
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+static uint8_t athr17_init_flag = 0;
+
+//#define ATHR_PHY_MAX (sizeof(ipPhyInfo) / sizeof(ipPhyInfo[0]))
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_GE0))
+            
+/* Forward references */
+BOOL athrs17_phy_is_link_alive(int phyUnit);
+uint32_t athrs17_reg_read(uint32_t reg_addr);
+void athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val);
+static void phy_mode_setup(void);
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+
+static void phy_mode_setup(void) 
+{
+#ifdef ATHRS17_VER_1_0
+    /*work around for phy4 rgmii mode*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);    
+
+    /*rx delay*/ 
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 0);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x824e);  
+
+    /*tx delay*/ 
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 5);     
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x3d47);    
+#endif
+}
+
+void athrs17_reg_init()
+{
+
+    int phy_addr = 0;
+
+    /* if using header for register configuration, we have to     */
+    /* configure s17 register after frame transmission is enabled */
+    
+    if (athr17_init_flag)
+        return;
+
+    athrs17_reg_write(0x624 , 0x7f7f7f7f);
+    athrs17_reg_write(0x10  , 0x40000000);
+    athrs17_reg_write(0x4   , 0x07600000);
+    athrs17_reg_write(0xc   , 0x01000000);
+    athrs17_reg_write(0x7c  , 0x0000007e);
+
+    /* AR8327/AR8328 v1.0 fixup */
+    if ((athrs17_reg_read(0x0) & 0xffff) == 0x1201)
+    {
+        for (phy_addr = 0x0; phy_addr <= ATHR_PHY_MAX; phy_addr++)
+        {
+            /* For 100M waveform */
+            phy_reg_write(0, phy_addr, 0x1d, 0x0);
+            phy_reg_write(0, phy_addr, 0x1e, 0x02ea);
+            /* Turn On Gigabit Clock */
+            phy_reg_write(0, phy_addr, 0x1d, 0x3d);
+            phy_reg_write(0, phy_addr, 0x1e, 0x68a0);
+        }
+    }
+ 
+
+    athr17_init_flag = 1;
+    printf("%s: complete\n",__func__);
+}
+
+/******************************************************************************
+*
+* athrs17_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs17_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs17_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs17_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+    
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        
+        phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,
+                      ATHR_ADVERTISE_ALL);
+
+        phy_reg_write(phyBase, phyAddr, ATHR_1000BASET_CONTROL,
+                      ATHR_ADVERTISE_1000FULL);
+
+        /* Reset PHYs*/
+        phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+                      ATHR_CTRL_AUTONEGOTIATION_ENABLE 
+                      | ATHR_CTRL_SOFTWARE_RESET);
+
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    sysMsDelay(1000);
+
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+#if 0
+	/* Enable RGMII */
+	phy_reg_write(0,phyUnit,0x1d,0x12);
+	phy_reg_write(0,phyUnit,0x1e,0x8);
+	/* Tx delay on PHY */
+	phy_reg_write(0,phyUnit,0x1d,0x5);
+	phy_reg_write(0,phyUnit,0x1e,0x100);
+        
+	/* Rx delay on PHY */
+	phy_reg_write(0,phyUnit,0x1d,0x0);
+	phy_reg_write(0,phyUnit,0x1e,0x8000);
+#endif
+        if (athrs17_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+        ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit, 
+            phy_reg_read(ATHR_PHYBASE(phyUnit),
+                         ATHR_PHYADDR(phyUnit),
+                         ATHR_PHY_SPEC_STATUS)));
+    }
+    phy_mode_setup();    
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs17_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs17_phy_is_fdx(int ethUnit)
+{
+    int       phyUnit;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+
+    if (ethUnit == ENET_UNIT_GE0)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs17_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read (phyBase, phyAddr, 
+                                               ATHR_PHY_SPEC_STATUS);
+		if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			break;
+                sysMsDelay(10);
+            } while(--ii);
+            
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs17_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100TX;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athrs17_phy_speed(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_GE0)
+        return _1000BASET;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs17_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
+                                              ATHR_PHY_SPEC_STATUS);
+		        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			        break;
+                sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+            
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                return _10BASET;
+            case 1:
+                return _100BASET;
+                break;
+            case 2:
+                return _1000BASET;
+                break;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        } 
+
+    }
+
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs17_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS);
+            if (!ATHR_RESET_DONE(phyHwStatus)) {
+                continue;
+            }
+
+            phyHwControl = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+            /* Check for AutoNegotiation complete */            
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr, 
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+
+    return (linkCount);
+
+}
+
+uint32_t
+athrs17_reg_read(uint32_t reg_addr)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr, tmp_val, reg_val;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as MIBs, since it is read/clear, we should */
+    /* read the lower 16-bit register then the higher one */
+
+    /* read register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    reg_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    tmp_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+    reg_val |= (tmp_val << 16);
+
+    return reg_val;   
+}
+
+void
+athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as ARL and VLAN, since they include BUSY bit */
+    /* in lower address, we should write the higher 16-bit register then the */
+    /* lower one */
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) ((reg_val >> 16) & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* write register in lower address */
+    reg_word_addr--;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) (reg_val & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val); 
+}
+
+
+
diff --git a/board/ar7240/common/athrs17_phy.h b/board/ar7240/common/athrs17_phy.h
new file mode 100644
index 0000000000..fa4f27f01d
--- /dev/null
+++ b/board/ar7240/common/athrs17_phy.h
@@ -0,0 +1,109 @@
+#ifndef _ATHRS17_PHY_H
+#define _ATHRS17_PHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+/* S17 CSR Registers */
+
+#define S17_ENABLE_CPU_BROADCAST             (1 << 26)
+
+#define S17_PHY_LINK_CHANGE_REG 		     0x4
+#define S17_PHY_LINK_UP 		             0x400
+#define S17_PHY_LINK_DOWN 		             0x800
+#define S17_PHY_LINK_DUPLEX_CHANGE 		     0x2000
+#define S17_PHY_LINK_SPEED_CHANGE		     0x4000
+#define S17_PHY_LINK_INTRS			     (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+/*add feature define here*/
+//#define FULL_FEATURE
+
+#ifdef CONFIG_AR7242_S17_PHY
+#undef HEADER_REG_CONF
+#undef HEADER_EN
+#endif
+
+void athrs17_reg_init(void);
+int athrs17_phy_is_up(int unit);
+int athrs17_phy_is_fdx(int unit);
+int athrs17_phy_speed(int unit);
+BOOL athrs17_phy_setup(int unit);
+
+#endif
+
+
diff --git a/board/ar7240/common/athrs_vir_phy.c b/board/ar7240/common/athrs_vir_phy.c
new file mode 100644
index 0000000000..6df4ced993
--- /dev/null
+++ b/board/ar7240/common/athrs_vir_phy.c
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+
+#define MODULE_NAME "ATHRS_VIR_PHY"
+
+#define TRUE    1
+#define FALSE   0
+#define BOOL	int
+
+/* Forward references */
+BOOL athr_vir_phy_is_link_alive(int phyUnit);
+
+
+/******************************************************************************
+*
+* athr_vir_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_vir_phy_is_link_alive(int phyUnit)
+{
+    return TRUE;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_vir_phy_setup(int ethUnit)
+{
+    return 0;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_vir_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    return TRUE;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_vir_phy_speed(int ethUnit,int phyUnit)
+{
+    return _1000BASET;
+}
+
+/*****************************************************************************
+*
+* athr_vir_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_vir_phy_is_up(int ethUnit)
+{
+    return 1;
+
+}
+/* Place holders */
+
+int 
+athr_vir_reg_init(void *arg)
+{
+   return 0;
+}
+
diff --git a/board/ar7240/common/athrsf1_phy.c b/board/ar7240/common/athrsf1_phy.c
new file mode 100644
index 0000000000..2f58e615b0
--- /dev/null
+++ b/board/ar7240/common/athrsf1_phy.c
@@ -0,0 +1,434 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athrsf1_phy.h"
+
+#define MODULE_NAME "ATHRSF1_PHY"
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY_MAX 5
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+ 
+/* Forward references */
+BOOL athr_phy_is_link_alive(int phyUnit);
+unsigned int last_phy_speed;
+
+void athr_enable_linkIntrs(int ethUnit) 
+{
+    return;
+}
+
+void athr_disable_linkIntrs(int ethUnit) 
+{
+	return;
+}
+void athr_auto_neg(int ethUnit,int phyUnit) 
+{ 
+    int timeout = 0;
+    uint16_t phyHwStatus;
+    
+    if(!is_emu()) {
+#if 0
+       phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+       phy_reg_write(ethUnit, phyUnit , ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+       phy_reg_write(ethUnit, phyUnit , ATHR_1000BASET_CONTROL, ATHR_ADVERTISE_1000FULL);
+#endif
+
+       printf("ATHR_AUTONEG_ADVERT:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_AUTONEG_ADVERT));
+       printf("ATHR_1000BASET_CONTROL:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_1000BASET_CONTROL));
+       printf("ATHR_PHY_CONTROL:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_PHY_CONTROL));
+    }
+    else {
+       phy_reg_write(ethUnit, phyUnit , ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+       /* Do not advertise 1000 */
+       phy_reg_write(ethUnit, phyUnit , ATHR_1000BASET_CONTROL,0x0);
+       phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+   /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    timeout=20;
+    for (;;) {
+        phyHwStatus = phy_reg_read(ethUnit, phyUnit, ATHR_PHY_CONTROL);
+
+        if (ATHR_RESET_DONE(phyHwStatus)) {
+            printf(MODULE_NAME": Port %d, Neg Success\n", phyUnit);
+            break;
+        }
+        if (timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+        if (--timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+
+        mdelay(150);
+    }
+
+    printf(MODULE_NAME": unit %d phy addr %x ", ethUnit, phyUnit);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_phy_is_link_alive(int phyUnit)
+{
+	uint16_t phyHwStatus;
+	uint32_t phyBase;
+	uint32_t phyAddr;
+
+	phyBase = ATHR_PHYBASE(phyUnit);
+	phyAddr = ATHR_PHYADDR(phyUnit);
+	phyHwStatus = phy_reg_read(0, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+	if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_phy_setup(int ethUnit)
+{
+	int       phyUnit = 0;
+	int       liveLinks = 0;
+
+	athr_auto_neg(ethUnit,phyUnit);
+
+	if (athr_phy_is_link_alive(phyUnit)) {
+		liveLinks++;
+		ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+	} else {
+		ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+	}
+	return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+         phyBase = ATHR_PHYBASE(phyUnit);
+         phyAddr = ATHR_PHYADDR(phyUnit);
+
+         do {
+                phyHwStatus = phy_reg_read(ethUnit, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+                mdelay(10);
+          } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+          
+          if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+          }
+    }
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        do {
+            phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+            mdelay(10);
+        } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+        phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                       ATHER_STATUS_LINK_SHIFT);
+
+        switch(phyHwStatus) {
+        case 0:
+	    if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x147);
+                last_phy_speed = phyHwStatus;
+            }
+            return _10BASET;
+        case 1:
+	     if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x147);
+                last_phy_speed = phyHwStatus;
+            }
+            return _100BASET;
+        case 2:
+   	      if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x0);
+                last_phy_speed = phyHwStatus;
+             }
+            return _1000BASET;
+        default:
+            printf("Unkown speed read!\n");
+        }
+    }
+
+      if (last_phy_speed != phyHwStatus)
+    	{
+        phy_reg_write(0, ATHR_PHYADDR(phyUnit), ATHR_DEBUG_PORT_ADDRESS, 0x0);
+        phy_reg_write(0, ATHR_PHYADDR(phyUnit), ATHR_DEBUG_PORT_DATA, 0x14e);
+        last_phy_speed = phyHwStatus;
+     }
+
+
+    //printf("athr_phy_speed: link down, returning 10t\n");
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < 1; phyUnit++) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+
+             phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) { /* check realtime link */
+                linkCount++;
+            } else {
+                phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+            /* If realtime failed check link in latch register before
+	     * asserting link down.
+             */
+                if (phyHwStatus & ATHR_LATCH_LINK_PASS)     
+                   linkCount++;
+		else
+                    lostLinks++;
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+
+            /* Check for reset complete */
+
+                phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+                phyHwControl = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_CONTROL);
+
+            /* Check for AutoNegotiation complete */ 
+           
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                    phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+                    if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                        gainedLinks++;
+                        linkCount++;
+                        lastStatus->isPhyAlive = TRUE;
+                   }  
+            }
+        }
+    }
+    return (linkCount);
+
+}
+/* Place holders */
+
+int 
+athr_reg_init(void *arg)
+{
+   return 0;
+}
+
diff --git a/board/ar7240/common/athrsf1_phy.h b/board/ar7240/common/athrsf1_phy.h
new file mode 100644
index 0000000000..4495d94f76
--- /dev/null
+++ b/board/ar7240/common/athrsf1_phy.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ATHRS26_RGMII_H
+#define _ATHRS26_RGMII_H
+#define BOOL int
+#include "athr_s27_phy.h"
+int athr_phy_is_up(int unit);
+int athr_phy_is_fdx(int unit,int phyUnit);
+int athr_phy_speed(int unit,int phyUnit);
+BOOL athr_phy_setup(int unit);
+BOOL athr_phy_is_link_alive(int phyUnit);
+#endif
diff --git a/board/ar7240/common/athrsf2_phy.c b/board/ar7240/common/athrsf2_phy.c
new file mode 100644
index 0000000000..7610c1fefb
--- /dev/null
+++ b/board/ar7240/common/athrsf2_phy.c
@@ -0,0 +1,377 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athrsf1_phy.h"
+
+#define MODULE_NAME "ATHRSF2_PHY"
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY_MAX 5
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+#define ATHR_PHY5_ADDR   0x5
+
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,                /* phy Base */
+     ATHR_PHY5_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+ 
+/* Forward references */
+BOOL athr_phy_is_link_alive(int phyUnit);
+
+void athr_enable_linkIntrs(int ethUnit) 
+{
+    return;
+}
+
+void athr_disable_linkIntrs(int ethUnit) 
+{
+	return;
+}
+void athr_auto_neg(int ethUnit,int phyUnit) 
+{ 
+    int timeout = 0;
+    uint16_t phyHwStatus;
+    int phyBase = 0,phyAddr =0;
+    
+    phyUnit = 0;
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    if(!is_emu()) {
+       phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+
+       printf("ATHR_AUTONEG_ADVERT:%X\n",phy_reg_read(phyBase, phyAddr,ATHR_AUTONEG_ADVERT));
+       printf("ATHR_1000BASET_CONTROL:%X\n",phy_reg_read(phyBase, phyAddr,ATHR_1000BASET_CONTROL));
+       printf("ATHR_PHY_CONTROL:%X\n",phy_reg_read(phyBase, phyAddr,ATHR_PHY_CONTROL));
+    }
+    else {
+       phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+       /* Do not advertise 1000 */
+       phy_reg_write(phyBase, phyAddr, ATHR_1000BASET_CONTROL,0x0);
+       phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+   /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    timeout=20;
+    for (;;) {
+        phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+        if (ATHR_RESET_DONE(phyHwStatus)) {
+            printf(MODULE_NAME": Port %d, Neg Success\n", phyUnit);
+            break;
+        }
+        if (timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+        if (--timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+
+        mdelay(150);
+    }
+
+    printf(MODULE_NAME": unit %d phy addr %x ", phyBase, phyAddr);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_phy_is_link_alive(int phyUnit)
+{
+	uint16_t phyHwStatus;
+	uint32_t phyBase;
+	uint32_t phyAddr;
+
+	phyBase = ATHR_PHYBASE(phyUnit);
+	phyAddr = ATHR_PHYADDR(phyUnit);
+
+	phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+	if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_phy_setup(int ethUnit)
+{
+	int       phyUnit = 0;
+	int       liveLinks = 0;
+
+	athr_auto_neg(ethUnit,phyUnit);
+
+	if (athr_phy_is_link_alive(phyUnit)) {
+		liveLinks++;
+		ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+	} else {
+		ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+	}
+	return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    phyUnit = 0;
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+         phyBase = ATHR_PHYBASE(phyUnit);
+         phyAddr = ATHR_PHYADDR(phyUnit);
+
+         do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr,ATHR_PHY_SPEC_STATUS);
+                mdelay(10);
+          } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+          
+          if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+          }
+    }
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+
+    phyUnit = 0;
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        do {
+            phyHwStatus = phy_reg_read(phyBase, phyAddr,ATHR_PHY_SPEC_STATUS);
+            mdelay(10);
+        } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+        phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                       ATHER_STATUS_LINK_SHIFT);
+
+        switch(phyHwStatus) {
+        case 0:
+            return _10BASET;
+        case 1:
+            return _100BASET;
+        case 2:
+            return _1000BASET;
+        default:
+            printf("Unkown speed read!!!!\n");
+        }
+    }
+
+    //printf("athr_phy_speed: link down, returning 10t\n");
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit= 0; phyUnit < 1; phyUnit++) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+
+             phyHwStatus = phy_reg_read(phyBase, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) { /* check realtime link */
+                linkCount++;
+            } else {
+                phyHwStatus = phy_reg_read(phyBase, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+            /* If realtime failed check link in latch register before
+	     * asserting link down.
+             */
+                if (phyHwStatus & ATHR_LATCH_LINK_PASS)     
+                   linkCount++;
+		else
+                    lostLinks++;
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+
+            /* Check for reset complete */
+
+                phyHwStatus = phy_reg_read(phyBase, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+                phyHwControl = phy_reg_read(phyBase, ATHR_PHYADDR(phyUnit),ATHR_PHY_CONTROL);
+
+            /* Check for AutoNegotiation complete */ 
+           
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                    phyHwStatus = phy_reg_read(phyBase, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+                    if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                        gainedLinks++;
+                        linkCount++;
+                        lastStatus->isPhyAlive = TRUE;
+                   }  
+            }
+        }
+    }
+    return (linkCount);
+
+}
+/* Place holders */
+
+int 
+athr_reg_init(void *arg)
+{
+   /* Feed 50 Mhz internal clk */
+   ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0);
+   printf("F2 phy:%s\n",__func__);
+   return 0;
+}
diff --git a/board/ar7240/common/lowlevel_init.S b/board/ar7240/common/lowlevel_init.S
new file mode 100644
index 0000000000..89f0e83217
--- /dev/null
+++ b/board/ar7240/common/lowlevel_init.S
@@ -0,0 +1,212 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7240_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define clear_mask(_reg, _mask)                     \
+    li  t7, KSEG1ADDR(_reg);                        \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+#define set_val(_reg, _mask, _val)                  \
+    li  t7, KSEG1ADDR(_reg);                        \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t9, _val;                                   \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+#define set_val_f(_reg, _mask, _val)                \
+    li  t7, KSEG1ADDR(_reg);                        \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t6, KSEG1ADDR(_val);                        \
+    lw  t9, 0(t6);                                  \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)            
+
+
+#define get_val(_reg, _mask, _shift, _res_reg)      \
+    li  t7, KSEG1ADDR(_reg);                        \
+    lw  t8, 0(t7);                                  \
+    li  t9, _mask;                                  \
+    and t8, t8, t9;                                 \
+    srl _res_reg, t8, _shift                        \
+
+#define pll_clr(_mask)                              \
+    clear_mask(AR7240_CPU_PLL_CONFIG, _mask)
+
+#define pll_set(_mask, _val)                        \
+    set_val(AR7240_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_set_f(_mask, _val)                      \
+    set_val_f(AR7240_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_get(_mask, _shift, _res_reg)            \
+    get_val(AR7240_CPU_PLL_CONFIG, _mask, _shift, _res_reg)
+
+#define clk_clr(_mask)                              \
+    clear_mask(AR7240_CPU_CLOCK_CONTROL, _mask)
+
+#define clk_set(_mask, _val)                        \
+    set_val(AR7240_CPU_CLOCK_CONTROL,  _mask, _val)
+
+#define clk_get(_mask, _shift, _res_reg)            \
+    get_val(AR7240_CPU_CLOCK_CONTROL, _mask, _shift, _res_reg)
+
+
+/******************************************************************************
+ * first level initialization:
+ * 
+ * 0) If clock cntrl reset switch is already set, we're recovering from 
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ * 
+ *****************************************************************************/
+
+.globl lowlevel_init
+
+lowlevel_init:
+
+    /*
+     * The code below is for the real chip. Wont work on FPGA
+     */
+    /* jr ra  */
+
+#if !defined(CONFIG_AR7240_EMU) && defined(CONFIG_WASP_SUPPORT)
+#if !defined(CONFIG_ATH_NAND_BR)
+	b ar934x_lowlevel_init
+#endif
+#else
+
+#ifndef CONFIG_HORNET_EMU
+#if defined(CONFIG_MACH_HORNET)
+    b hornet_pll_init
+#else
+wdt_reset:
+#ifndef CONFIG_AR7240_EMU
+	li	$3, -1207566336		# 0xffffffffb8060000
+	ori	$4, $3, 0x8
+	lw	$2, 0($4)
+	bltz	$2, $L6
+	nop
+	ori	$5, $3, 0xc
+
+	li	$3, 300			# 0x4
+	sw	$3, 0($5)
+	li	$3, 3			# 0x3
+	sw	$3, 0($4)
+$L3:
+	b	$L3
+	nop
+#endif
+$L6:
+	nop
+	nop
+#ifndef CONFIG_AR7240_EMU
+#ifndef COMPRESSED_UBOOT
+
+    /* 
+     * WAR for the bug#55574: Set the CKE (bit 7 in DDR_CONFIG2 register) 
+     * to low initially 
+     */
+    li  t7, KSEG1ADDR(AR7240_DDR_CONFIG2);
+    lw  t8, 0(t7);
+    li  t9, 0xffffff7f;
+    and t8, t8, t9;
+    sw  t8, 0(t7);
+#endif
+
+    /*
+     * Check if the PLL is already set and CPU is Reset
+     */
+    clk_get(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CONTROL_RST_SWITCH_SHIFT, t6)
+    bne zero, t6, initialize_pll
+    nop
+
+init_pll_values:
+    li  a2,PLL_CONFIG_VAL_F                 # 0xffffffffbf040000
+    lw  a0,0(a2)
+    li  v1,PLL_MAGIC                        # 0xffffffffaabb0000
+    beq a0,v1,read_pll_from_flash
+    nop
+
+#ifdef CONFIG_SUPPORT_AR7241
+    li  t7, KSEG1ADDR(AR7240_REV_ID)
+    lw  t8, 0(t7)
+    li  t9, AR7240_REV_ID_MASK
+    and t8, t8, t9
+    li  v1, AR7241_REV_1_0
+    beq t8,v1,init_7241_pll
+    nop
+    li  v1, AR7242_REV_1_0
+    beq t8,v1,init_7241_pll
+    nop
+    bne t8,v1,init_default
+
+init_7241_pll:
+    pll_clr(PLL_CONFIG_PLL_RESET_MASK)
+    pll_set( (PLL_CONFIG_DDR_DIV_MASK | PLL_CONFIG_AHB_DIV_MASK | PLL_CONFIG_PLL_NOPWD_MASK | PLL_CONFIG_PLL_REF_DIV_MASK | PLL_CONFIG_PLL_DIV_MASK) ,( PLL_7241_CONFIG_PLL_REF_DIV_VAL|PLL_7241_CONFIG_PLL_DIV_VAL|PLL_7241_CONFIG_AHB_DIV_VAL|PLL_7241_CONFIG_DDR_DIV_VAL|PLL_CONFIG_PLL_NOPWD_VAL))
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK) 
+    b wait_for_pll_update
+    nop
+
+init_default:
+#endif
+
+    pll_clr(PLL_CONFIG_PLL_RESET_MASK)
+    pll_set( (PLL_CONFIG_DDR_DIV_MASK | PLL_CONFIG_AHB_DIV_MASK | PLL_CONFIG_PLL_NOPWD_MASK | PLL_CONFIG_PLL_REF_DIV_MASK | PLL_CONFIG_PLL_DIV_MASK) ,( PLL_CONFIG_PLL_REF_DIV_VAL|PLL_CONFIG_PLL_DIV_VAL|PLL_CONFIG_AHB_DIV_VAL|PLL_CONFIG_DDR_DIV_VAL|PLL_CONFIG_PLL_NOPWD_VAL))
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK) 
+    b wait_for_pll_update
+    nop
+
+read_pll_from_flash:
+    pll_clr(PLL_CONFIG_PLL_RESET_MASK)
+    pll_set_f((PLL_CONFIG_DDR_DIV_MASK | PLL_CONFIG_AHB_DIV_MASK | PLL_CONFIG_PLL_NOPWD_MASK | PLL_CONFIG_PLL_REF_DIV_MASK | PLL_CONFIG_PLL_DIV_MASK) ,((PLL_CONFIG_VAL_F + 4) | PLL_CONFIG_PLL_NOPWD_VAL))
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK) 
+    b wait_for_pll_update
+    nop
+
+
+wait_for_pll_update:
+    pll_get(PLL_CONFIG_PLL_UPDATE_MASK, PLL_CONFIG_PLL_UPDATE_SHIFT, t6)
+    bne zero, t6, wait_for_pll_update
+    nop
+
+    /*
+     * Will cause a reset
+     * The RESET_SWITCH need to be set first and then 
+     * set the CLOCK_SWITCH for the CPU to boot properly
+     * after RESET.
+     */
+pll_locked:
+    clk_set(CLOCK_CONTROL_RST_SWITCH_MASK, 0x2)
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 0x1)
+    nop
+
+    /*
+     * When the PLL is already set and CPU is RESET
+     * The code will jump here
+     */
+initialize_pll:
+    clk_clr(CLOCK_CONTROL_RST_SWITCH_MASK)
+    clk_clr(CLOCK_CONTROL_CLOCK_SWITCH_MASK)
+#endif
+#endif /* CONFIG_MACH_HORNET */
+#endif /* CONFIG_HORNET_EMU */
+#endif /* CONFIG_MAC_WASP */
+    jr ra
+    nop
+
diff --git a/board/ar7240/common/lowlevel_init_934x-1.1.S b/board/ar7240/common/lowlevel_init_934x-1.1.S
new file mode 100644
index 0000000000..ce69a3a995
--- /dev/null
+++ b/board/ar7240/common/lowlevel_init_934x-1.1.S
@@ -0,0 +1,405 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7240_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define set_val(_reg, _mask, _val)		\
+	li	t7,	KSEG1ADDR(_reg);	\
+	lw	t8,	0(t7);			\
+	li	t9,	~_mask;			\
+	and	t8,	t8,	t9;		\
+	li	t9,	_val;			\
+	or	t8,	t8,	t9;		\
+	sw	t8,	0(t7)
+
+#define cpu_pll_set(_mask, _val)	\
+	set_val(AR934X_CPU_PLL_CONFIG, _mask, _val)
+
+#define ddr_pll_set(_mask, _val)	\
+	set_val(AR934X_DDR_PLL_CONFIG, _mask, _val)
+
+#define cpu_ddr_control_set(_mask, _val)	\
+	set_val(AR934X_CPU_DDR_CLOCK_CONTROL, _mask, _val)
+
+#define set_bb_pll(reg, val)		\
+	li	t7,	KSEG1ADDR(reg);	\
+	li	t8,	val;		\
+	sw	t8,	0(t7);
+
+#define set_srif_pll(reg, val)		\
+	li	t7,	KSEG1ADDR(reg);	\
+	li	t8,	val;		\
+	sw	t8,	0(t7);
+
+#define set_srif_pll_reg(reg, _r)	\
+	li	t7,	KSEG1ADDR(reg);	\
+	sw	_r,	0(t7);
+
+#define inc_loop_count(loc)		\
+	li	t9,	loc;		\
+	lw	t7,	0(t9);		\
+	addi	t7,	t7,	1;	\
+	sw	t7,	0(t9);
+
+#define clear_loop_count(loc)	\
+	li	t9,	loc;	\
+	sw	zero,	0(t9);
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl ar934x_1_dot_1_lowlevel_init
+	.type	ar934x_1_dot_1_lowlevel_init, @function
+	.text
+	.align 4
+ar934x_1_dot_1_lowlevel_init:
+
+	set_bb_pll(DPLL2_ADDRESS_c4, 0x13210f00);
+	set_bb_pll(DPLL3_ADDRESS_c8, 0x03000000);
+	set_bb_pll(DPLL2_ADDRESS_44, 0x13210f00);
+	set_bb_pll(DPLL3_ADDRESS_48, 0x03000000);
+	set_bb_pll(DPLL3_ADDRESS_88, 0x03000000);
+
+	li	t5,	KSEG1ADDR(WASP_BOOTSTRAP_REG);
+	li	t6,	WASP_REF_CLK_25
+	lw	t7,	0(t5);
+	and	t6,	t7,	t6
+	beq	zero,	t6,	setup_ref25_val
+	nop
+setup_ref40_val:
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL_40
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL_40
+	li	t7,	CPU_PLL_NFRAC_40
+	li	t9,	DDR_PLL_NFRAC_40
+	b	1f
+	nop
+
+setup_ref25_val:
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL_25
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL_25
+	li	t7,	CPU_PLL_NFRAC_25
+	li	t9,	DDR_PLL_NFRAC_25
+
+1:
+	li	t4,	(CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+			CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+	or	t4,	t4,	t7
+
+	li	t8,	(CPU_PLL_CONFIG_REF_DIV_VAL | \
+			CPU_PLL_CONFIG_RANGE_VAL | \
+			CPU_PLL_CONFIG_OUT_DIV_VAL2);
+	or	t5,	t5,	t8
+
+	li	t8,	(DDR_PLL_CONFIG_REF_DIV_VAL | \
+			DDR_PLL_CONFIG_RANGE_VAL | \
+			DDR_PLL_CONFIG_OUT_DIV_VAL2);
+	or	t6,	t6,	t8
+
+#if 0 /* !defined(CONFIG_AP123) && !defined(CONFIG_MI124) */
+	/*
+	 * From: Ravi Subramanian
+	 * Subject: Workaround for 5G RX reset-reset variation
+	 * Date: Mon, 30 Aug 2010 12:53:49 +0530
+	 *
+	 * We are observing a reset to reset issue related to 5G RX
+	 * performance (and EVM). As a workaround, pushing the DDR
+	 * frequency from 400 MHz to 406 MHz, fixes this issue.
+	 * Could you please give us a new u-boot with the following
+	 * change?
+	 */
+	li	t3,	(DDR_PLL_DITHER_DITHER_EN_SET(1) | \
+			DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+#else
+	li	t3,	(DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+			DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+#endif
+
+	or	t3,	t3,	t9
+
+	li	t7,	PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	PLL_MAGIC
+	beq	t7,	t8,	read_from_flash
+	nop
+	j	pll_bypass_set
+	nop
+read_from_flash:
+	li	t7,	PLL_CONFIG_VAL_F + 4
+	lw	t5,	0(t7)
+	lw	t4,	4(t7)
+	lw	t6,	8(t7)
+	lw	t3,	12(t7)
+
+
+pll_bypass_set:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+init_cpu_pll:
+	li	t7,	KSEG1ADDR(AR934X_CPU_PLL_CONFIG);
+	li	t8,	CPU_PLL_CONFIG_PLLPWD_SET(1)
+	or	t8,	t8,	t5
+	sw	t8,	0(t7);
+
+init_ddr_pll:
+	li	t7,	KSEG1ADDR(AR934X_DDR_PLL_CONFIG);
+	li	t8,	DDR_PLL_CONFIG_PLLPWD_SET(1)
+	or	t8,	t8,	t6
+	sw	t8,	0(t7);
+
+init_ahb_pll:
+	li	t7,	KSEG1ADDR(AR934X_CPU_DDR_CLOCK_CONTROL);
+	li	t8,	(CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL | \
+			CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR | \
+			CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR | \
+			CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU | \
+			CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV | \
+			CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV | \
+			CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1) | \
+			CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1) | \
+			CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+	sw	t8,	0(t7);
+#define cpu_from_srif	1
+#define ddr_from_srif	1
+
+pll_pwd_unset:
+#if !cpu_from_srif
+	cpu_pll_set(CPU_PLL_CONFIG_PLLPWD_MASK, CPU_PLL_CONFIG_PLLPWD_SET(0));
+#endif
+#if !ddr_from_srif
+	ddr_pll_set(DDR_PLL_CONFIG_PLLPWD_MASK, DDR_PLL_CONFIG_PLLPWD_SET(0));
+#endif
+
+srif_set:
+	/* See if we have to read the pll values from flash */
+	li	t7,	SRIF_PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	SRIF_PLL_MAGIC
+	beq	t7,	t8,	read_srif_from_flash
+	nop
+
+	/* Use built in values, based on ref clock */
+	li	t5,	KSEG1ADDR(WASP_BOOTSTRAP_REG);
+	li	t6,	WASP_REF_CLK_25
+	lw	t7,	0(t5);
+	and	t6,	t7,	t6
+	beq	zero,	t6,	1f
+	nop
+#if !defined(CONFIG_AP123)
+	/*		refdiv		nint		nfrac */
+#if cpu_from_srif
+	li	t4,	((0x8 << 27) | (112 << 18) | 0);// cpu freq = (40 MHz refclk/refdiv 8) * Nint
+#endif
+#if ddr_from_srif
+#ifdef CONFIG_ATH_NAND_SUPPORT
+	li	t5,	((0x8 << 27) | (160 << 18) | 0);// ddr freq = (40 MHz refclk/refdiv 8) * Nint
+#else
+	li	t5,	((0x8 << 27) | (90 << 18) | 0);	// ddr freq = (40 MHz refclk/refdiv 8) * Nint
+#endif /* CONFIG_ATH_NAND_SUPPORT */
+#endif
+	j	2f
+	nop
+1:
+#if cpu_from_srif
+	li	t4,	((0x5 << 27) | (112 << 18) | 0);// cpu freq = (25 MHz refclk/refdiv 5) * Nint
+#endif
+#if ddr_from_srif
+#ifdef CONFIG_ATH_NAND_SUPPORT
+	li	t5,	((0x5 << 27) | (160 << 18) | 0);// ddr freq = (25 MHz refclk/refdiv 5) * Nint
+#else
+	li	t5,	((0x5 << 27) | (90 << 18) | 0);	// ddr freq = (25 MHz refclk/refdiv 5) * Nint
+#endif /* CONFIG_ATH_NAND_SUPPORT */
+#endif
+	j	2f
+	nop
+#else	/* defined(CONFIG_AP123) */
+	/*		refdiv		nint		nfrac */
+#if cpu_from_srif
+	li	t4,	((0x8 << 27) | (107 << 18) | 0);// cpu freq = (40 MHz refclk/refdiv 8) * Nint
+#endif
+#if ddr_from_srif
+	li	t5,	((0x8 << 27) | (160 << 18) | 0);// ddr freq = (40 MHz refclk/refdiv 8) * Nint
+#endif
+	j	2f
+	nop
+1:
+#if cpu_from_srif
+	li	t4,	((0x5 << 27) | (107 << 18) | 0);// cpu freq = (25 MHz refclk/refdiv 5) * Nint
+#endif
+#if ddr_from_srif
+	li	t5,	((0x5 << 27) | (160 << 18) | 0);// ddr freq = (25 MHz refclk/refdiv 5) * Nint
+#endif
+	j	2f
+	nop
+#endif	/* !defined(CONFIG_AP123) */
+
+read_srif_from_flash:
+	li	t7,	SRIF_PLL_CONFIG_VAL_F + 4
+#if cpu_from_srif
+	lw	t4,	0(t7);	// CPU PLL
+#endif
+#if ddr_from_srif
+	lw	t5,	4(t7);	// DDR PLL
+#endif
+	/* CPU */
+2:
+
+	clear_loop_count(ATH_CPU_COUNT_LOC);
+
+cpu_pll_is_not_locked:
+
+	inc_loop_count(ATH_CPU_COUNT_LOC);
+
+#if cpu_from_srif
+	set_srif_pll(0xb81161c4, (0x4 << 26) | (0x10 << 19) | (0x1e << 7) | (1 << 16));
+	set_srif_pll_reg(0xb81161c0, t4);
+	set_srif_pll(0xb81161c4, (0x3 << 30) | (0x4 << 26) | (0x10 << 19) | (0x1e << 7) | (1 << 16));
+	set_srif_pll(0xb81161c8, (6 << 23));
+	set_srif_pll(0xb81161c4, (0x3 << 30) | (0x4 << 26) | (0x10 << 19) | (0x1e << 7));
+
+cpu_clear_do_meas1:
+	li	t7,	KSEG1ADDR(CPU_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	~CPU_DPLL3_DO_MEAS_SET(1)
+	and	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+cpu_set_do_meas:
+	li	t7,	KSEG1ADDR(CPU_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	CPU_DPLL3_DO_MEAS_SET(1)
+	or	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+	li	t7,	KSEG1ADDR(CPU_DPLL4_ADDRESS)
+cpu_wait_for_meas_done:
+	lw	t8,	0(t7)
+	andi	t8,	t8,	CPU_DPLL4_MEAS_DONE_SET(1)
+	beqz	t8,	cpu_wait_for_meas_done
+	nop
+
+cpu_clear_do_meas2:
+	li	t7,	KSEG1ADDR(CPU_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	~CPU_DPLL3_DO_MEAS_SET(1)
+	and	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+cpu_read_sqsum_dvc:
+	li	t7,	KSEG1ADDR(CPU_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	CPU_DPLL3_SQSUM_DVC_MASK
+	and	t8,	t8,	t9
+	sra	t8,	t8,	CPU_DPLL3_SQSUM_DVC_LSB
+	li	t9,	0x40000
+	subu	t8,	t8,	t9
+	bgez	t8,	cpu_pll_is_not_locked
+	nop
+
+#endif
+
+	/* DDR */
+#if ddr_from_srif
+
+	clear_loop_count(ATH_DDR_COUNT_LOC)
+
+ddr_pll_is_not_locked:
+
+	inc_loop_count(ATH_DDR_COUNT_LOC)
+
+#if defined(CONFIG_ATH_NAND_SUPPORT)
+	set_srif_pll(0xb8116244, (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7) | (1 << 16));
+	set_srif_pll_reg(0xb8116240, t5);
+	set_srif_pll(0xb8116244, (0x1 << 30) | (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7) | (1 << 16));
+	set_srif_pll(0xb8116248, (6 << 23));
+	set_srif_pll(0xb8116244, (0x1 << 30) | (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7));
+#elif !defined(CONFIG_AP123)
+	set_srif_pll(0xb8116244, (0x4 << 26) | (0x10 << 19) | (0x1e << 7) | (1 << 16));
+	set_srif_pll_reg(0xb8116240, t5);
+	set_srif_pll(0xb8116244, (0x3 << 30) | (0x4 << 26) | (0x10 << 19) | (0x1e << 7) | (1 << 16));
+	set_srif_pll(0xb8116248, (6 << 23));
+	set_srif_pll(0xb8116244, (0x3 << 30) | (0x4 << 26) | (0x10 << 19) | (0x1e << 7));
+#else /* defined(CONFIG_AP123) */
+	/* AP123 uses outdiv = 1 for ddr pll */
+	set_srif_pll(0xb8116244, (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7) | (1 << 16));
+	set_srif_pll_reg(0xb8116240, t5);
+	set_srif_pll(0xb8116244, (0x1 << 30) | (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7) | (1 << 16));
+	set_srif_pll(0xb8116248, (6 << 23));
+	set_srif_pll(0xb8116244, (0x1 << 30) | (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7));
+#endif /* !defined(CONFIG_AP123) */
+
+ddr_clear_do_meas1:
+	li	t7,	KSEG1ADDR(DDR_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	~DDR_DPLL3_DO_MEAS_SET(1)
+	and	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+
+ddr_set_do_meas:
+	li	t7,	KSEG1ADDR(DDR_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	DDR_DPLL3_DO_MEAS_SET(1)
+	or	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+	li	t7,	KSEG1ADDR(DDR_DPLL4_ADDRESS)
+ddr_wait_for_meas_done:
+	lw	t8,	0(t7)
+	andi	t8,	t8,	DDR_DPLL4_MEAS_DONE_SET(1)
+	beqz	t8,	ddr_wait_for_meas_done
+	nop
+
+ddr_clear_do_meas2:
+	li	t7,	KSEG1ADDR(DDR_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	~DDR_DPLL3_DO_MEAS_SET(1)
+	and	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+ddr_read_sqsum_dvc:
+	li	t7,	KSEG1ADDR(DDR_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	DDR_DPLL3_SQSUM_DVC_MASK
+	and	t8,	t8,	t9
+	sra	t8,	t8,	DDR_DPLL3_SQSUM_DVC_LSB
+	li	t9,	0x40000
+	subu	t8,	t8,	t9
+	bgez	t8,	ddr_pll_is_not_locked
+	nop
+#endif
+
+pll_bypass_unset:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(0));
+
+ddr_pll_dither_unset:
+	li	t7,	KSEG1ADDR(AR934X_DDR_PLL_DITHER);
+	sw	t3,	0(t7);
+
+cpu_pll_dither_unset:
+	li	t7,	KSEG1ADDR(AR934X_CPU_PLL_DITHER);
+	sw	t4,	0(t7);
+
+	jr ra
+	nop
+
diff --git a/board/ar7240/common/lowlevel_init_934x.S b/board/ar7240/common/lowlevel_init_934x.S
new file mode 100644
index 0000000000..989e1b9769
--- /dev/null
+++ b/board/ar7240/common/lowlevel_init_934x.S
@@ -0,0 +1,180 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7240_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define set_val(_reg, _mask, _val)		\
+	li	t7,	KSEG1ADDR(_reg);	\
+	lw	t8,	0(t7);			\
+	li	t9,	~_mask;			\
+	and	t8,	t8,	t9;		\
+	li	t9,	_val;			\
+	or	t8,	t8,	t9;		\
+	sw	t8,	0(t7)
+
+#define cpu_pll_set(_mask, _val)	\
+	set_val(AR934X_CPU_PLL_CONFIG, _mask, _val)
+
+#define ddr_pll_set(_mask, _val)	\
+	set_val(AR934X_DDR_PLL_CONFIG, _mask, _val)
+
+#define cpu_ddr_control_set(_mask, _val)	\
+	set_val(AR934X_CPU_DDR_CLOCK_CONTROL, _mask, _val)
+
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl ar934x_lowlevel_init
+	.type	ar934x_lowlevel_init, @function
+.globl lowlevel_init
+	.type	lowlevel_init, @function
+	.text
+	.align 4
+
+ar934x_lowlevel_init:
+lowlevel_init:
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	li	t7,	AR7240_REV_ID
+	lw	t7,	0(t7)
+	andi	t9,	t7,	0xf
+	bne	zero,	t9,	ar934x_1_dot_1_lowlevel_init
+	nop
+
+	li	t5,	KSEG1ADDR(WASP_BOOTSTRAP_REG);
+	li	t6,	WASP_REF_CLK_25
+	lw	t7,	0(t5);
+	and	t6,	t7,	t6
+	beq	zero,	t6,	setup_ref25_val
+	nop
+setup_ref40_val:
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL_40
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL_40
+	b	1f
+	nop
+
+setup_ref25_val:
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL_25
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL_25
+
+1:
+	li	t4,	(CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+			CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+			CPU_PLL_NFRAC_MIN_SET | \
+			CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+#if 0
+	/*
+	 * From: Ravi Subramanian
+	 * Subject: Workaround for 5G RX reset-reset variation
+	 * Date: Mon, 30 Aug 2010 12:53:49 +0530
+	 *
+	 * We are observing a reset to reset issue related to 5G RX
+	 * performance (and EVM). As a workaround, pushing the DDR
+	 * frequency from 400 MHz to 406 MHz, fixes this issue.
+	 * Could you please give us a new u-boot with the following
+	 * change?
+	 */
+	li	t3,	(DDR_PLL_DITHER_DITHER_EN_SET(1) | \
+			DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+			DDR_PLL_DITHER_NFRAC_MIN_SET(0x200) | \
+			DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+#else
+	li	t3,	(DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+			DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+			DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+#endif
+
+	li	t7,	PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	PLL_MAGIC
+	beq	t7,	t8,	read_from_flash
+	nop
+	j	pll_bypass_set
+	nop
+read_from_flash:
+	li	t7,	PLL_CONFIG_VAL_F + 4
+	lw	t5,	0(t7)
+	lw	t4,	4(t7)
+	lw	t6,	8(t7)
+	lw	t3,	12(t7)
+
+
+pll_bypass_set:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+init_cpu_pll:
+	li	t7,	KSEG1ADDR(AR934X_CPU_PLL_CONFIG);
+	li	t8,	(CPU_PLL_CONFIG_PLLPWD_SET(1) | \
+			CPU_PLL_CONFIG_REF_DIV_VAL | \
+			CPU_PLL_CONFIG_RANGE_VAL | \
+			CPU_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t5
+	sw	t8,	0(t7);
+
+init_ddr_pll:
+	li	t7,	KSEG1ADDR(AR934X_DDR_PLL_CONFIG);
+	li	t8,	(DDR_PLL_CONFIG_PLLPWD_SET(1) | \
+			DDR_PLL_CONFIG_REF_DIV_VAL | \
+			DDR_PLL_CONFIG_RANGE_VAL | \
+			DDR_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t6
+	sw	t8,	0(t7);
+
+init_ahb_pll:
+	li	t7,	KSEG1ADDR(AR934X_CPU_DDR_CLOCK_CONTROL);
+	li	t8,	(CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL | \
+			CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR | \
+			CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR | \
+			CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU | \
+			CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV | \
+			CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV | \
+			CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1) | \
+			CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1) | \
+			CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+	sw	t8,	0(t7);
+
+pll_pwd_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_PLLPWD_MASK, CPU_PLL_CONFIG_PLLPWD_SET(0));
+	ddr_pll_set(DDR_PLL_CONFIG_PLLPWD_MASK, DDR_PLL_CONFIG_PLLPWD_SET(0));
+
+outdiv_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_OUTDIV_MASK, CPU_PLL_CONFIG_OUT_DIV_VAL2);
+	ddr_pll_set(DDR_PLL_CONFIG_OUTDIV_MASK, DDR_PLL_CONFIG_OUT_DIV_VAL2);
+
+pll_bypass_unset:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(0));
+
+ddr_pll_dither_unset:
+	li	t7,	KSEG1ADDR(AR934X_DDR_PLL_DITHER);
+	sw	t3,	0(t7);
+
+cpu_pll_dither_unset:
+	li	t7,	KSEG1ADDR(AR934X_CPU_PLL_DITHER);
+	sw	t4,	0(t7);
+
+#endif
+	jr ra
+	nop
diff --git a/board/ar7240/common/phy.h b/board/ar7240/common/phy.h
new file mode 100644
index 0000000000..96aec4b489
--- /dev/null
+++ b/board/ar7240/common/phy.h
@@ -0,0 +1,19 @@
+#ifndef _PHY_H
+#define _PHY_H
+
+#include <config.h>
+/*
+ * This file defines the interface between MAC and various phy switches.
+ */
+#define ag7240_unit2name(_unit) _unit ?  "eth1" : "eth0"
+extern int  ag7240_miiphy_read(char *devname, uint32_t phaddr,
+		uint8_t reg);
+extern int  ag7240_miiphy_write(char *devname, uint32_t phaddr,
+		uint8_t reg, uint16_t data);
+
+#define phy_reg_read(base, addr, reg)                    \
+    ag7240_miiphy_read(ag7240_unit2name(base), addr, reg)
+#define phy_reg_write(base, addr, reg, data)                   \
+        ag7240_miiphy_write(ag7240_unit2name(base), addr, reg, data)
+
+#endif
diff --git a/board/ar7240/cus136/Makefile b/board/ar7240/cus136/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/cus136/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/cus136/config.mk b/board/ar7240/cus136/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/cus136/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/cus136/cus136.c b/board/ar7240/cus136/cus136.c
new file mode 100644
index 0000000000..a333899e7d
--- /dev/null
+++ b/board/ar7240/cus136/cus136.c
@@ -0,0 +1,70 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Default tap values for starting the tap_init*/
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+
+    ar7240_gpio_config();
+#ifndef COMPRESSED_UBOOT
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "CUS136 (ar7240) U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("CUS136 (ar7240) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/cus136/flash.c b/board/ar7240/cus136/flash.c
new file mode 100644
index 0000000000..e1b30b51d6
--- /dev/null
+++ b/board/ar7240/cus136/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/cus136/u-boot.lds b/board/ar7240/cus136/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/cus136/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/db12x-extender/Makefile b/board/ar7240/db12x-extender/Makefile
new file mode 100644
index 0000000000..6898bc08b5
--- /dev/null
+++ b/board/ar7240/db12x-extender/Makefile
@@ -0,0 +1,62 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifdef BOOT_FROM_NAND
+OBJS	+= ../common/ath_nand_flash.o 
+else
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif 
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/db12x-extender/config.mk b/board/ar7240/db12x-extender/config.mk
new file mode 100644
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/db12x-extender/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/db12x-extender/db12x-extender.c b/board/ar7240/db12x-extender/db12x-extender.c
new file mode 100644
index 0000000000..961dad3ac1
--- /dev/null
+++ b/board/ar7240/db12x-extender/db12x-extender.c
@@ -0,0 +1,136 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+int
+wasp_mem_config(void)
+{
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+#if !defined(CONFIG_ATH_NAND_BR)
+	if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+		if (type == 2) {
+			// ddr1
+			ar7240_reg_wr_nf(0x18116c44, 0x10000000); /* AR_PHY_PMU2 */
+		} else {
+			// ddr2 & sdram
+			ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+		}
+	} else {
+		ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+	}
+#endif
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/db12x-extender/flash.c b/board/ar7240/db12x-extender/flash.c
new file mode 100644
index 0000000000..48f3df09bd
--- /dev/null
+++ b/board/ar7240/db12x-extender/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/db12x-extender/u-boot-bootstrap.lds b/board/ar7240/db12x-extender/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/db12x-extender/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/db12x-extender/u-boot.lds b/board/ar7240/db12x-extender/u-boot.lds
new file mode 100644
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/db12x-extender/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/db12x-hybrid/Makefile b/board/ar7240/db12x-hybrid/Makefile
new file mode 100644
index 0000000000..60b78b3dc6
--- /dev/null
+++ b/board/ar7240/db12x-hybrid/Makefile
@@ -0,0 +1,68 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifeq ($(BOOT_FROM_NAND),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif 
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/db12x-hybrid/config.mk b/board/ar7240/db12x-hybrid/config.mk
new file mode 100644
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/db12x-hybrid/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/db12x-hybrid/db12x-hybrid.c b/board/ar7240/db12x-hybrid/db12x-hybrid.c
new file mode 100644
index 0000000000..add5fbce5a
--- /dev/null
+++ b/board/ar7240/db12x-hybrid/db12x-hybrid.c
@@ -0,0 +1,170 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+	ar7240_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ar7240_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ar7240_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ar7240_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+#ifdef CONFIG_AP123
+	extern void ath_ddr_tap_cal(void);
+#endif
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+#ifdef CONFIG_AP123
+	ath_ddr_tap_cal();
+
+#ifndef COMPRESSED_UBOOT
+	printf("Tap value selected = 0x%x [0x%x - 0x%x]\n",
+		ar7240_reg_rd(AR7240_DDR_TAP_CONTROL0),
+		ar7240_reg_rd(0xbd007f10), ar7240_reg_rd(0xbd007f14));
+#endif
+#endif
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+	ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+
+	wasp_usb_initial_config();
+
+#endif /* !defined(CONFIG_ATH_NAND_BR) */
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */ 
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/db12x-hybrid/flash.c b/board/ar7240/db12x-hybrid/flash.c
new file mode 100644
index 0000000000..0d511b13b4
--- /dev/null
+++ b/board/ar7240/db12x-hybrid/flash.c
@@ -0,0 +1,30 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
diff --git a/board/ar7240/db12x-hybrid/u-boot-bootstrap.lds b/board/ar7240/db12x-hybrid/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/db12x-hybrid/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/db12x-hybrid/u-boot.lds b/board/ar7240/db12x-hybrid/u-boot.lds
new file mode 100644
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/db12x-hybrid/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/db12x/Makefile b/board/ar7240/db12x/Makefile
new file mode 100644
index 0000000000..b6a9439dc5
--- /dev/null
+++ b/board/ar7240/db12x/Makefile
@@ -0,0 +1,78 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+#
+# The files included in EXTRA_OBJS use some functions that are not
+# available in the `bootstrap' portion of tuboot.bin resulting in
+# compile/link errors. Hence have them separate (i.e. don't include
+# into lib$(BOARD).a and include them only in `u-boot' portion of
+# tuboot.bin.
+#
+
+ifeq ($(strip $(COMPRESSED_UBOOT)),0) #{
+OBJS	+= $(BOARD_EXTRA_OBJS_tmp)
+else
+EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif #}
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS) $(EXTRA_OBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/db12x/config.mk b/board/ar7240/db12x/config.mk
new file mode 100755
index 0000000000..df2665e385
--- /dev/null
+++ b/board/ar7240/db12x/config.mk
@@ -0,0 +1,35 @@
+# ROM version
+ifdef BOOT_FROM_NAND #{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0xa0100000
+else #}{
+TEXT_BASE = 0xa0100000
+endif #}
+else #}{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else #}{
+TEXT_BASE = 0x9f000000
+endif #}
+endif #}
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
+
+export BOARD_EXTRA_OBJS_tmp =
+
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(BOARDDIR)/extra.o
+ifeq ($(BOOT_FROM_NAND),1)
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(VENDOR)/common/ath_nand.o $(TOPDIR)/drivers/nand/nand_ids.o
+endif
+
+ifeq ($(COMPRESSED_UBOOT),1) #{
+BOARD_EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif
diff --git a/board/ar7240/db12x/db12x.c b/board/ar7240/db12x/db12x.c
new file mode 100644
index 0000000000..53361f53b0
--- /dev/null
+++ b/board/ar7240/db12x/db12x.c
@@ -0,0 +1,131 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#	define args		char *s
+#	define board_str(a)	do {			\
+	char ver[] = "0";				\
+	strcpy(s, "U-Boot " a "Wasp 1.");		\
+	ver[0] += ar7240_reg_rd(AR7240_REV_ID) & 0xf;	\
+	strcat(s, ver);					\
+} while (0)
+#else
+#	define prmsg		printf
+#	define args		void
+#	define board_str(a)	printf(a)
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+	ar7240_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ar7240_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ar7240_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ar7240_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+}
+
+int
+wasp_mem_config(void)
+{
+	extern void ath_ddr_tap_cal(void);
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	ath_ddr_tap_cal();
+
+	prmsg("Tap value selected = 0x%x [0x%x - 0x%x]\n",
+		ar7240_reg_rd(AR7240_DDR_TAP_CONTROL0),
+		ar7240_reg_rd(0xbd007f10), ar7240_reg_rd(0xbd007f14));
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+	ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+
+	wasp_usb_initial_config();
+
+#endif /* !defined(CONFIG_ATH_NAND_BR) */
+
+	wasp_gpio_config();
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+int	checkboard(args)
+{
+#if CONFIG_AP123
+	board_str("AP123\n");
+#elif CONFIG_MI124
+	board_str("MI124\n");
+#elif CONFIG_CUS227
+	board_str("CUS227\n");
+#else
+	board_str("DB120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/db12x/extra.c b/board/ar7240/db12x/extra.c
new file mode 100644
index 0000000000..d9f74dce91
--- /dev/null
+++ b/board/ar7240/db12x/extra.c
@@ -0,0 +1,89 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#ifdef CONFIG_ATH_NAND_BR
+void *
+ath_get_nand_cal_data(void)
+{
+        ulong           off,size;
+        int             ret;
+        static u_char   nand_cal_data[256 * 1024];
+        nand_info_t *nand;
+
+         /*
+          * caldata partition is of 128k
+          *
+          */
+        nand = &nand_info[nand_curr_device];
+        size = nand->erasesize;
+
+        /*
+         * Get the Offset of Caldata partition
+         */
+        off = ath_nand_get_cal_offset(getenv("bootargs"));
+        if(off == ATH_CAL_OFF_INVAL) {
+                printf("Invalid CAL offset \n");
+                return 1;
+        }
+
+        /*
+         * Get the values from flash, and program into the MAC address
+         * registers
+         */
+        ret = nand_read(nand, (loff_t)off, &size, nand_cal_data);
+        printf(" %d bytes %s: %s\n", size,
+                        "read", ret ? "ERROR" : "OK");
+        if(ret != 0 ) {
+                return NULL;
+        }
+
+        return nand_cal_data;
+}
+#endif
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep;
+	uint32_t	val;
+
+#ifdef CONFIG_ATH_NAND_BR
+        eep = (ar9300_eeprom_t *)ath_get_nand_cal_data();
+#else
+        eep = (ar9300_eeprom_t *)WLANCAL;
+#endif /* CONFIG_ATH_NAND_BR */
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	printf("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
diff --git a/board/ar7240/db12x/flash.c b/board/ar7240/db12x/flash.c
new file mode 100644
index 0000000000..0d511b13b4
--- /dev/null
+++ b/board/ar7240/db12x/flash.c
@@ -0,0 +1,30 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
diff --git a/board/ar7240/db12x/u-boot-bootstrap.lds b/board/ar7240/db12x/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/db12x/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/db12x/u-boot.lds b/board/ar7240/db12x/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/db12x/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/dhp1565/Makefile b/board/ar7240/dhp1565/Makefile
new file mode 100644
index 0000000000..6898bc08b5
--- /dev/null
+++ b/board/ar7240/dhp1565/Makefile
@@ -0,0 +1,62 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifdef BOOT_FROM_NAND
+OBJS	+= ../common/ath_nand_flash.o 
+else
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif 
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/dhp1565/config.mk b/board/ar7240/dhp1565/config.mk
new file mode 100644
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/dhp1565/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/dhp1565/dhp1565.c b/board/ar7240/dhp1565/dhp1565.c
new file mode 100644
index 0000000000..86f1d52fb4
--- /dev/null
+++ b/board/ar7240/dhp1565/dhp1565.c
@@ -0,0 +1,171 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+#if !defined(CONFIG_ATH_NAND_BR)
+	if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+		if (type == 2) {
+			// ddr1
+			ar7240_reg_wr_nf(0x18116c44, 0x10000000); /* AR_PHY_PMU2 */
+		} else {
+			// ddr2 & sdram
+			ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+		}
+	} else {
+		ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+	}
+#endif
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */ 
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/dhp1565/flash.c b/board/ar7240/dhp1565/flash.c
new file mode 100644
index 0000000000..48f3df09bd
--- /dev/null
+++ b/board/ar7240/dhp1565/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/dhp1565/u-boot-bootstrap.lds b/board/ar7240/dhp1565/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/dhp1565/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/dhp1565/u-boot.lds b/board/ar7240/dhp1565/u-boot.lds
new file mode 100644
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/dhp1565/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/mi93/Makefile b/board/ar7240/mi93/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/mi93/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/mi93/config.mk b/board/ar7240/mi93/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/mi93/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/mi93/flash.c b/board/ar7240/mi93/flash.c
new file mode 100644
index 0000000000..3884a2e528
--- /dev/null
+++ b/board/ar7240/mi93/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/mi93/mi93.c b/board/ar7240/mi93/mi93.c
new file mode 100644
index 0000000000..d5cd33303c
--- /dev/null
+++ b/board/ar7240/mi93/mi93.c
@@ -0,0 +1,67 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004); 
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+	printf("MI93 (ar7241 - Virian) U-boot\n");
+	return 0;
+}
diff --git a/board/ar7240/mi93/u-boot.lds b/board/ar7240/mi93/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/mi93/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/pb90/Makefile b/board/ar7240/pb90/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/pb90/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/pb90/config.mk b/board/ar7240/pb90/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/pb90/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/pb90/flash.c b/board/ar7240/pb90/flash.c
new file mode 100644
index 0000000000..48f3df09bd
--- /dev/null
+++ b/board/ar7240/pb90/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/pb90/pb90.c b/board/ar7240/pb90/pb90.c
new file mode 100644
index 0000000000..14ecbd23e9
--- /dev/null
+++ b/board/ar7240/pb90/pb90.c
@@ -0,0 +1,59 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+/* Default tap values for starting the tap_init*/
+
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x7);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x7);
+
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("PB90 (ar7240) U-boot\n");
+    return 0;
+}
diff --git a/board/ar7240/pb90/u-boot.lds b/board/ar7240/pb90/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/pb90/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/pb92/Makefile b/board/ar7240/pb92/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/pb92/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/pb92/config.mk b/board/ar7240/pb92/config.mk
new file mode 100755
index 0000000000..4e9c48e5e6
--- /dev/null
+++ b/board/ar7240/pb92/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/pb92/flash.c b/board/ar7240/pb92/flash.c
new file mode 100644
index 0000000000..e1b30b51d6
--- /dev/null
+++ b/board/ar7240/pb92/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/pb92/pb92.c b/board/ar7240/pb92/pb92.c
new file mode 100644
index 0000000000..d1368c752a
--- /dev/null
+++ b/board/ar7240/pb92/pb92.c
@@ -0,0 +1,75 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+/* Default tap values for starting the tap_init*/
+#ifndef COMPRESSED_UBOOT
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#else
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x9);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0xa);
+#endif
+    ar7240_gpio_config();
+
+#ifndef COMPRESSED_UBOOT
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "PB9x (ar7242) u-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("PB9x (ar7242) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/pb92/u-boot-bootstrap.lds b/board/ar7240/pb92/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/pb92/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/pb92/u-boot.lds b/board/ar7240/pb92/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/pb92/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/pb93/Makefile b/board/ar7240/pb93/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/pb93/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/pb93/config.mk b/board/ar7240/pb93/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/pb93/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/pb93/flash.c b/board/ar7240/pb93/flash.c
new file mode 100644
index 0000000000..48f3df09bd
--- /dev/null
+++ b/board/ar7240/pb93/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/pb93/pb93.c b/board/ar7240/pb93/pb93.c
new file mode 100644
index 0000000000..9f1729fd7f
--- /dev/null
+++ b/board/ar7240/pb93/pb93.c
@@ -0,0 +1,72 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+	ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0); 
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+        printf("PB93 (ar7241 - Virian) U-boot\n");
+    else
+        printf("PB93 (ar7240 - Python) U-boot\n");
+
+    return 0;
+}
diff --git a/board/ar7240/pb93/u-boot.lds b/board/ar7240/pb93/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/pb93/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/pb9x-2.6.31/Makefile b/board/ar7240/pb9x-2.6.31/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/pb9x-2.6.31/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/pb9x-2.6.31/config.mk b/board/ar7240/pb9x-2.6.31/config.mk
new file mode 100644
index 0000000000..4e9c48e5e6
--- /dev/null
+++ b/board/ar7240/pb9x-2.6.31/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/pb9x-2.6.31/flash.c b/board/ar7240/pb9x-2.6.31/flash.c
new file mode 100644
index 0000000000..48f3df09bd
--- /dev/null
+++ b/board/ar7240/pb9x-2.6.31/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/pb9x-2.6.31/pb9x-2.6.31.c b/board/ar7240/pb9x-2.6.31/pb9x-2.6.31.c
new file mode 100644
index 0000000000..0406602a10
--- /dev/null
+++ b/board/ar7240/pb9x-2.6.31/pb9x-2.6.31.c
@@ -0,0 +1,86 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#ifndef COMPRESSED_UBOOT
+        ar7240_ddr_tap_init();
+#endif
+    }
+    else {
+	ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0); 
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+#ifndef COMPRESSED_UBOOT
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+#endif
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    if ((is_ar7241() || is_ar7242()))
+        strcpy(board_string,"pb9x (ar7241 - Virian) U-boot\n");
+    else
+        strcpy(board_string,"pb9x (ar7240 - Python) U-boot\n");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+        printf("PB93 (ar7241 - Virian) U-boot\n");
+    else
+        printf("PB93 (ar7240 - Python) U-boot\n");
+
+    return 0;
+}
+#endif
diff --git a/board/ar7240/pb9x-2.6.31/u-boot-bootstrap.lds b/board/ar7240/pb9x-2.6.31/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/pb9x-2.6.31/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/pb9x-2.6.31/u-boot.lds b/board/ar7240/pb9x-2.6.31/u-boot.lds
new file mode 100644
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/pb9x-2.6.31/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/pb9x-2x8/Makefile b/board/ar7240/pb9x-2x8/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/pb9x-2x8/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/pb9x-2x8/config.mk b/board/ar7240/pb9x-2x8/config.mk
new file mode 100755
index 0000000000..4e9c48e5e6
--- /dev/null
+++ b/board/ar7240/pb9x-2x8/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/pb9x-2x8/flash.c b/board/ar7240/pb9x-2x8/flash.c
new file mode 100644
index 0000000000..e1b30b51d6
--- /dev/null
+++ b/board/ar7240/pb9x-2x8/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/pb9x-2x8/pb9x-2x8.c b/board/ar7240/pb9x-2x8/pb9x-2x8.c
new file mode 100644
index 0000000000..d1368c752a
--- /dev/null
+++ b/board/ar7240/pb9x-2x8/pb9x-2x8.c
@@ -0,0 +1,75 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+/* Default tap values for starting the tap_init*/
+#ifndef COMPRESSED_UBOOT
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#else
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x9);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0xa);
+#endif
+    ar7240_gpio_config();
+
+#ifndef COMPRESSED_UBOOT
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "PB9x (ar7242) u-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("PB9x (ar7242) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/pb9x-2x8/u-boot-bootstrap.lds b/board/ar7240/pb9x-2x8/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/pb9x-2x8/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/pb9x-2x8/u-boot.lds b/board/ar7240/pb9x-2x8/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/pb9x-2x8/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/pb9x/Makefile b/board/ar7240/pb9x/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/pb9x/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/pb9x/config.mk b/board/ar7240/pb9x/config.mk
new file mode 100644
index 0000000000..4e9c48e5e6
--- /dev/null
+++ b/board/ar7240/pb9x/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/pb9x/flash.c b/board/ar7240/pb9x/flash.c
new file mode 100644
index 0000000000..48f3df09bd
--- /dev/null
+++ b/board/ar7240/pb9x/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/pb9x/pb9x.c b/board/ar7240/pb9x/pb9x.c
new file mode 100644
index 0000000000..0406602a10
--- /dev/null
+++ b/board/ar7240/pb9x/pb9x.c
@@ -0,0 +1,86 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#ifndef COMPRESSED_UBOOT
+        ar7240_ddr_tap_init();
+#endif
+    }
+    else {
+	ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0); 
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+#ifndef COMPRESSED_UBOOT
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+#endif
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    if ((is_ar7241() || is_ar7242()))
+        strcpy(board_string,"pb9x (ar7241 - Virian) U-boot\n");
+    else
+        strcpy(board_string,"pb9x (ar7240 - Python) U-boot\n");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+        printf("PB93 (ar7241 - Virian) U-boot\n");
+    else
+        printf("PB93 (ar7240 - Python) U-boot\n");
+
+    return 0;
+}
+#endif
diff --git a/board/ar7240/pb9x/u-boot-bootstrap.lds b/board/ar7240/pb9x/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/pb9x/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/pb9x/u-boot.lds b/board/ar7240/pb9x/u-boot.lds
new file mode 100644
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/pb9x/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/reh132/Makefile b/board/ar7240/reh132/Makefile
new file mode 100644
index 0000000000..6898bc08b5
--- /dev/null
+++ b/board/ar7240/reh132/Makefile
@@ -0,0 +1,62 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifdef BOOT_FROM_NAND
+OBJS	+= ../common/ath_nand_flash.o 
+else
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif 
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o 
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/reh132/config.mk b/board/ar7240/reh132/config.mk
new file mode 100644
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/reh132/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/reh132/flash.c b/board/ar7240/reh132/flash.c
new file mode 100644
index 0000000000..48f3df09bd
--- /dev/null
+++ b/board/ar7240/reh132/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/reh132/reh132.c b/board/ar7240/reh132/reh132.c
new file mode 100644
index 0000000000..2c955cec28
--- /dev/null
+++ b/board/ar7240/reh132/reh132.c
@@ -0,0 +1,176 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+        /*  Enable xLNBIAS signal on GPIO (19, 20) */
+        ar7240_reg_wr (AR7240_GPIO_FUNC4, ((ar7240_reg_rd(AR7240_GPIO_FUNC4) & 0x00ffffff)) | 0x2f000000);
+        ar7240_reg_wr (AR7240_GPIO_FUNC5, ((ar7240_reg_rd(AR7240_GPIO_FUNC5) & 0xffffff00)) | 0x2e);
+        ar7240_reg_wr (AR7240_GPIO_OE, (ar7240_reg_rd(AR7240_GPIO_OE) & 0xffe7ffff));
+
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+#if !defined(CONFIG_ATH_NAND_FL)
+	if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+		if (type == 2) {
+			// ddr1
+			ar7240_reg_wr_nf(0x18116c44, 0x10000000); /* AR_PHY_PMU2 */
+		} else {
+			// ddr2 & sdram
+			ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+		}
+	} else {
+		ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+	}
+#endif
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */ 
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot REH132\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot REH132\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/reh132/u-boot-bootstrap.lds b/board/ar7240/reh132/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/reh132/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/reh132/u-boot.lds b/board/ar7240/reh132/u-boot.lds
new file mode 100644
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/reh132/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/tb327/Makefile b/board/ar7240/tb327/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/tb327/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/tb327/config.mk b/board/ar7240/tb327/config.mk
new file mode 100755
index 0000000000..f110fcb6ff
--- /dev/null
+++ b/board/ar7240/tb327/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/tb327/flash.c b/board/ar7240/tb327/flash.c
new file mode 100644
index 0000000000..48f3df09bd
--- /dev/null
+++ b/board/ar7240/tb327/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/tb327/tb327.c b/board/ar7240/tb327/tb327.c
new file mode 100644
index 0000000000..65461399c3
--- /dev/null
+++ b/board/ar7240/tb327/tb327.c
@@ -0,0 +1,52 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1,tap_val2;
+
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x7);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x7);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x7);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x7);
+
+    ar7240_usb_initial_config();
+
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("AP93 (ar7240) U-boot\n");
+    return 0;
+}
diff --git a/board/ar7240/tb327/u-boot.lds b/board/ar7240/tb327/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/tb327/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/wasp_emu/Makefile b/board/ar7240/wasp_emu/Makefile
new file mode 100644
index 0000000000..8ed365cbcc
--- /dev/null
+++ b/board/ar7240/wasp_emu/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/athr_s27_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/wasp_emu/config.mk b/board/ar7240/wasp_emu/config.mk
new file mode 100755
index 0000000000..15c64df10c
--- /dev/null
+++ b/board/ar7240/wasp_emu/config.mk
@@ -0,0 +1,9 @@
+# ROM version
+# TEXT_BASE = 0x9f000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+#TEXT_BASE = 0x83fc0000
+TEXT_BASE = 0x80100000
diff --git a/board/ar7240/wasp_emu/flash.c b/board/ar7240/wasp_emu/flash.c
new file mode 100644
index 0000000000..48f3df09bd
--- /dev/null
+++ b/board/ar7240/wasp_emu/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/wasp_emu/u-boot.lds b/board/ar7240/wasp_emu/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/wasp_emu/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/wasp_emu/wasp_emu.c b/board/ar7240/wasp_emu/wasp_emu.c
new file mode 100644
index 0000000000..8bc8d2b577
--- /dev/null
+++ b/board/ar7240/wasp_emu/wasp_emu.c
@@ -0,0 +1,69 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+#if !defined(CONFIG_WASP_EMU)
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004); 
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+#endif 
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+	printf("Wasp Emulation U-boot\n");
+	return 0;
+}
diff --git a/board/ar7240/wrt54g/Makefile b/board/ar7240/wrt54g/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/wrt54g/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/wrt54g/config.mk b/board/ar7240/wrt54g/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/wrt54g/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/wrt54g/flash.c b/board/ar7240/wrt54g/flash.c
new file mode 100644
index 0000000000..8840bda48b
--- /dev/null
+++ b/board/ar7240/wrt54g/flash.c
@@ -0,0 +1,42 @@
+/*****************************************************************************/
+/* \file flash.c
+** \brief flash read/write support
+**
+**  This file contains the routine that detects the flash geometry, and is used
+**  in the WRT54G project in u-boot.
+**
+**  Copyright (c) 2009 Atheros Communications Inc.  All rights reserved.
+** 
+**  This file is proprietary to Atheros Communications, Inc.'s and licensed only
+**  according to a Technology License Agreement approved and executed by Atheros,
+**  or sublicensed by an authorized sublicensor.
+*/
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long 
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+    
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/wrt54g/u-boot.lds b/board/ar7240/wrt54g/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/wrt54g/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/wrt54g/wrt54g.c b/board/ar7240/wrt54g/wrt54g.c
new file mode 100644
index 0000000000..e7041a4cc8
--- /dev/null
+++ b/board/ar7240/wrt54g/wrt54g.c
@@ -0,0 +1,73 @@
+/*****************************************************************************/
+/* \file wrt54g.c
+** \brief wrt54g support routines
+**
+**  This file contains all of the support and initialization routines for the
+**  WRT54G project in u-boot.
+**
+**  Copyright (c) 2009 Atheros Communications Inc.  All rights reserved.
+** 
+**  This file is proprietary to Atheros Communications, Inc.'s and licensed only
+**  according to a Technology License Agreement approved and executed by Atheros,
+**  or sublicensed by an authorized sublicensor.
+*/
+
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+/* Default tap values for starting the tap_init*/
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    printf("WRT54G (ar7240) U-boot\n");
+    return 0;
+}
diff --git a/board/atheros/aph131/Makefile b/board/atheros/aph131/Makefile
new file mode 100644
index 0000000000..cde476d424
--- /dev/null
+++ b/board/atheros/aph131/Makefile
@@ -0,0 +1,58 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	=			\
+	$(BOARD).o		\
+	flash.o			\
+	../common/init-955x.o	\
+	../common/serial.o	\
+	../common/ath_pci.o	\
+	../common/qca-eth-955x.o
+
+#
+# The files included in EXTRA_OBJS use some functions that are not
+# available in the `bootstrap' portion of tuboot.bin resulting in
+# compile/link errors. Hence have them separate (i.e. don't include
+# into lib$(BOARD).a and include them only in `u-boot' portion of
+# tuboot.bin.
+#
+
+ifeq ($(strip $(COMPRESSED_UBOOT)),0) #{
+OBJS	+= $(BOARD_EXTRA_OBJS_tmp)
+else
+EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif #}
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ath_flash.o
+endif
+
+ifeq ($(ATH_RGMII_CAL),1)
+OBJS	+= ../common/rgmii-cal-955x.o	
+OBJS	+= ../common/athrs17_lpbk.o
+endif
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+ifeq ($(ETH_CONFIG2), _ar8033)
+OBJS	+= ../common/athr_ar8033_phy.o
+endif
+
+SOBJS	= ../common/955x.o ../common/tap-955x.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS) $(EXTRA_OBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/atheros/aph131/aph131.c b/board/atheros/aph131/aph131.c
new file mode 100644
index 0000000000..0bfb6efe6d
--- /dev/null
+++ b/board/atheros/aph131/aph131.c
@@ -0,0 +1,143 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+extern int ath_ddr_initial_config(uint32_t refresh);
+extern int ath_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#	define args		char *s
+#	define board_str(a)	do {			\
+	char ver[] = "0";				\
+	strcpy(s, a " - Scorpion 1.");			\
+	ver[0] += ath_reg_rd(RST_REVISION_ID_ADDRESS)	\
+						& 0xf;	\
+	strcat(s, ver);					\
+} while (0)
+#else
+#	define prmsg	printf
+#	define args		void
+#	define board_str(a)				\
+	printf(a " - Scorpion 1.%d", ath_reg_rd		\
+			(RST_REVISION_ID_ADDRESS) & 0xf)
+#endif
+
+void
+ath_usb1_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+		ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+		SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	udelay(1000);
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS,
+				RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_HOST_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB1_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+void
+ath_usb2_initial_config(void)
+{
+	if (is_drqfn()) {
+		return;
+	}
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_MODE_SET(1));
+	udelay(10);
+	ath_reg_rmw_set(RST_RESET2_ADDRESS,
+				RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_HOST2_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+
+void ath_gpio_config(void)
+{
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+	/* Set GPIO 13 as input for LED functionality to be OFF during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 13));
+	/* Turn off JUMPST_LED and 5Gz LED during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 15));
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 12));
+}
+
+int
+ath_mem_config(void)
+{
+	unsigned int type, reg32, *tap;
+	extern uint32_t *ath_ddr_tap_cal(void);
+
+#if !defined(CONFIG_ATH_EMULATION)
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	type = ath_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	tap = ath_ddr_tap_cal();
+	prmsg("tap = 0x%p\n", tap);
+
+	tap = (uint32_t *)0xbd007f10;
+	prmsg("Tap (low, high) = (0x%x, 0x%x)\n", tap[0], tap[1]);
+
+	tap = (uint32_t *)TAP_CONTROL_0_ADDRESS;
+	prmsg("Tap values = (0x%x, 0x%x, 0x%x, 0x%x)\n",
+		tap[0], tap[2], tap[2], tap[3]);
+
+	/* Take WMAC out of reset */
+	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+	reg32 = reg32 & ~RST_RESET_RTC_RESET_SET(1);
+	ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+#endif
+
+	ath_usb1_initial_config();
+	ath_usb2_initial_config();
+
+	ath_gpio_config();
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+
+	return ath_ddr_find_size();
+}
+
+long int initdram(int board_type)
+{
+	return (ath_mem_config());
+}
+
+int	checkboard(args)
+{
+	board_str(CONFIG_BOARD_NAME);
+	return 0;
+}
diff --git a/board/atheros/aph131/config.mk b/board/atheros/aph131/config.mk
new file mode 100755
index 0000000000..df2665e385
--- /dev/null
+++ b/board/atheros/aph131/config.mk
@@ -0,0 +1,35 @@
+# ROM version
+ifdef BOOT_FROM_NAND #{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0xa0100000
+else #}{
+TEXT_BASE = 0xa0100000
+endif #}
+else #}{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else #}{
+TEXT_BASE = 0x9f000000
+endif #}
+endif #}
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
+
+export BOARD_EXTRA_OBJS_tmp =
+
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(BOARDDIR)/extra.o
+ifeq ($(BOOT_FROM_NAND),1)
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(VENDOR)/common/ath_nand.o $(TOPDIR)/drivers/nand/nand_ids.o
+endif
+
+ifeq ($(COMPRESSED_UBOOT),1) #{
+BOARD_EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif
diff --git a/board/atheros/aph131/extra.c b/board/atheros/aph131/extra.c
new file mode 100644
index 0000000000..a14942daf5
--- /dev/null
+++ b/board/atheros/aph131/extra.c
@@ -0,0 +1,103 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#ifdef CONFIG_ATH_NAND_BR
+void *
+ath_get_nand_cal_data(void)
+{
+	extern unsigned long long ath_nand_get_cal_offset(const char *ba);
+
+        ulong           off,size;
+        int             ret;
+        static u_char   nand_cal_data[256 * 1024];
+        nand_info_t *nand;
+
+         /*
+          * caldata partition is of 128k
+          *
+          */
+        nand = &nand_info[nand_curr_device];
+        size = nand->erasesize;
+
+        /*
+         * Get the Offset of Caldata partition
+         */
+        off = ath_nand_get_cal_offset(getenv("bootargs"));
+        if(off == ATH_CAL_OFF_INVAL) {
+                printf("Invalid CAL offset \n");
+                return 1;
+        }
+
+        /*
+         * Get the values from flash, and program into the MAC address
+         * registers
+         */
+        ret = nand_read(nand, (loff_t)off, &size, nand_cal_data);
+        printf(" %d bytes %s: %s\n", size,
+                        "read", ret ? "ERROR" : "OK");
+        if(ret != 0 ) {
+                return NULL;
+        }
+
+        return nand_cal_data;
+}
+#endif
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep;
+	uint32_t	val;
+
+#ifdef CONFIG_ATH_NAND_BR
+        eep = (ar9300_eeprom_t *)ath_get_nand_cal_data();
+#else
+        eep = (ar9300_eeprom_t *)WLANCAL;
+#endif /* CONFIG_ATH_NAND_BR */
+
+	val =	XTAL_TCXODET_SET(0x0) |
+		XTAL_XTAL_CAPINDAC_SET(0x45) |
+		XTAL_XTAL_CAPOUTDAC_SET(0x45) |
+		XTAL_XTAL_DRVSTR_SET(0x3) |
+		XTAL_XTAL_SHORTXIN_SET(0x0) |
+		XTAL_XTAL_LOCALBIAS_SET(0x1) |
+		XTAL_XTAL_PWDCLKD_SET(0x0) |
+		XTAL_XTAL_BIAS2X_SET(0x0) |
+		XTAL_XTAL_LBIAS2X_SET(0x0) |
+		XTAL_XTAL_ATBVREG_SET(0x0) |
+		XTAL_XTAL_OSCON_SET(0x1) |
+		XTAL_XTAL_PWDCLKIN_SET(0x0) |
+		XTAL_LOCAL_XTAL_SET(0x1) |
+		XTAL_PWD_SWREGCLK_SET(0x0) |
+		XTAL_SWREGCLK_EDGE_SEL_SET(0x0) |
+		XTAL_SPARE_SET(0xf);
+
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		val &= ~(XTAL_XTAL_CAPINDAC_MASK | XTAL_XTAL_CAPOUTDAC_MASK);
+		val |=	XTAL_XTAL_CAPINDAC_SET(eep->params_for_tuning_caps[0]) |
+			XTAL_XTAL_CAPOUTDAC_SET(eep->params_for_tuning_caps[0]);
+	}
+
+	ath_reg_wr(XTAL_ADDRESS, val);
+
+#define __str(x)	# x
+#define str(x)		__str(x)
+
+	printf("Setting " str(XTAL_ADDRESS) " to 0x%x\n", val);
+	return;
+}
diff --git a/board/atheros/aph131/flash.c b/board/atheros/aph131/flash.c
new file mode 100644
index 0000000000..ffcbf7fe4f
--- /dev/null
+++ b/board/atheros/aph131/flash.c
@@ -0,0 +1,32 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+#ifndef CONFIG_ATH_NAND_BR
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
+#endif /* CONFIG_ATH_NAND_BR */
diff --git a/board/atheros/aph131/u-boot-bootstrap.lds b/board/atheros/aph131/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/atheros/aph131/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/atheros/aph131/u-boot.lds b/board/atheros/aph131/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/atheros/aph131/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/atheros/board953x/Makefile b/board/atheros/board953x/Makefile
new file mode 100755
index 0000000000..cb2d46cd0c
--- /dev/null
+++ b/board/atheros/board953x/Makefile
@@ -0,0 +1,68 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	=			\
+	$(BOARD).o		\
+	flash.o			\
+	../common/init-953x.o	\
+	../common/serial.o	\
+	../common/ath_pci.o	\
+	../common/qca-eth-953x.o
+
+#
+# The files included in EXTRA_OBJS use some functions that are not
+# available in the `bootstrap' portion of tuboot.bin resulting in
+# compile/link errors. Hence have them separate (i.e. don't include
+# into lib$(BOARD).a and include them only in `u-boot' portion of
+# tuboot.bin.
+#
+
+ifeq ($(strip $(COMPRESSED_UBOOT)),0) #{
+OBJS	+= $(BOARD_EXTRA_OBJS_tmp)
+else
+EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif #}
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ath_flash.o
+endif
+
+ifeq ($(ATH_RGMII_CAL),1)
+OBJS	+= ../common/rgmii-cal-953x.o	
+OBJS	+= ../common/athrs17_lpbk.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/953x.o ../common/tap-953x.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS) $(EXTRA_OBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/atheros/board953x/board953x.c b/board/atheros/board953x/board953x.c
new file mode 100755
index 0000000000..7f1d20d863
--- /dev/null
+++ b/board/atheros/board953x/board953x.c
@@ -0,0 +1,145 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+extern int ath_ddr_initial_config(uint32_t refresh);
+extern int ath_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+
+#	define prmsg(...)
+#	define args		char *s
+#	define board_str(a)	do {			\
+	char ver[] = "0";				\
+	strcpy(s, a " - Honey Bee 1.");			\
+	ver[0] += ath_reg_rd(RST_REVISION_ID_ADDRESS)	\
+						& 0xf;	\
+	strcat(s, ver);					\
+} while (0)
+
+#else
+#	define prmsg	printf
+#	define args		void
+#	define board_str(a)				\
+	printf(a " - Honey Bee 1.%d", ath_reg_rd	\
+			(RST_REVISION_ID_ADDRESS) & 0xf)
+#endif
+
+void
+ath_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if (ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_TESTROM_ENABLE_MASK) {
+
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_USB_HOST_RESET_SET(1));
+		udelay(1000);
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_USB_PHY_RESET_SET(1));
+		udelay(1000);
+
+		ath_reg_wr(PHY_CTRL5_ADDRESS, PHY_CTRL5_RESET_1);
+		udelay(1000);
+
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1));
+		udelay(1000);
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_USB_PHY_ARESET_SET(1));
+		udelay(1000);
+
+		ath_reg_rmw_clear(RST_CLKGAT_EN_ADDRESS, RST_CLKGAT_EN_USB1_SET(1));
+
+		return;
+	}
+
+	ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+		ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+		SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	udelay(1000);
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS,
+				RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_HOST_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1));
+	udelay(10);
+}
+
+void ath_gpio_config(void)
+{
+
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+#if 0
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+//#else
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x0));
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+#endif
+
+#if 0
+	/* Set GPIO 13 as input for LED functionality to be OFF during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 13));
+	/* Turn off JUMPST_LED and 5Gz LED during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 15));
+//#else
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 13));
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 15));
+#endif
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 12));
+
+}
+
+int
+ath_mem_config(void)
+{
+	unsigned int type, reg32, *tap;
+	extern uint32_t *ath_ddr_tap_cal(void);
+
+#if !defined(CONFIG_ATH_EMULATION)
+	type = ath_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	tap = ath_ddr_tap_cal();
+	prmsg("tap = 0x%p\n", tap);
+
+	tap = (uint32_t *)0xbd001f10;
+	prmsg("Tap (low, high) = (0x%x, 0x%x)\n", tap[0], tap[1]);
+
+	tap = (uint32_t *)TAP_CONTROL_0_ADDRESS;
+	prmsg("Tap values = (0x%x, 0x%x, 0x%x, 0x%x)\n",
+		tap[0], tap[2], tap[2], tap[3]);
+
+	/* Take WMAC out of reset */
+	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+	reg32 = reg32 & ~RST_RESET_RTC_RESET_SET(1);
+	ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+
+	ath_usb_initial_config();
+
+	ath_gpio_config();
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+
+	return ath_ddr_find_size();
+}
+
+long int initdram(int board_type)
+{
+	return (ath_mem_config());
+}
+
+int	checkboard(args)
+{
+	board_str(CONFIG_BOARD_NAME);
+	return 0;
+}
diff --git a/board/atheros/board953x/config.mk b/board/atheros/board953x/config.mk
new file mode 100755
index 0000000000..0240aa8c1b
--- /dev/null
+++ b/board/atheros/board953x/config.mk
@@ -0,0 +1,23 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else #}{
+TEXT_BASE = 0x9f000000
+endif #}
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
+
+export BOARD_EXTRA_OBJS_tmp =
+
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(BOARDDIR)/extra.o
+
+ifeq ($(COMPRESSED_UBOOT),1) #{
+BOARD_EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif
diff --git a/board/atheros/board953x/extra.c b/board/atheros/board953x/extra.c
new file mode 100755
index 0000000000..b27bcc1d7c
--- /dev/null
+++ b/board/atheros/board953x/extra.c
@@ -0,0 +1,55 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep;
+	uint32_t	val;
+
+        eep = (ar9300_eeprom_t *)WLANCAL;
+
+	val =	XTAL_TCXODET_SET(0x0) |
+		XTAL_XTAL_CAPINDAC_SET(0x4b) |
+		XTAL_XTAL_CAPOUTDAC_SET(0x4b) |
+		XTAL_XTAL_DRVSTR_SET(0x3) |
+		XTAL_XTAL_SHORTXIN_SET(0x0) |
+		XTAL_XTAL_LOCALBIAS_SET(0x1) |
+		XTAL_XTAL_PWDCLKD_SET(0x0) |
+		XTAL_XTAL_BIAS2X_SET(0x0) |
+		XTAL_XTAL_LBIAS2X_SET(0x0) |
+		XTAL_XTAL_OSCON_SET(0x1) |
+		XTAL_XTAL_PWDCLKIN_SET(0x0) |
+		XTAL_LOCAL_XTAL_SET(0x0) |
+		XTAL_PWD_SWREGCLK_SET(0x0) |
+		XTAL_SPARE_SET(0x0);
+
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		val &= ~(XTAL_XTAL_CAPINDAC_MASK | XTAL_XTAL_CAPOUTDAC_MASK);
+		val |=	XTAL_XTAL_CAPINDAC_SET(eep->params_for_tuning_caps[0]) |
+			XTAL_XTAL_CAPOUTDAC_SET(eep->params_for_tuning_caps[0]);
+	}
+
+	ath_reg_wr(XTAL_ADDRESS, val);
+	ath_reg_wr(XTAL2_ADDRESS, XTAL2_DCA_BYPASS_SET(0x1) |
+					XTAL2_FSM_START_L_SET(0x1));
+	ath_reg_wr(XTAL3_ADDRESS, XTAL3_EVAL_LENGTH_SET(0x400) |
+					XTAL3_HARMONIC_NUMBER_SET(0x51));
+
+#define __str(x)	# x
+#define str(x)		__str(x)
+
+	printf("Setting " str(XTAL_ADDRESS) " to 0x%x\n", val);
+	return;
+}
diff --git a/board/atheros/board953x/flash.c b/board/atheros/board953x/flash.c
new file mode 100755
index 0000000000..cf16d62ec1
--- /dev/null
+++ b/board/atheros/board953x/flash.c
@@ -0,0 +1,30 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	/*printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);*/
+
+	return (flash_info->size);
+}
diff --git a/board/atheros/board953x/u-boot-bootstrap.lds b/board/atheros/board953x/u-boot-bootstrap.lds
new file mode 100755
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/atheros/board953x/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/atheros/board953x/u-boot.lds b/board/atheros/board953x/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/atheros/board953x/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/atheros/board955x/Makefile b/board/atheros/board955x/Makefile
new file mode 100644
index 0000000000..3d1fa24555
--- /dev/null
+++ b/board/atheros/board955x/Makefile
@@ -0,0 +1,97 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	=			\
+	$(BOARD).o		\
+	flash.o			\
+	../common/init-955x.o	\
+	../common/serial.o	\
+	../common/ath_pci.o	\
+	../common/qca-eth-955x.o
+
+#
+# The files included in EXTRA_OBJS use some functions that are not
+# available in the `bootstrap' portion of tuboot.bin resulting in
+# compile/link errors. Hence have them separate (i.e. don't include
+# into lib$(BOARD).a and include them only in `u-boot' portion of
+# tuboot.bin.
+#
+
+ifeq ($(strip $(COMPRESSED_UBOOT)),0) #{
+OBJS	+= $(BOARD_EXTRA_OBJS_tmp)
+else
+EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif #}
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ath_flash.o
+endif
+
+ifeq ($(ATH_RGMII_CAL),1)
+OBJS	+= ../common/rgmii-cal-955x.o	
+OBJS	+= ../common/athrs17_lpbk.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _ar8033)
+OBJS	+= ../common/athr_ar8033_phy.o
+endif
+
+
+SOBJS	= ../common/955x.o ../common/tap-955x.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS) $(EXTRA_OBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/atheros/board955x/board955x.c b/board/atheros/board955x/board955x.c
new file mode 100644
index 0000000000..0bfb6efe6d
--- /dev/null
+++ b/board/atheros/board955x/board955x.c
@@ -0,0 +1,143 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+extern int ath_ddr_initial_config(uint32_t refresh);
+extern int ath_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#	define args		char *s
+#	define board_str(a)	do {			\
+	char ver[] = "0";				\
+	strcpy(s, a " - Scorpion 1.");			\
+	ver[0] += ath_reg_rd(RST_REVISION_ID_ADDRESS)	\
+						& 0xf;	\
+	strcat(s, ver);					\
+} while (0)
+#else
+#	define prmsg	printf
+#	define args		void
+#	define board_str(a)				\
+	printf(a " - Scorpion 1.%d", ath_reg_rd		\
+			(RST_REVISION_ID_ADDRESS) & 0xf)
+#endif
+
+void
+ath_usb1_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+		ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+		SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	udelay(1000);
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS,
+				RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_HOST_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB1_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+void
+ath_usb2_initial_config(void)
+{
+	if (is_drqfn()) {
+		return;
+	}
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_MODE_SET(1));
+	udelay(10);
+	ath_reg_rmw_set(RST_RESET2_ADDRESS,
+				RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_HOST2_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+
+void ath_gpio_config(void)
+{
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+	/* Set GPIO 13 as input for LED functionality to be OFF during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 13));
+	/* Turn off JUMPST_LED and 5Gz LED during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 15));
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 12));
+}
+
+int
+ath_mem_config(void)
+{
+	unsigned int type, reg32, *tap;
+	extern uint32_t *ath_ddr_tap_cal(void);
+
+#if !defined(CONFIG_ATH_EMULATION)
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	type = ath_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	tap = ath_ddr_tap_cal();
+	prmsg("tap = 0x%p\n", tap);
+
+	tap = (uint32_t *)0xbd007f10;
+	prmsg("Tap (low, high) = (0x%x, 0x%x)\n", tap[0], tap[1]);
+
+	tap = (uint32_t *)TAP_CONTROL_0_ADDRESS;
+	prmsg("Tap values = (0x%x, 0x%x, 0x%x, 0x%x)\n",
+		tap[0], tap[2], tap[2], tap[3]);
+
+	/* Take WMAC out of reset */
+	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+	reg32 = reg32 & ~RST_RESET_RTC_RESET_SET(1);
+	ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+#endif
+
+	ath_usb1_initial_config();
+	ath_usb2_initial_config();
+
+	ath_gpio_config();
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+
+	return ath_ddr_find_size();
+}
+
+long int initdram(int board_type)
+{
+	return (ath_mem_config());
+}
+
+int	checkboard(args)
+{
+	board_str(CONFIG_BOARD_NAME);
+	return 0;
+}
diff --git a/board/atheros/board955x/config.mk b/board/atheros/board955x/config.mk
new file mode 100755
index 0000000000..df2665e385
--- /dev/null
+++ b/board/atheros/board955x/config.mk
@@ -0,0 +1,35 @@
+# ROM version
+ifdef BOOT_FROM_NAND #{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0xa0100000
+else #}{
+TEXT_BASE = 0xa0100000
+endif #}
+else #}{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else #}{
+TEXT_BASE = 0x9f000000
+endif #}
+endif #}
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
+
+export BOARD_EXTRA_OBJS_tmp =
+
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(BOARDDIR)/extra.o
+ifeq ($(BOOT_FROM_NAND),1)
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(VENDOR)/common/ath_nand.o $(TOPDIR)/drivers/nand/nand_ids.o
+endif
+
+ifeq ($(COMPRESSED_UBOOT),1) #{
+BOARD_EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif
diff --git a/board/atheros/board955x/extra.c b/board/atheros/board955x/extra.c
new file mode 100644
index 0000000000..a14942daf5
--- /dev/null
+++ b/board/atheros/board955x/extra.c
@@ -0,0 +1,103 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#ifdef CONFIG_ATH_NAND_BR
+void *
+ath_get_nand_cal_data(void)
+{
+	extern unsigned long long ath_nand_get_cal_offset(const char *ba);
+
+        ulong           off,size;
+        int             ret;
+        static u_char   nand_cal_data[256 * 1024];
+        nand_info_t *nand;
+
+         /*
+          * caldata partition is of 128k
+          *
+          */
+        nand = &nand_info[nand_curr_device];
+        size = nand->erasesize;
+
+        /*
+         * Get the Offset of Caldata partition
+         */
+        off = ath_nand_get_cal_offset(getenv("bootargs"));
+        if(off == ATH_CAL_OFF_INVAL) {
+                printf("Invalid CAL offset \n");
+                return 1;
+        }
+
+        /*
+         * Get the values from flash, and program into the MAC address
+         * registers
+         */
+        ret = nand_read(nand, (loff_t)off, &size, nand_cal_data);
+        printf(" %d bytes %s: %s\n", size,
+                        "read", ret ? "ERROR" : "OK");
+        if(ret != 0 ) {
+                return NULL;
+        }
+
+        return nand_cal_data;
+}
+#endif
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep;
+	uint32_t	val;
+
+#ifdef CONFIG_ATH_NAND_BR
+        eep = (ar9300_eeprom_t *)ath_get_nand_cal_data();
+#else
+        eep = (ar9300_eeprom_t *)WLANCAL;
+#endif /* CONFIG_ATH_NAND_BR */
+
+	val =	XTAL_TCXODET_SET(0x0) |
+		XTAL_XTAL_CAPINDAC_SET(0x45) |
+		XTAL_XTAL_CAPOUTDAC_SET(0x45) |
+		XTAL_XTAL_DRVSTR_SET(0x3) |
+		XTAL_XTAL_SHORTXIN_SET(0x0) |
+		XTAL_XTAL_LOCALBIAS_SET(0x1) |
+		XTAL_XTAL_PWDCLKD_SET(0x0) |
+		XTAL_XTAL_BIAS2X_SET(0x0) |
+		XTAL_XTAL_LBIAS2X_SET(0x0) |
+		XTAL_XTAL_ATBVREG_SET(0x0) |
+		XTAL_XTAL_OSCON_SET(0x1) |
+		XTAL_XTAL_PWDCLKIN_SET(0x0) |
+		XTAL_LOCAL_XTAL_SET(0x1) |
+		XTAL_PWD_SWREGCLK_SET(0x0) |
+		XTAL_SWREGCLK_EDGE_SEL_SET(0x0) |
+		XTAL_SPARE_SET(0xf);
+
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		val &= ~(XTAL_XTAL_CAPINDAC_MASK | XTAL_XTAL_CAPOUTDAC_MASK);
+		val |=	XTAL_XTAL_CAPINDAC_SET(eep->params_for_tuning_caps[0]) |
+			XTAL_XTAL_CAPOUTDAC_SET(eep->params_for_tuning_caps[0]);
+	}
+
+	ath_reg_wr(XTAL_ADDRESS, val);
+
+#define __str(x)	# x
+#define str(x)		__str(x)
+
+	printf("Setting " str(XTAL_ADDRESS) " to 0x%x\n", val);
+	return;
+}
diff --git a/board/atheros/board955x/flash.c b/board/atheros/board955x/flash.c
new file mode 100644
index 0000000000..ffcbf7fe4f
--- /dev/null
+++ b/board/atheros/board955x/flash.c
@@ -0,0 +1,32 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+#ifndef CONFIG_ATH_NAND_BR
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
+#endif /* CONFIG_ATH_NAND_BR */
diff --git a/board/atheros/board955x/u-boot-bootstrap.lds b/board/atheros/board955x/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/atheros/board955x/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/atheros/board955x/u-boot.lds b/board/atheros/board955x/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/atheros/board955x/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/atheros/common/953x.S b/board/atheros/common/953x.S
new file mode 100755
index 0000000000..5eb9d26cdb
--- /dev/null
+++ b/board/atheros/common/953x.S
@@ -0,0 +1,151 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define reg_write(_reg, _val)			\
+	li	t7,	KSEG1ADDR(_reg);	\
+	li	t8,	_val;			\
+	sw	t8,	0(t7);
+
+#define reg_rmw_set(_reg, _mask, _val)		\
+	li	t7,	KSEG1ADDR(_reg);	\
+	lw	t8,	0(t7);			\
+	li	t9,	~(_mask);		\
+	and	t8,	t8,	t9;		\
+	li	t9,	_val;			\
+	or	t8,	t8,	t9;		\
+	sw	t8,	0(t7)
+
+#define cpu_pll_set(_mask, _val)	\
+	reg_rmw_set(CPU_PLL_CONFIG_ADDRESS, _mask, _val)
+
+#define ddr_pll_set(_mask, _val)	\
+	reg_rmw_set(DDR_PLL_CONFIG_ADDRESS, _mask, _val)
+
+#define cpu_ddr_control_set(_mask, _val)	\
+	reg_rmw_set(CPU_DDR_CLOCK_CONTROL_ADDRESS, _mask, _val)
+
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl lowlevel_init
+	.type	lowlevel_init, @function
+	.text
+	.align 4
+
+lowlevel_init:
+
+#if !defined(CONFIG_ATH_EMULATION)
+
+	reg_write(BB_DPLL2_ADDRESS, BB_DPLL2_KI_SET(2) | \
+				BB_DPLL2_KD_SET(0x10) | \
+				BB_DPLL2_PLL_PWD_SET(1));
+	reg_write(PCIe_DPLL2_ADDRESS, PCIe_DPLL2_KI_SET(2) | \
+				PCIe_DPLL2_KD_SET(0x10) | \
+				PCIe_DPLL2_PLL_PWD_SET(1));
+	reg_write(DDR_DPLL2_ADDRESS, DDR_DPLL2_KI_SET(2) | \
+				DDR_DPLL2_KD_SET(0x10) | \
+				DDR_DPLL2_PLL_PWD_SET(1));
+	reg_write(CPU_DPLL2_ADDRESS, CPU_DPLL2_KI_SET(2) | \
+				CPU_DPLL2_KD_SET(0x10) | \
+				CPU_DPLL2_PLL_PWD_SET(1));
+
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL
+	li	t4,	CPU_PLL_DITHER_VAL
+	li	t3,	DDR_PLL_DITHER_VAL
+
+	li	t7,	PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	PLL_MAGIC
+	beq	t7,	t8,	read_from_flash
+	nop
+	j	pll_bypass_set
+	nop
+read_from_flash:
+	li	t7,	PLL_CONFIG_VAL_F + 4
+	lw	t5,	0(t7)
+	lw	t4,	4(t7)
+	lw	t6,	8(t7)
+	lw	t3,	12(t7)
+
+
+pll_bypass_set:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+init_cpu_pll:
+	li	t7,	KSEG1ADDR(CPU_PLL_CONFIG_ADDRESS);
+	li	t8,	(CPU_PLL_CONFIG_PLLPWD_SET(1) | \
+			CPU_PLL_CONFIG_REF_DIV_VAL | \
+			CPU_PLL_CONFIG_RANGE_VAL | \
+			CPU_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t5
+	sw	t8,	0(t7);
+
+init_ddr_pll:
+	li	t7,	KSEG1ADDR(DDR_PLL_CONFIG_ADDRESS);
+	li	t8,	(DDR_PLL_CONFIG_PLLPWD_SET(1) | \
+			DDR_PLL_CONFIG_REF_DIV_VAL | \
+			DDR_PLL_CONFIG_RANGE_VAL | \
+			DDR_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t6
+	sw	t8,	0(t7);
+
+init_ahb_pll:
+	reg_write(CPU_DDR_CLOCK_CONTROL_ADDRESS,
+			CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL |
+			AHB_CLK_FROM_DDR |
+			CLK_SRC_CONTROL |
+			CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV |
+			CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV |
+			CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1) |
+			CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1) |
+			CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+pll_pwd_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_PLLPWD_MASK, CPU_PLL_CONFIG_PLLPWD_SET(0));
+	ddr_pll_set(DDR_PLL_CONFIG_PLLPWD_MASK, DDR_PLL_CONFIG_PLLPWD_SET(0));
+
+outdiv_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_OUTDIV_MASK, CPU_PLL_CONFIG_OUT_DIV_VAL2);
+	ddr_pll_set(DDR_PLL_CONFIG_OUTDIV_MASK, DDR_PLL_CONFIG_OUT_DIV_VAL2);
+
+pll_bypass_unset:
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(0));
+
+ddr_pll_dither_unset:
+	li	t7,	KSEG1ADDR(DDR_PLL_DITHER_ADDRESS);
+	sw	t3,	0(t7);
+
+cpu_pll_dither_unset:
+	li	t7,	KSEG1ADDR(CPU_PLL_DITHER_ADDRESS);
+	sw	t4,	0(t7);
+
+	lui	t7,	47110;
+	lui	t8,	1020;
+	sw	t8,	0xb4(t7);
+
+
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+	jr ra
+	nop
diff --git a/board/atheros/common/955x.S b/board/atheros/common/955x.S
new file mode 100644
index 0000000000..9421036878
--- /dev/null
+++ b/board/atheros/common/955x.S
@@ -0,0 +1,153 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define reg_write(_reg, _val)			\
+	li	t7,	KSEG1ADDR(_reg);	\
+	li	t8,	_val;			\
+	sw	t8,	0(t7);
+
+#define reg_rmw_set(_reg, _mask, _val)		\
+	li	t7,	KSEG1ADDR(_reg);	\
+	lw	t8,	0(t7);			\
+	li	t9,	~(_mask);		\
+	and	t8,	t8,	t9;		\
+	li	t9,	_val;			\
+	or	t8,	t8,	t9;		\
+	sw	t8,	0(t7)
+
+#define cpu_pll_set(_mask, _val)	\
+	reg_rmw_set(CPU_PLL_CONFIG_ADDRESS, _mask, _val)
+
+#define ddr_pll_set(_mask, _val)	\
+	reg_rmw_set(DDR_PLL_CONFIG_ADDRESS, _mask, _val)
+
+#define cpu_ddr_control_set(_mask, _val)	\
+	reg_rmw_set(CPU_DDR_CLOCK_CONTROL_ADDRESS, _mask, _val)
+
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl lowlevel_init
+	.type	lowlevel_init, @function
+	.text
+	.align 4
+
+lowlevel_init:
+
+#if !defined(CONFIG_ATH_EMULATION)
+#if !defined(CONFIG_ATH_NAND_BR)
+
+	reg_write(BB_DPLL2_ADDRESS, BB_DPLL2_KI_SET(4) | \
+				BB_DPLL2_KD_SET(0x60) | \
+				BB_DPLL2_PLL_PWD_SET(1) | \
+				BB_DPLL2_DELTA_SET(0x1e));
+	reg_write(PCIe_DPLL2_ADDRESS, PCIe_DPLL2_KI_SET(4) | \
+				PCIe_DPLL2_KD_SET(0x60) | \
+				PCIe_DPLL2_PLL_PWD_SET(1) | \
+				PCIe_DPLL2_DELTA_SET(0x1e));
+	reg_write(DDR_DPLL2_ADDRESS, DDR_DPLL2_KI_SET(4) | \
+				DDR_DPLL2_KD_SET(0x60) | \
+				DDR_DPLL2_PLL_PWD_SET(1) | \
+				DDR_DPLL2_DELTA_SET(0x1e));
+	reg_write(CPU_DPLL2_ADDRESS, CPU_DPLL2_KI_SET(4) | \
+				CPU_DPLL2_KD_SET(0x60) | \
+				CPU_DPLL2_PLL_PWD_SET(1) | \
+				CPU_DPLL2_DELTA_SET(0x1e));
+
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL
+	li	t4,	CPU_PLL_DITHER_VAL
+	li	t3,	DDR_PLL_DITHER_VAL
+
+	li	t7,	PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	PLL_MAGIC
+	beq	t7,	t8,	read_from_flash
+	nop
+	j	pll_bypass_set
+	nop
+read_from_flash:
+	li	t7,	PLL_CONFIG_VAL_F + 4
+	lw	t5,	0(t7)
+	lw	t4,	4(t7)
+	lw	t6,	8(t7)
+	lw	t3,	12(t7)
+
+
+pll_bypass_set:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+init_cpu_pll:
+	li	t7,	KSEG1ADDR(CPU_PLL_CONFIG_ADDRESS);
+	li	t8,	(CPU_PLL_CONFIG_PLLPWD_SET(1) | \
+			CPU_PLL_CONFIG_REF_DIV_VAL | \
+			CPU_PLL_CONFIG_RANGE_VAL | \
+			CPU_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t5
+	sw	t8,	0(t7);
+
+init_ddr_pll:
+	li	t7,	KSEG1ADDR(DDR_PLL_CONFIG_ADDRESS);
+	li	t8,	(DDR_PLL_CONFIG_PLLPWD_SET(1) | \
+			DDR_PLL_CONFIG_REF_DIV_VAL | \
+			DDR_PLL_CONFIG_RANGE_VAL | \
+			DDR_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t6
+	sw	t8,	0(t7);
+
+init_ahb_pll:
+	reg_write(CPU_DDR_CLOCK_CONTROL_ADDRESS,
+			CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL |
+			AHB_CLK_FROM_DDR |
+			CPU_AND_DDR_CLK_FROM_DDR |
+			CPU_AND_DDR_CLK_FROM_CPU |
+			CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV |
+			CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV |
+			CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1) |
+			CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1) |
+			CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+pll_pwd_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_PLLPWD_MASK, CPU_PLL_CONFIG_PLLPWD_SET(0));
+	ddr_pll_set(DDR_PLL_CONFIG_PLLPWD_MASK, DDR_PLL_CONFIG_PLLPWD_SET(0));
+
+outdiv_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_OUTDIV_MASK, CPU_PLL_CONFIG_OUT_DIV_VAL2);
+	ddr_pll_set(DDR_PLL_CONFIG_OUTDIV_MASK, DDR_PLL_CONFIG_OUT_DIV_VAL2);
+
+pll_bypass_unset:
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(0));
+
+ddr_pll_dither_unset:
+	li	t7,	KSEG1ADDR(DDR_PLL_DITHER_ADDRESS);
+	sw	t3,	0(t7);
+
+cpu_pll_dither_unset:
+	li	t7,	KSEG1ADDR(CPU_PLL_DITHER_ADDRESS);
+	sw	t4,	0(t7);
+
+#endif /* !defined(CONFIG_ATH_NAND_BR) */
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+	jr ra
+	nop
diff --git a/board/atheros/common/ath_flash.c b/board/atheros/common/ath_flash.c
new file mode 100644
index 0000000000..9a90666aa8
--- /dev/null
+++ b/board/atheros/common/ath_flash.c
@@ -0,0 +1,323 @@
+#include <common.h>
+#include <jffs2/jffs2.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <atheros.h>
+#include "ath_flash.h"
+
+#if !defined(ATH_DUAL_FLASH)
+#	define	ath_spi_flash_print_info	flash_print_info
+#endif
+
+/*
+ * globals
+ */
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+/*
+ * statics
+ */
+static void ath_spi_write_enable(void);
+static void ath_spi_poll(void);
+#if !defined(ATH_SST_FLASH)
+static void ath_spi_write_page(uint32_t addr, uint8_t * data, int len);
+#endif
+static void ath_spi_sector_erase(uint32_t addr);
+
+static void
+ath_spi_read_id(void)
+{
+	u32 rd;
+
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_DIS);
+	ath_spi_bit_banger(ATH_SPI_CMD_RDID);
+	ath_spi_delay_8();
+	ath_spi_delay_8();
+	ath_spi_delay_8();
+	ath_spi_go();
+
+	rd = ath_reg_rd(ATH_SPI_RD_STATUS);
+
+	printf("Flash Manuf Id 0x%x, DeviceId0 0x%x, DeviceId1 0x%x\n",
+		(rd >> 16) & 0xff, (rd >> 8) & 0xff, (rd >> 0) & 0xff);
+}
+
+
+#ifdef ATH_SST_FLASH
+void ath_spi_flash_unblock(void)
+{
+	ath_spi_write_enable();
+	ath_spi_bit_banger(ATH_SPI_CMD_WRITE_SR);
+	ath_spi_bit_banger(0x0);
+	ath_spi_go();
+	ath_spi_poll();
+}
+#endif
+
+unsigned long flash_init(void)
+{
+#if !(defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x))
+#ifdef ATH_SST_FLASH
+	ath_reg_wr_nf(ATH_SPI_CLOCK, 0x3);
+	ath_spi_flash_unblock();
+	ath_reg_wr(ATH_SPI_FS, 0);
+#else
+	ath_reg_wr_nf(ATH_SPI_CLOCK, 0x43);
+#endif
+#endif
+	ath_reg_rmw_set(ATH_SPI_FS, 1);
+	ath_spi_read_id();
+	ath_reg_rmw_clear(ATH_SPI_FS, 1);
+
+	/*
+	 * hook into board specific code to fill flash_info
+	 */
+	return (flash_get_geom(&flash_info[0]));
+}
+
+void
+ath_spi_flash_print_info(flash_info_t *info)
+{
+	printf("The hell do you want flinfo for??\n");
+}
+
+int
+flash_erase(flash_info_t *info, int s_first, int s_last)
+{
+	int i, sector_size = info->size / info->sector_count;
+
+	printf("\nFirst %#x last %#x sector size %#x\n",
+		s_first, s_last, sector_size);
+
+	for (i = s_first; i <= s_last; i++) {
+		printf("\b\b\b\b%4d", i);
+		ath_spi_sector_erase(i * sector_size);
+	}
+	ath_spi_done();
+	printf("\n");
+
+	return 0;
+}
+
+/*
+ * Write a buffer from memory to flash:
+ * 0. Assumption: Caller has already erased the appropriate sectors.
+ * 1. call page programming for every 256 bytes
+ */
+#ifdef ATH_SST_FLASH
+void
+ath_spi_flash_chip_erase(void)
+{
+	ath_spi_write_enable();
+	ath_spi_bit_banger(ATH_SPI_CMD_CHIP_ERASE);
+	ath_spi_go();
+	ath_spi_poll();
+}
+
+int
+write_buff(flash_info_t *info, uchar *src, ulong dst, ulong len)
+{
+	uint32_t val;
+
+	dst = dst - CFG_FLASH_BASE;
+	printf("write len: %lu dst: 0x%x src: %p\n", len, dst, src);
+
+	for (; len; len--, dst++, src++) {
+		ath_spi_write_enable();	// dont move this above 'for'
+		ath_spi_bit_banger(ATH_SPI_CMD_PAGE_PROG);
+		ath_spi_send_addr(dst);
+
+		val = *src & 0xff;
+		ath_spi_bit_banger(val);
+
+		ath_spi_go();
+		ath_spi_poll();
+	}
+	/*
+	 * Disable the Function Select
+	 * Without this we can't read from the chip again
+	 */
+	ath_reg_wr(ATH_SPI_FS, 0);
+
+	if (len) {
+		// how to differentiate errors ??
+		return ERR_PROG_ERROR;
+	} else {
+		return ERR_OK;
+	}
+}
+#else
+int
+write_buff(flash_info_t *info, uchar *source, ulong addr, ulong len)
+{
+	int total = 0, len_this_lp, bytes_this_page;
+	ulong dst;
+	uchar *src;
+
+	printf("write addr: %x\n", addr);
+	addr = addr - CFG_FLASH_BASE;
+
+	while (total < len) {
+		src = source + total;
+		dst = addr + total;
+		bytes_this_page =
+			ATH_SPI_PAGE_SIZE - (addr % ATH_SPI_PAGE_SIZE);
+		len_this_lp =
+			((len - total) >
+			bytes_this_page) ? bytes_this_page : (len - total);
+		ath_spi_write_page(dst, src, len_this_lp);
+		total += len_this_lp;
+	}
+
+	ath_spi_done();
+
+	return 0;
+}
+#endif
+
+static void
+ath_spi_write_enable()
+{
+	ath_reg_wr_nf(ATH_SPI_FS, 1);
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_DIS);
+	ath_spi_bit_banger(ATH_SPI_CMD_WREN);
+	ath_spi_go();
+}
+
+static void
+ath_spi_poll()
+{
+	int rd;
+
+	do {
+		ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_DIS);
+		ath_spi_bit_banger(ATH_SPI_CMD_RD_STATUS);
+		ath_spi_delay_8();
+		rd = (ath_reg_rd(ATH_SPI_RD_STATUS) & 1);
+	} while (rd);
+}
+
+#if !defined(ATH_SST_FLASH)
+static void
+ath_spi_write_page(uint32_t addr, uint8_t *data, int len)
+{
+	int i;
+	uint8_t ch;
+
+	display(0x77);
+	ath_spi_write_enable();
+	ath_spi_bit_banger(ATH_SPI_CMD_PAGE_PROG);
+	ath_spi_send_addr(addr);
+
+	for (i = 0; i < len; i++) {
+		ch = *(data + i);
+		ath_spi_bit_banger(ch);
+	}
+
+	ath_spi_go();
+	display(0x66);
+	ath_spi_poll();
+	display(0x6d);
+}
+#endif
+
+static void
+ath_spi_sector_erase(uint32_t addr)
+{
+	ath_spi_write_enable();
+	ath_spi_bit_banger(ATH_SPI_CMD_SECTOR_ERASE);
+	ath_spi_send_addr(addr);
+	ath_spi_go();
+	display(0x7d);
+	ath_spi_poll();
+}
+
+#ifdef ATH_DUAL_FLASH
+void flash_print_info(flash_info_t *info)
+{
+	ath_spi_flash_print_info(NULL);
+	ath_nand_flash_print_info(NULL);
+}
+#endif
+
+#ifdef FW_RECOVERY/*  by huangwenzhong, 03May13 */
+
+/******************************************************************************
+* FUNCTION      	: ar7240_auf_gpio_init()
+* AUTHOR        	: HouXB <houxubo@tp-link.net>
+* DESCRIPTION  		: set input and output indicator gpio, when auto upload firmware 
+* INPUT				: 
+*
+* OUTPUT        	: 
+* RETURN        	: 
+* OTHERS        	: 
+******************************************************************************/
+static void ath_gpio_set_val(int reg, int gpio, int val)
+{
+	if (val & 0x1) {
+		ath_reg_rmw_set(reg, (1 << gpio));
+	} else {
+		ath_reg_rmw_clear(reg, (1 << gpio));
+	}
+}
+
+void ath_auf_gpio_init()
+{
+	/* use reset button as input indicator */
+	ath_gpio_set_val(GPIO_OE_ADDRESS, FW_BUTTON_GPIO, 1);
+	
+	/* use wps led as output indicator */
+	ath_gpio_set_val(GPIO_OE_ADDRESS, FW_LED_GPIO, 0);	
+}
+
+/******************************************************************************
+* FUNCTION      	: ar7240_is_rst_btn_pressed()
+* AUTHOR        	: HouXB <houxubo@tp-link.net>
+* DESCRIPTION  		: check whether the reset button was pressed 
+* INPUT				: 
+*
+* OUTPUT        	: 
+* RETURN        	: 1, pressed; 0, not pressed
+* OTHERS        	: 
+******************************************************************************/
+int ath_is_rst_btn_pressed()
+{
+	int val;
+	int old_val;
+
+	udelay(10 * 1000); /* delay 1ms for input value stabile. by HouXB, 27Apr11 */
+	old_val = ath_reg_rd(GPIO_IN_ADDRESS);
+	udelay(1000);
+	val = ath_reg_rd(GPIO_IN_ADDRESS);
+
+	/* make sure the btn was pressed. by HouXB, 27Apr11 */
+	if(old_val != val)
+	{
+		return 0;
+	}
+	val = ((val & (1 << FW_BUTTON_GPIO)) >> FW_BUTTON_GPIO);
+	/* when pressed val is 0, return 1 to indicate pressed */
+	return (1 - val);
+}
+
+/******************************************************************************
+* FUNCTION      	: ar7240_usb_led_on()
+* AUTHOR        	: HouXB <houxubo@tp-link.net>
+* DESCRIPTION  		: auto upload firmware output indicator 
+* INPUT				: 
+*
+* OUTPUT        	: 
+* RETURN        	: 
+* OTHERS        	: 
+******************************************************************************/
+void ath_fw_led_on()
+{	
+	ath_gpio_set_val(GPIO_OUT_ADDRESS, FW_LED_GPIO, FW_LED_ON);
+}
+
+void ath_fw_led_off()
+{
+	ath_gpio_set_val(GPIO_OUT_ADDRESS, FW_LED_GPIO, FW_LED_OFF);
+}
+#endif
+
diff --git a/board/atheros/common/ath_flash.h b/board/atheros/common/ath_flash.h
new file mode 100644
index 0000000000..3afabc506f
--- /dev/null
+++ b/board/atheros/common/ath_flash.h
@@ -0,0 +1,53 @@
+#ifndef _ATH_FLASH_H
+#define _ATH_FLASH_H
+
+#define display(_x)
+
+/*
+ * primitives
+ */
+
+#define ath_be_msb(_val, _i) (((_val) & (1 << (7 - _i))) >> (7 - _i))
+
+#define ath_spi_bit_banger(_byte)	do {				\
+	int i;								\
+	for(i = 0; i < 8; i++) {					\
+		ath_reg_wr_nf(ATH_SPI_WRITE,				\
+			ATH_SPI_CE_LOW | ath_be_msb(_byte, i));		\
+		ath_reg_wr_nf(ATH_SPI_WRITE,				\
+			ATH_SPI_CE_HIGH | ath_be_msb(_byte, i));	\
+	}								\
+} while (0)
+
+#define ath_spi_go()	do {				\
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CE_LOW);	\
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_DIS);	\
+} while (0)
+
+
+#define ath_spi_send_addr(__a) do {			\
+	ath_spi_bit_banger(((__a & 0xff0000) >> 16));	\
+	ath_spi_bit_banger(((__a & 0x00ff00) >> 8));	\
+	ath_spi_bit_banger(__a & 0x0000ff);		\
+} while (0)
+
+#define ath_spi_delay_8()	ath_spi_bit_banger(0)
+#define ath_spi_done()		ath_reg_wr_nf(ATH_SPI_FS, 0)
+
+extern unsigned long flash_get_geom (flash_info_t *flash_info);
+
+#ifdef FW_RECOVERY/*  by huangwenzhong, 03May13 */
+
+#define FW_BUTTON_GPIO 		(FW_RECOVERY_INPUT_BUTTON_GPIO)
+#define FW_LED_GPIO 		(FW_RECOVERY_OUTPUT_LED_GPIO)
+#define FW_LED_ON			(FW_RECOVERY_OUTPUT_LED_ON)
+#define FW_LED_OFF			(!FW_LED_ON)
+
+void 	ath_auf_gpio_init(void);
+int 	ath_is_rst_btn_pressed(void);
+void 	ath_fw_led_on(void);
+void 	ath_fw_led_off(void);
+#endif
+
+
+#endif /* _ATH_FLASH_H */
diff --git a/board/atheros/common/ath_nand.c b/board/atheros/common/ath_nand.c
new file mode 100644
index 0000000000..388b82d12f
--- /dev/null
+++ b/board/atheros/common/ath_nand.c
@@ -0,0 +1,1593 @@
+/*
+ * linux/drivers/mtd/nand/ath_nand.c
+ * vim: tabstop=8 : noexpandtab
+ * Derived from alauda.c
+ */
+#include <common.h>
+#include <command.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <config.h>
+#include <atheros.h>
+#include <malloc.h>
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/bitops.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+
+#define ENOMEM		12
+#define EINVAL		22
+
+#define writesize		oobblock
+
+#define DRV_NAME	"ath-nand"
+#define DRV_VERSION	"0.1"
+#define DRV_AUTHOR	"Atheros"
+#define DRV_DESC	"Atheros on-chip NAND FLash Controller Driver"
+
+#define ATH_NF_COMMAND		(ATH_NAND_FLASH_BASE + 0x200u)
+#define ATH_NF_CTRL		(ATH_NAND_FLASH_BASE + 0x204u)
+#define ATH_NF_STATUS		(ATH_NAND_FLASH_BASE + 0x208u)
+#define ATH_NF_INT_MASK		(ATH_NAND_FLASH_BASE + 0x20cu)
+#define ATH_NF_INT_STATUS	(ATH_NAND_FLASH_BASE + 0x210u)
+#define ATH_NF_ECC_CTRL		(ATH_NAND_FLASH_BASE + 0x214u)
+#define ATH_NF_ECC_OFFSET	(ATH_NAND_FLASH_BASE + 0x218u)
+#define ATH_NF_ADDR0_0		(ATH_NAND_FLASH_BASE + 0x21cu)
+#define ATH_NF_ADDR1_0		(ATH_NAND_FLASH_BASE + 0x220u)
+#define ATH_NF_ADDR0_1		(ATH_NAND_FLASH_BASE + 0x224u)
+#define ATH_NF_ADDR1_1		(ATH_NAND_FLASH_BASE + 0x228u)
+#define ATH_NF_SPARE_SIZE	(ATH_NAND_FLASH_BASE + 0x230u)
+#define ATH_NF_PROTECT		(ATH_NAND_FLASH_BASE + 0x238u)
+#define ATH_NF_LOOKUP_EN	(ATH_NAND_FLASH_BASE + 0x240u)
+#define ATH_NF_LOOKUP0		(ATH_NAND_FLASH_BASE + 0x244u)
+#define ATH_NF_LOOKUP1		(ATH_NAND_FLASH_BASE + 0x248u)
+#define ATH_NF_LOOKUP2		(ATH_NAND_FLASH_BASE + 0x24cu)
+#define ATH_NF_LOOKUP3		(ATH_NAND_FLASH_BASE + 0x250u)
+#define ATH_NF_LOOKUP4		(ATH_NAND_FLASH_BASE + 0x254u)
+#define ATH_NF_LOOKUP5		(ATH_NAND_FLASH_BASE + 0x258u)
+#define ATH_NF_LOOKUP6		(ATH_NAND_FLASH_BASE + 0x25cu)
+#define ATH_NF_LOOKUP7		(ATH_NAND_FLASH_BASE + 0x260u)
+#define ATH_NF_DMA_ADDR		(ATH_NAND_FLASH_BASE + 0x264u)
+#define ATH_NF_DMA_COUNT	(ATH_NAND_FLASH_BASE + 0x268u)
+#define ATH_NF_DMA_CTRL		(ATH_NAND_FLASH_BASE + 0x26cu)
+#define ATH_NF_MEM_CTRL		(ATH_NAND_FLASH_BASE + 0x280u)
+#define ATH_NF_PG_SIZE		(ATH_NAND_FLASH_BASE + 0x284u)
+#define ATH_NF_RD_STATUS	(ATH_NAND_FLASH_BASE + 0x288u)
+#define ATH_NF_TIME_SEQ		(ATH_NAND_FLASH_BASE + 0x28cu)
+#define ATH_NF_TIMINGS_ASYN	(ATH_NAND_FLASH_BASE + 0x290u)
+#define ATH_NF_TIMINGS_SYN	(ATH_NAND_FLASH_BASE + 0x294u)
+#define ATH_NF_FIFO_DATA	(ATH_NAND_FLASH_BASE + 0x298u)
+#define ATH_NF_TIME_MODE	(ATH_NAND_FLASH_BASE + 0x29cu)
+#define ATH_NF_DMA_ADDR_OFFSET	(ATH_NAND_FLASH_BASE + 0x2a0u)
+#define ATH_NF_FIFO_INIT	(ATH_NAND_FLASH_BASE + 0x2b0u)
+#define ATH_NF_GENERIC_SEQ_CTRL	(ATH_NAND_FLASH_BASE + 0x2b4u)
+
+#define ATH_NF_TIMING_ASYN	0x11
+#define ATH_NF_STATUS_OK	0x40	//0xc0
+#define ATH_NF_RD_STATUS_MASK	0x47	//0xc7
+
+#define ATH_NF_COMMAND_CMD_2(x)		(((x) & 0xff) << 24)	// A code of the third command in a sequence.
+#define ATH_NF_COMMAND_CMD_1(x)		(((x) & 0xff) << 16)	// A code of the second command in a sequence.
+#define ATH_NF_COMMAND_CMD_0(x)		(((x) & 0xff) <<  8)	// A code of the first command in a sequence.
+#define ATH_NF_COMMAND_ADDR_SEL		(1 << 7)		// Address register select flag:
+								// 0  the address register 0 selected
+								// 1  the address register 1 selected
+#define ATH_NF_COMMAND_INPUT_SEL_DMA	(1 << 6) 		// Input module select flag:
+								// 0  select the SIU module as input
+								// 1  select the DMA module as input
+#define ATH_NF_COMMAND_CMD_SEQ_0	0x00
+#define ATH_NF_COMMAND_CMD_SEQ_1	0x21
+#define ATH_NF_COMMAND_CMD_SEQ_2	0x22
+#define ATH_NF_COMMAND_CMD_SEQ_3	0x03
+#define ATH_NF_COMMAND_CMD_SEQ_4	0x24
+#define ATH_NF_COMMAND_CMD_SEQ_5	0x25
+#define ATH_NF_COMMAND_CMD_SEQ_6	0x26
+#define ATH_NF_COMMAND_CMD_SEQ_7	0x27
+#define ATH_NF_COMMAND_CMD_SEQ_8	0x08
+#define ATH_NF_COMMAND_CMD_SEQ_9	0x29
+#define ATH_NF_COMMAND_CMD_SEQ_10	0x2A
+#define ATH_NF_COMMAND_CMD_SEQ_11	0x2B
+#define ATH_NF_COMMAND_CMD_SEQ_12	0x0C
+#define ATH_NF_COMMAND_CMD_SEQ_13	0x0D
+#define ATH_NF_COMMAND_CMD_SEQ_14	0x0E
+#define ATH_NF_COMMAND_CMD_SEQ_15	0x2F
+#define ATH_NF_COMMAND_CMD_SEQ_16	0x30
+#define ATH_NF_COMMAND_CMD_SEQ_17	0x11
+#define ATH_NF_COMMAND_CMD_SEQ_18	0x32
+#define ATH_NF_COMMAND_CMD_SEQ_19	0x13
+
+
+#define ATH_NF_CTRL_SMALL_BLOCK_EN	(1 << 21)
+
+#define ATH_NF_CTRL_ADDR_CYCLE1_0	(0 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_1	(1 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_2	(2 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_3	(3 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_4	(4 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_5	(5 << 18)
+
+#define ATH_NF_CTRL_ADDR1_AUTO_INC_EN	(1 << 17)
+#define ATH_NF_CTRL_ADDR0_AUTO_INC_EN	(1 << 16)
+#define ATH_NF_CTRL_WORK_MODE_SYNC	(1 << 15)
+#define ATH_NF_CTRL_PROT_EN		(1 << 14)
+#define ATH_NF_CTRL_LOOKUP_EN		(1 << 13)
+#define ATH_NF_CTRL_IO_WIDTH_16BIT	(1 << 12)
+#define ATH_NF_CTRL_CUSTOM_SIZE_EN	(1 << 11)
+
+#define ATH_NF_CTRL_PAGE_SIZE_256	(0 <<  8)	/* bytes */
+#define ATH_NF_CTRL_PAGE_SIZE_512	(1 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_1024	(2 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_2048	(3 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_4096	(4 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_8192	(5 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_16384	(6 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_0		(7 <<  8)
+
+#define ATH_NF_CTRL_BLOCK_SIZE_32	(0 <<  6)	/* pages */
+#define ATH_NF_CTRL_BLOCK_SIZE_64	(1 <<  6)
+#define ATH_NF_CTRL_BLOCK_SIZE_128	(2 <<  6)
+#define ATH_NF_CTRL_BLOCK_SIZE_256	(3 <<  6)
+
+#define ATH_NF_CTRL_ECC_EN		(1 <<  5)
+#define ATH_NF_CTRL_INT_EN		(1 <<  4)
+#define ATH_NF_CTRL_SPARE_EN		(1 <<  3)
+
+#define ATH_NF_CTRL_ADDR_CYCLE0_0	(0 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_1	(1 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_2	(2 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_3	(3 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_4	(4 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_5	(5 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0(c)	((c) << 0)
+
+
+#define ATH_NF_DMA_CTRL_DMA_START	(1 << 7)
+#define ATH_NF_DMA_CTRL_DMA_DIR_WRITE	(0 << 6)
+#define ATH_NF_DMA_CTRL_DMA_DIR_READ	(1 << 6)
+#define ATH_NF_DMA_CTRL_DMA_MODE_SG	(1 << 5)
+/*
+ * 000  incrementing precise burst of precisely four transfers
+ * 001  stream burst (address const)
+ * 010  single transfer (address increment)
+ * 011  burst of unspecified length (address increment)
+ * 100  incrementing precise burst of precisely eight transfers
+ * 101  incrementing precise burst of precisely sixteen transfers
+ */
+#define ATH_NF_DMA_CTRL_DMA_BURST_0	(0 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_1	(1 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_2	(2 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_3	(3 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_4	(4 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_5	(5 << 2)
+#define ATH_NF_DMA_CTRL_ERR_FLAG	(1 << 1)
+#define ATH_NF_DMA_CTRL_DMA_READY	(1 << 0)
+
+#define ATH_NF_ECC_CTRL_ERR_THRESH(x)	((x << 8) & (0x1fu << 8))
+#define ATH_NF_ECC_CTRL_ECC_CAP(x)	((x << 5) & (0x07u << 5))
+#define ATH_NF_ECC_CTRL_ECC_2_BITS	ATH_NF_ECC_CTRL_ECC_CAP(0)
+#define ATH_NF_ECC_CTRL_ECC_4_BITS	ATH_NF_ECC_CTRL_ECC_CAP(1)
+#define ATH_NF_ECC_CTRL_ECC_6_BITS	ATH_NF_ECC_CTRL_ECC_CAP(2)
+#define ATH_NF_ECC_CTRL_ECC_8_BITS	ATH_NF_ECC_CTRL_ECC_CAP(3)
+#define ATH_NF_ECC_CTRL_ECC_10_BITS	ATH_NF_ECC_CTRL_ECC_CAP(4)
+#define ATH_NF_ECC_CTRL_ECC_12_BITS	ATH_NF_ECC_CTRL_ECC_CAP(5)
+#define ATH_NF_ECC_CTRL_ECC_14_BITS	ATH_NF_ECC_CTRL_ECC_CAP(6)
+#define ATH_NF_ECC_CTRL_ECC_16_BITS	ATH_NF_ECC_CTRL_ECC_CAP(7)
+
+#define ATH_NF_ECC_CTRL_ERR_OVER	(1 << 2)
+#define ATH_NF_ECC_CTRL_ERR_UNCORR	(1 << 1)
+#define ATH_NF_ECC_CTRL_ERR_CORR	(1 << 0)
+#	define ATH_NF_ECC_ERROR		(ATH_NF_ECC_CTRL_ERR_UNCORR | \
+					 ATH_NF_ECC_CTRL_ERR_OVER)
+
+#define ATH_NF_CMD_END_INT		(1 << 1)
+
+#define ATH_NF_HW_ECC		1
+#define ATH_NF_STATUS_RETRY	1000
+
+#define ath_nand_get_cmd_end_status(void)	\
+	(ath_reg_rd(ATH_NF_INT_STATUS) & ATH_NF_CMD_END_INT)
+
+#define ath_nand_clear_int_status()	ath_reg_wr(ATH_NF_INT_STATUS, 0)
+
+#define ATH_NAND_BLK_DONT_KNOW	0x0
+#define ATH_NAND_BLK_GOOD	0x1
+#define ATH_NAND_BLK_BAD	0x2
+#define ATH_NAND_BLK_ERASED	0x3
+
+#define ATH_NF_GENERIC_SEQ_CTRL_COL_ADDR	(1 << 17)
+#define ATH_NF_GENERIC_SEQ_CTRL_DATA_EN		(1 << 16)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD3_CODE(x)	(((x) & 0xff) << 8)
+#define ATH_NF_GENERIC_SEQ_CTRL_DEL_EN(x)	(((x) & 3) << 6)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD3_EN		(1 << 5)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD2_EN		(1 << 4)
+#define ATH_NF_GENERIC_SEQ_CTRL_ADDR1_EN	(1 << 3)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD1_EN		(1 << 2)
+#define ATH_NF_GENERIC_SEQ_CTRL_ADDR0_EN	(1 << 1)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD0_EN		(1 << 0)
+
+#define ATH_NAND_JFFS2_ECC_OFF	0x04	// Give 4 bytes for Factory Bad Block Marker
+#define ATH_NAND_JFFS2_ECC_LEN	0x10	// Space for JFFS2 Clean Marker
+
+/*
+ * Note: The byte positions might not match the spec.
+ * It is to handle the endianness issues.
+ */
+#define ONFI_NUM_ADDR_CYCLES	102	/* see note */
+#define ONFI_DEV_DESC		32
+#define ONFI_DEV_DESC_SZ	32
+#define ONFI_PAGE_SIZE		80
+#define ONFI_SPARE_SIZE		86	/* see note */
+#define ONFI_PAGES_PER_BLOCK	92
+#define ONFI_BLOCKS_PER_LUN	96
+#define ONFI_NUM_LUNS		103	/* see note */
+#define ONFI_RD_PARAM_PAGE_SZ	128
+#define READ_PARAM_STATUS_OK	0x40
+#define READ_PARAM_STATUS_MASK	0x41
+
+#define ATH_NAND_IO_DBG		0
+#define ATH_NAND_OOB_DBG	0
+#define ATH_NAND_IN_DBG		0
+
+#if ATH_NAND_IO_DBG
+#	define iodbg	printk
+#else
+#	define iodbg(...)
+#endif
+
+#if ATH_NAND_OOB_DBG
+#	define oobdbg	printk
+#else
+#	define oobdbg(...)
+#endif
+
+#if ATH_NAND_IN_DBG
+#	define indbg(a, ...)					\
+	do {							\
+		printk("--- %s(%d):" a "\n",			\
+			__func__, __LINE__, ## __VA_ARGS__);	\
+	} while (0)
+#else
+#	define indbg(...)
+#	define indbg1(a, ...)					\
+	do {							\
+		printk("--- %s(%d):" a "\n",			\
+			__func__, __LINE__, ## __VA_ARGS__);	\
+	} while (0)
+#endif
+
+/*
+ * Data structures for ath nand flash controller driver
+ */
+
+typedef union {
+	uint8_t			byte_id[8];
+
+	struct {
+		uint8_t		sa1	: 1,	// Serial access time (bit 1)
+				org	: 1,	// Organisation
+				bs	: 2,	// Block size
+				sa0	: 1,	// Serial access time (bit 0)
+				ss	: 1,	// Spare size per 512 bytes
+				ps	: 2,	// Page Size
+
+				wc	: 1,	// Write Cache
+				ilp	: 1, 	// Interleaved Programming
+				nsp	: 2, 	// No. of simult prog pages
+				ct	: 2,	// Cell type
+				dp	: 2,	// Die/Package
+
+				did,		// Device id
+				vid,		// Vendor id
+
+				res1	: 2,	// Reserved
+				pls	: 2,	// Plane size
+				pn	: 2,	// Plane number
+				res2	: 2;	// Reserved
+	} __details;
+} ath_nand_id_t;
+
+uint64_t ath_plane_size[] = {
+	64 << 20,
+	 1 << 30,
+	 2 << 30,
+	 4 << 30,
+	 8 << 30
+};
+
+typedef struct {
+	uint8_t		vid,
+			did,
+			b3,
+			addrcyc,
+			small,
+			spare;	// for small block;
+	uint16_t	pgsz;	// for small block
+	uint32_t	blk;	// for small block
+} ath_nand_vend_data_t;
+
+#define is_small_block_device(x)	((x)->entry && (x)->entry->small)
+
+ath_nand_vend_data_t ath_nand_arr[] = {
+	{ 0x20, 0xda, 0x10, 5, },	// NU2g3B2D
+	{ 0x20, 0xf1, 0x00, 4, },	// NU1g3B2C
+	{ 0x20, 0xdc, 0x10, 5, },	// NU4g3B2D
+	{ 0x20, 0xd3, 0x10, 5, },	// NU8g3F2A
+	{ 0x20, 0xd3, 0x14, 5, },	// NU8g3C2B
+	{ 0xad, 0xf1, 0x00, 4, },	// HY1g2b
+	{ 0xad, 0xda, 0x10, 5, },	// HY2g2b
+	{ 0xec, 0xf1, 0x00, 4, },	// Samsung 3,3V 8-bit [128MB]
+	{ 0x98, 0xd1, 0x90, 4, },	// Toshiba
+	{ 0xad, 0x76, 0xad, 5, 1, 16, 512, 16 << 10 },	// Hynix 64MB NAND Flash
+	{ 0xad, 0x36, 0xad, 5, 1, 16, 512, 16 << 10 },	// Hynix 64MB NAND Flash
+	{ 0x20, 0x76, 0x20, 5, 1, 16, 512, 16 << 10 },	// ST Micro 64MB NAND Flash
+};
+
+#define NUM_ARRAY_ENTRIES(a)	(sizeof((a)) / sizeof((a)[0]))
+#define NUM_ATH_NAND		NUM_ARRAY_ENTRIES(ath_nand_arr)
+
+/* ath nand info */
+typedef struct {
+	/* mtd info */
+	struct mtd_info		*mtd;
+
+	/* platform info */
+	unsigned short		page_size,
+				data_width;
+
+	/* NAND MTD partition information */
+	int			nr_partitions;
+	struct mtd_partition	*partitions;
+
+	unsigned		*bbt;
+
+	ath_nand_vend_data_t	*entry;
+
+	unsigned		ba0,
+				ba1,
+				cmd;	// Current command
+	ath_nand_id_t		__id;	// for readid
+	uint8_t			onfi[ONFI_RD_PARAM_PAGE_SZ];
+#if ATH_NF_HW_ECC
+	uint32_t		ecc_offset;
+#endif
+	uint32_t		nf_ctrl;
+} ath_nand_sc_t;
+
+ath_nand_sc_t ath_nand_sc;
+static int ath_nand_hw_init(ath_nand_sc_t *, void *);
+
+struct mtd_info nand_info[CFG_MAX_NAND_DEVICE];
+int nand_curr_device = 0;
+
+#define	nid	__id.__details
+#define	bid	__id.byte_id
+
+static int ath_nand_block_isbad(struct mtd_info *mtd, loff_t ofs);
+void ath_nand_dump_buf(loff_t addr, void *v, unsigned count);
+
+/* max page size (16k) + oob buf size */
+uint8_t	ath_nand_io_buf[24 << 10] __attribute__((aligned(4096)));
+#define get_ath_nand_io_buf()	ath_nand_io_buf
+
+#define	bbt_index	(sizeof(*sc->bbt) * 8 / 2)
+
+/*
+ * MTD layer assumes the NAND device as a linear array of bytes.
+ * However, the NAND devices are organised into blocks, pages,
+ * spare area etc. Hence, the address provided by Linux has to
+ * converted to format expected by the devices.
+ *
+ * [in] mtd: MTD info pointer
+ * [in] addr: Linear Address as provided by MTD layer
+ * [out] addr0: Value to be set into ADDR0_0 register
+ * [out] addr1: Value to be set into ADDR0_1 register
+ * [in] small_block_erase: Address conversion for small block
+ *	is different. Hence, special case it.
+ */
+inline void
+ath_nand_conv_addr(struct mtd_info *mtd, loff_t addr, uint32_t *addr0,
+			uint32_t *addr1, int small_block_erase)
+{
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (is_small_block_device(sc) && small_block_erase) {
+		/*
+		 * The block address loading is accomplished three
+		 * cycles. Erase is a SEQ_14 type command. Hence, the
+		 * controller starts shifting from ADDR_0[16:32] &
+		 * ADDR_1 based on the number of address cycles in our
+		 * case... The device data sheet assumes to have 3
+		 * address cycles for having page address + block
+		 * address for erase. Ideally, SMALL_BLOCK_EN in the
+		 * NF_CTRL register should help but, that doesn't seem
+		 * to work as expected. Hence, the following
+		 * conversion.
+		 */
+
+		// Get the block no.
+		uint32_t b = (addr >> mtd->erasesize_shift);
+
+		*addr0 = (b & 0xfff) << 21;
+		*addr1 = (b >> 11) & 0x1;
+	} else if (is_small_block_device(sc)) {
+		/* +-----+----+----+----+----+----+----+----+----+
+		 * |cycle|I/O7|I/O6|I/O5|I/O4|I/O3|I/O2|I/O1|I/O0|
+		 * +-----+----+----+----+----+----+----+----+----+
+		 * | 1st | A7 | A6 | A5 | A4 | A3 | A2 | A1 | A0 |
+		 * | 2nd |A16 |A15 |A14 |A13 |A12 |A11 |A10 | A9 |
+		 * | 3rd |A24 |A23 |A22 |A21 |A20 |A19 |A18 |A17 |
+		 * | 4th | x  | x  | x  | x  | x  | x  | x  |A25 |
+		 * +-----+----+----+----+----+----+----+----+----+
+		 */
+		addr &= ~(mtd->writesize_mask);
+		*addr0 = ((addr & 0xff) |
+			  ((addr >> 1) & (~0xffu))) & ((1 << 25) - 1);
+		*addr1 = 0;
+	} else {
+		/* +-----+---+---+---+---+---+---+---+---+
+		 * |Cycle|IO0|IO1|IO2|IO3|IO4|IO5|IO6|IO7|
+		 * +-----+---+---+---+---+---+---+---+---+
+		 * | 1st | A0| A1| A2| A3| A4| A5| A6| A7|
+		 * | 2nd | A8| A9|A10|A11| x | x | x | x |
+		 * | 3rd |A12|A13|A14|A15|A16|A17|A18|A19|
+		 * | 4th |A20|A21|A22|A23|A24|A25|A26|A27|
+		 * +-----+---+---+---+---+---+---+---+---+
+		 */
+		*addr0 = ((addr >> mtd->writesize_shift) << 16);
+		*addr1 = ((addr >> (mtd->writesize_shift + 16)) & 0xf);
+	}
+}
+
+inline unsigned
+ath_nand_get_blk_state(struct mtd_info *mtd, loff_t b)
+{
+	unsigned		x, y;
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (!sc->bbt)	return ATH_NAND_BLK_DONT_KNOW;
+
+	b = b >> mtd->erasesize_shift;
+
+	x = b / bbt_index;
+	y = b % bbt_index;
+
+	return (sc->bbt[x] >> (y * 2)) & 0x3;
+}
+
+inline void
+ath_nand_set_blk_state(struct mtd_info *mtd, loff_t b, unsigned state)
+{
+	unsigned		x, y;
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (!sc->bbt)	return;
+
+	b = b >> mtd->erasesize_shift;
+
+	x = b / bbt_index;
+	y = b % bbt_index;
+
+	sc->bbt[x] = (sc->bbt[x] & ~(3 << (y * 2))) | (state << (y * 2));
+}
+
+static unsigned
+ath_nand_status(ath_nand_sc_t *sc, unsigned *ecc)
+{
+	unsigned	rddata, i, j, dmastatus;
+
+	rddata = ath_reg_rd(ATH_NF_STATUS);
+	for (i = 0; i < ATH_NF_STATUS_RETRY && rddata != 0xff; i++) {
+		udelay(5);
+		rddata = ath_reg_rd(ATH_NF_STATUS);
+	}
+
+	dmastatus = ath_reg_rd(ATH_NF_DMA_CTRL);
+	for (j = 0; j < ATH_NF_STATUS_RETRY && !(dmastatus & 1); j++) {
+		udelay(5);
+		dmastatus = ath_reg_rd(ATH_NF_DMA_CTRL);
+	}
+
+	if ((i == ATH_NF_STATUS_RETRY) || (j == ATH_NF_STATUS_RETRY)) {
+		//printk("ath_nand_status: i = %u j = %u\n", i, j);
+		ath_nand_hw_init(sc, NULL);
+		return -1;
+	}
+	if (ecc) {
+		*ecc = ath_reg_rd(ATH_NF_ECC_CTRL);
+	}
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_GENERIC_SEQ_CTRL, 0);
+	ath_reg_wr(ATH_NF_COMMAND, 0x07024);	// READ STATUS
+	while (ath_nand_get_cmd_end_status() == 0);
+	rddata = ath_reg_rd(ATH_NF_RD_STATUS);
+
+	return rddata;
+}
+
+static unsigned
+ath_check_all_0xff(ath_nand_sc_t *sc, unsigned addr0, unsigned addr1, unsigned *all_0xff)
+{
+	uint8_t		*pa, *buf = ath_nand_io_buf, *end;
+	struct mtd_info	*mtd = sc->mtd;
+	unsigned	i, count = mtd->writesize + mtd->oobsize;
+
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_DMA_COUNT, count);
+	ath_reg_wr(ATH_NF_DMA_CTRL, ATH_NF_DMA_CTRL_DMA_START |
+				ATH_NF_DMA_CTRL_DMA_DIR_READ |
+				ATH_NF_DMA_CTRL_DMA_BURST_3);
+	ath_reg_wr(ATH_NF_ECC_OFFSET, 0);
+	ath_reg_wr(ATH_NF_ECC_CTRL, 0);
+	ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_CUSTOM_SIZE_EN);
+	ath_reg_wr(ATH_NF_PG_SIZE, count);
+	pa = (void *)virt_to_phys(buf);
+	ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+	ath_reg_wr(ATH_NF_COMMAND, 0x30006a);	// Read page
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	i = ath_nand_status(sc, NULL) & ATH_NF_RD_STATUS_MASK;
+	memcpy(buf, pa, count);	// cache sync equivalent
+	if (i != ATH_NF_STATUS_OK) {
+		return 0;
+	}
+	end = buf + count;
+	for (buf += sc->ecc_offset; (*buf == 0xff) && buf != end; buf ++);
+
+	*all_0xff = 1;
+
+	if (buf == end) {
+		/* This page was read without ECC. From the spare area
+		 * content we see that it a blank page (i.e. full 0xff).
+		 * To take care of bit flips if any, force 0xff on it.
+		 */
+		memset(ath_nand_io_buf, 0xff, mtd->writesize);
+	} else {
+		ath_nand_dump_buf(addr0, ath_nand_io_buf, mtd->writesize + mtd->oobsize);
+	}
+	return (buf == end);
+}
+
+static unsigned
+ath_nand_rw_page(ath_nand_sc_t *sc, int rd, unsigned addr0, unsigned addr1, unsigned count, unsigned char *buf, unsigned ecc_needed)
+{
+	unsigned	ecc, i = 0, tmp, rddata, all_0xff = 0;
+#if ATH_NF_HW_ECC
+	unsigned	mlc_retry = 0;
+#endif
+	char		*err[] = { "Write", "Read" };
+#define ATH_MAX_RETRY	25
+#define ATH_MLC_RETRY	3
+retry:
+	ecc = 0;
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)buf);
+	ath_reg_wr(ATH_NF_DMA_COUNT, count);
+
+#if ATH_NF_HW_ECC
+	if (ecc_needed && sc->ecc_offset && (count & sc->mtd->writesize_mask) == 0) {
+		/*
+		 * ECC can operate only on the device's pages.
+		 * Cannot be used for non-page-sized read/write
+		 */
+		ath_reg_wr(ATH_NF_ECC_OFFSET, sc->ecc_offset);
+		ath_reg_wr(ATH_NF_ECC_CTRL, ATH_NF_ECC_CTRL_ERR_THRESH(4) |
+						ATH_NF_ECC_CTRL_ECC_4_BITS);
+		ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_ECC_EN);
+		ath_reg_wr(ATH_NF_SPARE_SIZE, sc->mtd->oobsize);
+	} else
+#endif
+	{
+		ath_reg_wr(ATH_NF_ECC_OFFSET, 0);
+		ath_reg_wr(ATH_NF_ECC_CTRL, 0);
+		ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_CUSTOM_SIZE_EN);
+		ath_reg_wr(ATH_NF_PG_SIZE, count);
+	}
+
+	if (rd) {	// Read Page
+		if (is_small_block_device(sc)) {
+			ath_reg_wr(ATH_NF_DMA_CTRL,
+						ATH_NF_DMA_CTRL_DMA_START |
+						ATH_NF_DMA_CTRL_DMA_DIR_READ |
+						ATH_NF_DMA_CTRL_DMA_BURST_3);
+			ath_reg_wr(ATH_NF_GENERIC_SEQ_CTRL,
+						ATH_NF_GENERIC_SEQ_CTRL_COL_ADDR |
+						ATH_NF_GENERIC_SEQ_CTRL_DATA_EN |
+						ATH_NF_GENERIC_SEQ_CTRL_DEL_EN(1) |
+						ATH_NF_GENERIC_SEQ_CTRL_ADDR0_EN |
+						ATH_NF_GENERIC_SEQ_CTRL_CMD0_EN);
+			ath_reg_wr(ATH_NF_COMMAND,
+						ATH_NF_COMMAND_CMD_SEQ_18 |
+						ATH_NF_COMMAND_INPUT_SEL_DMA |
+						ATH_NF_COMMAND_CMD_0(0));
+		} else {
+			ath_reg_wr(ATH_NF_DMA_CTRL,
+						ATH_NF_DMA_CTRL_DMA_START |
+						ATH_NF_DMA_CTRL_DMA_DIR_READ |
+						ATH_NF_DMA_CTRL_DMA_BURST_3);
+			ath_reg_wr(ATH_NF_COMMAND, 0x30006a);
+		}
+	} else {	// Write Page
+		ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);	// Remove write protect
+		ath_reg_wr(ATH_NF_DMA_CTRL,
+					ATH_NF_DMA_CTRL_DMA_START |
+					ATH_NF_DMA_CTRL_DMA_DIR_WRITE |
+					ATH_NF_DMA_CTRL_DMA_BURST_3);
+		ath_reg_wr(ATH_NF_COMMAND, 0x10804c);
+	}
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	//printk(KERN_DEBUG "%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+	//	rd ? 'r' : 'w', addr0, addr1, count, buf);
+
+	rddata = (tmp = ath_nand_status(sc, &ecc)) & ATH_NF_RD_STATUS_MASK;
+	if ((rddata != ATH_NF_STATUS_OK) && (i < ATH_MAX_RETRY)) {
+		i++;
+		goto retry;
+	}
+
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0x0000);	// Enable write protect
+	ath_reg_wr(ATH_NF_FIFO_INIT, 1);
+	ath_reg_wr(ATH_NF_FIFO_INIT, 0);
+
+	if (rddata != ATH_NF_STATUS_OK) {
+		printk("%s: %s Failed. tmp = 0x%x, status = 0x%x 0x%x retries = %d\n", __func__,
+			err[rd], tmp, rddata, ath_reg_rd(ATH_NF_DMA_CTRL), i);
+	}
+#if ATH_NF_HW_ECC
+	else {
+#define DDR_WB_FLUSH_USB_ADDRESS		0x180000a4
+
+		ath_reg_wr(DDR_WB_FLUSH_USB_ADDRESS, 1);
+		while (ath_reg_rd(DDR_WB_FLUSH_USB_ADDRESS) & 1);
+		udelay(2);
+
+		if (ecc_needed && (ecc & ATH_NF_ECC_ERROR)) {
+			if (rd && all_0xff == 0) {
+				if (ath_check_all_0xff(sc, addr0, addr1, &all_0xff)) {
+					return ATH_NF_STATUS_OK;
+				}
+			}
+
+			if (mlc_retry < ATH_MLC_RETRY) {
+				mlc_retry ++;
+				i = 0;
+				goto retry;
+			} else {
+				printk("%s: %s uncorrectable errors. ecc = 0x%x\n",
+					__func__, err[rd], ecc);
+				return -1;
+			}
+		}
+	}
+#endif
+	return rddata;
+}
+
+void
+ath_nand_dump_buf(loff_t addr, void *v, unsigned count)
+{
+	unsigned	*buf = v,
+			*end = buf + (count / sizeof(*buf));
+
+	iodbg("____ Dumping %d bytes at 0x%p 0x%lx_____\n", count, buf, (ulong)addr);
+
+	for (; buf && buf < end; buf += 4, addr += 16) {
+		printk("%08lx: %08x %08x %08x %08x\n",
+			(unsigned)addr, buf[0], buf[1], buf[2], buf[3]);
+	}
+	iodbg("___________________________________\n");
+	//while(1);
+}
+
+static int
+ath_nand_rw_buff(struct mtd_info *mtd, int rd, uint8_t *buf,
+		loff_t addr, size_t len, size_t *iodone)
+{
+	unsigned	iolen, ret = ATH_NF_STATUS_OK, ecc_needed;
+	unsigned char	*pa;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	*iodone = 0;
+
+	while (len) {
+		uint32_t c, ba0, ba1;
+
+		if (ath_nand_block_isbad(mtd, addr)) {
+			printk("Skipping bad block[0x%x]\n", (unsigned)addr);
+			addr += mtd->erasesize;
+			continue;
+		}
+
+		c = (addr & mtd->writesize_mask);
+
+		ath_nand_conv_addr(mtd, addr, &ba0, &ba1, 0);
+
+		if (c) {
+			iolen = mtd->writesize - c;
+		} else {
+			iolen = mtd->writesize;
+		}
+
+		if (len < iolen) {
+			iolen = len;
+		}
+
+		if (rd) {
+			ecc_needed = (ath_nand_get_blk_state(mtd, addr) != ATH_NAND_BLK_ERASED);
+		} else {
+			int i;
+
+			for (i = 0; (i < mtd->writesize) && (buf[i] == 0xff); i++);
+			if (i == mtd->writesize) {
+				ret = ATH_NF_STATUS_OK;
+				//printk("Skipping write for 0x%x\n", (ulong)addr);
+				goto skip_write_for_all_0xff;
+			}
+
+			/* FIXME for writes FIXME */
+			memcpy(ath_nand_io_buf, buf, iolen);
+			ecc_needed = 1;
+		}
+
+		pa = (void *)virt_to_phys(ath_nand_io_buf);
+
+		flush_cache((unsigned)ath_nand_io_buf, mtd->writesize);
+
+		//printk("%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+		//	rd ? 'r' : 'w', ba0, ba1, iolen, pa);
+
+		ret = ath_nand_rw_page(sc, rd, ba0, ba1, mtd->writesize, pa, ecc_needed);
+
+		flush_cache((unsigned)ath_nand_io_buf, mtd->writesize);
+
+		if (rd) {
+			memcpy(buf, ath_nand_io_buf + c, iolen);
+		}
+skip_write_for_all_0xff:
+		//ath_nand_dump_buf(addr, buf, iolen);
+
+		if (ret != ATH_NF_STATUS_OK) {
+			return 1;
+		}
+
+		len -= iolen;
+		buf += iolen;
+		addr += iolen;
+		*iodone += iolen;
+	}
+
+	return 0;
+}
+
+#define ath_nand_write_verify	0
+
+#if ath_nand_write_verify
+uint8_t	ath_nand_rd_buf[4096 + 256] __attribute__((aligned(4096)));
+#endif
+
+static int
+ath_nand_write(struct mtd_info *mtd, loff_t to, size_t len,
+		size_t *retlen, const u_char *buf)
+{
+	int	ret;
+#if ath_nand_write_verify
+	int	r, rl;
+#endif
+
+	if (!len || !retlen) return (0);
+
+	indbg("0x%llx	%u", to, len);
+
+	ret = ath_nand_rw_buff(mtd, 0 /* write */, (u_char *)buf, to, len, retlen);
+#if ath_nand_write_verify
+	//printk("Verifying 0x%llx 0x%x\n", to, len);
+	r = ath_nand_rw_buff(mtd, 1 /* read */, ath_nand_rd_buf, to, len, &rl);
+	if (r || memcmp(ath_nand_rd_buf, buf, len)) {
+		printk("write failed at 0x%llx 0x%x\n", to, len);
+		while (1);
+	}
+#endif
+	return ret;
+}
+
+static int
+ath_nand_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	int	ret;
+
+	if (!len || !retlen) return (0);
+
+	ret = ath_nand_rw_buff(mtd, 1 /* read */, buf, from, len, retlen);
+
+	return ret;
+}
+
+static inline int
+ath_nand_block_erase(ath_nand_sc_t *sc, unsigned addr0, unsigned addr1)
+{
+	unsigned	rddata;
+
+	indbg("0x%x 0x%x", addr1, addr0);
+
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);	// Remove write protect
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_COMMAND, 0xd0600e);	// BLOCK ERASE
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	rddata = ath_nand_status(sc, NULL) & ATH_NF_RD_STATUS_MASK;
+
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0x0000);	// Enable write protect
+
+	if (rddata != ATH_NF_STATUS_OK) {
+		printk("Erase Failed. status = 0x%x\n", rddata);
+		return 1;
+	}
+	return 0;
+}
+
+
+static int
+ath_nand_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	ulong		s_first, i;
+	unsigned	n, j;
+	int		ret, bad = 0;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	if (instr->addr + instr->len > mtd->size) {
+		return (-EINVAL);
+	}
+
+	s_first = instr->addr;
+	n = instr->len >> mtd->erasesize_shift;
+
+	if (instr->len & mtd->erasesize_mask) n ++;
+
+	indbg("0x%llx 0x%x 0x%x", instr->addr, n, mtd->erasesize);
+
+	printk("%s: 0x%x %u\n", __func__, s_first, n);
+
+	for (j = 0, i = s_first; j < n; j++, i += mtd->erasesize) {
+		uint32_t ba0, ba1;
+
+		if (ath_nand_block_isbad(mtd, i)) {
+			bad ++;
+			continue;
+		}
+
+		ath_nand_conv_addr(mtd, i, &ba0, &ba1, 1);
+
+		printk("\b\b\b\b%4d", j);
+
+		if ((ret = ath_nand_block_erase(sc, ba0, ba1)) != 0) {
+			printf("%s: erase failed 0x%x 0x%x 0x%x %x "
+				"%lx %lx\n", __func__, instr->addr, n,
+				mtd->erasesize, i, ba1, ba0);
+			break;
+		}
+		ath_nand_set_blk_state(mtd, i, ATH_NAND_BLK_ERASED);
+	}
+
+	if (instr->callback) {
+		if (j < n) {
+			instr->state = MTD_ERASE_FAILED;
+		} else {
+			instr->state = MTD_ERASE_DONE;
+		}
+		mtd_erase_callback(instr);
+	}
+
+	printk("Skipped %d bad blocks\n", bad);
+
+	return ret;
+}
+
+/* lifted from linux */
+typedef enum {
+	MTD_OOB_PLACE,
+	MTD_OOB_AUTO,
+	MTD_OOB_RAW,
+} mtd_oob_mode_t;
+
+struct mtd_oob_ops {
+	mtd_oob_mode_t  mode;
+	size_t          len;
+	size_t          retlen;
+	size_t          ooblen;
+	size_t          oobretlen;
+	uint32_t        ooboffs;
+	uint8_t         *datbuf;
+	uint8_t         *oobbuf;
+};
+
+static int
+ath_nand_rw_oob(struct mtd_info *mtd, int rd, loff_t addr,
+		struct mtd_oob_ops *ops)
+{
+	unsigned	ret = ATH_NF_STATUS_OK;
+	unsigned char	*pa;
+	uint32_t	ba0, ba1;
+	uint8_t		*oob = ath_nand_io_buf + mtd->writesize;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	ath_nand_conv_addr(mtd, addr, &ba0, &ba1, 0);
+
+	if (!rd) {
+		if (ops->datbuf) {
+			/*
+			 * XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX
+			 * We assume that the caller gives us a full
+			 * page to write. We don't read the page and
+			 * update the changed portions alone.
+			 *
+			 * Hence, not checking for len < or > pgsz etc...
+			 * XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX
+			 */
+			memcpy(ath_nand_io_buf, ops->datbuf, ops->len);
+		}
+		if (ops->mode == MTD_OOB_PLACE) {
+			oob += ops->ooboffs;
+		} else if (ops->mode == MTD_OOB_AUTO) {
+			// clean markers
+			oob[0] = oob[1] = 0xff;
+			oob += 2;
+		}
+		memcpy(oob, ops->oobbuf, ops->ooblen);
+	}
+
+	pa = (void *)virt_to_phys(ath_nand_io_buf);
+	if (!rd) flush_cache(ath_nand_io_buf, mtd->writesize + mtd->oobsize);	// for writes...
+
+	//printk("%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+	//	rd ? 'r' : 'w', ba0, ba1, mtd->writesize + mtd->oobsize, pa);
+
+	ret = ath_nand_rw_page(sc, rd, ba0, ba1, mtd->writesize + mtd->oobsize, pa, 0);
+
+	if (ret != ATH_NF_STATUS_OK) {
+		return 1;
+	}
+
+	if (rd) {
+		memcpy(ath_nand_io_buf, KSEG1ADDR(pa), mtd->writesize + mtd->oobsize);	// for reads...
+
+		if (ops->datbuf) {
+			memcpy(ops->datbuf, ath_nand_io_buf, ops->len);
+		}
+		if (ops->mode == MTD_OOB_PLACE) {
+			oob += ops->ooboffs;
+		} else if (ops->mode == MTD_OOB_AUTO) {
+			// copy after clean marker
+			oob += 2;
+		}
+		memcpy(ops->oobbuf, oob, ops->ooblen);
+	}
+
+	//if (rd) {
+	//	ath_nand_dump_buf(addr, ops->datbuf, ops->len);
+	//	ath_nand_dump_buf(addr, ops->oobbuf, ops->ooblen);
+	//}
+
+	if (ops->datbuf) {
+		ops->retlen = ops->len;
+	}
+	ops->oobretlen = ops->ooblen;
+
+	return 0;
+}
+
+//static int
+//ath_nand_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
+int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen)
+{
+	struct mtd_oob_ops ops = { MTD_OOB_RAW, len, 0, ooblen, 0,
+					0, buf, buf + mtd->writesize };
+
+	oobdbg(	"%s: from: 0x%lx mode: 0x%x len: 0x%x retlen: 0x%x\n"
+		"ooblen: 0x%x oobretlen: 0x%x ooboffs: 0x%x datbuf: %p "
+		"oobbuf: %p\n", __func__, (uint32_t)from,
+		ops.mode, ops.len, ops.retlen, ops.ooblen,
+		ops.oobretlen, ops.ooboffs, ops.datbuf,
+		ops.oobbuf);
+
+	oobdbg("0x%lx %p %p %u\n", (uint32_t)from, ops.oobbuf, ops.datbuf, ops.len);
+
+	if (len == 0) {
+		ops.datbuf = 0;
+		ops.oobbuf = buf;
+	}
+	if (ooblen == 0) {
+		ops.oobbuf = NULL;
+	}
+
+	return ath_nand_rw_oob(mtd, 1 /* read */, from, &ops);
+}
+
+#if 0
+static int
+ath_nand_write_oob(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops)
+{
+	int ret;
+	unsigned char oob[128];
+	struct mtd_oob_ops	rops = {
+		.mode	= MTD_OOB_RAW,
+		.ooblen	= mtd->oobsize,
+		.oobbuf	= oob,
+	};
+
+	if (ops->mode == MTD_OOB_AUTO) {
+		/* read existing oob */
+		if (ath_nand_read_oob(mtd, to, &rops) ||
+			rops.oobretlen != rops.ooblen) {
+			printk("%s: oob read failed at 0x%llx\n", __func__, to);
+			return 1;
+		}
+		memcpy(oob + 2, ops->oobbuf, ops->ooblen);
+		rops = *ops;
+		ops->oobbuf = oob;
+		ops->ooblen = mtd->oobsize;
+		ops->mode = MTD_OOB_RAW;
+	}
+
+	oobdbg(	"%s: from: 0x%llx mode: 0x%x len: 0x%x retlen: 0x%x\n"
+		"ooblen: 0x%x oobretlen: 0x%x ooboffs: 0x%x datbuf: %p "
+		"oobbuf: %p\n", __func__, to,
+		ops->mode, ops->len, ops->retlen, ops->ooblen,
+		ops->oobretlen, ops->ooboffs, ops->datbuf,
+		ops->oobbuf);
+
+	indbg("0x%llx", to);
+
+	ret = ath_nand_rw_oob(mtd, 0 /* write */, to, ops);
+
+	if (rops.mode == MTD_OOB_AUTO) {
+		if (ret == 0) { // rw oob success
+			rops.oobretlen = rops.ooblen;
+			rops.retlen = rops.len;
+		}
+		*ops = rops;
+	}
+
+	return ret;
+}
+#endif
+
+static int
+ath_nand_block_isbad(struct mtd_info *mtd, loff_t ofs)
+{
+	unsigned char		oob[256];
+	unsigned		bs, i;
+	unsigned		*force = (unsigned *)0xbd000000;
+
+	if (*force == 0x12345678) {
+		return 0;
+	}
+
+	bs = ath_nand_get_blk_state(mtd, ofs);
+
+	if ((bs == ATH_NAND_BLK_ERASED) || (bs == ATH_NAND_BLK_GOOD)) {
+		return 0;
+	}
+
+	if (bs == ATH_NAND_BLK_BAD) {
+		return 1;
+	}
+
+	/*
+	 * H27U1G8F2B Series [1 Gbit (128 M x 8 bit) NAND Flash]
+	 *
+	 * The Bad Block Information is written prior to shipping. Any
+	 * block where the 1st Byte in the spare area of the 1st or
+	 * 2nd th page (if the 1st page is Bad) does not contain FFh
+	 * is a Bad Block. The Bad Block Information must be read
+	 * before any erase is attempted as the Bad Block Information
+	 * may be erased. For the system to be able to recognize the
+	 * Bad Blocks based on the original information it is
+	 * recommended to create a Bad Block table following the
+	 * flowchart shown in Figure 24. The 1st block, which is
+	 *                               ^^^^^^^^^^^^^
+	 * placed on 00h block address is guaranteed to be a valid
+	 * block.                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
+	 */
+
+	for (i = 0; i < 2; i++, ofs += mtd->writesize) {
+		if (nand_read_raw(mtd, oob, ofs, 0, mtd->oobsize)) {
+			printk("%s: oob read failed at 0x%lx\n", __func__, (unsigned)ofs);
+			ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_DONT_KNOW);
+			return 1;
+		}
+
+		/* First two bytes of oob data are clean markers */
+		if (oob[0] != 0xff || oob[1] != 0xff) {
+			oobdbg("%s: block is bad at 0x%lx\n", __func__, (unsigned)ofs);
+			oobdbg(	"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				0xff & oob[ 0], 0xff & oob[ 1], 0xff & oob[ 2],
+				0xff & oob[ 3], 0xff & oob[ 4], 0xff & oob[ 5],
+				0xff & oob[ 6], 0xff & oob[ 7], 0xff & oob[ 8],
+				0xff & oob[ 9], 0xff & oob[10], 0xff & oob[11],
+				0xff & oob[12], 0xff & oob[13], 0xff & oob[14],
+				0xff & oob[15], 0xff & oob[16], 0xff & oob[17],
+				0xff & oob[18], 0xff & oob[19], 0xff & oob[20],
+				0xff & oob[21], 0xff & oob[22], 0xff & oob[23],
+				0xff & oob[24], 0xff & oob[25], 0xff & oob[26],
+				0xff & oob[27], 0xff & oob[28], 0xff & oob[29],
+				0xff & oob[30], 0xff & oob[31], 0xff & oob[32],
+				0xff & oob[33], 0xff & oob[34], 0xff & oob[35],
+				0xff & oob[36], 0xff & oob[37], 0xff & oob[38],
+				0xff & oob[39], 0xff & oob[40], 0xff & oob[41],
+				0xff & oob[42], 0xff & oob[43], 0xff & oob[44],
+				0xff & oob[45], 0xff & oob[46], 0xff & oob[47],
+				0xff & oob[48], 0xff & oob[49], 0xff & oob[50],
+				0xff & oob[51], 0xff & oob[52], 0xff & oob[53],
+				0xff & oob[54], 0xff & oob[55], 0xff & oob[56],
+				0xff & oob[57], 0xff & oob[58], 0xff & oob[59],
+				0xff & oob[60], 0xff & oob[61], 0xff & oob[62],
+				0xff & oob[63]);
+			ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_BAD);
+			return 1;
+		}
+	}
+
+	for (i = 0; (i < mtd->oobsize) && (oob[i] == 0xff); i++);
+
+	if (i == mtd->oobsize) {
+		ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_ERASED);
+	} else {
+		ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_GOOD);
+	}
+
+	return 0;
+}
+
+static int
+ath_nand_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	indbg("unimplemented 0x%llx", ofs);
+	return 0;
+}
+
+static unsigned long
+ath_parse_read_id(ath_nand_sc_t *sc)
+{
+	int	i;
+
+	extern struct nand_manufacturers nand_manuf_ids[];
+	extern struct nand_flash_dev nand_flash_ids[];
+
+	iodbg(	"____ %s _____\n"
+		"  vid did wc  ilp nsp ct  dp  sa1 org bs  sa0 ss  "
+		"ps  res1 pls pn  res2\n"
+		"0x%3x %3x %3x %3x %3x %3x %3x %3x %3x %3x %3x %3x "
+		"%3x %3x  %3x %3x %3x\n-------------\n", __func__,
+			sc->nid.vid, sc->nid.did, sc->nid.wc, sc->nid.ilp,
+			sc->nid.nsp, sc->nid.ct, sc->nid.dp, sc->nid.sa1,
+			sc->nid.org, sc->nid.bs, sc->nid.sa0, sc->nid.ss,
+			sc->nid.ps, sc->nid.res1, sc->nid.pls, sc->nid.pn,
+			sc->nid.res2);
+
+	for (i = 0; i < nand_manuf_ids[i].id; i++) {
+		if (nand_manuf_ids[i].id == sc->nid.vid) {
+			printk(nand_manuf_ids[i].name);
+			break;
+		}
+	}
+
+	for (i = 0; i < nand_flash_ids[i].id; i++) {
+		if (nand_flash_ids[i].id == sc->nid.did) {
+			printk(" %s [%uMB]\n", nand_flash_ids[i].name,
+				nand_flash_ids[i].chipsize);
+			return nand_flash_ids[i].chipsize;
+		}
+	}
+
+	return 0;
+}
+
+ath_nand_vend_data_t *
+nand_get_entry(ath_nand_id_t *nand_id, ath_nand_vend_data_t *tbl, int count)
+{
+	int     i;
+
+	for (i = 0; i < count; i++, tbl ++) {
+		if ((nand_id->__details.vid == tbl->vid) &&
+		    (nand_id->__details.did == tbl->did) &&
+		    (nand_id->byte_id[1] == tbl->b3)) {
+			return tbl;
+		}
+	}
+
+	return NULL;
+}
+
+static inline void
+ath_nand_onfi_endian_convert(uint8_t *buf)
+{
+	uint32_t	i, *u = (uint32_t *)(buf + ONFI_DEV_DESC);
+
+	for (i = 0; i < (ONFI_DEV_DESC_SZ / sizeof(*u)); i++) {
+		u[i] = __le32_to_cpu(u[i]);
+	}
+
+	// Hope nobody has a 20 character device description
+	buf[ONFI_DEV_DESC + ONFI_DEV_DESC_SZ - 1] = 0;
+}
+
+int
+nand_param_page(ath_nand_sc_t *sc, uint8_t *buf, unsigned count)
+{
+	unsigned int	tries, rddata;
+	uint8_t		*pa;
+
+	pa = virt_to_phys(buf);
+
+	for (tries = 3; tries; tries --) {
+		// ADDR0_0 Reg Settings
+		ath_reg_wr(ATH_NF_ADDR0_0, 0x0);
+
+		// ADDR0_1 Reg Settings
+		ath_reg_wr(ATH_NF_ADDR0_1, 0x0);
+
+		// DMA Start Addr
+		ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+
+		// DMA count
+		ath_reg_wr(ATH_NF_DMA_COUNT, count);
+
+		// Custom Page Size
+		ath_reg_wr(ATH_NF_PG_SIZE, count);
+
+		// DMA Control Reg
+		ath_reg_wr(ATH_NF_DMA_CTRL, 0xcc);
+
+		ath_nand_clear_int_status();
+		// READ PARAMETER PAGE
+		ath_reg_wr(ATH_NF_COMMAND, 0xec62);
+		while (ath_nand_get_cmd_end_status() == 0);
+
+		rddata = ath_nand_status(sc, NULL) & READ_PARAM_STATUS_MASK;
+		if (rddata == READ_PARAM_STATUS_OK) {
+			break;
+		} else {
+			printk("\nParam Page Failure: 0x%x", rddata);
+			ath_nand_hw_init(sc, NULL);
+		}
+	}
+
+	memcpy(buf, KSEG1ADDR(buf), count);	// get into the cache
+
+	//ath_nand_dump_buf(buf, buf, count);
+
+	if ((rddata == READ_PARAM_STATUS_OK) &&
+	    (buf[3] == 'O' && buf[2] == 'N' && buf[1] == 'F' && buf[0] == 'I')) {
+		ath_nand_onfi_endian_convert(buf);
+		printf("ONFI %s\n", buf + ONFI_DEV_DESC);
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * System initialization functions
+ */
+static int
+ath_nand_hw_init(ath_nand_sc_t *sc, void *p)
+{
+	uint8_t		id[8];
+	unsigned char	*pa;
+	unsigned	rddata, i;
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_NANDF_RESET_MASK);
+	udelay(250);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_NANDF_RESET_MASK);
+	udelay(100);
+
+	ath_reg_wr(ATH_NF_INT_MASK, ATH_NF_CMD_END_INT);
+	ath_nand_clear_int_status();
+
+	// TIMINGS_ASYN Reg Settings
+	ath_reg_wr(ATH_NF_TIMINGS_ASYN, ATH_NF_TIMING_ASYN);
+
+	// NAND Mem Control Reg
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);
+
+	// Reset Command
+	ath_reg_wr(ATH_NF_COMMAND, 0xff00);
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	udelay(1000);
+
+	rddata = ath_reg_rd(ATH_NF_STATUS);
+	for (i = 0; i < ATH_NF_STATUS_RETRY && rddata != 0xff; i++) {
+		udelay(25);
+		rddata = ath_reg_rd(ATH_NF_STATUS);
+	}
+
+	if (i == ATH_NF_STATUS_RETRY) {
+		printf("device reset failed\n");
+		while(1);
+	}
+
+	if (p) {
+		ath_nand_vend_data_t *entry;
+
+		ath_nand_clear_int_status();
+		pa = (void *)virt_to_phys(p ? p : id);
+		ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+		ath_reg_wr(ATH_NF_ADDR0_0, 0x0);
+		ath_reg_wr(ATH_NF_ADDR0_1, 0x0);
+		ath_reg_wr(ATH_NF_DMA_COUNT, 0x8);
+		ath_reg_wr(ATH_NF_PG_SIZE, 0x8);
+		ath_reg_wr(ATH_NF_DMA_CTRL, 0xcc);
+		ath_reg_wr(ATH_NF_COMMAND, 0x9061);	// READ ID
+		while (ath_nand_get_cmd_end_status() == 0);
+
+		rddata = ath_nand_status(sc, NULL);
+		if ((rddata & ATH_NF_RD_STATUS_MASK) != ATH_NF_STATUS_OK) {
+			printf("%s: ath nand status = 0x%x\n", __func__, rddata);
+		}
+
+		pa = p;
+		printk("Ath Nand ID[%p]: %02x:%02x:%02x:%02x:%02x\n",
+				pa, pa[3], pa[2], pa[1], pa[0], pa[7]);
+
+		sc->onfi[0] = 0;
+
+		entry = nand_get_entry((ath_nand_id_t *)p, ath_nand_arr, NUM_ATH_NAND);
+		if (entry) {
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(entry->addrcyc);
+		} else if (nand_param_page(sc, sc->onfi, sizeof(sc->onfi)) == 0) {
+			rddata = sc->onfi[ONFI_NUM_ADDR_CYCLES];
+			rddata = ((rddata >> 4) & 0xf) + (rddata & 0xf);
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(rddata);
+		} else {
+			printk("Attempting to use unknown device\n");
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(5);
+		}
+
+		iodbg("******* %s done ******\n", __func__);
+	}
+
+	return 0;
+}
+
+/*
+ * Copied from drivers/mtd/nand/nand_base.c
+ * http://ptgmedia.pearsoncmg.com/images/chap17_9780132396554/elementLinks/17fig04.gif
+ *
+ * +---...---+--+----------+---------+
+ * |  2048   |  |          |         |
+ * | File    |cm| FS spare | ecc data|
+ * | data    |  |          |         |
+ * +---...---+--+----------+---------+
+ * cm -> clean marker (2 bytes)
+ * FS Spare -> bytes available for jffs2
+ */
+
+static void
+ath_nand_ecc_init(struct mtd_info *mtd)
+{
+#if ATH_NF_HW_ECC
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (is_small_block_device(sc)) {
+		// ECC cannot be supported...
+		sc->ecc_offset = 0;
+	} else {
+		sc->ecc_offset = mtd->writesize + ATH_NAND_JFFS2_ECC_OFF +
+						ATH_NAND_JFFS2_ECC_LEN;
+	}
+#else
+	sc->ecc_offset = 0;
+#endif
+}
+
+void
+ath_nand_set_ns(struct mtd_info *mtd)
+{
+#define ATH_DEF_PAGE_SIZE	(2u << 10)
+#define ATH_DEF_BLK_SIZE	(128u << 10)
+#define ATH_NAND_SPEC		"ns"
+
+	char ns[64], *p;
+
+	if ((p = getenv(ATH_NAND_SPEC))) {
+		/* don't override user setting */
+		return;
+	}
+
+	if (mtd->writesize == ATH_DEF_PAGE_SIZE &&
+	    mtd->erasesize == ATH_DEF_BLK_SIZE) {
+		return;
+	}
+
+	sprintf(ns, "-0x%x-0x%x", mtd->erasesize, mtd->writesize);
+	setenv(ATH_NAND_SPEC, ns);
+	printf("set " ATH_NAND_SPEC " %s\n", ns);
+}
+
+/*
+ * ath_nand_probe
+ *
+ * called by device layer when it finds a device matching
+ * one our driver can handled. This code checks to see if
+ * it can allocate all necessary resources then calls the
+ * nand layer to look for devices
+ */
+static ulong ath_nand_probe(void)
+{
+	ath_nand_sc_t	*sc = NULL;
+	struct mtd_info	*mtd = NULL;
+	int		i, err = 0, bbt_size;
+	unsigned	nf_ctrl_pg[][2] = {
+		/* page size in bytes, register val */
+		{   256, ATH_NF_CTRL_PAGE_SIZE_256	},
+		{   512, ATH_NF_CTRL_PAGE_SIZE_512	},
+		{  1024, ATH_NF_CTRL_PAGE_SIZE_1024	},
+		{  2048, ATH_NF_CTRL_PAGE_SIZE_2048	},
+		{  4096, ATH_NF_CTRL_PAGE_SIZE_4096	},
+		{  8192, ATH_NF_CTRL_PAGE_SIZE_8192	},
+		{ 16384, ATH_NF_CTRL_PAGE_SIZE_16384	},
+		{     0, ATH_NF_CTRL_PAGE_SIZE_0	},
+		};
+	unsigned	nf_ctrl_blk[][2] = {
+		/* no. of pages, register val */
+		{  32, ATH_NF_CTRL_BLOCK_SIZE_32	},
+		{  64, ATH_NF_CTRL_BLOCK_SIZE_64	},
+		{ 128, ATH_NF_CTRL_BLOCK_SIZE_128	},
+		{ 256, ATH_NF_CTRL_BLOCK_SIZE_256	},
+		{   0, 0				},
+		};
+
+	sc = &ath_nand_sc;
+	sc->mtd = &nand_info[nand_curr_device];
+
+	/* initialise the hardware */
+	err = ath_nand_hw_init(sc, &sc->nid);
+	if (err) {
+		goto out_err_hw_init;
+	}
+
+	/* initialise mtd sc data struct */
+	mtd = sc->mtd;
+	mtd->size = ath_parse_read_id(sc) << 20;
+
+	mtd->name		= DRV_NAME;
+	if (mtd->size == 0) {
+		mtd->size	= ath_plane_size[sc->nid.pls] << sc->nid.pn;
+	}
+
+	if (is_small_block_device(sc)) {
+		mtd->writesize		= sc->entry->pgsz;
+		mtd->writesize_shift	= ffs(mtd->writesize) - 1;
+		mtd->writesize_mask	= mtd->writesize - 1;
+
+		mtd->erasesize		= sc->entry->blk;
+		mtd->erasesize_shift	= ffs(mtd->erasesize) - 1;
+		mtd->erasesize_mask	= mtd->erasesize - 1;
+
+		mtd->oobsize		= sc->entry->spare;
+		mtd->oobavail		= mtd->oobsize;
+	} else if (!sc->onfi[0]) {
+		mtd->writesize_shift	= 10 + sc->nid.ps;
+		mtd->writesize		= (1 << mtd->writesize_shift);
+		mtd->writesize_mask	= (mtd->writesize - 1);
+
+		mtd->erasesize_shift	= 16 + sc->nid.bs;
+		mtd->erasesize		= (1 << mtd->erasesize_shift);
+		mtd->erasesize_mask	= (mtd->erasesize - 1);
+
+		mtd->oobsize		= (mtd->writesize / 512) * (8 << sc->nid.ss);
+		mtd->oobavail		= mtd->oobsize;
+	} else {
+		mtd->writesize		= *(uint32_t *)(&sc->onfi[ONFI_PAGE_SIZE]);
+		mtd->writesize_shift	= ffs(mtd->writesize) - 1;
+		mtd->writesize_mask	= (mtd->writesize - 1);
+
+		mtd->erasesize		= *(uint32_t *)(&sc->onfi[ONFI_PAGES_PER_BLOCK]) *
+					  mtd->writesize;
+		mtd->erasesize_shift	= ffs(mtd->erasesize) - 1;
+		mtd->erasesize_mask	= (mtd->erasesize - 1);
+
+		mtd->oobsize		= *(uint16_t *)(&sc->onfi[ONFI_SPARE_SIZE]);
+		mtd->oobavail		= mtd->oobsize;
+
+		mtd->size		= mtd->erasesize *
+					  (*(uint32_t *)(&sc->onfi[ONFI_BLOCKS_PER_LUN])) *
+					  sc->onfi[ONFI_NUM_LUNS];
+	}
+
+	for (i = 0; nf_ctrl_pg[i][0]; i++) {
+		if (nf_ctrl_pg[i][0] == mtd->writesize) {
+			sc->nf_ctrl |= nf_ctrl_pg[i][1];
+			break;
+		}
+	}
+
+	for (i = 0; nf_ctrl_blk[i][0]; i++) {
+		if (nf_ctrl_blk[i][0] == (mtd->erasesize / mtd->writesize)) {
+			sc->nf_ctrl |= nf_ctrl_blk[i][1];
+			break;
+		}
+	}
+
+	ath_nand_set_ns(mtd);
+
+	mtd->type		= MTD_NANDFLASH;
+	mtd->flags		= MTD_CAP_NANDFLASH;
+
+	mtd->read		= ath_nand_read;
+	mtd->write		= ath_nand_write;
+	mtd->erase		= ath_nand_erase;
+
+	//mtd->read_oob		= ath_nand_read_oob;
+	//mtd->write_oob		= ath_nand_write_oob;
+
+	mtd->block_isbad	= ath_nand_block_isbad;
+	mtd->block_markbad	= ath_nand_block_markbad;
+
+	mtd->priv		= sc;
+
+	ath_nand_ecc_init(mtd);
+
+	// bbt has 2 bits per block
+	bbt_size = ((mtd->size >> mtd->erasesize_shift) * 2) / 8;
+	sc->bbt = malloc(bbt_size);
+
+	if (sc->bbt) {
+		memset(sc->bbt, 0, bbt_size);
+	}
+
+	printf(	"====== NAND Parameters ======\n"
+		"sc = 0x%p bbt = 0x%p bbt_size = 0x%x nf_ctrl = 0x%x\n"
+		"page = 0x%x block = 0x%x oob = 0x%x\nsize = %uMB\n", sc, sc->bbt, bbt_size,
+		sc->nf_ctrl, mtd->writesize, mtd->erasesize, mtd->oobsize, mtd->size >> 20);
+
+	return mtd->size;
+
+out_err_hw_init:
+	return 0;
+}
+
+#if 0
+static struct platform_driver ath_nand_driver = {
+	//.probe		= ath_nand_probe,
+	.remove		= __exit_p(ath_nand_remove),
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+#endif
+
+ulong ath_nand_init(void)
+{
+	printk(DRV_DESC ", Version " DRV_VERSION
+		" (c) 2010 Atheros Communications, Ltd.\n");
+
+	//return platform_driver_register(&ath_nand_driver);
+	//return platform_driver_probe(&ath_nand_driver, ath_nand_probe);
+	return ath_nand_probe();
+}
diff --git a/board/atheros/common/ath_pci.c b/board/atheros/common/ath_pci.c
new file mode 100644
index 0000000000..51757e6f4d
--- /dev/null
+++ b/board/atheros/common/ath_pci.c
@@ -0,0 +1,421 @@
+/*****************************************************************************/
+/*! file ath_pci.c
+** /brief PCI support for Atheros boards
+**
+** This provides the support code required for PCI support on the AP91/93
+** board in the U-Boot environment. This board is a Python based system
+** with a Merlin WLAN interface. This file also contains the support
+** for initialization of the Merlin radios on the PCi bus, required for
+** pre-configuration for use by Linux.
+**
+** Copyright (c) 2008 Atheros Communications Inc. All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <pci.h>
+#include <atheros.h>
+
+/*
+** PCI controller "hose" value
+*/
+
+static struct pci_controller hose;
+
+static int ath_local_read_config(int where, int size, uint32_t *value);
+static int ath_local_write_config(int where, int size, uint32_t value);
+
+static int
+ath_local_read_config(int where, int size, uint32_t *value)
+{
+	*value = ath_reg_rd(ATH_PCI_CRP + where);
+	return 0;
+}
+
+static int
+ath_local_write_config(int where, int size, uint32_t value)
+{
+	ath_reg_wr((ATH_PCI_CRP + where),value);
+	return 0;
+}
+
+static int
+ath_pci_read_config(struct pci_controller *hose,
+			pci_dev_t dev, int where, uint32_t *value)
+{
+	*value = ath_reg_rd(ATH_PCI_DEV_CFGBASE + where);
+	return 0;
+}
+
+static int
+ath_pci_write_config(struct pci_controller *hose,
+			pci_dev_t dev, int where, uint32_t value)
+{
+	ath_reg_wr((ATH_PCI_DEV_CFGBASE + where), value);
+	return 0;
+}
+
+#ifdef PCIE2_APP_ADDRESS
+static int
+ath_local_read_config_rc2(int where, int size, uint32_t *value)
+{
+	*value = ath_reg_rd(0x18250000 + where);
+	return 0;
+}
+
+static int
+ath_local_write_config_rc2(int where, int size, uint32_t value)
+{
+	ath_reg_wr((0x18250000 + where),value);
+	return 0;
+}
+
+static int
+ath_pci_read_config_rc2(struct pci_controller *hose,
+			pci_dev_t dev, int where, uint32_t *value)
+{
+	*value = ath_reg_rd(0xb6000000 + where);
+	return 0;
+}
+
+static int
+ath_pci_write_config_rc2(struct pci_controller *hose,
+			pci_dev_t dev, int where, uint32_t value)
+{
+	ath_reg_wr((0xb6000000 + where), value);
+	return 0;
+}
+#endif
+
+/*
+** We will use the ART configuration information stored in flash to initialize
+** these devices as required.
+*/
+
+void plat_dev_init(void)
+{
+	u32	val;
+	u32	addr;
+	u32	BaseAddr = 0x10000000;
+	u32	CalAddr = WLANCAL;
+	volatile u16 *calData;
+
+	/*
+	 * Copy the device ID from Flash to device config space.
+	 */
+
+	calData = (u16 *)CalAddr;
+
+#ifndef CONFIG_PCI_CONFIG_DATA_IN_OTP
+	if (calData[0] != 0xa55a && calData[0] != 0x5aa5)
+	{
+#ifndef COMPRESSED_UBOOT
+		prmsg("BOARD IS NOT CALIBRATED!!!\n");
+#endif
+		return;
+	}
+#else
+	return;
+#endif
+	/*
+	** Need to setup the PCI device to access the internal registers
+	*/
+	if ((is_ar7241() || is_ar7242()))
+		ath_pci_write_config(&hose, NULL, 0x10, 0x1000ffff);
+	else
+		ath_pci_write_config(&hose, NULL, 0x10, 0xffff);
+
+	ath_pci_write_config(&hose, NULL, 0x04, 0x6);
+
+#ifdef PCIE2_APP_ADDRESS
+	ath_pci_write_config_rc2(&hose, NULL, 0x10, 0xffff);
+
+	ath_pci_write_config_rc2(&hose, NULL, 0x04, 0x6);
+#endif
+
+	/*
+	** Set pointer to first reg address
+	*/
+
+	calData += ATH_ART_PCICFG_OFFSET;
+
+	while(*calData != 0xffff)
+	{
+		u16 cd;
+
+		cd = *calData++;
+		addr = BaseAddr + cd;
+		val = *calData++;
+		val |= (*calData++) << 16;
+
+		ath_reg_wr_nf(addr,val);
+		udelay(100);
+	}
+
+	return;
+}
+
+
+/******************************************************************************/
+/*!
+** \brief pci host initialization
+**
+** Sets up the PCI controller on the host. For AR7240 this may not be necessary,
+** but this function is required for board support.
+**
+** We want a 1:1 mapping between PCI and DDR for inbound and outbound.
+** The PCI<---AHB decoding works as follows:
+**
+** 8 registers in the DDR unit provide software configurable 32 bit offsets
+** for each of the eight 16MB PCI windows in the 128MB. The offsets will be
+** added to any address in the 16MB segment before being sent to the PCI unit.
+**
+** Essentially for any AHB address generated by the CPU,
+** 1. the MSB four bits are stripped off, [31:28],
+** 2. Bit 27 is used to decide between the lower 128Mb (PCI) or the rest of
+**    the AHB space
+** 3. Bits 26:24 are used to access one of the 8 window registers and are
+**    masked off.
+** 4. If it is a PCI address, then the WINDOW offset in the WINDOW register
+**    corresponding to the next 3 bits (bit 26:24) is ADDED to the address,
+**    to generate the address to PCI unit.
+**
+**     eg. CPU address = 0x100000ff
+**         window 0 offset = 0x10000000
+**         This points to lowermost 16MB window in PCI space.
+**         So the resulting address would be 0x000000ff+0x10000000
+**         = 0x100000ff
+**
+**         eg2. CPU address = 0x120000ff
+**         WINDOW 2 offset = 0x12000000
+**         resulting address would be 0x000000ff+0x12000000
+**                         = 0x120000ff
+**
+** There is no translation for inbound access (PCI device as a master)
+**
+**  \return N/A
+*/
+
+#ifdef  COMPRESSED_UBOOT
+#	define PCI_INIT_RET_TYPE	int
+#	define PCI_INIT_RETURN		return 0
+#else
+#	define PCI_INIT_RET_TYPE	void
+#	define PCI_INIT_RETURN		return
+#endif
+
+PCI_INIT_RET_TYPE
+pci_init_board (void)
+{
+#ifdef CONFIG_ATH_EMULATION
+	prmsg("--- Skipping %s for emulation\n", __func__);
+#else
+	uint32_t cmd;
+
+	if (is_drqfn() && !is_qca953x()) {
+		/*
+		 * Dont enable PCIe in DRQFN package as it has some issues
+		 * related to PCIe
+		 */
+		PCI_INIT_RETURN;
+	}
+
+#if defined(CONFIG_MACH_QCA953x)
+	if (ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_TESTROM_ENABLE_MASK) { 
+	ath_reg_rmw_clear(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY_SET(1));
+
+		ath_reg_wr(PCIE_PHY_REG_1_ADDRESS, PCIE_PHY_REG_1_RESET_1); 
+		ath_reg_wr(PCIE_PHY_REG_3_ADDRESS, PCIE_PHY_REG_3_RESET_1); 
+
+	ath_reg_rmw_set(PCIE_PWR_MGMT_ADDRESS, PCIE_PWR_MGMT_ASSERT_CLKREQN_SET(1));
+
+	ath_reg_rmw_set(PCIE_PLL_CONFIG_ADDRESS, PCIE_PLL_CONFIG_PLLPWD_SET(1));
+
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_PCIE_RESET_SET(1));
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_PCIE_PHY_RESET_SET(1));
+
+		ath_reg_rmw_clear(RST_CLKGAT_EN_ADDRESS, RST_CLKGAT_EN_PCIE_RC_SET(1));
+
+	PCI_INIT_RETURN;
+	}
+#endif 
+
+	// common for rc1 and rc2
+	ath_reg_wr_nf(PCIE_PLL_DITHER_DIV_MAX_ADDRESS,
+		PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_SET(0x1) |
+		PCIE_PLL_DITHER_DIV_MAX_USE_MAX_SET(0x1) |
+		PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_SET(0x14) |
+		PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_SET(0x3ff));
+
+	ath_reg_wr_nf(PCIE_PLL_DITHER_DIV_MIN_ADDRESS,
+		PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_SET(0x14));
+
+	ath_reg_wr_nf(PCIE_PLL_CONFIG_ADDRESS,
+		PCIE_PLL_CONFIG_REFDIV_SET(1) |
+		PCIE_PLL_CONFIG_BYPASS_SET(1) |
+		PCIE_PLL_CONFIG_PLLPWD_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_clear(PCIE_PLL_CONFIG_ADDRESS, PCIE_PLL_CONFIG_PLLPWD_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(PCIE_PLL_CONFIG_ADDRESS, PCIE_PLL_CONFIG_BYPASS_SET(1));
+	udelay(1000);
+
+#ifdef PCIE2_APP_ADDRESS
+	if (!(ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_PCIE_RC_EP_SELECT_MASK)) {
+		pci_rc2_init_board();
+		return;
+	}
+#endif
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_PCIE_PHY_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_PCIE_RESET_SET(1));
+	udelay(10000);
+
+#ifdef PCIE2_APP_ADDRESS
+	ath_reg_rmw_clear(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY_SET(1));
+	udelay(10000);
+#endif
+
+	ath_reg_wr_nf(PCIE_RESET_ADDRESS, 0);	// Put endpoint in reset
+	udelay(100000);
+
+#ifdef PCIE2_APP_ADDRESS
+	ath_reg_rmw_set(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY_SET(1));
+	udelay(10000);
+#endif
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_PCIE_PHY_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_PCIE_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_wr_nf(PCIE_APP_ADDRESS, PCIE_APP_PCIE_BAR_MSN_SET(1) |
+					PCIE_APP_CFG_BE_SET(0xf) |
+					PCIE_APP_SLV_RESP_ERR_MAP_SET(0x3f) |
+					PCIE_APP_LTSSM_ENABLE_SET(1));
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+		PCI_COMMAND_PARITY | PCI_COMMAND_SERR | PCI_COMMAND_FAST_BACK;
+
+	ath_local_write_config(PCI_COMMAND, 4, cmd);
+	ath_local_write_config(0x20, 4, 0x1ff01000);
+	ath_local_write_config(0x24, 4, 0x1ff01000);
+
+	ath_reg_wr_nf(PCIE_RESET_ADDRESS, 4);	// Pull endpoint out of reset
+	udelay(100000);
+
+	/*
+	 * Check if the WLAN PCI-E H/W is present, If the
+	 * WLAN H/W is not present, skip the PCI platform
+	 * initialization code and return
+	 */
+	if (((ath_reg_rd(PCIE_RESET_ADDRESS)) & 0x1) == 0x0) {
+		prmsg("*** Warning *** : PCIe WLAN Module not found !!!\n");
+	}
+
+#ifdef PCIE2_APP_ADDRESS
+	pci_rc2_init_board();
+#endif
+
+#ifndef COMPRESSED_UBOOT
+	/*
+	 * Now, configure for u-boot tools
+	 */
+
+	hose.first_busno = 0;
+	hose.last_busno = 0xff;
+
+	/* System space */
+	pci_set_region(	&hose.regions[0],
+			0x80000000,
+			0x00000000,
+			32 * 1024 * 1024,
+			PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region(	&hose.regions[1],
+			0x10000000,
+			0x10000000,
+			128 * 1024 * 1024,
+			PCI_REGION_MEM);
+
+	hose.region_count = 2;
+
+	pci_register_hose(&hose);
+
+	pci_set_ops(	&hose,
+			pci_hose_read_config_byte_via_dword,
+			pci_hose_read_config_word_via_dword,
+			ath_pci_read_config,
+			pci_hose_write_config_byte_via_dword,
+			pci_hose_write_config_word_via_dword,
+			ath_pci_write_config);
+#endif
+	plat_dev_init();
+#endif /* CONFIG_ATH_EMULATION */
+
+	PCI_INIT_RETURN;
+}
+
+#ifdef PCIE2_APP_ADDRESS
+void
+pci_rc2_init_board (void)
+{
+	uint32_t	cmd;
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_PCIE2_PHY_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_PCIE2_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_clear(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY2_SET(1));
+	udelay(10000);
+
+	ath_reg_wr_nf(PCIE2_RESET_ADDRESS, 0);	// Put endpoint in reset
+	udelay(100000);
+
+	ath_reg_rmw_set(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY2_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET_PCIE_PHY_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET_PCIE_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_wr_nf(PCIE2_APP_ADDRESS, PCIE2_APP_PCIE2_BAR_MSN_SET(1) |
+					PCIE2_APP_CFG_BE_SET(0xf) |
+					PCIE2_APP_SLV_RESP_ERR_MAP_SET(0x3f) |
+					PCIE2_APP_LTSSM_ENABLE_SET(1));
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+		PCI_COMMAND_PARITY | PCI_COMMAND_SERR | PCI_COMMAND_FAST_BACK;
+
+	ath_local_write_config_rc2(PCI_COMMAND, 4, cmd);
+	ath_local_write_config_rc2(0x20, 4, 0x1ff01000);
+	ath_local_write_config_rc2(0x24, 4, 0x1ff01000);
+
+	ath_reg_wr_nf(PCIE2_RESET_ADDRESS, 4);	// Pull endpoint out of reset
+	udelay(100000);
+
+	/*
+	 * Check if the WLAN PCI-E H/W is present, If the
+	 * WLAN H/W is not present, skip the PCI platform
+	 * initialization code and return
+	 */
+	if (((ath_reg_rd(PCIE2_RESET_ADDRESS)) & 0x1) == 0x0) {
+		prmsg("*** Warning *** : PCIe WLAN Module not found !!!\n");
+		return;
+	}
+}
+#endif
diff --git a/board/atheros/common/athr_ar8033_phy.c b/board/atheros/common/athr_ar8033_phy.c
new file mode 100644
index 0000000000..37162f555f
--- /dev/null
+++ b/board/atheros/common/athr_ar8033_phy.c
@@ -0,0 +1,156 @@
+/*
+ * Copyright (c) 2010, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include <atheros.h>
+#include "athrs_ar8033_phy.h"
+
+
+void
+athrs_ar8033_mgmt_init(void)
+{
+    uint32_t rddata;
+
+
+    rddata = ath_reg_rd(GPIO_IN_ENABLE3_ADDRESS)&
+             ~GPIO_IN_ENABLE3_MII_GE1_MDI_MASK;
+    rddata |= GPIO_IN_ENABLE3_MII_GE1_MDI_SET(19);
+    ath_reg_wr(GPIO_IN_ENABLE3_ADDRESS, rddata);
+    
+    ath_reg_rmw_clear(GPIO_OE_ADDRESS, ATH_GPIO);
+
+    ath_reg_rmw_clear(GPIO_OE_ADDRESS, ATH_GPIO17);
+
+    
+    rddata = ath_reg_rd(GPIO_OUT_FUNCTION4_ADDRESS) & 
+             ~ (GPIO_FUNCTION4_MASK);
+
+    rddata |= (GPIO_FUNCTION4_ENABLE);
+
+    ath_reg_wr(GPIO_OUT_FUNCTION4_ADDRESS, rddata);
+
+#ifdef ATH_MDC_GPIO
+    rddata = ath_reg_rd(GPIO_OUT_FUNCTION3_ADDRESS) &
+           ~ (GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK);
+
+    rddata |= GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_SET(0x21);
+
+    ath_reg_wr(GPIO_OUT_FUNCTION3_ADDRESS, rddata);
+#endif
+
+}
+
+int
+athrs_ar8033_phy_setup(void  *arg)
+{
+    
+    return 0;
+}
+
+int
+athrs_ar8033_phy_is_fdx(int ethUnit)
+{
+   int phy_hw_status = 0x0;
+
+   phy_hw_status = ath_reg_rd(SGMII_MAC_RX_CONFIG_ADDRESS);
+
+   if (SGMII_MAC_RX_CONFIG_DUPLEX_MODE_GET(phy_hw_status) == 1) {
+        return 1;
+    } else if (SGMII_MAC_RX_CONFIG_DUPLEX_MODE_GET(phy_hw_status) == 0) {
+        return 0;
+    }
+
+    return 0;
+
+}
+
+int
+athrs_ar8033_phy_is_link_alive(int phyUnit)
+{
+   int phy_hw_status = 0x0;
+
+   phy_hw_status = ath_reg_rd(SGMII_MAC_RX_CONFIG_ADDRESS);
+
+   if (SGMII_MAC_RX_CONFIG_LINK_GET(phy_hw_status))
+        return 1;
+    else
+        return 0;
+
+  }
+
+int
+athrs_ar8033_phy_is_up(int ethUnit)
+{
+   int phy_hw_status = 0x0;
+
+   phy_hw_status = ath_reg_rd(SGMII_MAC_RX_CONFIG_ADDRESS);
+    if (SGMII_MAC_RX_CONFIG_LINK_GET(phy_hw_status))
+        return 1;
+    else
+        return 0;
+
+   
+}
+int
+athrs_ar8033_phy_speed(int ethUnit)
+{
+   int phy_hw_status = 0x0,speed;
+
+   phy_hw_status = ath_reg_rd(SGMII_MAC_RX_CONFIG_ADDRESS);
+
+   speed = ((phy_hw_status & (3 << 10)) >> 10);
+
+   switch (speed) {
+        case 0:
+                return _10BASET;
+                break;
+        case 1:
+                return _100BASET;
+                break;
+        case 2:
+                return _1000BASET;
+                break;
+        default:
+                return -1;
+                break;
+   }
+
+   return -1;
+
+}
+
+
+int 
+athrs_ar8033_reg_init(void *arg)
+{
+
+
+	athrs_ar8033_mgmt_init();
+	phy_reg_write(0x1,0x5, 0x1f, 0x101);
+
+
+
+	printf("%s: Done %x \n",__func__, phy_reg_read(0x1,0x5,0x1f));
+   
+	return 0;
+}
+
diff --git a/board/atheros/common/athr_s27_phy.c b/board/atheros/common/athr_s27_phy.c
new file mode 100755
index 0000000000..4ab143fca2
--- /dev/null
+++ b/board/atheros/common/athr_s27_phy.c
@@ -0,0 +1,878 @@
+
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include <atheros.h>
+#include "athr_s27_phy.h"
+
+/* PHY selections and access functions */
+
+typedef enum {
+    PHY_SRCPORT_INFO,
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG,
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+#define MODULE_NAME "ATHRS27"
+
+/*
+ * Track per-PHY port information.
+ */
+
+
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+
+   {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY4_ADDR,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+
+#define ATHR_GLOBALREGBASE    0
+
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+
+/* Forward references */
+BOOL athrs27_phy_is_link_alive(int phyUnit);
+uint32_t athrs27_reg_read(uint32_t reg_addr);
+void athrs27_reg_write(uint32_t reg_addr, uint32_t reg_val);
+unsigned int s27_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+void s27_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data);
+
+
+void athrs27_powersave_off(int phy_addr)
+{
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0x29);
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x36c0);
+
+}
+void athrs27_sleep_off(int phy_addr)
+{
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0xb);
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x3c00);
+}
+
+void athrs27_force_100M(int phyAddr,int duplex)
+{
+   /*
+    *  Force MDI and MDX to alternate ports 
+    *  Phy 0,2 and 4 -- MDI
+    *  Phy 1 and 3 -- MDX
+    */
+
+    if(phyAddr%2) {
+        s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+    }
+    else {
+        s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+    }
+
+    s27_wr_phy(phyAddr,0x1d,0x29);
+    s27_wr_phy(phyAddr,0x1e,0x0);
+    s27_wr_phy(phyAddr,0x10,0xc60);
+    s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,(0xa000|(duplex << 8)));
+}
+
+void athrs27_force_10M(int phyAddr,int duplex)
+{
+
+    athrs27_powersave_off(phyAddr);
+    athrs27_sleep_off(phyAddr);
+
+    s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,(0x8000 |(duplex << 8)));
+}
+
+int athrs27_reg_init(void)
+{
+#if S27_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+
+    /* if using header for register configuration, we have to     */
+    /* configure s27 register after frame transmission is enabled */
+    athrs27_reg_rmw(0x8,(1<<28));  /* Set WAN port is connected to GE0 */
+
+#if defined(S27_FORCE_100M)
+    athrs27_force_100M(ATHR_PHY4_ADDR,1);
+#elif  defined(S27_FORCE_10M)
+    athrs27_force_10M(ATHR_PHY4_ADDR,1);
+#else
+    s27_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0x9000);
+
+#endif
+#ifdef S27_PHY_DEBUG
+    printf(MODULE_NAME":OPERATIONAL_MODE_REG0:%x\n",athrs27_reg_read(OPERATIONAL_MODE_REG0));
+    printf(MODULE_NAME":REG 0x4-->:%x\n",athrs27_reg_read(0x4));
+    printf(MODULE_NAME":REG 0x2c-->:%x\n",athrs27_reg_read(0x2c));
+    printf(MODULE_NAME":REG 0x8-->:%x\n",athrs27_reg_read(0x8));
+#endif
+
+    return 0;
+}
+ 
+int athrs27_reg_init_lan(void)
+{
+    int i = 60;
+#if S26_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+    int       phyUnit;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+
+
+    /* reset switch */
+    printf(MODULE_NAME ": resetting s27\n");
+    athrs27_reg_write(0x0, athrs27_reg_read(0x0)|0x80000000);
+
+    while(i--) {
+        sysMsDelay(100);
+        if(!(athrs27_reg_read(0x0)&0x80000000))
+            break;
+    }
+    printf(MODULE_NAME ": s27 reset done\n");
+    athrs27_reg_write(PORT_STATUS_REGISTER0,0x4e);
+
+    athrs27_reg_rmw(OPERATIONAL_MODE_REG0,(1<<6));  /* Set GMII mode */
+
+    if (is_emu() || is_wasp()) {
+       athrs27_reg_rmw(0x2c,((1<<26)| (1<<16) | 0x1)); /* FiX ME: EBU debug */
+    }
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+#if defined(S27_FORCE_100M)
+        athrs27_force_100M(phyAddr,1);
+#elif defined(S27_FORCE_10M)
+        athrs27_force_10M(phyAddr,1);
+#else
+        s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,0x9000);
+#endif
+
+#if S27_PHY_DEBUG
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_FUNC_CONTROL);
+        printf("S27 ATHR_PHY_FUNC_CONTROL (%d):%x\n",phyAddr,rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_ID1);
+        printf("S27 PHY ID  (%d) :%x\n",phyAddr, rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_SPEC_STATUS);
+        printf("S27 PHY CTRL  (%d) :%x\n",phyAddr, rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_STATUS);
+        printf("S27 ATHR PHY STATUS  (%d) :%x\n",phyAddr, rd_val);
+#endif
+    }
+
+    /* 
+     * status[1:0]=2'h2;   - (0x10 - 1000 Mbps , 0x01 - 100Mbps, 0x0 - 10 Mbps)
+     * status[2]=1'h1;     - Tx Mac En
+     * status[3]=1'h1;     - Rx Mac En
+     * status[4]=1'h1;     - Tx Flow Ctrl En
+     * status[5]=1'h1;     - Rx Flow Ctrl En
+     * status[6]=1'h1;     - Duplex Mode
+     */
+    athrs27_reg_write(PORT_STATUS_REGISTER1, 0x200);  /* LAN - 1 */
+    athrs27_reg_write(PORT_STATUS_REGISTER2, 0x200);  /* LAN - 2 */
+    athrs27_reg_write(PORT_STATUS_REGISTER3, 0x200);  /* LAN - 3 */
+    athrs27_reg_write(PORT_STATUS_REGISTER4, 0x200);  /* LAN - 4 */
+
+    if (is_emu()) {
+        athrs27_reg_write(PORT_STATUS_REGISTER1, 0x4C);  /* LAN - 1 */
+        athrs27_reg_write(PORT_STATUS_REGISTER2, 0x4c);  /* LAN - 2 */
+        athrs27_reg_write(PORT_STATUS_REGISTER3, 0x4c);  /* LAN - 3 */
+        athrs27_reg_write(PORT_STATUS_REGISTER4, 0x4c);  /* LAN - 4 */
+    }
+
+    /* QM Control */
+    athrs27_reg_write(0x38, 0xc000050e);
+
+    /*
+     * status[11]=1'h0;    - CPU Disable
+     * status[7] = 1'b1;   - Learn One Lock
+     * status[14] = 1'b0;  - Learn Enable
+     */
+#ifdef ATHEROS_HEADER_EN
+    athrs27_reg_write(PORT_CONTROL_REGISTER0, 0x4804);
+#else
+   /* Atheros Header Disable */
+    athrs27_reg_write(PORT_CONTROL_REGISTER0, 0x4004);
+#endif
+
+    /* Tag Priority Mapping */
+    athrs27_reg_write(0x70, 0xfa50);
+
+    /* Enable ARP packets to CPU port */
+    athrs27_reg_write(S27_ARL_TBL_CTRL_REG,(athrs27_reg_read(S27_ARL_TBL_CTRL_REG) | 0x100000));
+
+   /* Enable Broadcast packets to CPU port */
+    athrs27_reg_write(S27_FLD_MASK_REG,(athrs27_reg_read(S27_FLD_MASK_REG) |
+                           S27_ENABLE_CPU_BROADCAST | S27_ENABLE_CPU_BCAST_FWD ));
+
+    return 0;
+}
+
+/******************************************************************************
+*
+* athrs27_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs27_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+    phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs27_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*   
+* Resets the associated PHY port.
+*   
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+BOOL
+athrs27_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+//#if S27_PHY_DEBUG
+    uint32_t  rd_val = 0;
+//#endif
+    uint32_t  ar7240_revid;
+
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+        if (!is_emu()) {
+           s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+
+           s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+        }
+        else  {
+		printf("############ is emulation ############\n");
+
+           if(ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN) {
+               s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+               s27_wr_phy(phyAddr,0x9, 0x0); //donot advertise 1000Mbps mode
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,0x0);
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+           }
+           else { 
+
+               s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,(ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE |
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL));
+               s27_wr_phy(phyAddr,0x9, 0x0); //donot advertise 1000Mbps mode
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,0x0);
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+           }
+       }
+       rd_val = s27_rd_phy(phyAddr,ATHR_PHY_CONTROL);
+       printf("%s ATHR_PHY_CONTROL %d:0x%x\n",__func__,phyAddr,rd_val);
+       rd_val = s27_rd_phy(phyAddr,ATHR_PHY_SPEC_STATUS);
+       printf("%s ATHR_PHY_SPEC_STAUS %d:0x%x\n",__func__,phyAddr,rd_val);
+    }
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    if (ethUnit == ENET_UNIT_LAN)
+        sysMsDelay(100);// changed by lsz, sysMsDelay(1000);
+    else
+        sysMsDelay(300);// changed by lsz, sysMsDelay(3000);
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN)
+            continue;
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus =  s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+        /* extend the cable length */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x14);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xf52);
+
+       /* Force Class A setting phys */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 4);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xebbb);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 5);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0x2c47);
+
+        /* fine-tune PHYs */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x3c);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0x1c1);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x37);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xd600);
+
+
+#ifdef S27_VER_1_0
+        /* turn off power saving */
+        s27_wr_phy(phyUnit, 29, 41);
+        s27_wr_phy(phyUnit, 30, 0);
+        printf("def_ S27_VER_1_0\n");
+#endif
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit,
+            s27_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS)));
+    }
+
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs27_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs27_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = s27_rd_phy (phyAddr, ATHR_PHY_SPEC_STATUS);
+                        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+                                break;
+                sysMsDelay(10);
+            } while(--ii);
+            if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+            }
+        }
+    }
+
+    return FALSE;
+}
+/******************************************************************************
+*
+* athrs27_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               ATHR_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               ATHR_PHY_SPEED_1000T;
+*/
+
+int
+athrs27_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+    int       phySpeed;
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        phySpeed = _10BASET;
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+
+            do {
+                phyHwStatus = s27_rd_phy(phyAddr,
+                                              ATHR_PHY_SPEC_STATUS);
+                        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+                                break;
+                sysMsDelay(10);
+            }while(--ii);
+
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                phySpeed = _10BASET;
+		break;
+            case 1:
+                phySpeed = _100BASET;
+		break;
+            case 2:
+                phySpeed = _1000BASET;
+		break;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        }
+
+        phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x18);
+
+        if(phySpeed == _100BASET) {
+            phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_DATA, 0xba8);
+        } else {
+            phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_DATA, 0x2ea);
+        }
+    }
+
+    if (ethUnit == ENET_UNIT_LAN)
+         phySpeed = _1000BASET;
+
+    return phySpeed;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs27_phy_is_up(int ethUnit)
+{
+
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+    int           phyUnit;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                printf("enet%d port%d down\n",ethUnit, phyUnit);
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            if(is_emu())
+            {
+                phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_STATUS);
+                if(phyAddr%2) {
+                    s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+                }
+                else {
+                    s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+                }
+
+                if((phyHwStatus & 0x4)==0)
+                {
+                   s27_wr_phy(phyAddr,0x9,0x0);
+                   if(phyAddr !=0x4)
+                       s27_wr_phy(phyAddr,0x4,0x41);
+                   s27_wr_phy(phyAddr,0x0,0x9000);
+                }
+            }
+
+            phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+             phyHwControl = s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+             phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_STATUS);
+
+            /* Check for AutoNegotiation complete */
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = s27_rd_phy(phyAddr,
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                printf("enet%d port%d up\n",ethUnit, phyUnit);
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+    return (linkCount);
+}
+
+unsigned int athrs27_reg_read(unsigned int s27_addr)
+{
+    unsigned int addr_temp;
+    unsigned int s27_rd_csr_low, s27_rd_csr_high, s27_rd_csr;
+    unsigned int data,unit = 0;
+    unsigned int phy_address, reg_address;
+
+    addr_temp = s27_addr >>2;
+    data = addr_temp >> 7;
+
+    phy_address = 0x1f;
+    reg_address = 0x10;
+
+    if (is_ar7240()) {
+        unit = 0;
+    }
+    else if(is_ar7241() || is_ar7242() || is_wasp()|| is_qca953x() ) {
+        unit = 1;
+    }
+
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+    reg_address = ((addr_temp << 1) & 0x1e);
+    s27_rd_csr_low = (uint32_t) phy_reg_read(unit,phy_address, reg_address);
+
+    reg_address = reg_address | 0x1;
+    s27_rd_csr_high = (uint32_t) phy_reg_read(unit,phy_address, reg_address);
+    s27_rd_csr = (s27_rd_csr_high << 16) | s27_rd_csr_low ;
+	
+    return(s27_rd_csr);
+}
+
+void athrs27_reg_write(unsigned int s27_addr, unsigned int s27_write_data)
+{
+    unsigned int addr_temp;
+    unsigned int data;
+    unsigned int phy_address, reg_address,unit = 0;
+
+    addr_temp = (s27_addr ) >>2;
+    data = addr_temp >> 7;
+
+    phy_address = 0x1f;
+    reg_address = 0x10;
+
+    if (is_ar7240()) {
+        unit = 0;
+    }
+    else if(is_ar7241() || is_ar7242() || is_wasp() || is_qca953x()) {
+        unit = 1;
+    }
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+
+    reg_address = (((addr_temp << 1) & 0x1e) | 0x1);
+    data = (s27_write_data >> 16) & 0xffff;
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    reg_address = ((addr_temp << 1) & 0x1e);
+    data = s27_write_data  & 0xffff;
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+}
+
+void athrs27_reg_rmw(unsigned int s27_addr, unsigned int s27_write_data)
+{
+    int val = athrs27_reg_read(s27_addr);
+    athrs27_reg_write(s27_addr,(val | s27_write_data));
+}
+
+unsigned int s27_rd_phy(unsigned int phy_addr, unsigned int reg_addr)
+{
+
+     unsigned int rddata, i = 100;
+
+
+    /* MDIO_CMD is set for read */
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = (rddata & 0x0) | (reg_addr<<16)
+              | (phy_addr<<21) | (1<<27)
+              | (1<<30) | (1<<31) ;
+
+    athrs27_reg_write(0x98, rddata);
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = rddata & (1<<31);
+
+    /* Check MDIO_BUSY status */
+    while(rddata && --i){
+        rddata = athrs27_reg_read(0x98);
+        rddata = rddata & (1<<31);
+    }
+
+    if(i <= 0)
+      printf("ERROR:%s failed:phy:%d reg:%X rddata:%X\n",
+                __func__,phy_addr,reg_addr,rddata);
+    /* Read the data from phy */
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = rddata & 0xffff;
+    return(rddata);
+}
+void s27_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data)
+{
+    unsigned int rddata,i = 100;
+
+    /* MDIO_CMD is set for read */
+
+    rddata = athrs27_reg_read(0x98);
+
+    rddata = (rddata & 0x0) | (write_data & 0xffff)
+               | (reg_addr<<16) | (phy_addr<<21)
+               | (0<<27) | (1<<30) | (1<<31) ;
+
+    athrs27_reg_write(0x98, rddata);
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = rddata & (1<<31);
+
+    /* Check MDIO_BUSY status */
+    while(rddata && --i){
+        rddata = athrs27_reg_read(0x98);
+        rddata = rddata & (1<<31);
+    }
+    if(i <= 0)
+      printf("ERROR:%s failed:phy:%d reg%X\n",__func__,phy_addr,reg_addr);
+
+}
+
+int athrs27_mdc_check()
+{
+    int i;
+
+    for (i=0; i<4000; i++) {
+        if(athrs27_reg_read(0x10c) != 0x18007fff)
+            return -1;
+    }
+    return 0;
+}
+
diff --git a/board/atheros/common/athr_s27_phy.h b/board/atheros/common/athr_s27_phy.h
new file mode 100755
index 0000000000..9846a4f0a3
--- /dev/null
+++ b/board/atheros/common/athr_s27_phy.h
@@ -0,0 +1,208 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ATHRS27_PHY_H
+#define _ATHRS27_PHY_H
+
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_FUNC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+#define ATHR_PHY_INTR_ENABLE             0x12
+#define ATHR_PHY_INTR_STATUS             0x13
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+#define ATHR_ADVERTISE_1000HALF		      0x0100
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DUPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_LATCH_LINK_PASS                  0x0004 
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+#define OPERATIONAL_MODE_REG0                0x4
+
+/* S27 CSR Registers */
+
+#define PORT_STATUS_REGISTER0                0x0100 
+#define PORT_STATUS_REGISTER1                0x0200
+#define PORT_STATUS_REGISTER2                0x0300
+#define PORT_STATUS_REGISTER3                0x0400
+#define PORT_STATUS_REGISTER4                0x0500
+#define PORT_STATUS_REGISTER5                0x0600
+
+#define RATE_LIMIT_REGISTER0                 0x010C
+#define RATE_LIMIT_REGISTER1                 0x020C
+#define RATE_LIMIT_REGISTER2                 0x030C
+#define RATE_LIMIT_REGISTER3                 0x040C
+#define RATE_LIMIT_REGISTER4                 0x050C
+#define RATE_LIMIT_REGISTER5                 0x060C
+
+#define PORT_CONTROL_REGISTER0               0x0104
+#define PORT_CONTROL_REGISTER1               0x0204
+#define PORT_CONTROL_REGISTER2               0x0304
+#define PORT_CONTROL_REGISTER3               0x0404
+#define PORT_CONTROL_REGISTER4               0x0504
+#define PORT_CONTROL_REGISTER5               0x0604
+
+#define CPU_PORT_REGISTER                    0x0078
+#define MDIO_CTRL_REGISTER                   0x0098
+
+#define S27_ARL_TBL_FUNC_REG0                0x0050
+#define S27_ARL_TBL_FUNC_REG1                0x0054
+#define S27_ARL_TBL_FUNC_REG2                0x0058
+#define S27_FLD_MASK_REG                     0x002c
+#define S27_ARL_TBL_CTRL_REG                 0x005c
+#define S27_GLOBAL_INTR_REG                  0x10
+#define S27_GLOBAL_INTR_MASK_REG             0x14
+
+
+#define S27_ENABLE_CPU_BROADCAST             (1 << 26)
+#define S27_ENABLE_CPU_BCAST_FWD             (1 << 25)
+
+#define PHY_LINK_CHANGE_REG 		     0x4
+#define PHY_LINK_UP 		             0x400
+#define PHY_LINK_DOWN 		             0x800
+#define PHY_LINK_DUPLEX_CHANGE 		     0x2000
+#define PHY_LINK_SPEED_CHANGE		     0x4000
+#define PHY_LINK_INTRS			     (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+/* SWITCH QOS REGISTERS */
+
+#define ATHR_QOS_PORT_0			0x110 /* CPU PORT */
+#define ATHR_QOS_PORT_1			0x210
+#define ATHR_QOS_PORT_2			0x310
+#define ATHR_QOS_PORT_3			0x410
+#define ATHR_QOS_PORT_4			0x510
+
+#define ATHR_ENABLE_TOS                 (1 << 16)
+
+#define ATHR_QOS_MODE_REGISTER          0x030
+#define ATHR_QOS_FIXED_PRIORITY        ((0 << 31) | (0 << 28))
+#define ATHR_QOS_WEIGHTED              ((1 << 31) | (0 << 28)) /* Fixed weight 8,4,2,1 */
+#define ATHR_QOS_MIXED                 ((1 << 31) | (1 << 28)) /* Q3 for managment; Q2,Q1,Q0 - 4,2,1 */
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+#define mdelay(_x)      sysMsDelay(_x)
+
+#undef S27_VER_1_0
+
+/*
+ *  Atheros header defines
+ */
+#ifndef _ATH_HEADER_CONF
+#define _ATH_HEADER_CONF
+
+typedef enum {
+    NORMAL_PACKET,
+    RESERVED0,
+    MIB_1ST,
+    RESERVED1,
+    RESERVED2,
+    READ_WRITE_REG,
+    READ_WRITE_REG_ACK,
+    RESERVED3
+} AT_HEADER_TYPE;
+
+typedef struct {
+    uint16_t    reserved0  :2;
+    uint16_t    priority   :2;
+    uint16_t    type       :4;
+    uint16_t    broadcast  :1;
+    uint16_t    from_cpu   :1;
+    uint16_t    reserved1  :2;
+    uint16_t    port_num   :4;
+}at_header_t;
+
+#define ATHR_HEADER_LEN 2
+
+#endif // _ATH_HEADER_CONF
+
+typedef enum {
+    PORT_EG_UNMODIFIED = 0,  /**<  egress transmit packets unmodified */
+    PORT_EG_UNTAGGED,        /**<  egress transmit packets without vlan tag */
+    PORT_EG_TAGGED,          /**<  egress transmit packets with vlan tag */
+} port_1q_egmode_t;
+
+extern void set_packet_inspection_flag(int flag);
+
+#endif
diff --git a/board/atheros/common/athrs17_lpbk.c b/board/atheros/common/athrs17_lpbk.c
new file mode 100644
index 0000000000..ef1dcdf9bc
--- /dev/null
+++ b/board/atheros/common/athrs17_lpbk.c
@@ -0,0 +1,290 @@
+// ----------------------------------
+// S17 Initialization
+// author : subha@atheros.com
+// adapted: Abishek Goda <Abishek.Goda at atheros dot com>
+// ----------------------------------
+
+//#include <prototypes.h>
+//#include <gmac_defines.h>
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#include <atheros.h>
+#include "qca-eth-955x.h"
+#include "qca-eth-955x_phy.h"
+#include "phy.h"
+#include "athrs17_phy.h"
+
+uint32_t athrs17_reg_read(uint32_t reg_addr);
+void athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val);
+
+#ifdef ATH_RGMII_CAL
+
+# define ATHR_PHY_MAX 1
+
+#if 0
+void s17_phy_write( unsigned int phy_address, 
+                    unsigned int reg_address, 
+                    unsigned int write_data ) {
+
+    unsigned int rddata;
+    unsigned int address;
+
+    address = ((phy_address << 8) & 0x1f00) | (reg_address & 0x1f);
+
+    reg_write(GE0_MAC_MII_MGMT_CFG, 0x7);
+
+    rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    while(rddata){
+        rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    }
+    reg_write(GE0_MAC_MII_MGMT_CMD, 0x0);
+    reg_write(GE0_MAC_MII_MGMT_ADDR, address);
+    reg_write(GE0_MAC_MII_MGMT_CNTR, write_data);
+    while(rddata){
+        rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    }
+}
+
+unsigned int s17_phy_read(unsigned int phy_address, unsigned int reg_address) {
+
+    unsigned int rddata;
+    unsigned int address;
+    unsigned int phy_rddata;
+
+    address = ((phy_address << 8) & 0x1f00) | (reg_address & 0x1f);
+
+    reg_write(GE0_MAC_MII_MGMT_CFG, 0x7);
+
+    rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    while(rddata){
+        rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    }
+    reg_write(GE0_MAC_MII_MGMT_CMD, 0x0);
+    reg_write(GE0_MAC_MII_MGMT_ADDR, address);
+    reg_write(GE0_MAC_MII_MGMT_CMD, 0x1);
+
+    rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    while(rddata){
+        rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    }
+
+    phy_rddata = reg_read(GE0_MAC_MII_MGMT_STAT);
+    reg_write(GE0_MAC_MII_MGMT_CMD, 0x0);
+
+    return(phy_rddata);
+
+}
+
+void s17_reg_write(unsigned int reg_addr, unsigned int reg_val) {
+
+    unsigned int reg_word_addr;
+    unsigned int phy_addr;
+    unsigned int phy_val;
+    unsigned int phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    /* bit16-8 of reg address          */
+    phy_val = (unsigned int) ((reg_word_addr >> 8) & 0x3ff);  
+    s17_phy_write(phy_addr, phy_reg, phy_val);
+
+    /* For S17 registers such as ARL and VLAN, since they include BUSY bit   */
+    /* in higher address, we should write the lower 16-bit register then the */
+    /* higher one */
+
+    /* write register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);  /* bit7-5 of reg address */
+    phy_reg = (unsigned int) (reg_word_addr & 0x1f); /* bit4-0 of reg address */
+    phy_val = (unsigned int) (reg_val & 0xffff);
+    s17_phy_write( phy_addr, phy_reg, phy_val);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);  /* bit7-5 of reg address */
+    phy_reg = (unsigned int) (reg_word_addr & 0x1f); /* bit4-0 of reg address */
+    phy_val = (unsigned int) ((reg_val >> 16) & 0xffff);
+    s17_phy_write( phy_addr, phy_reg, phy_val);
+}
+
+unsigned int s17_reg_read(unsigned int reg_addr) 
+{
+    unsigned int reg_word_addr;
+    unsigned int phy_addr, tmp_val, reg_val;
+    unsigned int phy_val;
+    unsigned int phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    /* bit16-8 of reg address */
+    phy_val = (unsigned int) ((reg_word_addr >> 8) & 0x3ff); 
+    s17_phy_write( phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as MIBs, since it is read/clear, we should */
+    /* read the lower 16-bit register then the higher one */
+
+    /* read register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);  /* bit7-5 of reg address */
+    phy_reg = (unsigned int) (reg_word_addr & 0x1f); /* bit4-0 of reg address */
+    reg_val = (unsigned int) s17_phy_read( phy_addr, phy_reg);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);  /* bit7-5 of reg address */
+    phy_reg = (unsigned int) (reg_word_addr & 0x1f); /* bit4-0 of reg address */
+    tmp_val = (unsigned int) s17_phy_read( phy_addr, phy_reg);
+    reg_val |= (tmp_val << 16);
+
+    return reg_val;
+}
+#endif
+
+void s17_reg_rmw(unsigned int reg_addr, unsigned int reg_val) 
+{
+
+    reg_val |= athrs17_reg_read(reg_addr);
+    athrs17_reg_write(reg_addr,reg_val);
+}
+
+void init_s17(void) 
+{
+    int phyUnit = 0;
+    int phyBase = 0;
+    int phyAddr = 0;
+    unsigned int rddata;
+
+    athrs17_reg_write(0x624 , 0x003f3f3f);
+    athrs17_reg_write(0x10  , 0x40000000);
+    athrs17_reg_write(0x4   , 0x07500000);
+    athrs17_reg_write(0xc   , 0x01000000);
+    athrs17_reg_write(0x7c  , 0x000000fe); // 1gbps
+    //athrs17_reg_write(0x7c  , 0x0000007d); // 100 mbps
+    //athrs17_reg_write(0x7c  , 0x0000007c); // 10 mbps
+
+    for (phyUnit= 0; phyUnit <= ATHR_PHY_MAX; phyUnit++)
+    {
+        phyBase = 0;
+        phyAddr = phyUnit;
+        // To enable loopback on a phy
+        // rddata = s17_phy_read(phyAddr, 0x0);
+        // s17_phy_write(phyAddr, 0x0, (rddata | (1 << 14)));
+        /* For 100M waveform */
+        phy_reg_write(0, phyAddr, 0x1d, 0x18);
+        phy_reg_write(0, phyAddr, 0x1e, 0x02ea);
+        /* Turn On Gigabit Clock */
+        phy_reg_write(0, phyAddr, 0x1d, 0x3d);
+        phy_reg_write(0, phyAddr, 0x1e, 0x48a0);
+
+    }
+
+    /* Enable flow control */
+    s17_reg_rmw(0x80,0x30);
+    s17_reg_rmw(0x84,0x30);
+    s17_reg_rmw(0x88,0x30);
+    s17_reg_rmw(0x8c,0x30);
+    s17_reg_rmw(0x90,0x30);
+}
+
+void vlan_config(void)
+{
+    athrs17_reg_write(S17_P0LOOKUP_CTRL_REG, 0x0014001e);
+    athrs17_reg_write(S17_P0VLAN_CTRL0_REG, 0x10001);
+
+    athrs17_reg_write(S17_P1LOOKUP_CTRL_REG, 0x0014001d);
+    athrs17_reg_write(S17_P1VLAN_CTRL0_REG, 0x10001);
+
+    athrs17_reg_write(S17_P2LOOKUP_CTRL_REG, 0x0014001b);
+    athrs17_reg_write(S17_P2VLAN_CTRL0_REG, 0x10001);
+
+    athrs17_reg_write(S17_P3LOOKUP_CTRL_REG, 0x00140017);
+    athrs17_reg_write(S17_P3VLAN_CTRL0_REG, 0x10001);
+
+    athrs17_reg_write(S17_P4LOOKUP_CTRL_REG, 0x0014000f);
+    athrs17_reg_write(S17_P4VLAN_CTRL0_REG, 0x10001);
+
+    athrs17_reg_write(S17_P5LOOKUP_CTRL_REG, 0x00140040);
+    athrs17_reg_write(S17_P5VLAN_CTRL0_REG, 0x20001);
+
+    athrs17_reg_write(S17_P6LOOKUP_CTRL_REG, 0x00140020);
+    athrs17_reg_write(S17_P6VLAN_CTRL0_REG, 0x20001);
+
+}
+
+void init_s17_lpbk(void) 
+{
+    int phyUnit = 0;
+    int phyBase = 0;
+    int phyAddr = 0;
+    unsigned int rddata;
+
+#ifdef ATH_S17_MAC0_SGMII
+    athrs17_reg_write(0x4   , 0x080080);
+    athrs17_reg_write(0xc   , 0x07600000);
+    athrs17_reg_write(0x94  , 0x000000fe); // 1gbps
+    athrs17_reg_write(0x624 , 0x007f7f7f);
+    printf ("Vlan config...\n");
+    vlan_config();
+#else
+    athrs17_reg_write(0x624 , 0x003f3f3f);
+    athrs17_reg_write(0x4   , 0x07500000);
+    athrs17_reg_write(0xc   , 0x01000000);
+#endif
+    athrs17_reg_write(0x10  , 0x4000000);
+    athrs17_reg_write(0x7c  , 0x000000fe); // 1gbps
+    //athrs17_reg_write(0x7c  , 0x0000007d); // 100 mbps
+    //athrs17_reg_write(0x7c  , 0x0000007c); // 10 mbps
+
+    phyBase = 0;
+#ifdef ATH_S17_MAC0_SGMII
+    phyAddr = 4;
+#else
+    phyAddr = 0;
+#endif
+    // To enable loopback on single phy
+    phy_reg_write(0, phyAddr, 0x0, 0xc140);
+    for(rddata=0; rddata<1000; rddata++);
+    phy_reg_write(0, phyAddr, 0x0, 0x4140);
+    for(rddata=0; rddata<1000; rddata++);
+    rddata = phy_reg_read(0, phyAddr, 0x0);
+#ifdef DEBUG
+    printf("s17 phy0 register value 0x%08x\n", rddata);
+#endif
+    // power down other phys
+#ifdef ATH_S17_MAC0_SGMII
+    phy_reg_write(0, 0x0, 0x0, 0x8800);
+#else
+    phy_reg_write(0, 0x4, 0x0, 0x8800);
+#endif
+    phy_reg_write(0, 0x1, 0x0, 0x8800);
+    phy_reg_write(0, 0x2, 0x0, 0x8800);
+    phy_reg_write(0, 0x3, 0x0, 0x8800);
+    /* For 100M waveform */
+    phy_reg_write(0, phyAddr, 0x1d, 0x18);
+    phy_reg_write(0, phyAddr, 0x1e, 0x02ea);
+    /* Turn On Gigabit Clock */
+    phy_reg_write(0, phyAddr, 0x1d, 0x3d);
+    phy_reg_write(0, phyAddr, 0x1e, 0x48a0);
+
+    /* Enable flow control */
+    s17_reg_rmw(0x80,0x30);
+    s17_reg_rmw(0x84,0x30);
+    s17_reg_rmw(0x88,0x30);
+    s17_reg_rmw(0x8c,0x30);
+    s17_reg_rmw(0x90,0x30);
+}
+
+#endif /* #ifdef RGMII_CAL */
diff --git a/board/atheros/common/athrs17_phy.c b/board/atheros/common/athrs17_phy.c
new file mode 100644
index 0000000000..2a7e8529ae
--- /dev/null
+++ b/board/atheros/common/athrs17_phy.c
@@ -0,0 +1,713 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include <atheros.h>
+#include "athrs17_phy.h"
+
+/* PHY selections and access functions */
+typedef enum {
+	PHY_SRCPORT_INFO,
+	PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+	PHY_SRCPORT_NONE,
+	PHY_SRCPORT_VLANTAG,
+	PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+#define ENET_UNIT_GE0 0
+#define ENET_UNIT_GE1 1
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+#define ATHR_IND_PHY 4
+
+#define MODULE_NAME "ATHRS17"
+#define S17_PHY_DEBUG 1
+extern int xmii_val;
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+#if defined(ATH_S17_MAC0_SGMII)
+#define ENET_UNIT            ENET_UNIT_GE1
+#define ENET_UNIT_WAN        ENET_UNIT_GE0
+#else
+#define ENET_UNIT            ENET_UNIT_GE0
+#define ENET_UNIT_WAN        ENET_UNIT_GE1
+#endif
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+	{
+		TRUE,   /* phy port 0 -- LAN port 0 */
+		FALSE,
+		ENET_UNIT,
+		0,
+		ATHR_PHY0_ADDR,
+		ATHR_LAN_PORT_VLAN
+	},
+	{
+		TRUE,   /* phy port 1 -- LAN port 1 */
+		FALSE,
+		ENET_UNIT,
+		0,
+		ATHR_PHY1_ADDR,
+		ATHR_LAN_PORT_VLAN
+	},
+	{
+		TRUE,   /* phy port 2 -- LAN port 2 */
+		FALSE,
+		ENET_UNIT,
+		0,
+		ATHR_PHY2_ADDR,
+		ATHR_LAN_PORT_VLAN
+	},
+	{
+		TRUE,   /* phy port 3 -- LAN port 3 */
+		FALSE,
+		ENET_UNIT,
+		0,
+		ATHR_PHY3_ADDR,
+		ATHR_LAN_PORT_VLAN
+	},
+	{
+		TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+		FALSE,
+#if defined(CONFIG_ATH_S17_WAN) || defined (ATH_S17_MAC0_SGMII)
+		ENET_UNIT_WAN,
+#else
+		ENET_UNIT,
+#endif
+		0,
+		ATHR_PHY4_ADDR,
+		ATHR_LAN_PORT_VLAN   /* Send to all ports */
+	},
+	{
+		FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+		TRUE,
+		ENET_UNIT,
+		0,
+		0x00,
+		ATHR_LAN_PORT_VLAN    /* Send to all ports */
+	},
+};
+
+static uint8_t athr17_init_flag = 0;
+
+//#define ATHR_PHY_MAX (sizeof(ipPhyInfo) / sizeof(ipPhyInfo[0]))
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit)	\
+	(ATHR_IS_ENET_PORT(phyUnit) &&		\
+	 ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_GE0))
+
+/* Forward references */
+BOOL athrs17_phy_is_link_alive(int phyUnit);
+uint32_t athrs17_reg_read(uint32_t reg_addr);
+void athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val);
+static void phy_mode_setup(void);
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+
+static void phy_mode_setup(void)
+{
+#ifdef ATHRS17_VER_1_0
+	/*work around for phy4 rgmii mode*/
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);
+
+	/*rx delay*/
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 0);
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x824e);
+
+	/*tx delay*/
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 5);
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x3d47);
+#endif
+}
+/*
+ * V-lan configuration given by Switch team
+ * Vlan 1:PHY0,1,2,3 and Mac 0 of s17
+ * Vlam 2:PHY4 and Mac 6 of s17
+ */
+
+void athrs17_vlan_config()
+{
+	athrs17_reg_write(S17_P0LOOKUP_CTRL_REG, 0x0014001e);
+	athrs17_reg_write(S17_P0VLAN_CTRL0_REG, 0x10001);
+
+	athrs17_reg_write(S17_P1LOOKUP_CTRL_REG, 0x0014001d);
+	athrs17_reg_write(S17_P1VLAN_CTRL0_REG, 0x10001);
+
+	athrs17_reg_write(S17_P2LOOKUP_CTRL_REG, 0x0014001b);
+	athrs17_reg_write(S17_P2VLAN_CTRL0_REG, 0x10001);
+
+	athrs17_reg_write(S17_P3LOOKUP_CTRL_REG, 0x00140017);
+	athrs17_reg_write(S17_P3VLAN_CTRL0_REG, 0x10001);
+
+	athrs17_reg_write(S17_P4LOOKUP_CTRL_REG, 0x0014000f);
+	athrs17_reg_write(S17_P4VLAN_CTRL0_REG, 0x10001);
+
+	athrs17_reg_write(S17_P5LOOKUP_CTRL_REG, 0x00140040);
+	athrs17_reg_write(S17_P5VLAN_CTRL0_REG, 0x20001);
+
+	athrs17_reg_write(S17_P6LOOKUP_CTRL_REG, 0x00140020);
+	athrs17_reg_write(S17_P6VLAN_CTRL0_REG, 0x20001);
+
+
+}
+
+void athrs17_reg_init_wan(void)
+{
+
+#ifdef ATH_S17_MAC0_SGMII
+	athrs17_reg_write(S17_P6PAD_MODE_REG,0x07600000);
+
+#else
+	athrs17_reg_write(S17_P6PAD_MODE_REG,
+           athrs17_reg_read(S17_P6PAD_MODE_REG)|S17_MAC6_SGMII_EN);
+#endif
+	athrs17_reg_write(S17_P6STATUS_REG, S17_PORT_STATUS_AZ_DEFAULT);
+	athrs17_reg_write(S17_SGMII_CTRL_REG , 0xc74164d0); /* SGMII control */
+         
+        athrs17_vlan_config();
+	printf("%s done\n",__func__);
+
+}
+
+void athrs17_reg_init()
+{
+	int phy_addr = 0;
+
+	/* if using header for register configuration, we have to     */
+	/* configure s17 register after frame transmission is enabled */
+
+	if (athr17_init_flag)
+		return;
+	if (is_drqfn()) {
+		athrs17_reg_write(S17_P0PAD_MODE_REG, S17_MAC0_SGMII_EN);
+		athrs17_reg_write(S17_SGMII_CTRL_REG , 0xc74164d0); /* SGMII control  */
+        } else {
+		athrs17_reg_write(S17_GLOFW_CTRL1_REG,	0x7f7f7f7f);
+		/* 
+                 * If defined S17 Mac0 sgmii val of 0x4(S17_P0PAD_MODE_REG)
+                 * should be configured as 0x80
+                 */
+#ifdef ATH_S17_MAC0_SGMII
+		athrs17_reg_write(S17_P0PAD_MODE_REG,	0x80080);
+#else
+		athrs17_reg_write(S17_P0PAD_MODE_REG,	0x07680000);
+#endif
+		athrs17_reg_write(S17_P6PAD_MODE_REG,	0x01000000);
+
+		
+	}
+/*
+ * Values suggested by the swich team when s17 in sgmii configuration
+ * operates in forced mode.
+ * 0x10(S17_PWS_REG)=0x602613a0
+ */
+#ifdef ATH_SGMII_FORCED_MODE
+	athrs17_reg_write(S17_PWS_REG, 0x602613a0);
+#else
+	athrs17_reg_write(S17_PWS_REG,	0x40000000);
+#endif
+	athrs17_reg_write(S17_P0STATUS_REG,	 0x0000007e);
+
+	/* AR8327/AR8328 v1.0 fixup */
+	if ((athrs17_reg_read(0x0) & 0xffff) == 0x1201) {
+		for (phy_addr = 0x0; phy_addr <= ATHR_PHY_MAX; phy_addr++) {
+			/* For 100M waveform */
+			phy_reg_write(0, phy_addr, 0x1d, 0x0);
+			phy_reg_write(0, phy_addr, 0x1e, 0x02ea);
+			/* Turn On Gigabit Clock */
+			phy_reg_write(0, phy_addr, 0x1d, 0x3d);
+			phy_reg_write(0, phy_addr, 0x1e, 0x68a0);
+		}
+	}
+#if CONFIG_S17_SWMAC6_CONNECTED
+        printf ("Configuring Mac6 of s17 to slave scorpion\n");
+	athrs17_reg_write(S17_P6PAD_MODE_REG, S17_MAC6_RGMII_EN | S17_MAC6_RGMII_TXCLK_DELAY | \
+                              S17_MAC6_RGMII_RXCLK_DELAY | (1 << S17_MAC6_RGMII_TXCLK_SHIFT) | \
+                              (2 << S17_MAC6_RGMII_RXCLK_SHIFT));
+	athrs17_reg_write(S17_P6STATUS_REG, 0x7e);	
+        athrs17_vlan_config();
+#endif
+	athr17_init_flag = 1;
+	printf("%s: complete\n",__func__);
+}
+
+/******************************************************************************
+*
+* athrs17_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs17_phy_is_link_alive(int phyUnit)
+{
+	uint16_t phyHwStatus;
+	uint32_t phyBase;
+	uint32_t phyAddr;
+
+	phyBase = ATHR_PHYBASE(phyUnit);
+	phyAddr = ATHR_PHYADDR(phyUnit);
+
+	phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+	if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+		return TRUE;
+
+	return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs17_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs17_phy_setup(int ethUnit)
+{
+	int       phyUnit;
+	uint16_t  phyHwStatus;
+	uint16_t  timeout;
+	int       liveLinks = 0;
+	uint32_t  phyBase = 0;
+	BOOL      foundPhy = FALSE;
+	uint32_t  phyAddr = 0;
+
+	/* See if there's any configuration data for this enet */
+	/* start auto negogiation on each phy */
+	if (is_drqfn()) 
+		ethUnit=0;
+	for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+
+		foundPhy = TRUE;
+		phyBase = ATHR_PHYBASE(phyUnit);
+		phyAddr = ATHR_PHYADDR(phyUnit);
+
+		phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,
+				ATHR_ADVERTISE_ALL);
+
+		phy_reg_write(phyBase, phyAddr, ATHR_1000BASET_CONTROL,
+				ATHR_ADVERTISE_1000FULL);
+
+		/* Reset PHYs*/
+		phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+				ATHR_CTRL_AUTONEGOTIATION_ENABLE
+				| ATHR_CTRL_SOFTWARE_RESET);
+
+	}
+
+	if (!foundPhy) {
+		return FALSE; /* No PHY's configured for this ethUnit */
+	}
+
+	/*
+	 * After the phy is reset, it takes a little while before
+	 * it can respond properly.
+	 */
+	sysMsDelay(1000);
+
+
+	/*
+	 * Wait up to 3 seconds for ALL associated PHYs to finish
+	 * autonegotiation.  The only way we get out of here sooner is
+	 * if ALL PHYs are connected AND finish autonegotiation.
+	 */
+	for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+
+		timeout=20;
+		for (;;) {
+			phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+			if (ATHR_RESET_DONE(phyHwStatus)) {
+				DRV_PRINT(DRV_DEBUG_PHYSETUP,
+						("Port %d, Neg Success\n", phyUnit));
+				break;
+			}
+			if (timeout == 0) {
+				DRV_PRINT(DRV_DEBUG_PHYSETUP,
+						("Port %d, Negogiation timeout\n", phyUnit));
+				break;
+			}
+			if (--timeout == 0) {
+				DRV_PRINT(DRV_DEBUG_PHYSETUP,
+						("Port %d, Negogiation timeout\n", phyUnit));
+				break;
+			}
+
+			sysMsDelay(150);
+		}
+	}
+
+	/*
+	 * All PHYs have had adequate time to autonegotiate.
+	 * Now initialize software status.
+	 *
+	 * It's possible that some ports may take a bit longer
+	 * to autonegotiate; but we can't wait forever.  They'll
+	 * get noticed by mv_phyCheckStatusChange during regular
+	 * polling activities.
+	 */
+	for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+#if 0
+		/* Enable RGMII */
+		phy_reg_write(0,phyUnit,0x1d,0x12);
+		phy_reg_write(0,phyUnit,0x1e,0x8);
+		/* Tx delay on PHY */
+		phy_reg_write(0,phyUnit,0x1d,0x5);
+		phy_reg_write(0,phyUnit,0x1e,0x100);
+
+		/* Rx delay on PHY */
+		phy_reg_write(0,phyUnit,0x1d,0x0);
+		phy_reg_write(0,phyUnit,0x1e,0x8000);
+#endif
+		if (athrs17_phy_is_link_alive(phyUnit)) {
+			liveLinks++;
+			ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+		} else {
+			ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+		}
+
+		DRV_PRINT(DRV_DEBUG_PHYSETUP,
+				("eth%d: Phy Specific Status=%4.4x\n",
+				 ethUnit,
+				 phy_reg_read(ATHR_PHYBASE(phyUnit),
+					 ATHR_PHYADDR(phyUnit),
+					 ATHR_PHY_SPEC_STATUS)));
+	}
+	phy_mode_setup();
+	return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs17_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs17_phy_is_fdx(int ethUnit)
+{
+	int       phyUnit;
+	uint32_t  phyBase;
+	uint32_t  phyAddr;
+	uint16_t  phyHwStatus;
+	int       ii = 200;
+
+
+	if (is_drqfn())
+		ethUnit = 0;
+
+
+	for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+
+		if (athrs17_phy_is_link_alive(phyUnit)) {
+
+			phyBase = ATHR_PHYBASE(phyUnit);
+			phyAddr = ATHR_PHYADDR(phyUnit);
+
+			do {
+				phyHwStatus = phy_reg_read (phyBase, phyAddr,
+						ATHR_PHY_SPEC_STATUS);
+				if(phyHwStatus & ATHR_STATUS_RESOVLED)
+					break;
+				sysMsDelay(10);
+			} while(--ii);
+
+			if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+				return TRUE;
+		}
+	}
+
+	if (ethUnit == ENET_UNIT_GE0 || ethUnit == ENET_UNIT_GE1)
+		return TRUE;
+
+	return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs17_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS: _10BASET, _100BASETX, _1000BASET
+*/
+
+int
+athrs17_phy_speed(int ethUnit)
+{
+	int       phyUnit;
+	uint16_t  phyHwStatus;
+	uint32_t  phyBase;
+	uint32_t  phyAddr;
+	int       ii = 200;
+
+	if ((ethUnit == ENET_UNIT_GE0) || (ethUnit == ENET_UNIT_GE1))
+		return _1000BASET;
+
+	for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+
+		if (athrs17_phy_is_link_alive(phyUnit)) {
+
+			phyBase = ATHR_PHYBASE(phyUnit);
+			phyAddr = ATHR_PHYADDR(phyUnit);
+
+			do {
+				phyHwStatus = phy_reg_read(phyBase, phyAddr,
+						ATHR_PHY_SPEC_STATUS);
+				if(phyHwStatus & ATHR_STATUS_RESOVLED)
+					break;
+				sysMsDelay(10);
+			} while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+			phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+					ATHER_STATUS_LINK_SHIFT);
+
+			switch(phyHwStatus) {
+			case 0: return _10BASET;
+			case 1: return _100BASET;
+			case 2: return _1000BASET;
+			default: printf("Unkown speed read!\n");
+			}
+		}
+
+	}
+
+	return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs17_phy_is_up(int ethUnit)
+{
+	int           phyUnit;
+	uint16_t      phyHwStatus, phyHwControl;
+	athrPhyInfo_t *lastStatus;
+	int           linkCount   = 0;
+	int           lostLinks   = 0;
+	int           gainedLinks = 0;
+	uint32_t      phyBase;
+	uint32_t      phyAddr;
+
+	if (is_drqfn()) 
+		ethUnit = 0;
+	for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+
+		phyBase = ATHR_PHYBASE(phyUnit);
+		phyAddr = ATHR_PHYADDR(phyUnit);
+
+		lastStatus = &athrPhyInfo[phyUnit];
+
+		if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+			phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+			/* See if we've lost link */
+			if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+				linkCount++;
+			} else {
+				lostLinks++;
+				DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+							ethUnit, phyUnit));
+				lastStatus->isPhyAlive = FALSE;
+			}
+		} else { /* last known link status was DEAD */
+			/* Check for reset complete */
+			phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS);
+			if (!ATHR_RESET_DONE(phyHwStatus)) {
+				continue;
+			}
+
+			phyHwControl = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+			/* Check for AutoNegotiation complete */
+			if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+					|| ATHR_AUTONEG_DONE(phyHwStatus)) {
+				phyHwStatus = phy_reg_read(phyBase, phyAddr,
+						ATHR_PHY_SPEC_STATUS);
+
+				if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+					gainedLinks++;
+					linkCount++;
+					DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+								ethUnit, phyUnit));
+					lastStatus->isPhyAlive = TRUE;
+				}
+			}
+		}
+	}
+
+	return (linkCount);
+
+}
+
+uint32_t
+athrs17_reg_read(uint32_t reg_addr)
+{
+	uint32_t reg_word_addr;
+	uint32_t phy_addr, tmp_val, reg_val;
+	uint16_t phy_val;
+	uint8_t phy_reg;
+
+	/* change reg_addr to 16-bit word address, 32-bit aligned */
+	reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+	/* configure register high address */
+	phy_addr = 0x18;
+	phy_reg = 0x0;
+	phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+	phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+	/* For some registers such as MIBs, since it is read/clear, we should */
+	/* read the lower 16-bit register then the higher one */
+
+	/* read register in lower address */
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+	reg_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+
+	/* read register in higher address */
+	reg_word_addr++;
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+	tmp_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+	reg_val |= (tmp_val << 16);
+
+	return reg_val;
+}
+
+void
+athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val)
+{
+	uint32_t reg_word_addr;
+	uint32_t phy_addr;
+	uint16_t phy_val;
+	uint8_t phy_reg;
+
+	/* change reg_addr to 16-bit word address, 32-bit aligned */
+	reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+	/* configure register high address */
+	phy_addr = 0x18;
+	phy_reg = 0x0;
+	phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+	phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+	/* For some registers such as ARL and VLAN, since they include BUSY bit */
+	/* in lower address, we should write the higher 16-bit register then the */
+	/* lower one */
+
+	/* read register in higher address */
+	reg_word_addr++;
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+	phy_val = (uint16_t) ((reg_val >> 16) & 0xffff);
+	phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+	/* write register in lower address */
+	reg_word_addr--;
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+	phy_val = (uint16_t) (reg_val & 0xffff);
+	phy_reg_write(0, phy_addr, phy_reg, phy_val);
+}
diff --git a/board/atheros/common/athrs17_phy.h b/board/atheros/common/athrs17_phy.h
new file mode 100644
index 0000000000..c3fc3df6b5
--- /dev/null
+++ b/board/atheros/common/athrs17_phy.h
@@ -0,0 +1,555 @@
+#ifndef _ATHRS17_PHY_H
+#define _ATHRS17_PHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+/* S17 CSR Registers */
+
+#define S17_ENABLE_CPU_BROADCAST             (1 << 26)
+
+#define S17_PHY_LINK_CHANGE_REG 		     0x4
+#define S17_PHY_LINK_UP 		             0x400
+#define S17_PHY_LINK_DOWN 		             0x800
+#define S17_PHY_LINK_DUPLEX_CHANGE 		     0x2000
+#define S17_PHY_LINK_SPEED_CHANGE		     0x4000
+#define S17_PHY_LINK_INTRS			     (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+//defines from athrs17_phy.h driver
+
+#define S17_MASK_CTRL_REG               0x0000
+#define S17_P0PAD_MODE_REG              0x0004
+#define S17_P5PAD_MODE_REG              0x0008
+#define S17_P6PAD_MODE_REG              0x000c
+#define S17_PWS_REG                     0x0010
+#define S17_GLOBAL_INT0_REG             0x0020
+#define S17_GLOBAL_INT1_REG             0x0024
+#define S17_GLOBAL_INTMASK0             0x0028
+#define S17_GLOBAL_INTMASK1             0x002c
+#define S17_MODULE_EN_REG               0x0030
+#define S17_MIB_REG                     0x0034
+#define S17_INTF_HIADDR_REG             0x0038
+#define S17_MDIO_CTRL_REG               0x003c
+#define S17_BIST_CTRL_REG               0x0040
+#define S17_BIST_REC_REG                0x0044
+#define S17_SERVICE_REG                 0x0048
+#define S17_LED_CTRL0_REG               0x0050
+#define S17_LED_CTRL1_REG               0x0054
+#define S17_LED_CTRL2_REG               0x0058
+#define S17_LED_CTRL3_REG               0x005c
+#define S17_MACADDR0_REG                0x0060
+#define S17_MACADDR1_REG                0x0064
+#define S17_MAX_FRAME_SIZE_REG          0x0078
+#define S17_P0STATUS_REG                0x007c
+#define S17_P1STATUS_REG                0x0080
+#define S17_P2STATUS_REG                0x0084
+#define S17_P3STATUS_REG                0x0088
+#define S17_P4STATUS_REG                0x008c
+#define S17_P5STATUS_REG                0x0090
+#define S17_P6STATUS_REG                0x0094
+#define S17_HDRCTRL_REG                 0x0098
+#define S17_P0HDRCTRL_REG               0x009c
+#define S17_P1HDRCTRL_REG               0x00A0
+#define S17_P2HDRCTRL_REG               0x00a4
+#define S17_P3HDRCTRL_REG               0x00a8
+#define S17_P4HDRCTRL_REG               0x00ac
+#define S17_P5HDRCTRL_REG               0x00b0
+#define S17_P6HDRCTRL_REG               0x00b4
+#define S17_SGMII_CTRL_REG              0x00e0
+#define S17_EEE_CTRL_REG		0x0100
+
+/* ACL Registers */
+#define S17_ACL_FUNC0_REG               0x0400
+#define S17_ACL_FUNC1_REG               0x0404
+#define S17_ACL_FUNC2_REG               0x0408
+#define S17_ACL_FUNC3_REG               0x040c
+#define S17_ACL_FUNC4_REG               0x0410
+#define S17_ACL_FUNC5_REG               0x0414
+#define S17_PRIVATE_IP_REG              0x0418
+#define S17_P0VLAN_CTRL0_REG            0x0420
+#define S17_P0VLAN_CTRL1_REG            0x0424
+#define S17_P1VLAN_CTRL0_REG            0x0428
+#define S17_P1VLAN_CTRL1_REG            0x042c
+#define S17_P2VLAN_CTRL0_REG            0x0430
+#define S17_P2VLAN_CTRL1_REG            0x0434
+#define S17_P3VLAN_CTRL0_REG            0x0438
+#define S17_P3VLAN_CTRL1_REG            0x043c
+#define S17_P4VLAN_CTRL0_REG            0x0440
+#define S17_P4VLAN_CTRL1_REG            0x0444
+#define S17_P5VLAN_CTRL0_REG            0x0448
+#define S17_P5VLAN_CTRL1_REG            0x044c
+#define S17_P6VLAN_CTRL0_REG            0x0450
+#define S17_P6VLAN_CTRL1_REG            0x0454
+
+/* Table Lookup Registers */
+#define S17_ATU_DATA0_REG               0x0600
+#define S17_ATU_DATA1_REG               0x0604
+#define S17_ATU_DATA2_REG               0x0608
+#define S17_ATU_FUNC_REG                0x060C
+#define S17_VTU_FUNC0_REG               0x0610
+#define S17_VTU_FUNC1_REG               0x0614
+#define S17_ARL_CTRL_REG                0x0618
+#define S17_GLOFW_CTRL0_REG             0x0620
+#define S17_GLOFW_CTRL1_REG             0x0624
+#define S17_GLOLEARN_LIMIT_REG          0x0628
+#define S17_TOS_PRIMAP_REG0             0x0630
+#define S17_TOS_PRIMAP_REG1             0x0634
+#define S17_TOS_PRIMAP_REG2             0x0638
+#define S17_TOS_PRIMAP_REG3             0x063c
+#define S17_TOS_PRIMAP_REG4             0x0640
+#define S17_TOS_PRIMAP_REG5             0x0644
+#define S17_TOS_PRIMAP_REG6             0x0648
+#define S17_TOS_PRIMAP_REG7             0x064c
+#define S17_VLAN_PRIMAP_REG0            0x0650
+#define S17_LOOP_CHECK_REG              0x0654
+#define S17_P0LOOKUP_CTRL_REG           0x0660
+#define S17_P0PRI_CTRL_REG              0x0664
+#define S17_P0LEARN_LMT_REG             0x0668
+#define S17_P1LOOKUP_CTRL_REG           0x066c
+#define S17_P1PRI_CTRL_REG              0x0670
+#define S17_P1LEARN_LMT_REG             0x0674
+#define S17_P2LOOKUP_CTRL_REG           0x0678
+#define S17_P2PRI_CTRL_REG              0x067c
+#define S17_P2LEARN_LMT_REG             0x0680
+#define S17_P3LOOKUP_CTRL_REG           0x0684
+#define S17_P3PRI_CTRL_REG              0x0688
+#define S17_P3LEARN_LMT_REG             0x068c
+#define S17_P4LOOKUP_CTRL_REG           0x0690
+#define S17_P4PRI_CTRL_REG              0x0694
+#define S17_P4LEARN_LMT_REG             0x0698
+#define S17_P5LOOKUP_CTRL_REG           0x069c
+#define S17_P5PRI_CTRL_REG              0x06a0
+#define S17_P5LEARN_LMT_REG             0x06a4
+#define S17_P6LOOKUP_CTRL_REG           0x06a8
+#define S17_P6PRI_CTRL_REG              0x06ac
+#define S17_P6LEARN_LMT_REG             0x06b0
+#define S17_GLO_TRUNK_CTRL0_REG         0x0700
+#define S17_GLO_TRUNK_CTRL1_REG         0x0704
+#define S17_GLO_TRUNK_CTRL2_REG         0x0708
+
+/* Queue Management Registers */
+#define S17_PORT0_HOL_CTRL0		0x0970
+#define S17_PORT0_HOL_CTRL1		0x0974
+#define S17_PORT1_HOL_CTRL0		0x0978
+#define S17_PORT1_HOL_CTRL1		0x097c
+#define S17_PORT2_HOL_CTRL0		0x0980
+#define S17_PORT2_HOL_CTRL1		0x0984
+#define S17_PORT3_HOL_CTRL0		0x0988
+#define S17_PORT3_HOL_CTRL1		0x098c
+#define S17_PORT4_HOL_CTRL0		0x0990
+#define S17_PORT4_HOL_CTRL1		0x0994
+#define S17_PORT5_HOL_CTRL0		0x0998
+#define S17_PORT5_HOL_CTRL1		0x099c
+#define S17_PORT6_HOL_CTRL0		0x09a0
+#define S17_PORT6_HOL_CTRL1		0x09a4
+
+/* Port flow control registers */
+#define S17_P0_FLCTL_REG		0x09b0
+#define S17_P1_FLCTL_REG		0x09b4
+#define S17_P2_FLCTL_REG		0x09b8
+#define S17_P3_FLCTL_REG		0x09bc
+#define S17_P4_FLCTL_REG		0x09c0
+#define S17_P5_FLCTL_REG		0x09c4
+
+/* Packet Edit registers */
+#define S17_PKT_EDIT_CTRL		0x0c00
+#define S17_P0Q_REMAP_REG0		0x0c40
+#define S17_P0Q_REMAP_REG1		0x0c44
+#define S17_P1Q_REMAP_REG0		0x0c48
+#define S17_P2Q_REMAP_REG0		0x0c4c
+#define S17_P3Q_REMAP_REG0		0x0c50
+#define S17_P4Q_REMAP_REG0		0x0c54
+#define S17_P5Q_REMAP_REG0		0x0c58
+#define S17_P5Q_REMAP_REG1		0x0c5c
+#define S17_P6Q_REMAP_REG0		0x0c60
+#define S17_P6Q_REMAP_REG1		0x0c64
+#define S17_ROUTER_VID0			0x0c70
+#define S17_ROUTER_VID1			0x0c74
+#define S17_ROUTER_VID2			0x0c78
+#define S17_ROUTER_VID3			0x0c7c
+#define S17_ROUTER_EG_VLAN_MODE		0x0c80
+
+/* L3 Registers */
+#define S17_HROUTER_CTRL_REG            0x0e00
+#define S17_HROUTER_PBCTRL0_REG         0x0e04
+#define S17_HROUTER_PBCTRL1_REG         0x0e08
+#define S17_HROUTER_PBCTRL2_REG         0x0e0c
+#define S17_WCMP_HASH_TABLE0_REG        0x0e10
+#define S17_WCMP_HASH_TABLE1_REG        0x0e14
+#define S17_WCMP_HASH_TABLE2_REG        0x0e18
+#define S17_WCMP_HASH_TABLE3_REG        0x0e1c
+#define S17_WCMP_NHOP_TABLE0_REG        0x0e20
+#define S17_WCMP_NHOP_TABLE1_REG        0x0e24
+#define S17_WCMP_NHOP_TABLE2_REG        0x0e28
+#define S17_WCMP_NHOP_TABLE3_REG        0x0e2c
+#define S17_ARP_ENTRY_CTRL_REG          0x0e30
+#define S17_ARP_USECNT_REG              0x0e34
+#define S17_HNAT_CTRL_REG               0x0e38
+#define S17_NAPT_ENTRY_CTRL0_REG        0x0e3c
+#define S17_NAPT_ENTRY_CTRL1_REG        0x0e40
+#define S17_NAPT_USECNT_REG             0x0e44
+#define S17_ENTRY_EDIT_DATA0_REG        0x0e48
+#define S17_ENTRY_EDIT_DATA1_REG        0x0e4c
+#define S17_ENTRY_EDIT_DATA2_REG        0x0e50
+#define S17_ENTRY_EDIT_DATA3_REG        0x0e54
+#define S17_ENTRY_EDIT_CTRL_REG         0x0e58
+#define S17_HNAT_PRIVATE_IP_REG         0x0e5c
+
+/* MIB counters */
+#define S17_MIB_PORT0			0x1000
+#define S17_MIB_PORT1			0x1100
+#define S17_MIB_PORT2			0x1200
+#define S17_MIB_PORT3			0x1300
+#define S17_MIB_PORT4			0x1400
+#define S17_MIB_PORT5			0x1500
+#define S17_MIB_PORT6			0x1600
+
+#define S17_MIB_RXBROAD			0x0
+#define S17_MIB_RXPAUSE			0x4
+#define S17_MIB_RXMULTI			0x8
+#define S17_MIB_RXFCSERR		0xC
+#define S17_MIB_RXALIGNERR		0x10
+#define S17_MIB_RXUNDERSIZE		0x14
+#define S17_MIB_RXFRAG			0x18
+#define S17_MIB_RX64B			0x1C
+#define S17_MIB_RX128B			0x20
+#define S17_MIB_RX256B			0x24
+#define S17_MIB_RX512B			0x28
+#define S17_MIB_RX1024B			0x2C
+#define S17_MIB_RX1518B			0x30
+#define S17_MIB_RXMAXB			0x34
+#define S17_MIB_RXTOOLONG		0x38
+#define S17_MIB_RXBYTE1			0x3C
+#define S17_MIB_RXBYTE2			0x40
+#define S17_MIB_RXOVERFLOW		0x4C
+#define S17_MIB_FILTERED		0x50
+#define S17_MIB_TXBROAD			0x54
+#define S17_MIB_TXPAUSE			0x58
+#define S17_MIB_TXMULTI			0x5C
+#define S17_MIB_TXUNDERRUN		0x60
+#define S17_MIB_TX64B			0x64
+#define S17_MIB_TX128B			0x68
+#define S17_MIB_TX256B			0x6c
+#define S17_MIB_TX512B			0x70
+#define S17_MIB_TX1024B			0x74
+#define S17_MIB_TX1518B			0x78
+#define S17_MIB_TXMAXB			0x7C
+#define S17_MIB_TXOVERSIZE		0x80
+#define S17_MIB_TXBYTE1			0x84
+#define S17_MIB_TXBYTE2			0x88
+#define S17_MIB_TXCOL			0x8C
+#define S17_MIB_TXABORTCOL		0x90
+#define S17_MIB_TXMULTICOL		0x94
+#define S17_MIB_TXSINGLECOL		0x98
+#define S17_MIB_TXEXCDEFER		0x9C
+#define S17_MIB_TXDEFER			0xA0
+#define S17_MIB_TXLATECOL		0xA4
+
+/* Register fields */
+#define S17_CHIPID_V1_0			0x1201
+#define S17_CHIPID_V1_1			0x1202
+
+#define S17_MAC0_MAC_MII_RXCLK_SEL	(1 << 0)
+#define S17_MAC0_MAC_MII_TXCLK_SEL	(1 << 1)
+#define S17_MAC0_MAC_MII_EN		(1 << 2)
+#define S17_MAC0_MAC_GMII_RXCLK_SEL	(1 << 4)
+#define S17_MAC0_MAC_GMII_TXCLK_SEL	(1 << 5)
+#define S17_MAC0_MAC_GMII_EN		(1 << 6)
+#define S17_MAC0_SGMII_EN		(1 << 7)
+#define S17_MAC0_PHY_MII_RXCLK_SEL	(1 << 8)
+#define S17_MAC0_PHY_MII_TXCLK_SEL	(1 << 9)
+#define S17_MAC0_PHY_MII_EN		(1 << 10)
+#define S17_MAC0_PHY_MII_PIPE_SEL	(1 << 11)
+#define S17_MAC0_PHY_GMII_RXCLK_SEL	(1 << 12)
+#define S17_MAC0_PHY_GMII_TXCLK_SEL	(1 << 13)
+#define S17_MAC0_PHY_GMII_EN		(1 << 14)
+#define S17_MAC0_RGMII_RXCLK_SHIFT	20
+#define S17_MAC0_RGMII_TXCLK_SHIFT	22
+#define S17_MAC0_RGMII_RXCLK_DELAY	(1 << 24)
+#define S17_MAC0_RGMII_TXCLK_DELAY	(1 << 25)
+#define S17_MAC0_RGMII_EN		(1 << 26)
+
+#define S17_MAC5_MAC_MII_RXCLK_SEL	(1 << 0)
+#define S17_MAC5_MAC_MII_TXCLK_SEL	(1 << 1)
+#define S17_MAC5_MAC_MII_EN		(1 << 2)
+#define S17_MAC5_PHY_MII_RXCLK_SEL	(1 << 8)
+#define S17_MAC5_PHY_MII_TXCLK_SEL	(1 << 9)
+#define S17_MAC5_PHY_MII_EN		(1 << 10)
+#define S17_MAC5_PHY_MII_PIPE_SEL	(1 << 11)
+#define S17_MAC5_RGMII_RXCLK_SHIFT	20
+#define S17_MAC5_RGMII_TXCLK_SHIFT	22
+#define S17_MAC5_RGMII_RXCLK_DELAY	(1 << 24)
+#define S17_MAC5_RGMII_TXCLK_DELAY	(1 << 25)
+#define S17_MAC5_RGMII_EN		(1 << 26)
+
+#define S17_MAC6_MAC_MII_RXCLK_SEL	(1 << 0)
+#define S17_MAC6_MAC_MII_TXCLK_SEL	(1 << 1)
+#define S17_MAC6_MAC_MII_EN		(1 << 2)
+#define S17_MAC6_MAC_GMII_RXCLK_SEL	(1 << 4)
+#define S17_MAC6_MAC_GMII_TXCLK_SEL	(1 << 5)
+#define S17_MAC6_MAC_GMII_EN		(1 << 6)
+#define S17_MAC6_SGMII_EN		(1 << 7)
+#define S17_MAC6_PHY_MII_RXCLK_SEL	(1 << 8)
+#define S17_MAC6_PHY_MII_TXCLK_SEL	(1 << 9)
+#define S17_MAC6_PHY_MII_EN		(1 << 10)
+#define S17_MAC6_PHY_MII_PIPE_SEL	(1 << 11)
+#define S17_MAC6_PHY_GMII_RXCLK_SEL	(1 << 12)
+#define S17_MAC6_PHY_GMII_TXCLK_SEL	(1 << 13)
+#define S17_MAC6_PHY_GMII_EN		(1 << 14)
+#define S17_PHY4_GMII_EN		(1 << 16)
+#define S17_PHY4_RGMII_EN		(1 << 17)
+#define S17_PHY4_MII_EN			(1 << 18)
+#define S17_MAC6_RGMII_RXCLK_SHIFT	20
+#define S17_MAC6_RGMII_TXCLK_SHIFT	22
+#define S17_MAC6_RGMII_RXCLK_DELAY	(1 << 24)
+#define S17_MAC6_RGMII_TXCLK_DELAY	(1 << 25)
+#define S17_MAC6_RGMII_EN		(1 << 26)
+
+#define S17_SPEED_10M			(0 << 0)
+#define S17_SPEED_100M			(1 << 0)
+#define S17_SPEED_1000M			(2 << 0)
+#define S17_TXMAC_EN			(1 << 2)
+#define S17_RXMAC_EN			(1 << 3)
+#define S17_TX_FLOW_EN			(1 << 4)
+#define S17_RX_FLOW_EN			(1 << 5)
+#define S17_DUPLEX_FULL			(1 << 6)
+#define S17_DUPLEX_HALF			(0 << 6)
+#define S17_TX_HALF_FLOW_EN		(1 << 7)
+#define S17_LINK_EN			(1 << 9)
+#define S17_FLOW_LINK_EN		(1 << 12)
+#define S17_PORT_STATUS_DEFAULT		(S17_SPEED_1000M | S17_TXMAC_EN | \
+                                        S17_RXMAC_EN | S17_TX_FLOW_EN | \
+                                        S17_RX_FLOW_EN | S17_DUPLEX_FULL | \
+                                        S17_TX_HALF_FLOW_EN)
+
+#define S17_PORT_STATUS_AZ_DEFAULT	(S17_SPEED_1000M | S17_TXMAC_EN | \
+                                        S17_RXMAC_EN | S17_TX_FLOW_EN | \
+                                        S17_RX_FLOW_EN | S17_DUPLEX_FULL)
+
+
+#define S17_HDRLENGTH_SEL		(1 << 16)
+#define S17_HDR_VALUE			0xAAAA
+
+#define S17_TXHDR_MODE_NO		0
+#define S17_TXHDR_MODE_MGM		1
+#define S17_TXHDR_MODE_ALL		2
+#define S17_RXHDR_MODE_NO		(0 << 2)
+#define S17_RXHDR_MODE_MGM		(1 << 2)
+#define S17_RXHDR_MODE_ALL		(2 << 2)
+
+#define S17_CPU_PORT_EN			(1 << 10)
+#define S17_PPPOE_REDIR_EN		(1 << 8)
+#define S17_MIRROR_PORT_SHIFT		4
+#define S17_IGMP_COPY_EN		(1 << 3)
+#define S17_RIP_COPY_EN			(1 << 2)
+#define S17_EAPOL_REDIR_EN		(1 << 0)
+
+#define S17_IGMP_JOIN_LEAVE_DP_SHIFT	24
+#define S17_BROAD_DP_SHIFT		16
+#define S17_MULTI_FLOOD_DP_SHIFT	8
+#define S17_UNI_FLOOD_DP_SHIFT		0
+#define S17_IGMP_JOIN_LEAVE_DPALL	(0x7f << S17_IGMP_JOIN_LEAVE_DP_SHIFT)
+#define S17_BROAD_DPALL			(0x7f << S17_BROAD_DP_SHIFT)
+#define S17_MULTI_FLOOD_DPALL		(0x7f << S17_MULTI_FLOOD_DP_SHIFT)
+#define S17_UNI_FLOOD_DPALL		(0x7f << S17_UNI_FLOOD_DP_SHIFT)
+
+#define S17_PWS_CHIP_AR8327             (1 << 30)
+
+/* S17_PHY_CONTROL fields */
+#define S17_CTRL_SOFTWARE_RESET                    0x8000
+#define S17_CTRL_SPEED_LSB                         0x2000
+#define S17_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define S17_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define S17_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define S17_CTRL_SPEED_MSB                         0x0040
+
+/* For EEE_CTRL_REG */
+#define S17_LPI_DISABLE_P1		     (1 << 4)
+#define S17_LPI_DISABLE_P2		     (1 << 6)
+#define S17_LPI_DISABLE_P3		     (1 << 8)
+#define S17_LPI_DISABLE_P4		     (1 << 10)
+#define S17_LPI_DISABLE_P5		     (1 << 12)
+#define S17_LPI_DISABLE_ALL		     0x1550
+
+/* For MMD register control */
+#define S17_MMD_FUNC_ADDR			(0 << 14)
+#define S17_MMD_FUNC_DATA			(1 << 14)
+#define S17_MMD_FUNC_DATA_2			(2 << 14)
+#define S17_MMD_FUNC_DATA_3			(3 << 14)
+
+/* For phyInfo_t azFeature */
+#define S17_8023AZ_PHY_ENABLED			(1 << 0)
+#define S17_8023AZ_PHY_LINKED                   (1 << 1)
+
+/* Queue Management registe fields */
+#define S17_HOL_CTRL0_LAN		0x2a008888 /* egress priority 8, eg_portq = 0x2a */
+#define S17_HOL_CTRL0_WAN		0x2a666666 /* egress priority 6, eg_portq = 0x2a */
+#define S17_HOL_CTRL1_DEFAULT		0xc6	   /* enable HOL control */
+
+/* Packet Edit register fields */
+#define S17_ROUTER_EG_UNMOD		0x0	/* unmodified */
+#define S17_ROUTER_EG_WOVLAN		0x1	/* without VLAN */
+#define S17_ROUTER_EG_WVLAN		0x2	/* with VLAN */
+#define S17_ROUTER_EG_UNTOUCH		0x3	/* untouched */
+#define S17_ROUTER_EG_MODE_DEFAULT	0x01111111 /* all ports without VLAN */
+
+#define S17_RESET_DONE(phy_control)                   \
+    (((phy_control) & (S17_CTRL_SOFTWARE_RESET)) == 0)
+    
+/* Phy status fields */
+#define S17_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define S17_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (S17_STATUS_AUTO_NEG_DONE)) ==                    \
+        (S17_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define S17_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define S17_LINK_100BASETX                   0x0080
+#define S17_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define S17_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define S17_ADVERTISE_NEXT_PAGE              0x8000
+#define S17_ADVERTISE_ASYM_PAUSE             0x0800
+#define S17_ADVERTISE_PAUSE                  0x0400
+#define S17_ADVERTISE_100FULL                0x0100
+#define S17_ADVERTISE_100HALF                0x0080  
+#define S17_ADVERTISE_10FULL                 0x0040  
+#define S17_ADVERTISE_10HALF                 0x0020  
+
+#define S17_ADVERTISE_ALL (S17_ADVERTISE_ASYM_PAUSE | S17_ADVERTISE_PAUSE | \
+                            S17_ADVERTISE_10HALF | S17_ADVERTISE_10FULL | \
+                            S17_ADVERTISE_100HALF | S17_ADVERTISE_100FULL)
+                       
+/* 1000BASET_CONTROL */
+#define S17_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define S17_STATUS_LINK_MASK                0xC000
+#define S17_STATUS_LINK_SHIFT               14
+#define S17_STATUS_FULL_DEPLEX              0x2000
+#define S17_STATUS_LINK_PASS                 0x0400 
+#define S17_STATUS_RESOLVED                  0x0800
+#define S17_STATUS_LINK_10M			 0
+#define S17_STATUS_LINK_100M			 1
+#define S17_STATUS_LINK_1000M			 2
+
+#define S17_GLOBAL_INT_PHYMASK	 	     (1 << 15)
+
+#define S17_PHY_LINK_UP 		     0x400
+#define S17_PHY_LINK_DOWN 		     0x800
+#define S17_PHY_LINK_DUPLEX_CHANGE 	     0x2000
+#define S17_PHY_LINK_SPEED_CHANGE	     0x4000
+
+/* For Port flow control registers */
+#define S17_PORT_FLCTL_XON_DEFAULT		(0x3a << 16)
+#define S17_PORT_FLCTL_XOFF_DEFAULT		(0x4a)
+
+/* Module enable Register */
+#define S17_MODULE_L3_EN		(1 << 2)
+#define S17_MODULE_ACL_EN		(1 << 1)
+#define S17_MODULE_MIB_EN		(1 << 0)
+
+/* MIB Function Register 1 */
+#define S17_MIB_FUNC_ALL		(3 << 24)
+#define S17_MIB_CPU_KEEP		(1 << 20)
+#define S17_MIB_BUSY			(1 << 17)
+#define S17_MIB_AT_HALF_EN		(1 << 16)
+#define S17_MIB_TIMER_DEFAULT		0x100
+
+#define S17_MAC_MAX			7
+
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+/*add feature define here*/
+//#define FULL_FEATURE
+
+#ifdef CONFIG_AR7242_S17_PHY
+#undef HEADER_REG_CONF
+#undef HEADER_EN
+#endif
+
+void athrs17_reg_init(void);
+int athrs17_phy_is_up(int unit);
+int athrs17_phy_is_fdx(int unit);
+int athrs17_phy_speed(int unit);
+BOOL athrs17_phy_setup(int unit);
+
+#endif
+
+
diff --git a/board/atheros/common/athrs_ar8033_phy.h b/board/atheros/common/athrs_ar8033_phy.h
new file mode 100644
index 0000000000..99bbc17ae6
--- /dev/null
+++ b/board/atheros/common/athrs_ar8033_phy.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2010, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ATHRS_8033_PHY_H
+#define _ATHRS_8033_PHY_H
+
+#define BOOL int
+
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400 
+#define ATHR_LATCH_LINK_PASS                  0x0004 
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080  
+#define ATHR_ADVERTISE_10FULL                 0x0040  
+#define ATHR_ADVERTISE_10HALF                 0x0020  
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+
+
+#ifdef ATH_MDC_GPIO
+#define ATH_GPIO	14
+#define GPIO_FUNCTION4_MASK  	(GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK)
+                		 
+#define GPIO_FUNCTION4_ENABLE	(GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(0x20))
+
+
+              			
+#else 
+#define GPIO_FUNCTION4_MASK  	(GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK |\
+                		 GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK)
+
+#define GPIO_FUNCTION4_ENABLE	(GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(0x20) | \
+              			 GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(0x21))
+
+#define ATH_GPIO	19
+#endif
+
+#define ATH_GPIO17 	17
+
+/*
+ *  Atheros header defines
+ */
+#ifndef _ATH_HEADER_CONF
+#define _ATH_HEADER_CONF
+
+
+
+#define ATHR_HEADER_LEN 2
+
+typedef enum {
+    NORMAL_PACKET,
+    RESERVED0,
+    MIB_1ST,
+    RESERVED1,
+    RESERVED2,
+    READ_WRITE_REG,
+    READ_WRITE_REG_ACK,
+    RESERVED3
+} AT_HEADER_TYPE;
+
+#endif // _ATH_HEADER_CONF
+
+#endif
diff --git a/board/atheros/common/athrs_vir_phy.c b/board/atheros/common/athrs_vir_phy.c
new file mode 100644
index 0000000000..c0f2026fe7
--- /dev/null
+++ b/board/atheros/common/athrs_vir_phy.c
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+#define MODULE_NAME "ATHRS_VIR_PHY"
+
+#define TRUE    1
+#define FALSE   0
+#define BOOL	int
+
+/* Forward references */
+BOOL athr_vir_phy_is_link_alive(int phyUnit);
+
+
+/******************************************************************************
+*
+* athr_vir_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_vir_phy_is_link_alive(int phyUnit)
+{
+    return TRUE;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_vir_phy_setup(int ethUnit)
+{
+    return 0;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_vir_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    return TRUE;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_vir_phy_speed(int ethUnit,int phyUnit)
+{
+    return _1000BASET;
+}
+
+/*****************************************************************************
+*
+* athr_vir_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_vir_phy_is_up(int ethUnit)
+{
+    return 1;
+
+}
+/* Place holders */
+
+int 
+athr_vir_reg_init(void *arg)
+{
+   return 0;
+}
+
diff --git a/board/atheros/common/athrsf1_phy.c b/board/atheros/common/athrsf1_phy.c
new file mode 100755
index 0000000000..2f58e615b0
--- /dev/null
+++ b/board/atheros/common/athrsf1_phy.c
@@ -0,0 +1,434 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athrsf1_phy.h"
+
+#define MODULE_NAME "ATHRSF1_PHY"
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY_MAX 5
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+ 
+/* Forward references */
+BOOL athr_phy_is_link_alive(int phyUnit);
+unsigned int last_phy_speed;
+
+void athr_enable_linkIntrs(int ethUnit) 
+{
+    return;
+}
+
+void athr_disable_linkIntrs(int ethUnit) 
+{
+	return;
+}
+void athr_auto_neg(int ethUnit,int phyUnit) 
+{ 
+    int timeout = 0;
+    uint16_t phyHwStatus;
+    
+    if(!is_emu()) {
+#if 0
+       phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+       phy_reg_write(ethUnit, phyUnit , ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+       phy_reg_write(ethUnit, phyUnit , ATHR_1000BASET_CONTROL, ATHR_ADVERTISE_1000FULL);
+#endif
+
+       printf("ATHR_AUTONEG_ADVERT:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_AUTONEG_ADVERT));
+       printf("ATHR_1000BASET_CONTROL:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_1000BASET_CONTROL));
+       printf("ATHR_PHY_CONTROL:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_PHY_CONTROL));
+    }
+    else {
+       phy_reg_write(ethUnit, phyUnit , ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+       /* Do not advertise 1000 */
+       phy_reg_write(ethUnit, phyUnit , ATHR_1000BASET_CONTROL,0x0);
+       phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+   /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    timeout=20;
+    for (;;) {
+        phyHwStatus = phy_reg_read(ethUnit, phyUnit, ATHR_PHY_CONTROL);
+
+        if (ATHR_RESET_DONE(phyHwStatus)) {
+            printf(MODULE_NAME": Port %d, Neg Success\n", phyUnit);
+            break;
+        }
+        if (timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+        if (--timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+
+        mdelay(150);
+    }
+
+    printf(MODULE_NAME": unit %d phy addr %x ", ethUnit, phyUnit);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_phy_is_link_alive(int phyUnit)
+{
+	uint16_t phyHwStatus;
+	uint32_t phyBase;
+	uint32_t phyAddr;
+
+	phyBase = ATHR_PHYBASE(phyUnit);
+	phyAddr = ATHR_PHYADDR(phyUnit);
+	phyHwStatus = phy_reg_read(0, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+	if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_phy_setup(int ethUnit)
+{
+	int       phyUnit = 0;
+	int       liveLinks = 0;
+
+	athr_auto_neg(ethUnit,phyUnit);
+
+	if (athr_phy_is_link_alive(phyUnit)) {
+		liveLinks++;
+		ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+	} else {
+		ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+	}
+	return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+         phyBase = ATHR_PHYBASE(phyUnit);
+         phyAddr = ATHR_PHYADDR(phyUnit);
+
+         do {
+                phyHwStatus = phy_reg_read(ethUnit, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+                mdelay(10);
+          } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+          
+          if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+          }
+    }
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        do {
+            phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+            mdelay(10);
+        } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+        phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                       ATHER_STATUS_LINK_SHIFT);
+
+        switch(phyHwStatus) {
+        case 0:
+	    if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x147);
+                last_phy_speed = phyHwStatus;
+            }
+            return _10BASET;
+        case 1:
+	     if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x147);
+                last_phy_speed = phyHwStatus;
+            }
+            return _100BASET;
+        case 2:
+   	      if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x0);
+                last_phy_speed = phyHwStatus;
+             }
+            return _1000BASET;
+        default:
+            printf("Unkown speed read!\n");
+        }
+    }
+
+      if (last_phy_speed != phyHwStatus)
+    	{
+        phy_reg_write(0, ATHR_PHYADDR(phyUnit), ATHR_DEBUG_PORT_ADDRESS, 0x0);
+        phy_reg_write(0, ATHR_PHYADDR(phyUnit), ATHR_DEBUG_PORT_DATA, 0x14e);
+        last_phy_speed = phyHwStatus;
+     }
+
+
+    //printf("athr_phy_speed: link down, returning 10t\n");
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < 1; phyUnit++) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+
+             phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) { /* check realtime link */
+                linkCount++;
+            } else {
+                phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+            /* If realtime failed check link in latch register before
+	     * asserting link down.
+             */
+                if (phyHwStatus & ATHR_LATCH_LINK_PASS)     
+                   linkCount++;
+		else
+                    lostLinks++;
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+
+            /* Check for reset complete */
+
+                phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+                phyHwControl = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_CONTROL);
+
+            /* Check for AutoNegotiation complete */ 
+           
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE)) 
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                    phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+                    if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                        gainedLinks++;
+                        linkCount++;
+                        lastStatus->isPhyAlive = TRUE;
+                   }  
+            }
+        }
+    }
+    return (linkCount);
+
+}
+/* Place holders */
+
+int 
+athr_reg_init(void *arg)
+{
+   return 0;
+}
+
diff --git a/board/atheros/common/athrsf1_phy.h b/board/atheros/common/athrsf1_phy.h
new file mode 100755
index 0000000000..4495d94f76
--- /dev/null
+++ b/board/atheros/common/athrsf1_phy.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ATHRS26_RGMII_H
+#define _ATHRS26_RGMII_H
+#define BOOL int
+#include "athr_s27_phy.h"
+int athr_phy_is_up(int unit);
+int athr_phy_is_fdx(int unit,int phyUnit);
+int athr_phy_speed(int unit,int phyUnit);
+BOOL athr_phy_setup(int unit);
+BOOL athr_phy_is_link_alive(int phyUnit);
+#endif
diff --git a/board/atheros/common/init-953x.c b/board/atheros/common/init-953x.c
new file mode 100755
index 0000000000..dad78920df
--- /dev/null
+++ b/board/atheros/common/init-953x.c
@@ -0,0 +1,381 @@
+#include <common.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+#define ATH_MAX_DDR_SIZE		(256 * 1024 * 1024)
+#define ATH_DDR_SIZE_INCR		(4 * 1024 * 1024)
+
+int
+ath_ddr_find_size(void)
+{
+	uint8_t  *p = (uint8_t *)KSEG1, pat = 0x77;
+	int i;
+
+#define max_i		(ATH_MAX_DDR_SIZE / ATH_DDR_SIZE_INCR)
+
+	*p = pat;
+
+	/*
+	 * DDR wraps around. Write a pattern to 0x0000_0000. Write an
+	 * address pattern at 4M, 8M, 16M etc. and check when
+	 * 0x0000_0000 gets overwritten.
+	 */
+	for(i = 1; (i < max_i); i++) {
+		*(p + i * ATH_DDR_SIZE_INCR) = (uint8_t)(i);
+		if (*p != pat) {
+			break;
+		}
+	}
+
+	return ((i < max_i) ? (i * ATH_DDR_SIZE_INCR) : ATH_MAX_DDR_SIZE);
+}
+
+inline int
+ath_ram_type(uint32_t bs)
+{
+	if (RST_BOOTSTRAP_DDR_SELECT_GET(bs)) {
+		return ATH_MEM_DDR1;
+	} else {
+		return ATH_MEM_DDR2;
+	}
+}
+
+#define CFG_DDR2_SCORPION_CAS_LATENCY	4
+
+#ifdef CONFIG_TB614
+#	define DDR_CONFIG2_SWAP_A26_A27_VAL	(0x1)
+#else
+#	define DDR_CONFIG2_SWAP_A26_A27_VAL	(0x0)
+#endif
+
+#if CFG_DDR2_SCORPION_CAS_LATENCY == 4
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x1) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x1) | \
+						DDR_CONFIG_TMRD_SET(0xf) | \
+						DDR_CONFIG_TRFC_SET(0x15) | \
+						DDR_CONFIG_TRRD_SET(0x7) | \
+						DDR_CONFIG_TRP_SET(0x9) | \
+						DDR_CONFIG_TRCD_SET(0x9) | \
+						DDR_CONFIG_TRAS_SET(0x1b)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0x8) | \
+						DDR_CONFIG2_TWTR_SET(0x15) | \
+						DDR_CONFIG2_TRTP_SET(0x9) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0x1) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+#define CFG_DDR2_CONFIG3_VAL			0x0000000a
+#define CFG_DDR2_EXT_MODE_VAL			0x402
+#define CFG_DDR2_MODE_VAL_INIT			0x143
+#define CFG_DDR2_MODE_VAL			0x43
+#define CFG_DDR2_TAP_VAL			0x10
+#define CFG_DDR2_EN_TWL_VAL			0x0000167d
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+
+#elif CFG_DDR2_SCORPION_CAS_LATENCY == 5
+
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x1) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x4) | \
+						DDR_CONFIG_TMRD_SET(0xf) | \
+						DDR_CONFIG_TRFC_SET(0x15) | \
+						DDR_CONFIG_TRRD_SET(0x7) | \
+						DDR_CONFIG_TRP_SET(0x9) | \
+						DDR_CONFIG_TRCD_SET(0x9) | \
+						DDR_CONFIG_TRAS_SET(0x1b)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0xb) | \
+						DDR_CONFIG2_TWTR_SET(0x15) | \
+						DDR_CONFIG2_TRTP_SET(0x9) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0x1) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+#define CFG_DDR2_CONFIG3_VAL			0x0000000a
+#define CFG_DDR2_EXT_MODE_VAL			0x402
+#define CFG_DDR2_MODE_VAL_INIT			0x153
+#define CFG_DDR2_MODE_VAL			0x53
+#define CFG_DDR2_TAP_VAL			0x10
+#define CFG_DDR2_EN_TWL_VAL			0x00001e7d
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#endif
+
+#define CFG_DDR1_CONFIG_VAL			DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x7) | \
+						DDR_CONFIG_TMRD_SET(0x5) | \
+						DDR_CONFIG_TRFC_SET(0x7) | \
+						DDR_CONFIG_TRRD_SET(0x4) | \
+						DDR_CONFIG_TRP_SET(0x6) | \
+						DDR_CONFIG_TRCD_SET(0x6) | \
+						DDR_CONFIG_TRAS_SET(0x10)
+
+#define CFG_DDR1_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0x6) | \
+						DDR_CONFIG2_TWTR_SET(0xe) | \
+						DDR_CONFIG2_TRTP_SET(0x8) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0xd) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+#define CFG_DDR1_CONFIG3_VAL			0x0
+#define CFG_DDR1_EXT_MODE_VAL			0x0
+#define CFG_DDR1_MODE_VAL_INIT			0x133
+#define CFG_DDR1_MODE_VAL			0x33
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR1_TAP_VAL			0x20
+
+#define CFG_DDR_CTL_CONFIG			DDR_CTL_CONFIG_SRAM_TSEL_SET(0x1) | \
+						DDR_CTL_CONFIG_GE0_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_GE1_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_USB_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_PCIE_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_WMAC_SRAM_SYNC_SET(0x1)
+
+int /* ram type */
+ath_ddr_initial_config(uint32_t refresh)
+{
+#if !defined(CONFIG_ATH_EMULATION)
+	int		ddr_config, ddr_config2, ddr_config3, ext_mod, mod_val,
+			mod_val_init, cycle_val, tap_val, type, ctl_config;
+	uint32_t	*pll = (unsigned *)PLL_CONFIG_VAL_F;
+	uint32_t	bootstrap;
+
+	prmsg("\nsri\n");
+	prmsg("Honey Bee 1.%d\n", ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf);
+
+	bootstrap = ath_reg_rd(RST_BOOTSTRAP_ADDRESS);
+
+	switch(type = ath_ram_type(bootstrap)) {
+	case ATH_MEM_DDR2:
+		ddr_config	= CFG_DDR2_CONFIG_VAL;
+		ddr_config2	= CFG_DDR2_CONFIG2_VAL;
+		ddr_config3	= CFG_DDR2_CONFIG3_VAL;
+		ext_mod		= CFG_DDR2_EXT_MODE_VAL;
+		mod_val_init	= CFG_DDR2_MODE_VAL_INIT;
+		mod_val		= CFG_DDR2_MODE_VAL;
+		tap_val		= CFG_DDR2_TAP_VAL;
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x10);
+		udelay(10);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x20);
+		udelay(10);
+		prmsg("%s(%d): (", __func__, __LINE__);
+
+		prmsg("16");
+		ctl_config =	CFG_DDR_CTL_CONFIG |
+				CPU_DDR_SYNC_MODE |
+				DDR_CTL_CONFIG_PAD_DDR2_SEL_SET(0x1) |
+				DDR_CTL_CONFIG_HALF_WIDTH_SET(0x1);
+
+		cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16;
+
+		ath_reg_wr_nf(DDR_CTL_CONFIG_ADDRESS, ctl_config);
+
+		prmsg("bit) ddr2 init\n");
+		udelay(10);
+		break;
+	case ATH_MEM_DDR1:
+		ddr_config	= CFG_DDR1_CONFIG_VAL;
+		ddr_config2	= CFG_DDR1_CONFIG2_VAL;
+		ddr_config3	= CFG_DDR1_CONFIG3_VAL;
+		ext_mod		= CFG_DDR1_EXT_MODE_VAL;
+		mod_val_init	= CFG_DDR1_MODE_VAL_INIT;
+		mod_val		= CFG_DDR1_MODE_VAL;
+		tap_val		= CFG_DDR1_TAP_VAL;
+
+		prmsg("%s(%d): (", __func__, __LINE__);
+		prmsg("16");
+		cycle_val = CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16;
+
+		ctl_config =	CFG_DDR_CTL_CONFIG |
+				CPU_DDR_SYNC_MODE |
+				DDR_CTL_CONFIG_HALF_WIDTH_SET(0x1);
+
+		ath_reg_wr_nf(DDR_CTL_CONFIG_ADDRESS, ctl_config);
+		udelay(10);
+		prmsg("bit) ddr1 init\n");
+
+		break;
+	}
+
+	ath_reg_wr_nf(DDR_RD_DATA_THIS_CYCLE_ADDRESS, cycle_val);
+	udelay(100);
+	ath_reg_wr_nf(DDR_BURST_ADDRESS, 0x74444444);
+	udelay(100);
+	ath_reg_wr_nf(DDR_BURST2_ADDRESS, 0x4);
+	udelay(100);
+	ath_reg_wr_nf(DDR_AHB_MASTER_TIMEOUT_MAX_ADDRESS, 0xfffff);
+	udelay(100);
+	ath_reg_wr_nf(DDR_CONFIG_ADDRESS, ddr_config);
+	udelay(100);
+	ath_reg_wr_nf(DDR_CONFIG2_ADDRESS, ddr_config2);
+	udelay(100);
+	ath_reg_wr(DDR_CONFIG_3_ADDRESS, ddr_config3);
+	udelay(100);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR2_CONFIG_ADDRESS, CFG_DDR2_EN_TWL_VAL);
+		udelay(100);
+	}
+
+	ath_reg_wr_nf(DDR_CONFIG2_ADDRESS, ddr_config2 | 0x80);	// CKE Enable
+	udelay(100);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x8);	// Precharge
+	udelay(10);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x10);	// EMR2
+		udelay(10);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x20);	// EMR3
+		udelay(10);
+	}
+
+	if (type == ATH_MEM_DDR1 || type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, CFG_DDR2_EXT_MODE_VAL); // EMR DLL enable, Reduced Driver Impedance control, Differential DQS disabled
+		udelay(100);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(10);
+	}
+
+	ath_reg_wr_nf(DDR_MODE_REGISTER_ADDRESS, mod_val_init);
+	udelay(1000);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x1);	// MR Write
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x8);	// Precharge
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x4);	// Auto Refresh
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x4);	// Auto Refresh
+	udelay(10);
+
+	// Issue MRS to remove DLL out-of-reset
+	ath_reg_wr_nf(DDR_MODE_REGISTER_ADDRESS, mod_val);
+	udelay(100);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x1); // MR write
+	udelay(100);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, 0x782);
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, CFG_DDR2_EXT_MODE_VAL);
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(100);
+	}
+
+	ath_reg_wr_nf(DDR_REFRESH_ADDRESS, refresh);
+	udelay(100);
+
+        ath_reg_wr(TAP_CONTROL_0_ADDRESS, tap_val);
+	ath_reg_wr(TAP_CONTROL_1_ADDRESS, tap_val);
+
+#ifdef CFG_TRAVEL_ROUTER
+	ath_reg_wr(PMU1_ADDRESS, 0x633c8168);
+#else 
+	ath_reg_wr(PMU1_ADDRESS, 0x633c8178);
+#endif 
+
+
+	// Set DDR2 Voltage to 1.8 volts
+	ath_reg_wr(PMU2_ADDRESS, PMU2_SWREGMSB_SET(0x40) | PMU2_PGM_SET(0x1));
+	return type;
+#else	// !emulation
+	return 0;
+#endif
+}
+
+int
+ath_uart_freq(void)
+{
+	//if (ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_REF_CLK_MASK) {
+	//	return 40 * 1000 * 1000;
+	//} else {
+		return 25 * 1000 * 1000;
+	//}
+}
+
+void
+ath_sys_frequency(uint32_t *cpu, uint32_t *ddr, uint32_t *ahb)
+{
+#if !defined(CONFIG_ATH_EMULATION)
+	uint32_t pll, out_div, ref_div, nint, frac, clk_ctrl;
+#endif
+	uint32_t ref;
+	static uint32_t ath_cpu_freq, ath_ddr_freq, ath_ahb_freq;
+
+	if (ath_cpu_freq)
+		goto done;
+
+#ifdef CONFIG_ATH_EMULATION
+	ath_cpu_freq = 80000000;
+	ath_ddr_freq = 80000000;
+	ath_ahb_freq = 40000000;
+#else
+	prmsg("%s: ", __func__);
+
+	clk_ctrl = ath_reg_rd(ATH_DDR_CLK_CTRL);
+
+	pll = ath_reg_rd(ATH_PLL_CONFIG);
+	out_div	= CPU_PLL_CONFIG_OUTDIV_GET(pll);
+	ref_div	= CPU_PLL_CONFIG_REFDIV_GET(pll);
+	nint	= CPU_PLL_CONFIG_NINT_GET(pll);
+	frac	= CPU_PLL_CONFIG_NFRAC_GET(pll);
+	pll = ref >> 6;
+	frac	= frac * pll / ref_div;
+	prmsg("cpu apb ");
+	ath_cpu_freq = (((nint * (ref / ref_div)) + frac) >> out_div) /
+			(CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_GET(clk_ctrl) + 1);
+
+	pll = ath_reg_rd(ATH_DDR_PLL_CONFIG);
+	out_div	= DDR_PLL_CONFIG_OUTDIV_GET(pll);
+	ref_div	= DDR_PLL_CONFIG_REFDIV_GET(pll);
+	nint	= DDR_PLL_CONFIG_NINT_GET(pll);
+	frac	= DDR_PLL_CONFIG_NFRAC_GET(pll);
+	pll = ref >> 10;
+	frac	= frac * pll / ref_div;
+	prmsg("ddr apb ");
+	ath_ddr_freq = (((nint * (ref / ref_div)) + frac) >> out_div) /
+			(CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_GET(clk_ctrl) + 1);
+
+	if (CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_GET(clk_ctrl)) {
+		ath_ahb_freq = ath_ddr_freq /
+			(CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(clk_ctrl) + 1);
+	} else {
+		ath_ahb_freq = ath_cpu_freq /
+			(CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(clk_ctrl) + 1);
+	}
+#endif
+	prmsg("cpu %u ddr %u ahb %u\n",
+		ath_cpu_freq / 1000000,
+		ath_ddr_freq / 1000000,
+		ath_ahb_freq / 1000000);
+done:
+	*cpu = ath_cpu_freq;
+	*ddr = ath_ddr_freq;
+	*ahb = ath_ahb_freq;
+}
diff --git a/board/atheros/common/init-955x.c b/board/atheros/common/init-955x.c
new file mode 100644
index 0000000000..1d6d64e51b
--- /dev/null
+++ b/board/atheros/common/init-955x.c
@@ -0,0 +1,458 @@
+#include <common.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+#define ATH_MAX_DDR_SIZE		(256 * 1024 * 1024)
+#define ATH_DDR_SIZE_INCR		(4 * 1024 * 1024)
+
+int
+ath_ddr_find_size(void)
+{
+	uint8_t  *p = (uint8_t *)KSEG1, pat = 0x77;
+	int i;
+
+#define max_i		(ATH_MAX_DDR_SIZE / ATH_DDR_SIZE_INCR)
+
+	*p = pat;
+
+	/*
+	 * DDR wraps around. Write a pattern to 0x0000_0000. Write an
+	 * address pattern at 4M, 8M, 16M etc. and check when
+	 * 0x0000_0000 gets overwritten.
+	 */
+	for(i = 1; (i < max_i); i++) {
+		*(p + i * ATH_DDR_SIZE_INCR) = (uint8_t)(i);
+		if (*p != pat) {
+			break;
+		}
+	}
+
+	return ((i < max_i) ? (i * ATH_DDR_SIZE_INCR) : ATH_MAX_DDR_SIZE);
+}
+
+inline int
+ath_ram_type(uint32_t bs)
+{
+	if (RST_BOOTSTRAP_DDR_SELECT_GET(bs)) {
+		return ATH_MEM_DDR1;
+	} else {
+		return ATH_MEM_DDR2;
+	}
+}
+
+#define CFG_DDR2_SCORPION_CAS_LATENCY	4
+
+#ifdef CONFIG_TB614
+#	define DDR_CONFIG2_SWAP_A26_A27_VAL	(0x1)
+#else
+#	define DDR_CONFIG2_SWAP_A26_A27_VAL	(0x0)
+#endif
+
+#if CFG_DDR2_SCORPION_CAS_LATENCY == 4
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x1) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x1) | \
+						DDR_CONFIG_TMRD_SET(0xf) | \
+						DDR_CONFIG_TRFC_SET(0x15) | \
+						DDR_CONFIG_TRRD_SET(0x7) | \
+						DDR_CONFIG_TRP_SET(0x9) | \
+						DDR_CONFIG_TRCD_SET(0x9) | \
+						DDR_CONFIG_TRAS_SET(0x1b)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0x8) | \
+						DDR_CONFIG2_TWTR_SET(0x15) | \
+						DDR_CONFIG2_TRTP_SET(0x9) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0x1) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+#define CFG_DDR2_CONFIG3_VAL			0x0000000a
+#define CFG_DDR2_EXT_MODE_VAL			0x402
+#define CFG_DDR2_MODE_VAL_INIT			0x143
+#define CFG_DDR2_MODE_VAL			0x43
+#define CFG_DDR2_TAP_VAL			0x10
+#define CFG_DDR2_EN_TWL_VAL			0x0000167d
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+
+#elif CFG_DDR2_SCORPION_CAS_LATENCY == 5
+
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x1) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x4) | \
+						DDR_CONFIG_TMRD_SET(0xf) | \
+						DDR_CONFIG_TRFC_SET(0x15) | \
+						DDR_CONFIG_TRRD_SET(0x7) | \
+						DDR_CONFIG_TRP_SET(0x9) | \
+						DDR_CONFIG_TRCD_SET(0x9) | \
+						DDR_CONFIG_TRAS_SET(0x1b)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0xb) | \
+						DDR_CONFIG2_TWTR_SET(0x15) | \
+						DDR_CONFIG2_TRTP_SET(0x9) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0x1) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+#define CFG_DDR2_CONFIG3_VAL			0x0000000a
+#define CFG_DDR2_EXT_MODE_VAL			0x402
+#define CFG_DDR2_MODE_VAL_INIT			0x153
+#define CFG_DDR2_MODE_VAL			0x53
+#define CFG_DDR2_TAP_VAL			0x10
+#define CFG_DDR2_EN_TWL_VAL			0x00001e7d
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#endif
+
+#define CFG_DDR1_CONFIG_VAL			DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x7) | \
+						DDR_CONFIG_TMRD_SET(0x5) | \
+						DDR_CONFIG_TRFC_SET(0x7) | \
+						DDR_CONFIG_TRRD_SET(0x4) | \
+						DDR_CONFIG_TRP_SET(0x6) | \
+						DDR_CONFIG_TRCD_SET(0x6) | \
+						DDR_CONFIG_TRAS_SET(0x10)
+
+#define CFG_DDR1_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0x6) | \
+						DDR_CONFIG2_TWTR_SET(0xe) | \
+						DDR_CONFIG2_TRTP_SET(0x8) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0xd) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+#define CFG_DDR1_CONFIG3_VAL			0x0
+#define CFG_DDR1_EXT_MODE_VAL			0x0
+#define CFG_DDR1_MODE_VAL_INIT			0x133
+#define CFG_DDR1_MODE_VAL			0x33
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR1_TAP_VAL			0x20
+
+#define CFG_DDR_CTL_CONFIG			DDR_CTL_CONFIG_SRAM_TSEL_SET(0x1) | \
+						DDR_CTL_CONFIG_GE0_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_GE1_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_USB_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_PCIE_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_WMAC_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_SET(0x1)
+
+int /* ram type */
+ath_ddr_initial_config(uint32_t refresh)
+{
+#if !defined(CONFIG_ATH_NAND_BR) && !defined(CONFIG_ATH_EMULATION)
+	int		ddr_config, ddr_config2, ddr_config3, ext_mod, mod_val,
+			mod_val_init, cycle_val, tap_val, type, ctl_config;
+	uint32_t	*pll = (unsigned *)PLL_CONFIG_VAL_F;
+	uint32_t	bootstrap;
+
+	prmsg("\nsri\n");
+	prmsg("Scorpion 1.%d\n", ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf);
+
+	bootstrap = ath_reg_rd(RST_BOOTSTRAP_ADDRESS);
+
+	switch(type = ath_ram_type(bootstrap)) {
+	case ATH_MEM_DDR2:
+		ddr_config	= CFG_DDR2_CONFIG_VAL;
+		ddr_config2	= CFG_DDR2_CONFIG2_VAL;
+		ddr_config3	= CFG_DDR2_CONFIG3_VAL;
+		ext_mod		= CFG_DDR2_EXT_MODE_VAL;
+		mod_val_init	= CFG_DDR2_MODE_VAL_INIT;
+		mod_val		= CFG_DDR2_MODE_VAL;
+		tap_val		= CFG_DDR2_TAP_VAL;
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x10);
+		udelay(10);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x20);
+		udelay(10);
+		prmsg("%s(%d): (", __func__, __LINE__);
+
+		if (RST_BOOTSTRAP_DDR_WIDTH_GET(bootstrap)) {
+			prmsg("32");
+			ctl_config =	CFG_DDR_CTL_CONFIG |
+					DDR_CTL_CONFIG_PAD_DDR2_SEL_SET(0x1);
+
+			cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32;
+		} else {
+			prmsg("16");
+			ctl_config =	CFG_DDR_CTL_CONFIG |
+					DDR_CTL_CONFIG_PAD_DDR2_SEL_SET(0x1) |
+					DDR_CTL_CONFIG_HALF_WIDTH_SET(0x1);
+
+			cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16;
+		}
+
+		ctl_config |= CPU_DDR_SYNC_MODE;
+
+		ath_reg_wr_nf(DDR_CTL_CONFIG_ADDRESS, ctl_config);
+
+		prmsg("bit) ddr2 init\n");
+		udelay(10);
+		break;
+	case ATH_MEM_DDR1:
+		ddr_config	= CFG_DDR1_CONFIG_VAL;
+		ddr_config2	= CFG_DDR1_CONFIG2_VAL;
+		ddr_config3	= CFG_DDR1_CONFIG3_VAL;
+		ext_mod		= CFG_DDR1_EXT_MODE_VAL;
+		mod_val_init	= CFG_DDR1_MODE_VAL_INIT;
+		mod_val		= CFG_DDR1_MODE_VAL;
+		tap_val		= CFG_DDR1_TAP_VAL;
+
+		prmsg("%s(%d): (", __func__, __LINE__);
+		if (RST_BOOTSTRAP_DDR_WIDTH_GET(bootstrap)) {
+			prmsg("32");
+                        ctl_config = CFG_DDR_CTL_CONFIG; 
+			cycle_val = CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_32;
+		} else {
+			prmsg("16");
+			cycle_val = CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16;
+                        ctl_config = 0; 
+		}
+
+		ctl_config |= CPU_DDR_SYNC_MODE;
+
+		ath_reg_wr_nf(DDR_CTL_CONFIG_ADDRESS, ctl_config);
+		udelay(10);
+		prmsg("bit) ddr1 init\n");
+
+		break;
+	}
+#if 0
+	if (*pll == PLL_MAGIC) {
+		uint32_t cas = pll[5];
+		if (cas == 3 || cas == 4) {
+			cas = (cas * 2) + 2;
+			ddr_config &= ~(DDR_CONFIG_CAS_LATENCY_MSB_MASK |
+					DDR_CONFIG_CAS_LATENCY_MASK);
+			ddr_config |= DDR_CONFIG_CAS_LATENCY_SET(cas & 0x7) |
+				DDR_CONFIG_CAS_LATENCY_MSB_SET((cas >> 3) & 1);
+
+			cas = pll[5];
+
+			ddr_config2 &= ~DDR_CONFIG2_GATE_OPEN_LATENCY_MASK;
+			ddr_config2 |= DDR_CONFIG2_GATE_OPEN_LATENCY_SET((2 * cas) + 1);
+
+			if (type == ATH_MEM_DDR2) {
+				uint32_t tmp;
+				tmp = ath_reg_rd(DDR2_CONFIG_ADDRESS);
+				tmp &= ~DDR2_CONFIG_DDR2_TWL_MASK;
+				tmp |= DDR2_CONFIG_DDR2_TWL_SET(cas == 3 ? 3 : 5);
+				ath_reg_wr_nf(DDR2_CONFIG_ADDRESS, tmp);
+			}
+
+			mod_val = (cas == 3 ? 0x33 : 0x43);
+			mod_val_init = 0x100 | mod_val;
+		}
+	}
+#endif
+
+	ath_reg_wr_nf(DDR_RD_DATA_THIS_CYCLE_ADDRESS, cycle_val);
+	udelay(100);
+	ath_reg_wr_nf(DDR_BURST_ADDRESS, 0x74444444);
+	udelay(100);
+	ath_reg_wr_nf(DDR_BURST2_ADDRESS, 0x44444444);
+	udelay(100);
+	ath_reg_wr_nf(DDR_AHB_MASTER_TIMEOUT_MAX_ADDRESS, 0xfffff);
+	udelay(100);
+	ath_reg_wr_nf(DDR_CONFIG_ADDRESS, ddr_config);
+	udelay(100);
+	ath_reg_wr_nf(DDR_CONFIG2_ADDRESS, ddr_config2);
+	udelay(100);
+	ath_reg_wr(DDR_CONFIG_3_ADDRESS, ddr_config3);
+	udelay(100);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR2_CONFIG_ADDRESS, CFG_DDR2_EN_TWL_VAL);
+		udelay(100);
+	}
+
+	ath_reg_wr_nf(DDR_CONFIG2_ADDRESS, ddr_config2 | 0x80);	// CKE Enable
+	udelay(100);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x8);	// Precharge
+	udelay(10);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x10);	// EMR2
+		udelay(10);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x20);	// EMR3
+		udelay(10);
+	}
+
+	if (type == ATH_MEM_DDR1 || type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, CFG_DDR2_EXT_MODE_VAL); // EMR DLL enable, Reduced Driver Impedance control, Differential DQS disabled
+		udelay(100);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(10);
+	}
+
+	ath_reg_wr_nf(DDR_MODE_REGISTER_ADDRESS, mod_val_init);
+	udelay(1000);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x1);	// MR Write
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x8);	// Precharge
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x4);	// Auto Refresh
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x4);	// Auto Refresh
+	udelay(10);
+
+	// Issue MRS to remove DLL out-of-reset
+	ath_reg_wr_nf(DDR_MODE_REGISTER_ADDRESS, mod_val);
+	udelay(100);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x1); // MR write
+	udelay(100);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, 0x782);
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, CFG_DDR2_EXT_MODE_VAL);
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(100);
+	}
+
+	ath_reg_wr_nf(DDR_REFRESH_ADDRESS, refresh);
+	udelay(100);
+
+        ath_reg_wr(TAP_CONTROL_0_ADDRESS, tap_val);
+	ath_reg_wr(TAP_CONTROL_1_ADDRESS, tap_val);
+
+	if (RST_BOOTSTRAP_DDR_WIDTH_GET(bootstrap)) {
+		ath_reg_wr (TAP_CONTROL_2_ADDRESS, tap_val);
+		ath_reg_wr (TAP_CONTROL_3_ADDRESS, tap_val);
+	}
+
+	ath_reg_wr(PMU1_ADDRESS, 0x233c8178);
+	ath_reg_wr(PMU2_ADDRESS, 0x10380000);
+
+	return type;
+#else	// !nand flash and !emulation
+	return 0;
+#endif
+}
+
+int
+ath_uart_freq(void)
+{
+	if (ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_REF_CLK_MASK) {
+		return 40 * 1000 * 1000;
+	} else {
+		return 25 * 1000 * 1000;
+	}
+}
+
+void
+ath_sys_frequency(uint32_t *cpu, uint32_t *ddr, uint32_t *ahb)
+{
+#if !defined(CONFIG_ATH_EMULATION)
+	uint32_t pll, out_div, ref_div, nint, frac, clk_ctrl;
+#endif
+	uint32_t ref;
+	static uint32_t ath_cpu_freq, ath_ddr_freq, ath_ahb_freq;
+
+	if (ath_cpu_freq)
+		goto done;
+
+#ifdef CONFIG_ATH_EMULATION
+	ath_cpu_freq = 80000000;
+	ath_ddr_freq = 80000000;
+	ath_ahb_freq = 40000000;
+#else
+	prmsg("%s: ", __func__);
+
+	clk_ctrl = ath_reg_rd(ATH_DDR_CLK_CTRL);
+
+#if 0
+	pll = ath_reg_rd(CPU_DPLL2_ADDRESS);
+	if (CPU_DPLL2_LOCAL_PLL_GET(pll)) {
+		out_div	= CPU_DPLL2_OUTDIV_GET(pll);
+
+		pll = ath_reg_rd(CPU_DPLL_ADDRESS);
+		nint = CPU_DPLL_NINT_GET(pll);
+		frac = CPU_DPLL_NFRAC_GET(pll);
+		ref_div = CPU_DPLL_REFDIV_GET(pll);
+		pll = ref >> 18;
+		frac	= frac * pll / ref_div;
+		prmsg("cpu srif ");
+	} else {
+#endif
+		pll = ath_reg_rd(ATH_PLL_CONFIG);
+		out_div	= CPU_PLL_CONFIG_OUTDIV_GET(pll);
+		ref_div	= CPU_PLL_CONFIG_REFDIV_GET(pll);
+		nint	= CPU_PLL_CONFIG_NINT_GET(pll);
+		frac	= CPU_PLL_CONFIG_NFRAC_GET(pll);
+		pll = ref >> 6;
+		frac	= frac * pll / ref_div;
+		prmsg("cpu apb ");
+//	}
+	ath_cpu_freq = (((nint * (ref / ref_div)) + frac) >> out_div) /
+			(CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_GET(clk_ctrl) + 1);
+
+#if 0
+	pll = ath_reg_rd(DDR_DPLL2_ADDRESS);
+	if (DDR_DPLL2_LOCAL_PLL_GET(pll)) {
+		out_div	= DDR_DPLL2_OUTDIV_GET(pll);
+
+		pll = ath_reg_rd(DDR_DPLL_ADDRESS);
+		nint = DDR_DPLL_NINT_GET(pll);
+		frac = DDR_DPLL_NFRAC_GET(pll);
+		ref_div = DDR_DPLL_REFDIV_GET(pll);
+		pll = ref >> 18;
+		frac	= frac * pll / ref_div;
+		prmsg("ddr srif ");
+	} else {
+#endif
+		pll = ath_reg_rd(ATH_DDR_PLL_CONFIG);
+		out_div	= DDR_PLL_CONFIG_OUTDIV_GET(pll);
+		ref_div	= DDR_PLL_CONFIG_REFDIV_GET(pll);
+		nint	= DDR_PLL_CONFIG_NINT_GET(pll);
+		frac	= DDR_PLL_CONFIG_NFRAC_GET(pll);
+		pll = ref >> 10;
+		frac	= frac * pll / ref_div;
+		prmsg("ddr apb ");
+//	}
+	ath_ddr_freq = (((nint * (ref / ref_div)) + frac) >> out_div) /
+			(CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_GET(clk_ctrl) + 1);
+
+	if (CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_GET(clk_ctrl)) {
+		ath_ahb_freq = ath_ddr_freq /
+			(CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(clk_ctrl) + 1);
+	} else {
+		ath_ahb_freq = ath_cpu_freq /
+			(CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(clk_ctrl) + 1);
+	}
+#endif
+		ath_cpu_freq = 720 * 1000000;
+		ath_ddr_freq = 600 * 1000000;
+		ath_ahb_freq = 200 * 1000000;
+	prmsg("cpu %u ddr %u ahb %u\n",
+		ath_cpu_freq / 1000000,
+		ath_ddr_freq / 1000000,
+		ath_ahb_freq / 1000000);
+done:
+	*cpu = ath_cpu_freq;
+	*ddr = ath_ddr_freq;
+	*ahb = ath_ahb_freq;
+
+}
diff --git a/board/atheros/common/phy.h b/board/atheros/common/phy.h
new file mode 100644
index 0000000000..b285078e1e
--- /dev/null
+++ b/board/atheros/common/phy.h
@@ -0,0 +1,17 @@
+#ifndef _PHY_H
+#define _PHY_H
+
+#include <config.h>
+
+#define ath_gmac_unit2name(_unit) (_unit ?  "eth1" : "eth0")
+
+extern int ath_gmac_miiphy_read(char *devname, uint32_t phaddr, uint8_t reg);
+extern int ath_gmac_miiphy_write(char *devname, uint32_t phaddr, uint8_t reg, uint16_t data);
+
+#define phy_reg_read(base, addr, reg)	\
+	ath_gmac_miiphy_read(ath_gmac_unit2name(base), addr, reg)
+
+#define phy_reg_write(base, addr, reg, data)	\
+	ath_gmac_miiphy_write(ath_gmac_unit2name(base), addr, reg, data)
+
+#endif
diff --git a/board/atheros/common/qca-eth-953x.c b/board/atheros/common/qca-eth-953x.c
new file mode 100755
index 0000000000..c8a449cce9
--- /dev/null
+++ b/board/atheros/common/qca-eth-953x.c
@@ -0,0 +1,681 @@
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#include <atheros.h>
+#include "qca-eth-953x.h"
+#include "qca-eth-953x_phy.h"
+#define SGMII_LINK_WAR_MAX_TRY 10
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ath_gmac_unit2mac(_unit)     ath_gmac_macs[(_unit)]
+#define ath_gmac_name2mac(name)	   is_drqfn() ? ath_gmac_unit2mac(1):strcmp(name,"eth0") ? ath_gmac_unit2mac(1) : ath_gmac_unit2mac(0)
+
+uint16_t ath_gmac_miiphy_read(char *devname, uint32_t phaddr, uint8_t reg);
+void  ath_gmac_miiphy_write(char *devname, uint32_t phaddr, uint8_t reg, uint16_t data);
+extern void ath_sys_frequency(uint32_t *, uint32_t *, uint32_t *);
+
+#ifndef CFG_ATH_GMAC_NMACS
+#define CFG_ATH_GMAC_NMACS	1
+#endif /* CFG_ATH_GMAC_NMACS */
+
+ath_gmac_mac_t *ath_gmac_macs[CFG_ATH_GMAC_NMACS];
+
+
+
+#ifdef  CFG_ATHRS27_PHY
+#define is_s27() 1
+
+#else 
+#define is_s27() 0
+
+#endif 
+#ifdef  CFG_ATHRS27_PHY
+extern void athrs27_reg_init(void);
+extern void athrs27_reg_init_wan(void);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+extern int athr_vir_phy_setup(int unit);
+extern int athr_vir_phy_is_up(int unit);
+extern int athr_vir_phy_is_fdx(int unit);
+extern int athr_vir_phy_speed(int unit);
+extern void athr_vir_reg_init(void);
+#endif
+
+static int
+ath_gmac_send(struct eth_device *dev, volatile void *packet, int length)
+{
+	int i;
+
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
+
+	ath_gmac_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+	f->pkt_size = length;
+	f->res1 = 0;
+	f->pkt_start_addr = virt_to_phys(packet);
+
+	ath_gmac_tx_give_to_dma(f);
+	flush_cache((u32) packet, length);
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_DESC, virt_to_phys(f));
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_CTRL, ATH_TXE);
+
+	for (i = 0; i < MAX_WAIT; i++) {
+		udelay(10);
+		if (!ath_gmac_tx_owned_by_dma(f))
+			break;
+	}
+	if (i == MAX_WAIT)
+		printf("Tx Timed out\n");
+
+	f->pkt_start_addr = 0;
+	f->pkt_size = 0;
+
+	if (++mac->next_tx >= NO_OF_TX_FIFOS)
+		mac->next_tx = 0;
+
+	return (0);
+}
+
+static int ath_gmac_recv(struct eth_device *dev)
+{
+	int length;
+	ath_gmac_desc_t *f;
+	ath_gmac_mac_t *mac;
+	volatile int dmaed_pkt=0;
+	int count = 0;
+
+	mac = (ath_gmac_mac_t *)dev->priv;
+
+	for (;;) {
+		f = mac->fifo_rx[mac->next_rx];
+		if (ath_gmac_rx_owned_by_dma(f)) {
+			/* check if the current Descriptor is_empty is 1,But the DMAed count is not-zero
+			   then move to desciprot where the packet is available */
+			dmaed_pkt = (ath_gmac_reg_rd(mac, 0x194) >> 16);
+			if (!dmaed_pkt) {
+				break ;
+			} else {
+				if (f->is_empty == 1) {
+					while (count < NO_OF_RX_FIFOS) {
+						if (++mac->next_rx >= NO_OF_RX_FIFOS) {
+							mac->next_rx = 0;
+						}
+						f = mac->fifo_rx[mac->next_rx];
+						/*
+						 * Break on valid data in the desc by checking
+						 * empty bit.
+						 */
+						if (!f->is_empty) {
+							count = 0;
+							break;
+						}
+						count++;
+					}
+				}
+			}
+		}
+
+		length = f->pkt_size;
+
+		NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+		flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+		ath_gmac_reg_wr(mac,0x194,1);
+		ath_gmac_rx_give_to_dma(f);
+
+		if (++mac->next_rx >= NO_OF_RX_FIFOS)
+			mac->next_rx = 0;
+	}
+
+	if (!(ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL))) {
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, virt_to_phys(f));
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, 1);
+	}
+
+	return (0);
+}
+
+void ath_gmac_mii_setup(ath_gmac_mac_t *mac)
+{
+	u32 mgmt_cfg_val;
+
+	ath_reg_wr(SWITCH_CLOCK_SPARE_ADDRESS, 0x231);
+	//ath_reg_wr(SWITCH_CLOCK_SPARE_ADDRESS, 0x520);
+	if ((mac->mac_unit == 1)) {
+		printf("Honey Bee ---->  MAC 1 S27 PHY*\n");
+		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(3)|
+					ETH_CFG_RGMII_GE0_SET(1));
+
+		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
+						ETH_XMII_RX_DELAY_SET(2) |
+						ETH_XMII_TX_DELAY_SET(1) |
+						ETH_XMII_GIGE_SET(1));
+        	mgmt_cfg_val = 2;
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+		return;
+	}
+
+	if (is_vir_phy()) {
+		printf("Honey Bee ---->VIR PHY*\n");
+
+		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(3)|
+					ETH_CFG_RGMII_GE0_SET(1));
+		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
+						ETH_XMII_RX_DELAY_SET(2) |
+						ETH_XMII_TX_DELAY_SET(1) |
+						ETH_XMII_GIGE_SET(1));
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+		return;
+	}
+	if (is_s27()) {
+        	mgmt_cfg_val = 2;
+        	printf("Scorpion ---->S27 PHY*\n");
+		ath_reg_wr(ETH_CFG_ADDRESS, ETH_CFG_MII_GE0_SET(1)|
+                                        ETH_CFG_MII_GE0_SLAVE_SET(1));
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+	}
+
+
+
+
+}
+
+
+static void ath_gmac_hw_start(ath_gmac_mac_t *mac)
+{
+
+
+	if(mac->mac_unit)
+	{
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_1000));
+	} else {
+
+
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_10_100));
+	}
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_1, 0x10ffff);
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_2, 0xAAA0555);
+
+	ath_gmac_reg_rmw_set(mac, ATH_MAC_FIFO_CFG_4, 0x3ffff);
+	/*
+	 * Setting Drop CRC Errors, Pause Frames,Length Error frames
+	 * and Multi/Broad cast frames.
+	 */
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_5, 0x7eccf);
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_3, 0x1f00140);
+
+	printf("GMAC: cfg1 0x%x cfg2 0x%x\n", ath_gmac_reg_rd(mac, ATH_MAC_CFG1),
+			ath_gmac_reg_rd(mac, ATH_MAC_CFG2));
+
+
+}
+
+static int ath_gmac_check_link(ath_gmac_mac_t *mac)
+{
+	int link, duplex, speed;
+
+	ath_gmac_phy_link(mac->mac_unit, &link);
+	ath_gmac_phy_duplex(mac->mac_unit, &duplex);
+	ath_gmac_phy_speed(mac->mac_unit, &speed);
+
+	mac->link = link;
+
+	if(!mac->link) {
+		printf("%s link down\n",mac->dev->name);
+		return 0;
+	}
+
+	switch (speed)
+	{
+		case _1000BASET:
+			ath_gmac_set_mac_if(mac, 1);
+			ath_gmac_reg_rmw_set(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+			break;
+
+		case _100BASET:
+			ath_gmac_set_mac_if(mac, 0);
+			ath_gmac_set_mac_speed(mac, 1);
+			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+			break;
+
+		case _10BASET:
+			ath_gmac_set_mac_if(mac, 0);
+			ath_gmac_set_mac_speed(mac, 0);
+			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+			break;
+
+		default:
+			printf("Invalid speed detected\n");
+			return 0;
+	}
+
+	if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+		return 1;
+
+	mac->duplex = duplex;
+	mac->speed = speed;
+
+	printf("dup %d speed %d\n", duplex, speed);
+
+	ath_gmac_set_mac_duplex(mac,duplex);
+
+	return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ath_gmac_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+	int i;
+	ath_gmac_desc_t *fr;
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t*)dev->priv;
+
+	if (!ath_gmac_check_link(mac))
+		return 0;
+
+	mac->next_rx = 0;
+
+        ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+        ath_gmac_reg_wr(mac, ATH_MAC_CFG1, (ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+
+	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+		fr = mac->fifo_rx[i];
+		fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+		flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+		ath_gmac_rx_give_to_dma(fr);
+	}
+
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, ATH_RXE);	/* rx start */
+	udelay(1000 * 1000);
+
+
+	return 1;
+
+}
+
+static int ath_gmac_alloc_fifo(int ndesc, ath_gmac_desc_t ** fifo)
+{
+	int i;
+	u32 size;
+	uchar *p = NULL;
+
+	size = sizeof(ath_gmac_desc_t) * ndesc;
+	size += CFG_CACHELINE_SIZE - 1;
+
+	if ((p = malloc(size)) == NULL) {
+		printf("Cant allocate fifos\n");
+		return -1;
+	}
+
+	p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+			~(CFG_CACHELINE_SIZE - 1));
+	p = UNCACHED_SDRAM(p);
+
+	for (i = 0; i < ndesc; i++)
+		fifo[i] = (ath_gmac_desc_t *) p + i;
+
+	return 0;
+}
+
+static int ath_gmac_setup_fifos(ath_gmac_mac_t *mac)
+{
+	int i;
+
+	if (ath_gmac_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+		return 1;
+
+	for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+		mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+			virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+		ath_gmac_tx_own(mac->fifo_tx[i]);
+	}
+
+	if (ath_gmac_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+		return 1;
+
+	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+		mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+			virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+	}
+
+	return (1);
+}
+
+static void ath_gmac_halt(struct eth_device *dev)
+{
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
+        ath_gmac_reg_rmw_clear(mac, ATH_MAC_CFG1,(ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+        ath_gmac_reg_wr(mac,ATH_MAC_FIFO_CFG_0,0x1f1f);
+	ath_gmac_reg_wr(mac,ATH_DMA_RX_CTRL, 0);
+	while (ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL));
+}
+
+unsigned char *
+ath_gmac_mac_addr_loc(void)
+{
+#ifdef BOARDCAL
+	/*
+	 ** BOARDCAL environmental variable has the address of the cal sector
+	 */
+
+	return ((unsigned char *)BOARDCAL);
+
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+			(KSEG1ADDR(ATH_SPI_BASE) + (4 * 1024) +
+			 flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+static void ath_gmac_get_ethaddr(struct eth_device *dev)
+{
+	unsigned char *eeprom;
+	unsigned char *mac = dev->enetaddr;
+#ifndef CONFIG_ATH_EMULATION
+
+	eeprom = ath_gmac_mac_addr_loc();
+
+	if (strcmp(dev->name, "eth0") == 0) {
+		memcpy(mac, eeprom, 6);
+	} else if (strcmp(dev->name, "eth1") == 0) {
+		eeprom += 6;
+		memcpy(mac, eeprom, 6);
+	} else {
+		printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+		return;
+	}
+	/* Use fixed address if the above address is invalid */
+	if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff))
+#else
+	if (1)
+#endif
+	{
+		mac[0] = 0xba;
+		mac[1] = 0xbe;
+		mac[2] = 0xfa;
+		mac[3] = 0xce;
+		mac[4] = 0x08;
+		mac[5] = 0x41;
+		/*printf("No valid address in Flash. Using fixed address\n");*/
+	} else {
+		printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+	}
+}
+
+void
+athr_mgmt_init(void)
+{
+
+#ifdef CONFIG_MGMT_INIT
+	uint32_t rddata;
+
+	rddata = ath_reg_rd(GPIO_IN_ENABLE3_ADDRESS)&
+		~GPIO_IN_ENABLE3_MII_GE1_MDI_MASK;
+	rddata |= GPIO_IN_ENABLE3_MII_GE1_MDI_SET(19);
+	ath_reg_wr(GPIO_IN_ENABLE3_ADDRESS, rddata);
+
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 19));
+
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 17));
+
+
+	rddata = ath_reg_rd(GPIO_OUT_FUNCTION4_ADDRESS) &
+		~ (GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK |
+		GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK);
+
+	rddata |= GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(0x20) |
+	GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(0x21);
+
+	ath_reg_wr(GPIO_OUT_FUNCTION4_ADDRESS, rddata);
+#endif
+	printf ("%s ::done\n",__func__);
+}
+
+int ath_gmac_enet_initialize(bd_t * bis)
+{
+	struct eth_device *dev[CFG_ATH_GMAC_NMACS];
+	u32 mask, mac_h, mac_l;
+	int i;
+
+	printf("%s...\n", __func__);
+
+	/* Switch Analog and digital reset seq */
+	mask = ATH_RESET_GE1_PHY |  ATH_RESET_GE0_PHY;
+	ath_reg_rmw_set(RST_RESET_ADDRESS, mask);
+
+	udelay(1000 * 100);
+	mask = ATH_RESET_GE1_PHY ;
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+
+	udelay(1000 * 100);
+	mask = ATH_RESET_GE0_PHY ;
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+	udelay(100);
+
+
+	for (i = 0;i < CFG_ATH_GMAC_NMACS;i++) {
+
+		if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+			puts("malloc failed\n");
+			return 0;
+		}
+
+		if ((ath_gmac_macs[i] = (ath_gmac_mac_t *) malloc(sizeof (ath_gmac_mac_t))) == NULL) {
+			puts("malloc failed\n");
+			return 0;
+		}
+
+		memset(ath_gmac_macs[i], 0, sizeof(ath_gmac_macs[i]));
+		memset(dev[i], 0, sizeof(dev[i]));
+
+		sprintf(dev[i]->name, "eth%d", i);
+		ath_gmac_get_ethaddr(dev[i]);
+
+		ath_gmac_macs[i]->mac_unit = i;
+		ath_gmac_macs[i]->mac_base = i ? ATH_GE1_BASE : ATH_GE0_BASE ;
+		ath_gmac_macs[i]->dev = dev[i];
+
+		dev[i]->iobase = 0;
+		dev[i]->init = ath_gmac_clean_rx;
+		dev[i]->halt = ath_gmac_halt;
+		dev[i]->send = ath_gmac_send;
+		dev[i]->recv = ath_gmac_recv;
+		dev[i]->priv = (void *)ath_gmac_macs[i];
+	}
+
+	for (i = 0;i < CFG_ATH_GMAC_NMACS;i++) {
+
+		if(!i) {
+			mask = (ATH_RESET_GE0_MAC | ATH_RESET_GE1_MAC | ATH_RESET_GE0_MDIO | ATH_RESET_GE1_MDIO);
+
+
+			printf("%s: reset mask:0x%x\n", __func__, mask);
+
+			ath_reg_rmw_set(RST_RESET_ADDRESS, mask);
+			udelay(1000 * 100);
+
+			mask = mask | ATH_RESET_GE0_MDIO | ATH_RESET_GE1_MDIO;
+			ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+			udelay(1000 * 100);
+
+			udelay(10 * 1000);
+		}
+#if defined(CONFIG_MGMT_INIT) && defined (CONFIG_ATHR_SWITCH_ONLY_MODE) || defined ATH_MDC_GPIO
+		if (!i)
+			athr_mgmt_init();
+
+		if (ath_gmac_macs[i]->mac_unit == 0)
+                        continue;
+#endif
+		eth_register(dev[i]);
+#if(CONFIG_COMMANDS & CFG_CMD_MII)
+		miiphy_register(dev[i]->name, ath_gmac_miiphy_read, ath_gmac_miiphy_write);
+#endif
+		ath_gmac_mii_setup(ath_gmac_macs[i]);
+
+		/* if using header for register configuration, we have to     */
+		/* configure s26 register after frame transmission is enabled */
+
+		if (ath_gmac_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef  CFG_ATHRS27_PHY
+			printf("S27 reg init\n");
+			athrs27_reg_init();
+			mask = ATH_RESET_GE0_MAC;
+                        ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			printf("VIRPhy reg init \n");
+			athr_vir_reg_init();
+#endif
+		} else {
+#ifdef  CFG_ATHRS27_PHY
+			printf("S27 reg init\n");
+			athrs27_reg_init_lan();
+			mask = ATH_RESET_GE1_MAC;
+                        ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+#endif
+
+		}
+
+	 	ath_gmac_reg_rmw_set(ath_gmac_macs[i], ATH_MAC_CFG1, ATH_MAC_CFG1_SOFT_RST
+                                | ATH_MAC_CFG1_RX_RST | ATH_MAC_CFG1_TX_RST);
+
+
+		ath_gmac_hw_start(ath_gmac_macs[i]);
+		ath_gmac_setup_fifos(ath_gmac_macs[i]);
+
+
+
+		udelay(100 * 1000);
+
+		{
+			unsigned char *mac = dev[i]->enetaddr;
+
+			printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+					mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+					mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+		}
+		mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+		mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+			(dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+		ath_gmac_reg_wr(ath_gmac_macs[i], ATH_GE_MAC_ADDR1, mac_l);
+		ath_gmac_reg_wr(ath_gmac_macs[i], ATH_GE_MAC_ADDR2, mac_h);
+
+
+	ath_gmac_phy_setup(ath_gmac_macs[i]->mac_unit);
+		printf("%s up\n",dev[i]->name);
+	}
+
+
+	return 1;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+uint16_t
+ath_gmac_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg)
+{
+	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
+	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg, val;
+	volatile int           rddata;
+	uint16_t      ii = 0xFFFF;
+
+
+
+
+	/*
+	 * Check for previous transactions are complete. Added to avoid
+	 * race condition while running at higher frequencies.
+	 */
+	do
+	{
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	}while(rddata && --ii);
+
+	if (ii == 0)
+		printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_ADDRESS, addr);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, ATH_MGMT_CMD_READ);
+
+	do
+	{
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	}while(rddata && --ii);
+
+	if(ii==0)
+		printf("Error!!! Leave ath_gmac_miiphy_read without polling correct status!\n");
+
+	val = ath_gmac_reg_rd(mac, ATH_MII_MGMT_STATUS);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
+
+	return val;
+}
+
+void
+ath_gmac_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
+	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg;
+	volatile int rddata;
+	uint16_t      ii = 0xFFFF;
+
+
+	/*
+	 * Check for previous transactions are complete. Added to avoid
+	 * race condition while running at higher frequencies.
+	 */
+	do {
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	} while (rddata && --ii);
+
+	if (ii == 0)
+		printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_ADDRESS, addr);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CTRL, data);
+
+	do {
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	} while (rddata && --ii);
+
+	if (ii == 0)
+		printf("Error!!! Leave ath_gmac_miiphy_write without polling correct status!\n");
+}
+#endif		/* CONFIG_COMMANDS & CFG_CMD_MII */
diff --git a/board/atheros/common/qca-eth-953x.h b/board/atheros/common/qca-eth-953x.h
new file mode 100755
index 0000000000..8cd29cc507
--- /dev/null
+++ b/board/atheros/common/qca-eth-953x.h
@@ -0,0 +1,349 @@
+#ifndef __QCA_ETH_953X_H
+#define __QCA_ETH_953X_H
+
+#include <linux/types.h>
+
+#ifdef ATH_RGMII_CAL
+#define rgmii_cal_alg()    rgmii_calib(mac);
+#else
+#define rgmii_cal_alg()
+#endif
+
+/*
+ * h/w descriptor
+ */
+typedef struct {
+	uint32_t	pkt_start_addr,
+			is_empty	:  1,
+			res1		: 10,
+			ftpp_override	:  5,
+			res2		:  4,
+			pkt_size	: 12,
+			next_desc;
+} ath_gmac_desc_t;
+
+#define NO_OF_TX_FIFOS			8
+#define NO_OF_RX_FIFOS			8
+
+typedef struct {
+	ath_gmac_desc_t		*fifo_tx[NO_OF_TX_FIFOS],
+				*fifo_rx[NO_OF_RX_FIFOS];
+	struct eth_device	*dev;
+	uint32_t		next_tx,
+				next_rx,
+				link,
+				duplex,
+				speed,
+				mac_unit,
+				mac_base;
+} ath_gmac_mac_t;
+
+#define ath_gmac_reg_wr(_mac, _x, _y)	ath_reg_wr(((_x) + _mac->mac_base), (_y))
+#define ath_gmac_reg_rd(_mac, _x)	ath_reg_rd(((_x) + _mac->mac_base))
+
+#define ath_gmac_reg_rmw_set(_mac, _x, _y)	\
+	ath_reg_rmw_set(((_x) + _mac->mac_base ), (_y))
+#define ath_gmac_reg_rmw_clear(_mac, _x, _y)	\
+	ath_reg_rmw_clear(((_x) + _mac->mac_base), (_y))
+
+#ifdef COMPRESSED_UBOOT
+#define _1000BASET		1000
+#define _100BASET		100
+#define _10BASET		10
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/*
+ * spd is _1000BASET, _100BASET etc. defined in include/miiphy.h
+ */
+#define mii_reg(_mac)	(ATH_MII0_CTRL + ((_mac)->mac_unit * 4))
+#define mii_if(_mac)	(((_mac)->mac_unit == 0) ? mii0_if : mii1_if)
+
+#define ath_gmac_set_mii_ctrl_speed(_mac, _spd)	do {	\
+	ath_reg_rmw_clear(mii_reg(_mac), (3 << 4));	\
+	ath_reg_rmw_set(mii_reg(_mac), ((_spd) << 4));	\
+} while (0)
+
+#if defined (CFG_MII0_GMII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_MII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_RGMII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_RMII)
+#	define ath_gmac_get_mii_if()	0
+#endif
+
+#define MAX_WAIT			1000
+
+/*
+ * Config/Mac Register definitions
+ */
+#define ATH_MAC_CFG1			0x00
+#define ATH_MAC_CFG2			0x04
+#define ATH_MAC_IFCTL			0x38
+
+/*
+ * fifo control registers
+ */
+#define ATH_MAC_FIFO_CFG_0		0x48
+#define ATH_MAC_FIFO_CFG_1		0x4c
+#define ATH_MAC_FIFO_CFG_2		0x50
+#define ATH_MAC_FIFO_CFG_3		0x54
+#define ATH_MAC_FIFO_CFG_4		0x58
+
+#define ATH_MAC_FIFO_CFG_5		0x5c
+#define ATH_BYTE_PER_CLK_EN		(1 << 19)
+
+#define ATH_MAC_FIFO_RAM_0		0x60
+#define ATH_MAC_FIFO_RAM_1		0x64
+#define ATH_MAC_FIFO_RAM_2		0x68
+#define ATH_MAC_FIFO_RAM_3		0x6c
+#define ATH_MAC_FIFO_RAM_4		0x70
+#define ATH_MAC_FIFO_RAM_5		0x74
+#define ATH_MAC_FIFO_RAM_6		0x78
+#define ATH_MAC_FIFO_RAM_7		0x7c
+
+/*
+ * fields
+ */
+#define ATH_MAC_CFG1_SOFT_RST		(1 << 31)
+#define ATH_MAC_CFG1_RX_RST		(1 << 19)
+#define ATH_MAC_CFG1_TX_RST		(1 << 18)
+#define ATH_MAC_CFG1_LOOPBACK		(1 << 8)
+#define ATH_MAC_CFG1_RX_EN		(1 << 2)
+#define ATH_MAC_CFG1_TX_EN		(1 << 0)
+
+#define ATH_MAC_CFG2_FDX		(1 << 0)
+#define ATH_MAC_CFG2_PAD_CRC_EN		(1 << 2)
+#define ATH_MAC_CFG2_LEN_CHECK		(1 << 4)
+#define ATH_MAC_CFG2_HUGE_FRAME_EN	(1 << 5)
+#define ATH_MAC_CFG2_IF_1000		(1 << 9)
+#define ATH_MAC_CFG2_IF_10_100		(1 << 8)
+
+#define ATH_MAC_IFCTL_SPEED		(1 << 16)
+
+/*
+ * DMA (tx/rx) register defines
+ */
+#define ATH_DMA_TX_CTRL			0x180
+#define ATH_DMA_TX_DESC			0x184
+#define ATH_DMA_TX_STATUS		0x188
+#define ATH_DMA_RX_CTRL			0x18c
+#define ATH_DMA_RX_DESC			0x190
+#define ATH_DMA_RX_STATUS		0x194
+#define ATH_DMA_INTR_MASK		0x198
+#define ATH_DMA_INTR			0x19c
+
+/*
+ * tx/rx ctrl and status bits
+ */
+#define ATH_TXE				(1 << 0)
+#define ATH_TX_STATUS_PKTCNT_SHIFT	16
+#define ATH_TX_STATUS_PKT_SENT		0x1
+#define ATH_TX_STATUS_URN		0x2
+#define ATH_TX_STATUS_BUS_ERROR		0x8
+
+#define ATH_RXE				(1 << 0)
+
+#define ATH_RX_STATUS_PKTCNT_MASK	0xff0000
+#define ATH_RX_STATUS_PKT_RCVD		(1 << 0)
+#define ATH_RX_STATUS_OVF		(1 << 2)
+#define ATH_RX_STATUS_BUS_ERROR		(1 << 3)
+
+/*
+ * Int and int mask
+ */
+#define ATH_INTR_TX			(1 << 0)
+#define ATH_INTR_TX_URN			(1 << 1)
+#define ATH_INTR_TX_BUS_ERROR		(1 << 3)
+#define ATH_INTR_RX			(1 << 4)
+#define ATH_INTR_RX_OVF			(1 << 6)
+#define ATH_INTR_RX_BUS_ERROR		(1 << 7)
+
+/*
+ * MII registers
+ */
+#define ATH_MAC_MII_MGMT_CFG		0x20
+#define ATH_MGMT_CFG_CLK_DIV_20		0x07
+
+#define ATH_MII_MGMT_CMD		0x24
+#define ATH_MGMT_CMD_READ		0x1
+
+#define ATH_MII_MGMT_ADDRESS		0x28
+#define ATH_ADDR_SHIFT			8
+
+#define ATH_MII_MGMT_CTRL		0x2c
+#define ATH_MII_MGMT_STATUS		0x30
+
+#define ATH_MII_MGMT_IND		0x34
+#define ATH_MGMT_IND_BUSY		(1 << 0)
+#define ATH_MGMT_IND_INVALID		(1 << 2)
+
+#define ATH_GE_MAC_ADDR1		0x40
+#define ATH_GE_MAC_ADDR2		0x44
+
+/*
+ * Ethernet config registers
+ */
+#define ATH_ETH_CFG			0x18070000
+#define ATH_ETH_CFG_RGMII_GE0		(1<<0)
+#define ATH_ETH_CFG_MII_GE0		(1<<1)
+#define ATH_ETH_CFG_GMII_GE0		(1<<2)
+#define ATH_ETH_CFG_RMII_GE0		(1<<10)
+#define ATH_ETH_CFG_RMII_HISPD_GE0	(1<<11)
+#define ATH_ETH_CFG_RMII_MASTER_MODE	(1<<12)
+#define ATH_ETH_CFG_MII_GE0_MASTER	(1<<3)
+#define ATH_ETH_CFG_MII_GE0_SLAVE	(1<<4)
+#define ATH_ETH_CFG_GE0_ERR_EN		(1<<5)
+#define ATH_ETH_CFG_SW_ONLY_MODE	(1<<6)
+#define ATH_ETH_CFG_SW_PHY_SWAP		(1<<7)
+#define ATH_ETH_CFG_SW_PHY_ADDR_SWAP	(1<<8)
+#define ATH_ETH_CFG_RXD_DELAY		(1 << 14)
+#define ATH_ETH_CFG_RDV_DELAY		(1 << 16)
+#define ATH_ETH_SWITCH_CLK_SPARE	0x18050024
+
+#define ETH_CFG_ETH_SPARE_MSB                                        31
+#define ETH_CFG_ETH_SPARE_LSB                                        22
+#define ETH_CFG_ETH_SPARE_MASK                                       0xffc00000
+#define ETH_CFG_ETH_SPARE_GET(x)                                     (((x) & ETH_CFG_ETH_SPARE_MASK) >> ETH_CFG_ETH_SPARE_LSB)
+#define ETH_CFG_ETH_SPARE_SET(x)                                     (((x) << ETH_CFG_ETH_SPARE_LSB) & ETH_CFG_ETH_SPARE_MASK)
+#define ETH_CFG_ETH_SPARE_RESET                                      0x0 // 0
+#define ETH_CFG_ETH_TXEN_DELAY_MSB                                   21
+#define ETH_CFG_ETH_TXEN_DELAY_LSB                                   20
+#define ETH_CFG_ETH_TXEN_DELAY_MASK                                  0x00300000
+#define ETH_CFG_ETH_TXEN_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_TXEN_DELAY_MASK) >> ETH_CFG_ETH_TXEN_DELAY_LSB)
+#define ETH_CFG_ETH_TXEN_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_TXEN_DELAY_LSB) & ETH_CFG_ETH_TXEN_DELAY_MASK)
+#define ETH_CFG_ETH_TXEN_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_TXD_DELAY_MSB                                    19
+#define ETH_CFG_ETH_TXD_DELAY_LSB                                    18
+#define ETH_CFG_ETH_TXD_DELAY_MASK                                   0x000c0000
+#define ETH_CFG_ETH_TXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_TXD_DELAY_MASK) >> ETH_CFG_ETH_TXD_DELAY_LSB)
+#define ETH_CFG_ETH_TXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_TXD_DELAY_LSB) & ETH_CFG_ETH_TXD_DELAY_MASK)
+#define ETH_CFG_ETH_TXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_ETH_RXDV_DELAY_MSB                                   17
+#define ETH_CFG_ETH_RXDV_DELAY_LSB                                   16
+#define ETH_CFG_ETH_RXDV_DELAY_MASK                                  0x00030000
+#define ETH_CFG_ETH_RXDV_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_RXDV_DELAY_MASK) >> ETH_CFG_ETH_RXDV_DELAY_LSB)
+#define ETH_CFG_ETH_RXDV_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_RXDV_DELAY_LSB) & ETH_CFG_ETH_RXDV_DELAY_MASK)
+#define ETH_CFG_ETH_RXDV_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_RXD_DELAY_MSB                                    15
+#define ETH_CFG_ETH_RXD_DELAY_LSB                                    14
+#define ETH_CFG_ETH_RXD_DELAY_MASK                                   0x0000c000
+#define ETH_CFG_ETH_RXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_RXD_DELAY_MASK) >> ETH_CFG_ETH_RXD_DELAY_LSB)
+#define ETH_CFG_ETH_RXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_RXD_DELAY_LSB) & ETH_CFG_ETH_RXD_DELAY_MASK)
+#define ETH_CFG_ETH_RXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_RMII_GE0_MASTER_MSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_LSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_MASK                                 0x00001000
+#define ETH_CFG_RMII_GE0_MASTER_GET(x)                               (((x) & ETH_CFG_RMII_GE0_MASTER_MASK) >> ETH_CFG_RMII_GE0_MASTER_LSB)
+#define ETH_CFG_RMII_GE0_MASTER_SET(x)                               (((x) << ETH_CFG_RMII_GE0_MASTER_LSB) & ETH_CFG_RMII_GE0_MASTER_MASK)
+#define ETH_CFG_RMII_GE0_MASTER_RESET                                0x1 // 1
+#define ETH_CFG_MII_CNTL_SPEED_MSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_LSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_MASK                                  0x00000800
+#define ETH_CFG_MII_CNTL_SPEED_GET(x)                                (((x) & ETH_CFG_MII_CNTL_SPEED_MASK) >> ETH_CFG_MII_CNTL_SPEED_LSB)
+#define ETH_CFG_MII_CNTL_SPEED_SET(x)                                (((x) << ETH_CFG_MII_CNTL_SPEED_LSB) & ETH_CFG_MII_CNTL_SPEED_MASK)
+#define ETH_CFG_MII_CNTL_SPEED_RESET                                 0x0 // 0
+#define ETH_CFG_RMII_GE0_MSB                                         10
+#define ETH_CFG_RMII_GE0_LSB                                         10
+#define ETH_CFG_RMII_GE0_MASK                                        0x00000400
+#define ETH_CFG_RMII_GE0_GET(x)                                      (((x) & ETH_CFG_RMII_GE0_MASK) >> ETH_CFG_RMII_GE0_LSB)
+#define ETH_CFG_RMII_GE0_SET(x)                                      (((x) << ETH_CFG_RMII_GE0_LSB) & ETH_CFG_RMII_GE0_MASK)
+#define ETH_CFG_RMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_GE0_SGMII_MSB                                        6
+#define ETH_CFG_GE0_SGMII_LSB                                        6
+#define ETH_CFG_GE0_SGMII_MASK                                       0x00000040
+#define ETH_CFG_GE0_SGMII_GET(x)                                     (((x) & ETH_CFG_GE0_SGMII_MASK) >> ETH_CFG_GE0_SGMII_LSB)
+#define ETH_CFG_GE0_SGMII_SET(x)                                     (((x) << ETH_CFG_GE0_SGMII_LSB) & ETH_CFG_GE0_SGMII_MASK)
+#define ETH_CFG_GE0_SGMII_RESET                                      0x0 // 0
+#define ETH_CFG_GE0_ERR_EN_MSB                                       5
+#define ETH_CFG_GE0_ERR_EN_LSB                                       5
+#define ETH_CFG_GE0_ERR_EN_MASK                                      0x00000020
+#define ETH_CFG_GE0_ERR_EN_GET(x)                                    (((x) & ETH_CFG_GE0_ERR_EN_MASK) >> ETH_CFG_GE0_ERR_EN_LSB)
+#define ETH_CFG_GE0_ERR_EN_SET(x)                                    (((x) << ETH_CFG_GE0_ERR_EN_LSB) & ETH_CFG_GE0_ERR_EN_MASK)
+#define ETH_CFG_GE0_ERR_EN_RESET                                     0x0 // 0
+#define ETH_CFG_MII_GE0_SLAVE_MSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_LSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_MASK                                   0x00000010
+#define ETH_CFG_MII_GE0_SLAVE_GET(x)                                 (((x) & ETH_CFG_MII_GE0_SLAVE_MASK) >> ETH_CFG_MII_GE0_SLAVE_LSB)
+#define ETH_CFG_MII_GE0_SLAVE_SET(x)                                 (((x) << ETH_CFG_MII_GE0_SLAVE_LSB) & ETH_CFG_MII_GE0_SLAVE_MASK)
+#define ETH_CFG_MII_GE0_SLAVE_RESET                                  0x0 // 0
+#define ETH_CFG_MII_GE0_MASTER_MSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_LSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_MASK                                  0x00000008
+#define ETH_CFG_MII_GE0_MASTER_GET(x)                                (((x) & ETH_CFG_MII_GE0_MASTER_MASK) >> ETH_CFG_MII_GE0_MASTER_LSB)
+#define ETH_CFG_MII_GE0_MASTER_SET(x)                                (((x) << ETH_CFG_MII_GE0_MASTER_LSB) & ETH_CFG_MII_GE0_MASTER_MASK)
+#define ETH_CFG_MII_GE0_MASTER_RESET                                 0x0 // 0
+#define ETH_CFG_GMII_GE0_MSB                                         2
+#define ETH_CFG_GMII_GE0_LSB                                         2
+#define ETH_CFG_GMII_GE0_MASK                                        0x00000004
+#define ETH_CFG_GMII_GE0_GET(x)                                      (((x) & ETH_CFG_GMII_GE0_MASK) >> ETH_CFG_GMII_GE0_LSB)
+#define ETH_CFG_GMII_GE0_SET(x)                                      (((x) << ETH_CFG_GMII_GE0_LSB) & ETH_CFG_GMII_GE0_MASK)
+#define ETH_CFG_GMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_MII_GE0_MSB                                          1
+#define ETH_CFG_MII_GE0_LSB                                          1
+#define ETH_CFG_MII_GE0_MASK                                         0x00000002
+#define ETH_CFG_MII_GE0_GET(x)                                       (((x) & ETH_CFG_MII_GE0_MASK) >> ETH_CFG_MII_GE0_LSB)
+#define ETH_CFG_MII_GE0_SET(x)                                       (((x) << ETH_CFG_MII_GE0_LSB) & ETH_CFG_MII_GE0_MASK)
+#define ETH_CFG_MII_GE0_RESET                                        0x0 // 0
+#define ETH_CFG_RGMII_GE0_MSB                                        0
+#define ETH_CFG_RGMII_GE0_LSB                                        0
+#define ETH_CFG_RGMII_GE0_MASK                                       0x00000001
+#define ETH_CFG_RGMII_GE0_GET(x)                                     (((x) & ETH_CFG_RGMII_GE0_MASK) >> ETH_CFG_RGMII_GE0_LSB)
+#define ETH_CFG_RGMII_GE0_SET(x)                                     (((x) << ETH_CFG_RGMII_GE0_LSB) & ETH_CFG_RGMII_GE0_MASK)
+#define ETH_CFG_RGMII_GE0_RESET                                      0x0 // 0
+#define ETH_CFG_ADDRESS                                              0x18070000
+
+
+
+
+/*
+ * ownership of descriptors between DMA and cpu
+ */
+#define ath_gmac_rx_owned_by_dma(_ds)	((_ds)->is_empty == 1)
+#define ath_gmac_rx_give_to_dma(_ds)	((_ds)->is_empty = 1)
+#define ath_gmac_tx_owned_by_dma(_ds)	((_ds)->is_empty == 0)
+#define ath_gmac_tx_give_to_dma(_ds)	((_ds)->is_empty = 0)
+#define ath_gmac_tx_own(_ds)		((_ds)->is_empty = 1)
+
+/*
+ * link settings
+ */
+#define ath_gmac_set_mac_duplex(_mac, _fdx)	do {	\
+	if ((_fdx)) {					\
+		ath_gmac_reg_rmw_set(_mac,		\
+			ATH_MAC_CFG2, ATH_MAC_CFG2_FDX);\
+	} else {					\
+		ath_gmac_reg_rmw_clear(_mac,		\
+			ATH_MAC_CFG2, ATH_MAC_CFG2_FDX);\
+	}						\
+} while (0)
+
+#define ath_gmac_set_mac_if(_mac, _isXGMII)	do {		\
+	ath_gmac_reg_rmw_clear(_mac, ATH_MAC_CFG2,		\
+				ATH_MAC_CFG2_IF_1000 |		\
+				ATH_MAC_CFG2_IF_10_100);	\
+	if ((_isXGMII)) {					\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_CFG2,	\
+				ATH_MAC_CFG2_IF_1000);		\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_FIFO_CFG_5,	\
+				ATH_BYTE_PER_CLK_EN);		\
+	} else {						\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_CFG2,	\
+				ATH_MAC_CFG2_IF_10_100);	\
+		ath_gmac_reg_rmw_clear(_mac, ATH_MAC_FIFO_CFG_5,\
+				ATH_BYTE_PER_CLK_EN);		\
+	}							\
+} while (0)
+
+#define ath_gmac_set_mac_speed(_mac, _is100)	do {		\
+	if ((_is100)) {						\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_IFCTL,	\
+					ATH_MAC_IFCTL_SPEED);	\
+	} else {						\
+		ath_gmac_reg_rmw_clear(_mac, ATH_MAC_IFCTL,	\
+					ATH_MAC_IFCTL_SPEED);	\
+	}							\
+} while (0)
+
+#endif /* __QCA_ETH_953X_H */
diff --git a/board/atheros/common/qca-eth-953x_phy.h b/board/atheros/common/qca-eth-953x_phy.h
new file mode 100755
index 0000000000..f30d1f7be3
--- /dev/null
+++ b/board/atheros/common/qca-eth-953x_phy.h
@@ -0,0 +1,73 @@
+#ifndef _QCA_ETH_953x_PHY_H
+#define _QCA_ETH_953x_PHY_H
+#include <miiphy.h>
+
+
+#ifdef CONFIG_ATHR_8033_PHY
+extern int athrs_ar8033_reg_init(void *arg);
+extern int athrs_ar8033_phy_setup(void  *arg);
+extern int athrs_ar8033_phy_is_fdx(int ethUnit);
+extern int athrs_ar8033_phy_is_link_alive(int phyUnit);
+extern int athrs_ar8033_phy_is_up(int ethUnit);
+extern int athrs_ar8033_phy_speed(int ethUnit,int phyUnit);
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+extern int athrs27_phy_setup(int ethUnit);
+extern int athrs27_phy_is_up(int ethUnit);
+extern int athrs27_phy_is_fdx(int ethUnit);
+extern int athrs27_phy_speed(int ethUnit);
+#endif
+
+#ifdef CONFIG_ATHRS17_PHY
+extern int athrs17_phy_setup(int ethUnit);
+extern int athrs17_phy_is_up(int ethUnit);
+extern int athrs17_phy_is_fdx(int ethUnit);
+extern int athrs17_phy_speed(int ethUnit);
+#endif
+
+static inline void ath_gmac_phy_setup(int unit)
+{
+#ifdef CFG_ATHRS27_PHY
+                        athrs27_phy_setup(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+			athr_vir_phy_setup(unit);
+#endif
+}
+
+static inline void ath_gmac_phy_link(int unit, int *link)
+{
+
+#ifdef CFG_ATHRS27_PHY
+                        *link = athrs27_phy_is_up(unit);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			*link = athr_vir_phy_is_up(unit);
+#endif
+}
+
+static inline void ath_gmac_phy_duplex(int unit, int *duplex)
+{
+#ifdef CFG_ATHRS27_PHY
+                        *duplex = athrs27_phy_is_fdx(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+			*duplex = athr_vir_phy_is_fdx(unit);
+#endif
+}
+
+static inline void ath_gmac_phy_speed(int unit, int *speed)
+{
+#ifdef CFG_ATHRS27_PHY
+			 *speed = athrs27_phy_speed(unit);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			*speed = athr_vir_phy_speed(unit);
+#endif
+
+}
+
+#endif /* _QCA_ETH_953x_PHY_H */
diff --git a/board/atheros/common/qca-eth-955x.c b/board/atheros/common/qca-eth-955x.c
new file mode 100644
index 0000000000..62366ca246
--- /dev/null
+++ b/board/atheros/common/qca-eth-955x.c
@@ -0,0 +1,977 @@
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#include <atheros.h>
+#include "qca-eth-955x.h"
+#include "qca-eth-955x_phy.h"
+#define SGMII_LINK_WAR_MAX_TRY 10
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ath_gmac_unit2mac(_unit)     ath_gmac_macs[(_unit)]
+#define ath_gmac_name2mac(name)	   is_drqfn() ? ath_gmac_unit2mac(1):strcmp(name,"eth0") ? ath_gmac_unit2mac(1) : ath_gmac_unit2mac(0)
+
+uint16_t ath_gmac_miiphy_read(char *devname, uint32_t phaddr, uint8_t reg);
+void  ath_gmac_miiphy_write(char *devname, uint32_t phaddr, uint8_t reg, uint16_t data);
+extern void ath_sys_frequency(uint32_t *, uint32_t *, uint32_t *);
+
+#ifndef CFG_ATH_GMAC_NMACS
+#define CFG_ATH_GMAC_NMACS	1
+#endif /* CFG_ATH_GMAC_NMACS */
+
+ath_gmac_mac_t *ath_gmac_macs[CFG_ATH_GMAC_NMACS];
+
+
+#ifdef CONFIG_VIR_PHY
+extern int athr_vir_phy_setup(int unit);
+extern int athr_vir_phy_is_up(int unit);
+extern int athr_vir_phy_is_fdx(int unit);
+extern int athr_vir_phy_speed(int unit);
+extern void athr_vir_reg_init(void);
+#endif
+#ifdef  CONFIG_ATHRS17_PHY
+extern void athrs17_reg_init(void);
+extern void athrs17_reg_init_wan(void);
+#endif
+
+
+#ifdef CONFIG_ATHR_8033_PHY
+extern int athrs_ar8033_reg_init(void *arg);
+extern int athrs_ar8033_phy_setup(void  *arg);
+extern int athrs_ar8033_phy_is_fdx(int ethUnit);
+extern int athrs_ar8033_phy_is_link_alive(int phyUnit);
+extern int athrs_ar8033_phy_is_up(int ethUnit);
+extern int athrs_ar8033_phy_speed(int ethUnit,int phyUnit);
+#endif
+
+#ifdef CONFIG_ATH_NAND_BR
+
+#define ATH_ETH_MAC_READ_SIZE 4096
+extern unsigned long long
+ath_nand_get_cal_offset(const char *ba);
+#endif
+
+static int
+ath_gmac_send(struct eth_device *dev, volatile void *packet, int length)
+{
+	int i;
+
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
+
+	ath_gmac_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+	f->pkt_size = length;
+	f->res1 = 0;
+	f->pkt_start_addr = virt_to_phys(packet);
+
+	ath_gmac_tx_give_to_dma(f);
+	flush_cache((u32) packet, length);
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_DESC, virt_to_phys(f));
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_CTRL, ATH_TXE);
+
+	for (i = 0; i < MAX_WAIT; i++) {
+		udelay(10);
+		if (!ath_gmac_tx_owned_by_dma(f))
+			break;
+	}
+	if (i == MAX_WAIT)
+		printf("Tx Timed out\n");
+
+	f->pkt_start_addr = 0;
+	f->pkt_size = 0;
+
+	if (++mac->next_tx >= NO_OF_TX_FIFOS)
+		mac->next_tx = 0;
+
+	return (0);
+}
+
+static int ath_gmac_recv(struct eth_device *dev)
+{
+	int length;
+	ath_gmac_desc_t *f;
+	ath_gmac_mac_t *mac;
+    	volatile int dmaed_pkt=0;
+	int count = 0;
+
+	mac = (ath_gmac_mac_t *)dev->priv;
+
+	for (;;) {
+	     f = mac->fifo_rx[mac->next_rx];
+        if (ath_gmac_rx_owned_by_dma(f)) { 
+	 /* check if the current Descriptor is_empty is 1,But the DMAed count is not-zero 
+	    then move to desciprot where the packet is available */ 
+	   dmaed_pkt = (ath_gmac_reg_rd(mac, 0x194) >> 16);
+            if (!dmaed_pkt) {
+	        break ;
+              } else {  
+                if (f->is_empty == 1) {
+                    while ( count < NO_OF_RX_FIFOS ) {
+                        if (++mac->next_rx >= NO_OF_RX_FIFOS) {
+                            mac->next_rx = 0;
+                        }
+                        f = mac->fifo_rx[mac->next_rx];
+                        /*
+                         * Break on valid data in the desc by checking
+                         *  empty bit.
+                         */
+                        if (!f->is_empty){
+                            count = 0;
+                            break;
+                        }
+                        count++;
+                    }
+               }
+            } 
+	} 
+ 
+		length = f->pkt_size;
+
+		NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+		flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+		ath_gmac_reg_wr(mac,0x194,1);
+		ath_gmac_rx_give_to_dma(f);
+
+		if (++mac->next_rx >= NO_OF_RX_FIFOS)
+			mac->next_rx = 0;
+	}
+
+	if (!(ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL))) {
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, virt_to_phys(f));
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, 1);
+	}
+
+	return (0);
+}
+
+void ath_gmac_mii_setup(ath_gmac_mac_t *mac)
+{
+	u32 mgmt_cfg_val;
+
+	ath_reg_wr(SWITCH_CLOCK_SPARE_ADDRESS, 0x520);
+
+	if ((is_s17()  && mac->mac_unit == 0) || is_drqfn()) {
+		printf("Scorpion  ----> S17 PHY *\n");
+		mgmt_cfg_val = 7;
+#ifndef ATH_RGMII_CAL
+		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(3)|
+					ETH_CFG_RGMII_GE0_SET(1));
+
+		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
+                			     ETH_XMII_RX_DELAY_SET(2)  |
+                			     ETH_XMII_TX_DELAY_SET(1)  |
+					     ETH_XMII_GIGE_SET(1));
+#else
+        rgmii_cal_alg()
+#endif
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+		return;
+	}
+
+	if (is_ar8033 () && mac->mac_unit == 1) {
+        	printf("Scorpion ---->8033 PHY*\n");
+
+		mgmt_cfg_val = 7;
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+		return;
+        }
+        if (is_vir_phy()) {
+        	printf("Scorpion ---->VIR PHY*\n");
+
+		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(3)|
+					ETH_CFG_RGMII_GE0_SET(1));
+		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
+                			     ETH_XMII_RX_DELAY_SET(2)  |
+                			     ETH_XMII_TX_DELAY_SET(1)  |
+					     ETH_XMII_GIGE_SET(1));
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+                return;
+	}
+
+
+
+}
+
+void
+athrs_sgmii_res_cal(void)
+{
+	unsigned int read_data, read_data_otp, otp_value, otp_per_val, rbias_per;
+	unsigned int read_data_spi;
+	unsigned int *address_spi = (unsigned int *)0xbffffffc;
+	unsigned int rbias_pos_or_neg, res_cal_val;
+	unsigned int sgmii_pos, sgmii_res_cal_value;
+	unsigned int reversed_sgmii_value, use_value;
+
+	ath_reg_wr(OTP_INTF2_ADDRESS, 0x7d);
+	ath_reg_wr(OTP_LDO_CONTROL_ADDRESS, 0x0);
+
+	while (ath_reg_rd(OTP_LDO_STATUS_ADDRESS) & OTP_LDO_STATUS_POWER_ON_MASK);
+
+	read_data = ath_reg_rd(OTP_MEM_0_ADDRESS + 4);
+
+	while (!(ath_reg_rd(OTP_STATUS0_ADDRESS) & OTP_STATUS0_EFUSE_READ_DATA_VALID_MASK));
+
+	read_data_otp = ath_reg_rd(OTP_STATUS1_ADDRESS);
+
+	if (read_data_otp & 0x1fff) {
+		read_data = read_data_otp;
+	} else {
+		read_data_spi = *(address_spi);
+		if ((read_data_spi & 0xffff0000) == 0x5ca10000) {
+			read_data = read_data_spi;
+		} else {
+			read_data = read_data_otp;
+		}
+	}
+
+	if (read_data & 0x00001000) {
+		otp_value = (read_data & 0xfc0) >> 6;
+	} else {
+		otp_value = read_data & 0x3f;
+	}
+
+	if (otp_value > 31) {
+		otp_per_val = 63 - otp_value;
+		rbias_pos_or_neg = 1;
+	} else {
+		otp_per_val = otp_value;
+		rbias_pos_or_neg = 0;
+	}
+
+	rbias_per = otp_per_val * 15;
+
+	if (rbias_pos_or_neg == 1) {
+		res_cal_val = (rbias_per + 34) / 21;
+		sgmii_pos = 1;
+	} else {
+		if (rbias_per > 34) {
+			res_cal_val = (rbias_per - 34) / 21;
+			sgmii_pos = 0;
+		} else {
+			res_cal_val = (34 - rbias_per) / 21;
+			sgmii_pos = 1;
+		}
+	}
+
+	if (sgmii_pos == 1) {
+		sgmii_res_cal_value = 8 + res_cal_val;
+	} else {
+		sgmii_res_cal_value = 8 - res_cal_val;
+	}
+
+	reversed_sgmii_value = 0;
+	use_value = 0x8;
+	reversed_sgmii_value = reversed_sgmii_value | ((sgmii_res_cal_value & use_value) >> 3);
+	use_value = 0x4;
+	reversed_sgmii_value = reversed_sgmii_value | ((sgmii_res_cal_value & use_value) >> 1);
+	use_value = 0x2;
+	reversed_sgmii_value = reversed_sgmii_value | ((sgmii_res_cal_value & use_value) << 1);
+	use_value = 0x1;
+	reversed_sgmii_value = reversed_sgmii_value | ((sgmii_res_cal_value & use_value) << 3);
+
+	reversed_sgmii_value &= 0xf;
+
+	printf("%s: cal value = 0x%x\n", __func__, reversed_sgmii_value);
+
+	// To Check the locking of the SGMII PLL
+
+	read_data = (ath_reg_rd(SGMII_SERDES_ADDRESS) &
+				~SGMII_SERDES_RES_CALIBRATION_MASK) |
+			SGMII_SERDES_RES_CALIBRATION_SET(reversed_sgmii_value);
+
+	ath_reg_wr(SGMII_SERDES_ADDRESS, read_data);
+
+
+	ath_reg_wr(ETH_SGMII_SERDES_ADDRESS,
+			ETH_SGMII_SERDES_EN_LOCK_DETECT_MASK |
+			ETH_SGMII_SERDES_PLL_REFCLK_SEL_MASK |
+			ETH_SGMII_SERDES_EN_PLL_MASK);
+
+	ath_reg_rmw_set(SGMII_SERDES_ADDRESS,
+			SGMII_SERDES_CDR_BW_SET(3) |
+			SGMII_SERDES_TX_DR_CTRL_SET(1) |
+			SGMII_SERDES_PLL_BW_SET(1) |
+			SGMII_SERDES_EN_SIGNAL_DETECT_SET(1) |
+			SGMII_SERDES_FIBER_SDO_SET(1) |
+			SGMII_SERDES_VCO_REG_SET(3));
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_ARESET_MASK);
+	udelay(25);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_RESET_MASK);
+
+	while (!(ath_reg_rd(SGMII_SERDES_ADDRESS) & SGMII_SERDES_LOCK_DETECT_STATUS_MASK));
+}
+
+
+static void athr_gmac_sgmii_setup()
+{
+	int status = 0, count = 0;
+
+#ifdef ATH_SGMII_FORCED_MODE
+        ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_SPEED_SEL1_SET(1) |
+                                           MR_AN_CONTROL_PHY_RESET_SET(1)  |
+                                           MR_AN_CONTROL_DUPLEX_MODE_SET(1));
+        udelay(10);
+
+        ath_reg_wr(SGMII_CONFIG_ADDRESS, SGMII_CONFIG_MODE_CTRL_SET(2)   |
+                                          SGMII_CONFIG_FORCE_SPEED_SET(1) |
+                                          SGMII_CONFIG_SPEED_SET(2));
+
+        printf ("SGMII in forced mode\n");
+#else
+
+	ath_reg_wr(SGMII_CONFIG_ADDRESS, SGMII_CONFIG_MODE_CTRL_SET(2));
+
+	ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_AN_ENABLE_SET(1)
+                                      |MR_AN_CONTROL_PHY_RESET_SET(1));
+
+	ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_AN_ENABLE_SET(1));
+#endif
+/*
+ * SGMII reset sequence suggested by systems team.
+ */
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_RX_CLK_N_RESET);
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_TX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_TX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_CLK_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_TX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_CLK_N_SET(1)
+                                    |SGMII_RESET_TX_CLK_N_SET(1));
+
+        ath_reg_rmw_clear(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
+	/*
+	 * WAR::Across resets SGMII link status goes to weird
+	 * state.
+	 * if 0xb8070058 (SGMII_DEBUG register) reads other then 0x1f or 0x10
+	 * for sure we are in bad  state.
+	 * Issue a PHY reset in MR_AN_CONTROL_ADDRESS to keep going.
+	 */
+	status = (ath_reg_rd(SGMII_DEBUG_ADDRESS) & 0xff);
+	while (!(status == 0xf || status == 0x10)) {
+
+		ath_reg_rmw_set(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
+		udelay(100);
+		ath_reg_rmw_clear(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
+		if (count++ == SGMII_LINK_WAR_MAX_TRY) {
+			printf ("Max resets limit reached exiting...\n");
+			break;
+	    	}
+		status = (ath_reg_rd(SGMII_DEBUG_ADDRESS) & 0xff);
+	}
+
+	printf("%s SGMII done\n",__func__);
+
+}
+
+static void ath_gmac_hw_start(ath_gmac_mac_t *mac)
+{
+
+
+#ifndef ATH_RGMII_CAL /* Moved after mii_setup since these registers are touched in RGMII cal code */
+	if(mac->mac_unit)
+	{
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_1000));
+	} else {
+
+
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_10_100));
+	}
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+#endif
+
+
+#ifdef ATH_RGMII_CAL
+	if(mac->mac_unit)
+	{
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_1000));
+	} else {
+
+
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_10_100));
+	}
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+#endif
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_1, 0x10ffff);
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_2, 0xAAA0555);
+
+	ath_gmac_reg_rmw_set(mac, ATH_MAC_FIFO_CFG_4, 0x3ffff);
+	/*
+	 * Setting Drop CRC Errors, Pause Frames,Length Error frames
+	 * and Multi/Broad cast frames.
+	 */
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_5, 0x7eccf);
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_3, 0x1f00140);
+
+	printf(": cfg1 %#x cfg2 %#x\n", ath_gmac_reg_rd(mac, ATH_MAC_CFG1),
+			ath_gmac_reg_rd(mac, ATH_MAC_CFG2));
+
+
+}
+
+static int ath_gmac_check_link(ath_gmac_mac_t *mac)
+{
+	int link, duplex, speed;
+
+	ath_gmac_phy_link(mac->mac_unit, &link);
+	ath_gmac_phy_duplex(mac->mac_unit, &duplex);
+	ath_gmac_phy_speed(mac->mac_unit, &speed);
+
+	mac->link = link;
+
+	if(!mac->link) {
+		printf("%s link down\n",mac->dev->name);
+		return 0;
+	}
+
+	switch (speed)
+	{
+		case _1000BASET:
+			ath_gmac_set_mac_if(mac, 1);
+			ath_gmac_reg_rmw_set(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+
+			if (is_ar8033() && mac->mac_unit == 1) {
+				ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_GIGE_SET(1) |
+                                           ETH_SGMII_CLK_SEL_SET(1));
+			}
+
+			break;
+
+		case _100BASET:
+			ath_gmac_set_mac_if(mac, 0);
+			ath_gmac_set_mac_speed(mac, 1);
+			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+
+                        if (is_ar8033() && mac->mac_unit == 1) {
+                        	ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_PHASE0_COUNT_SET(1) |
+                                           ETH_SGMII_PHASE1_COUNT_SET(1));
+			}
+
+			break;
+
+		case _10BASET:
+			ath_gmac_set_mac_if(mac, 0);
+			ath_gmac_set_mac_speed(mac, 0);
+			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+
+			if (is_ar8033() && mac->mac_unit == 1) {
+				ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_PHASE0_COUNT_SET(19) |
+                                           ETH_SGMII_PHASE1_COUNT_SET(19));
+			}
+
+			break;
+
+		default:
+			printf("Invalid speed detected\n");
+			return 0;
+	}
+
+	if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+		return 1;
+
+	mac->duplex = duplex;
+	mac->speed = speed;
+
+	printf("dup %d speed %d\n", duplex, speed);
+
+	ath_gmac_set_mac_duplex(mac,duplex);
+
+	return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ath_gmac_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+	int i;
+	ath_gmac_desc_t *fr;
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t*)dev->priv;
+
+	if (!ath_gmac_check_link(mac))
+		return 0;
+
+	mac->next_rx = 0;
+
+        ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00); 
+        ath_gmac_reg_wr(mac, ATH_MAC_CFG1, (ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+
+	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+		fr = mac->fifo_rx[i];
+		fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+		flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+		ath_gmac_rx_give_to_dma(fr);
+	}
+
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, ATH_RXE);	/* rx start */
+	udelay(1000 * 1000);
+
+
+	return 1;
+
+}
+
+static int ath_gmac_alloc_fifo(int ndesc, ath_gmac_desc_t ** fifo)
+{
+	int i;
+	u32 size;
+	uchar *p = NULL;
+
+	size = sizeof(ath_gmac_desc_t) * ndesc;
+	size += CFG_CACHELINE_SIZE - 1;
+
+	if ((p = malloc(size)) == NULL) {
+		printf("Cant allocate fifos\n");
+		return -1;
+	}
+
+	p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+			~(CFG_CACHELINE_SIZE - 1));
+	p = UNCACHED_SDRAM(p);
+
+	for (i = 0; i < ndesc; i++)
+		fifo[i] = (ath_gmac_desc_t *) p + i;
+
+	return 0;
+}
+
+static int ath_gmac_setup_fifos(ath_gmac_mac_t *mac)
+{
+	int i;
+
+	if (ath_gmac_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+		return 1;
+
+	for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+		mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+			virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+		ath_gmac_tx_own(mac->fifo_tx[i]);
+	}
+
+	if (ath_gmac_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+		return 1;
+
+	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+		mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+			virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+	}
+
+	return (1);
+}
+
+static void ath_gmac_halt(struct eth_device *dev)
+{
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
+        ath_gmac_reg_rmw_clear(mac, ATH_MAC_CFG1,(ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+        ath_gmac_reg_wr(mac,ATH_MAC_FIFO_CFG_0,0x1f1f);
+	ath_gmac_reg_wr(mac,ATH_DMA_RX_CTRL, 0);
+	while (ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL));
+}
+
+#ifdef CONFIG_ATH_NAND_BR
+
+unsigned char *
+ath_eth_mac_addr(unsigned char *sectorBuff)
+{
+	ulong   off, size;
+	nand_info_t *nand;
+	unsigned char ret;
+
+	/*
+	 * caldata partition is of 128k
+	 */
+	nand = &nand_info[nand_curr_device];
+	size = ATH_ETH_MAC_READ_SIZE; /* To read 4k setting size as 4k */
+
+	/*
+	 * Get the Offset of Caldata partition
+	 */
+	off = ath_nand_get_cal_offset(getenv("bootargs"));
+	if(off == ATH_CAL_OFF_INVAL) {
+		printf("Invalid CAL offset \n");
+		return NULL;
+	}
+	/*
+	 * Get the values from flash, and program into the MAC address
+	 * registers
+	 */
+	ret = nand_read(nand, (loff_t)off, &size, (u_char *)sectorBuff);
+	printf(" %d bytes %s: %s\n", size,
+			"read", ret ? "ERROR" : "OK");
+	if(ret != 0 ) {
+		return NULL;
+	}
+
+	return sectorBuff;
+}
+
+#else  /* CONFIG_ATH_NAND_BR */
+
+unsigned char *
+ath_gmac_mac_addr_loc(void)
+{
+	extern flash_info_t flash_info[];
+
+#ifdef BOARDCAL
+	/*
+	 ** BOARDCAL environmental variable has the address of the cal sector
+	 */
+
+	return ((unsigned char *)BOARDCAL);
+
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+			(KSEG1ADDR(ATH_SPI_BASE) + (4 * 1024) +
+			 flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+#endif  /* CONFIG_ATH_NAND_BR */
+
+static void ath_gmac_get_ethaddr(struct eth_device *dev)
+{
+	unsigned char *eeprom;
+	unsigned char *mac = dev->enetaddr;
+#ifndef CONFIG_ATH_EMULATION
+
+#ifdef CONFIG_ATH_NAND_BR
+	unsigned char sectorBuff[ATH_ETH_MAC_READ_SIZE];
+
+	eeprom = ath_eth_mac_addr(sectorBuff);
+	if(eeprom == NULL) {
+		/* mac address will be set to default mac address */
+		mac[0] = 0xff;
+	}
+	else {
+#else  /* CONFIG_ATH_NAND_BR */
+		eeprom = ath_gmac_mac_addr_loc();
+#endif  /* CONFIG_ATH_NAND_BR */
+
+		if (strcmp(dev->name, "eth0") == 0) {
+			memcpy(mac, eeprom, 6);
+		} else if (strcmp(dev->name, "eth1") == 0) {
+			eeprom += 6;
+			memcpy(mac, eeprom, 6);
+		} else {
+			printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+			return;
+		}
+#ifdef CONFIG_ATH_NAND_BR
+	}
+#endif  /* CONFIG_ATH_NAND_BR */
+	/* Use fixed address if the above address is invalid */
+	if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff))
+#else
+	if (1)
+#endif
+	{
+		mac[0] = 0x00;
+		mac[1] = 0x03;
+		mac[2] = 0x7f;
+		mac[3] = 0x09;
+		mac[4] = 0x0b;
+		mac[5] = 0xad;
+		printf("No valid address in Flash. Using fixed address\n");
+	} else {
+		printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+	}
+}
+
+void
+athr_mgmt_init(void)
+{
+
+#ifdef CONFIG_MGMT_INIT
+	uint32_t rddata;
+
+	rddata = ath_reg_rd(GPIO_IN_ENABLE3_ADDRESS)&
+		~GPIO_IN_ENABLE3_MII_GE1_MDI_MASK;
+	rddata |= GPIO_IN_ENABLE3_MII_GE1_MDI_SET(19);
+	ath_reg_wr(GPIO_IN_ENABLE3_ADDRESS, rddata);
+
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 19));
+
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 17));
+
+
+	rddata = ath_reg_rd(GPIO_OUT_FUNCTION4_ADDRESS) &
+		~ (GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK |
+		GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK);
+
+	rddata |= GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(0x20) |
+	GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(0x21);
+
+	ath_reg_wr(GPIO_OUT_FUNCTION4_ADDRESS, rddata);
+#endif
+	printf ("%s ::done\n",__func__);
+}
+
+int ath_gmac_enet_initialize(bd_t * bis)
+{
+	struct eth_device *dev[CFG_ATH_GMAC_NMACS];
+	u32 mask, mac_h, mac_l;
+	int i;
+
+	printf("%s...\n", __func__);
+
+	athrs_sgmii_res_cal();
+
+	for (i = 0;i < CFG_ATH_GMAC_NMACS;i++) {
+
+		if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+			puts("malloc failed\n");
+			return 0;
+		}
+
+		if ((ath_gmac_macs[i] = (ath_gmac_mac_t *) malloc(sizeof (ath_gmac_mac_t))) == NULL) {
+			puts("malloc failed\n");
+			return 0;
+		}
+
+		memset(ath_gmac_macs[i], 0, sizeof(ath_gmac_macs[i]));
+		memset(dev[i], 0, sizeof(dev[i]));
+
+		sprintf(dev[i]->name, "eth%d", i);
+		ath_gmac_get_ethaddr(dev[i]);
+
+		ath_gmac_macs[i]->mac_unit = i;
+		ath_gmac_macs[i]->mac_base = i ? ATH_GE1_BASE : ATH_GE0_BASE ;
+		ath_gmac_macs[i]->dev = dev[i];
+
+		dev[i]->iobase = 0;
+		dev[i]->init = ath_gmac_clean_rx;
+		dev[i]->halt = ath_gmac_halt;
+		dev[i]->send = ath_gmac_send;
+		dev[i]->recv = ath_gmac_recv;
+		dev[i]->priv = (void *)ath_gmac_macs[i];
+	}
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	ath_reg_rmw_set(RST_RESET_ADDRESS,  RST_RESET_ETH_SGMII_ARESET_SET(1));
+	udelay(1000 * 100);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_ARESET_SET(1));
+	udelay(100);
+#endif
+	ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_RESET_SET(1) | RST_RESET_EXTERNAL_RESET_SET(1));
+	udelay(1000 * 100);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_RESET_SET(1) | RST_RESET_EXTERNAL_RESET_SET(1));
+	udelay(1000 * 100);
+
+	for (i = 0;i < CFG_ATH_GMAC_NMACS;i++) {
+
+		ath_gmac_reg_rmw_set(ath_gmac_macs[i], ATH_MAC_CFG1, ATH_MAC_CFG1_SOFT_RST
+				| ATH_MAC_CFG1_RX_RST | ATH_MAC_CFG1_TX_RST);
+
+		if(!i) {
+			mask = (ATH_RESET_GE0_MAC | ATH_RESET_GE1_MAC);
+
+			mask = mask | ATH_RESET_GE0_MDIO | ATH_RESET_GE1_MDIO;
+
+			printf("%s: reset mask:%x \n", __func__, mask);
+
+			ath_reg_rmw_set(RST_RESET_ADDRESS, mask);
+			udelay(1000 * 100);
+
+			ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+			udelay(1000 * 100);
+
+			udelay(10 * 1000);
+		}
+#if defined(CONFIG_MGMT_INIT) && defined (CONFIG_ATHR_SWITCH_ONLY_MODE) || defined ATH_MDC_GPIO
+		if (!i)
+			athr_mgmt_init();
+
+		if (ath_gmac_macs[i]->mac_unit == 0)
+                        continue;
+#endif
+		eth_register(dev[i]);
+#if(CONFIG_COMMANDS & CFG_CMD_MII)
+		miiphy_register(dev[i]->name, ath_gmac_miiphy_read, ath_gmac_miiphy_write);
+#endif
+		ath_gmac_mii_setup(ath_gmac_macs[i]);
+
+		/* if using header for register configuration, we have to     */
+		/* configure s26 register after frame transmission is enabled */
+
+		if (ath_gmac_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef  CONFIG_ATHRS17_PHY
+			athrs17_reg_init();
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			printf("VIRPhy reg init \n");
+			athr_vir_reg_init();
+#endif
+
+		} else {
+#ifdef CONFIG_ATHR_8033_PHY
+			printf("AR8033 PHY init \n");
+			athrs_ar8033_reg_init(NULL);
+
+#endif
+
+#if defined(CONFIG_MGMT_INIT) && defined (CONFIG_ATHR_SWITCH_ONLY_MODE)
+			athrs17_reg_init();
+                       
+#elif defined (CONFIG_ATHRS17_PHY) && !defined(CFG_DUAL_PHY_SUPPORT)
+			athrs17_reg_init_wan();
+#endif
+		}
+#ifdef CONFIG_ATHRS_GMAC_SGMII
+	/*
+         * MAC unit 1 or drqfn package call sgmii setup.
+	 */
+	if (i == 1 || is_drqfn())
+		athr_gmac_sgmii_setup();
+#endif
+		ath_gmac_hw_start(ath_gmac_macs[i]);
+		ath_gmac_setup_fifos(ath_gmac_macs[i]);
+
+
+
+		udelay(100 * 1000);
+
+		{
+			unsigned char *mac = dev[i]->enetaddr;
+
+			printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+					mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+					mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+		}
+		mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+		mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+			(dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+		ath_gmac_reg_wr(ath_gmac_macs[i], ATH_GE_MAC_ADDR1, mac_l);
+		ath_gmac_reg_wr(ath_gmac_macs[i], ATH_GE_MAC_ADDR2, mac_h);
+
+
+	ath_gmac_phy_setup(ath_gmac_macs[i]->mac_unit);
+		printf("%s up\n",dev[i]->name);
+	}
+
+
+	return 1;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+uint16_t
+ath_gmac_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg)
+{
+	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
+	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg, val;
+	volatile int           rddata;
+	uint16_t      ii = 0xFFFF;
+
+
+
+
+	/*
+	 * Check for previous transactions are complete. Added to avoid
+	 * race condition while running at higher frequencies.
+	 */
+	do
+	{
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	}while(rddata && --ii);
+
+	if (ii == 0)
+		printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_ADDRESS, addr);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, ATH_MGMT_CMD_READ);
+
+	do
+	{
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	}while(rddata && --ii);
+
+	if(ii==0)
+		printf("Error!!! Leave ath_gmac_miiphy_read without polling correct status!\n");
+
+	val = ath_gmac_reg_rd(mac, ATH_MII_MGMT_STATUS);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
+
+	return val;
+}
+
+void
+ath_gmac_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
+	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg;
+	volatile int rddata;
+	uint16_t      ii = 0xFFFF;
+
+
+	/*
+	 * Check for previous transactions are complete. Added to avoid
+	 * race condition while running at higher frequencies.
+	 */
+	do {
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	} while (rddata && --ii);
+
+	if (ii == 0)
+		printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_ADDRESS, addr);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CTRL, data);
+
+	do {
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	} while (rddata && --ii);
+
+	if (ii == 0)
+		printf("Error!!! Leave ath_gmac_miiphy_write without polling correct status!\n");
+}
+#endif		/* CONFIG_COMMANDS & CFG_CMD_MII */
diff --git a/board/atheros/common/qca-eth-955x.h b/board/atheros/common/qca-eth-955x.h
new file mode 100644
index 0000000000..86821f4f11
--- /dev/null
+++ b/board/atheros/common/qca-eth-955x.h
@@ -0,0 +1,407 @@
+#ifndef _AGxxxx_H
+#define _AGxxxx_H
+
+#include <linux/types.h>
+
+#ifdef ATH_RGMII_CAL
+#define rgmii_cal_alg()    rgmii_calib(mac);
+#else
+#define rgmii_cal_alg()    
+#endif
+
+/*
+ * h/w descriptor
+ */
+typedef struct {
+	uint32_t	pkt_start_addr,
+			is_empty	:  1,
+			res1		: 10,
+			ftpp_override	:  5,
+			res2		:  4,
+			pkt_size	: 12,
+			next_desc;
+} ath_gmac_desc_t;
+
+#define NO_OF_TX_FIFOS			8
+#define NO_OF_RX_FIFOS			8
+
+typedef struct {
+	ath_gmac_desc_t		*fifo_tx[NO_OF_TX_FIFOS],
+				*fifo_rx[NO_OF_RX_FIFOS];
+	struct eth_device	*dev;
+	uint32_t		next_tx,
+				next_rx,
+				link,
+				duplex,
+				speed,
+				mac_unit,
+				mac_base;
+} ath_gmac_mac_t;
+
+#define ath_gmac_reg_wr(_mac, _x, _y)	ath_reg_wr(((_x) + _mac->mac_base), (_y))
+#define ath_gmac_reg_rd(_mac, _x)	ath_reg_rd(((_x) + _mac->mac_base))
+
+#define ath_gmac_reg_rmw_set(_mac, _x, _y)	\
+	ath_reg_rmw_set(((_x) + _mac->mac_base ), (_y))
+#define ath_gmac_reg_rmw_clear(_mac, _x, _y)	\
+	ath_reg_rmw_clear(((_x) + _mac->mac_base), (_y))
+
+#ifdef COMPRESSED_UBOOT
+#define _1000BASET		1000
+#define _100BASET		100
+#define _10BASET		10
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/*
+ * spd is _1000BASET, _100BASET etc. defined in include/miiphy.h
+ */
+#define mii_reg(_mac)	(ATH_MII0_CTRL + ((_mac)->mac_unit * 4))
+#define mii_if(_mac)	(((_mac)->mac_unit == 0) ? mii0_if : mii1_if)
+
+#define ath_gmac_set_mii_ctrl_speed(_mac, _spd)	do {	\
+	ath_reg_rmw_clear(mii_reg(_mac), (3 << 4));	\
+	ath_reg_rmw_set(mii_reg(_mac), ((_spd) << 4));	\
+} while (0)
+
+#if defined (CFG_MII0_GMII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_MII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_RGMII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_RMII)
+#	define ath_gmac_get_mii_if()	0
+#endif
+
+#define MAX_WAIT			1000
+
+/*
+ * Config/Mac Register definitions
+ */
+#define ATH_MAC_CFG1			0x00
+#define ATH_MAC_CFG2			0x04
+#define ATH_MAC_IFCTL			0x38
+
+/*
+ * fifo control registers
+ */
+#define ATH_MAC_FIFO_CFG_0		0x48
+#define ATH_MAC_FIFO_CFG_1		0x4c
+#define ATH_MAC_FIFO_CFG_2		0x50
+#define ATH_MAC_FIFO_CFG_3		0x54
+#define ATH_MAC_FIFO_CFG_4		0x58
+
+#define ATH_MAC_FIFO_CFG_5		0x5c
+#define ATH_BYTE_PER_CLK_EN		(1 << 19)
+
+#define ATH_MAC_FIFO_RAM_0		0x60
+#define ATH_MAC_FIFO_RAM_1		0x64
+#define ATH_MAC_FIFO_RAM_2		0x68
+#define ATH_MAC_FIFO_RAM_3		0x6c
+#define ATH_MAC_FIFO_RAM_4		0x70
+#define ATH_MAC_FIFO_RAM_5		0x74
+#define ATH_MAC_FIFO_RAM_6		0x78
+#define ATH_MAC_FIFO_RAM_7		0x7c
+
+/*
+ * fields
+ */
+#define ATH_MAC_CFG1_SOFT_RST		(1 << 31)
+#define ATH_MAC_CFG1_RX_RST		(1 << 19)
+#define ATH_MAC_CFG1_TX_RST		(1 << 18)
+#define ATH_MAC_CFG1_LOOPBACK		(1 << 8)
+#define ATH_MAC_CFG1_RX_EN		(1 << 2)
+#define ATH_MAC_CFG1_TX_EN		(1 << 0)
+
+#define ATH_MAC_CFG2_FDX		(1 << 0)
+#define ATH_MAC_CFG2_PAD_CRC_EN		(1 << 2)
+#define ATH_MAC_CFG2_LEN_CHECK		(1 << 4)
+#define ATH_MAC_CFG2_HUGE_FRAME_EN	(1 << 5)
+#define ATH_MAC_CFG2_IF_1000		(1 << 9)
+#define ATH_MAC_CFG2_IF_10_100		(1 << 8)
+
+#define ATH_MAC_IFCTL_SPEED		(1 << 16)
+
+/*
+ * DMA (tx/rx) register defines
+ */
+#define ATH_DMA_TX_CTRL			0x180
+#define ATH_DMA_TX_DESC			0x184
+#define ATH_DMA_TX_STATUS		0x188
+#define ATH_DMA_RX_CTRL			0x18c
+#define ATH_DMA_RX_DESC			0x190
+#define ATH_DMA_RX_STATUS		0x194
+#define ATH_DMA_INTR_MASK		0x198
+#define ATH_DMA_INTR			0x19c
+
+/*
+ * tx/rx ctrl and status bits
+ */
+#define ATH_TXE				(1 << 0)
+#define ATH_TX_STATUS_PKTCNT_SHIFT	16
+#define ATH_TX_STATUS_PKT_SENT		0x1
+#define ATH_TX_STATUS_URN		0x2
+#define ATH_TX_STATUS_BUS_ERROR		0x8
+
+#define ATH_RXE				(1 << 0)
+
+#define ATH_RX_STATUS_PKTCNT_MASK	0xff0000
+#define ATH_RX_STATUS_PKT_RCVD		(1 << 0)
+#define ATH_RX_STATUS_OVF		(1 << 2)
+#define ATH_RX_STATUS_BUS_ERROR		(1 << 3)
+
+/*
+ * Int and int mask
+ */
+#define ATH_INTR_TX			(1 << 0)
+#define ATH_INTR_TX_URN			(1 << 1)
+#define ATH_INTR_TX_BUS_ERROR		(1 << 3)
+#define ATH_INTR_RX			(1 << 4)
+#define ATH_INTR_RX_OVF			(1 << 6)
+#define ATH_INTR_RX_BUS_ERROR		(1 << 7)
+
+/*
+ * MII registers
+ */
+#define ATH_MAC_MII_MGMT_CFG		0x20
+#define ATH_MGMT_CFG_CLK_DIV_20		0x07
+
+#define ATH_MII_MGMT_CMD		0x24
+#define ATH_MGMT_CMD_READ		0x1
+
+#define ATH_MII_MGMT_ADDRESS		0x28
+#define ATH_ADDR_SHIFT			8
+
+#define ATH_MII_MGMT_CTRL		0x2c
+#define ATH_MII_MGMT_STATUS		0x30
+
+#define ATH_MII_MGMT_IND		0x34
+#define ATH_MGMT_IND_BUSY		(1 << 0)
+#define ATH_MGMT_IND_INVALID		(1 << 2)
+
+#define ATH_GE_MAC_ADDR1		0x40
+#define ATH_GE_MAC_ADDR2		0x44
+
+/*
+ * Ethernet config registers
+ */
+#define ATH_ETH_CFG			0x18070000
+#define ATH_ETH_CFG_RGMII_GE0		(1<<0)
+#define ATH_ETH_CFG_MII_GE0		(1<<1)
+#define ATH_ETH_CFG_GMII_GE0		(1<<2)
+#define ATH_ETH_CFG_RMII_GE0		(1<<10)
+#define ATH_ETH_CFG_RMII_HISPD_GE0	(1<<11)
+#define ATH_ETH_CFG_RMII_MASTER_MODE	(1<<12)
+#define ATH_ETH_CFG_MII_GE0_MASTER	(1<<3)
+#define ATH_ETH_CFG_MII_GE0_SLAVE	(1<<4)
+#define ATH_ETH_CFG_GE0_ERR_EN		(1<<5)
+#define ATH_ETH_CFG_SW_ONLY_MODE	(1<<6)
+#define ATH_ETH_CFG_SW_PHY_SWAP		(1<<7)
+#define ATH_ETH_CFG_SW_PHY_ADDR_SWAP	(1<<8)
+#define ATH_ETH_CFG_RXD_DELAY		(1 << 14)
+#define ATH_ETH_CFG_RDV_DELAY		(1 << 16)
+#define ATH_ETH_SWITCH_CLK_SPARE	0x18050024
+
+#define ETH_XMII_TX_INVERT_MSB                                       31
+#define ETH_XMII_TX_INVERT_LSB                                       31
+#define ETH_XMII_TX_INVERT_MASK                                      0x80000000
+#define ETH_XMII_TX_INVERT_GET(x)                                    (((x) & ETH_XMII_TX_INVERT_MASK) >> ETH_XMII_TX_INVERT_LSB)
+#define ETH_XMII_TX_INVERT_SET(x)                                    (((x) << ETH_XMII_TX_INVERT_LSB) & ETH_XMII_TX_INVERT_MASK)
+#define ETH_XMII_TX_INVERT_RESET                                     0x0 // 0
+#define ETH_XMII_GIGE_QUAD_MSB                                       30
+#define ETH_XMII_GIGE_QUAD_LSB                                       30
+#define ETH_XMII_GIGE_QUAD_MASK                                      0x40000000
+#define ETH_XMII_GIGE_QUAD_GET(x)                                    (((x) & ETH_XMII_GIGE_QUAD_MASK) >> ETH_XMII_GIGE_QUAD_LSB)
+#define ETH_XMII_GIGE_QUAD_SET(x)                                    (((x) << ETH_XMII_GIGE_QUAD_LSB) & ETH_XMII_GIGE_QUAD_MASK)
+#define ETH_XMII_GIGE_QUAD_RESET                                     0x0 // 0
+#define ETH_XMII_RX_DELAY_MSB                                        29
+#define ETH_XMII_RX_DELAY_LSB                                        28
+#define ETH_XMII_RX_DELAY_MASK                                       0x30000000
+#define ETH_XMII_RX_DELAY_GET(x)                                     (((x) & ETH_XMII_RX_DELAY_MASK) >> ETH_XMII_RX_DELAY_LSB)
+#define ETH_XMII_RX_DELAY_SET(x)                                     (((x) << ETH_XMII_RX_DELAY_LSB) & ETH_XMII_RX_DELAY_MASK)
+#define ETH_XMII_RX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_TX_DELAY_MSB                                        27
+#define ETH_XMII_TX_DELAY_LSB                                        26
+#define ETH_XMII_TX_DELAY_MASK                                       0x0c000000
+#define ETH_XMII_TX_DELAY_GET(x)                                     (((x) & ETH_XMII_TX_DELAY_MASK) >> ETH_XMII_TX_DELAY_LSB)
+#define ETH_XMII_TX_DELAY_SET(x)                                     (((x) << ETH_XMII_TX_DELAY_LSB) & ETH_XMII_TX_DELAY_MASK)
+#define ETH_XMII_TX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_GIGE_MSB                                            25
+#define ETH_XMII_GIGE_LSB                                            25
+#define ETH_XMII_GIGE_MASK                                           0x02000000
+#define ETH_XMII_GIGE_GET(x)                                         (((x) & ETH_XMII_GIGE_MASK) >> ETH_XMII_GIGE_LSB)
+#define ETH_XMII_GIGE_SET(x)                                         (((x) << ETH_XMII_GIGE_LSB) & ETH_XMII_GIGE_MASK)
+#define ETH_XMII_GIGE_RESET                                          0x0 // 0
+#define ETH_XMII_OFFSET_PHASE_MSB                                    24
+#define ETH_XMII_OFFSET_PHASE_LSB                                    24
+#define ETH_XMII_OFFSET_PHASE_MASK                                   0x01000000
+#define ETH_XMII_OFFSET_PHASE_GET(x)                                 (((x) & ETH_XMII_OFFSET_PHASE_MASK) >> ETH_XMII_OFFSET_PHASE_LSB)
+#define ETH_XMII_OFFSET_PHASE_SET(x)                                 (((x) << ETH_XMII_OFFSET_PHASE_LSB) & ETH_XMII_OFFSET_PHASE_MASK)
+#define ETH_XMII_OFFSET_PHASE_RESET                                  0x0 // 0
+#define ETH_XMII_OFFSET_COUNT_MSB                                    23
+#define ETH_XMII_OFFSET_COUNT_LSB                                    16
+#define ETH_XMII_OFFSET_COUNT_MASK                                   0x00ff0000
+#define ETH_XMII_OFFSET_COUNT_GET(x)                                 (((x) & ETH_XMII_OFFSET_COUNT_MASK) >> ETH_XMII_OFFSET_COUNT_LSB)
+#define ETH_XMII_OFFSET_COUNT_SET(x)                                 (((x) << ETH_XMII_OFFSET_COUNT_LSB) & ETH_XMII_OFFSET_COUNT_MASK)
+#define ETH_XMII_OFFSET_COUNT_RESET                                  0x0 // 0
+#define ETH_XMII_PHASE1_COUNT_MSB                                    15
+#define ETH_XMII_PHASE1_COUNT_LSB                                    8
+#define ETH_XMII_PHASE1_COUNT_MASK                                   0x0000ff00
+#define ETH_XMII_PHASE1_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE1_COUNT_MASK) >> ETH_XMII_PHASE1_COUNT_LSB)
+#define ETH_XMII_PHASE1_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE1_COUNT_LSB) & ETH_XMII_PHASE1_COUNT_MASK)
+#define ETH_XMII_PHASE1_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_PHASE0_COUNT_MSB                                    7
+#define ETH_XMII_PHASE0_COUNT_LSB                                    0
+#define ETH_XMII_PHASE0_COUNT_MASK                                   0x000000ff
+#define ETH_XMII_PHASE0_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE0_COUNT_MASK) >> ETH_XMII_PHASE0_COUNT_LSB)
+#define ETH_XMII_PHASE0_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE0_COUNT_LSB) & ETH_XMII_PHASE0_COUNT_MASK)
+#define ETH_XMII_PHASE0_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_ADDRESS                                             0x18050028
+
+
+
+#define ETH_CFG_ETH_SPARE_MSB                                        31
+#define ETH_CFG_ETH_SPARE_LSB                                        22
+#define ETH_CFG_ETH_SPARE_MASK                                       0xffc00000
+#define ETH_CFG_ETH_SPARE_GET(x)                                     (((x) & ETH_CFG_ETH_SPARE_MASK) >> ETH_CFG_ETH_SPARE_LSB)
+#define ETH_CFG_ETH_SPARE_SET(x)                                     (((x) << ETH_CFG_ETH_SPARE_LSB) & ETH_CFG_ETH_SPARE_MASK)
+#define ETH_CFG_ETH_SPARE_RESET                                      0x0 // 0
+#define ETH_CFG_ETH_TXEN_DELAY_MSB                                   21
+#define ETH_CFG_ETH_TXEN_DELAY_LSB                                   20
+#define ETH_CFG_ETH_TXEN_DELAY_MASK                                  0x00300000
+#define ETH_CFG_ETH_TXEN_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_TXEN_DELAY_MASK) >> ETH_CFG_ETH_TXEN_DELAY_LSB)
+#define ETH_CFG_ETH_TXEN_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_TXEN_DELAY_LSB) & ETH_CFG_ETH_TXEN_DELAY_MASK)
+#define ETH_CFG_ETH_TXEN_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_TXD_DELAY_MSB                                    19
+#define ETH_CFG_ETH_TXD_DELAY_LSB                                    18
+#define ETH_CFG_ETH_TXD_DELAY_MASK                                   0x000c0000
+#define ETH_CFG_ETH_TXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_TXD_DELAY_MASK) >> ETH_CFG_ETH_TXD_DELAY_LSB)
+#define ETH_CFG_ETH_TXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_TXD_DELAY_LSB) & ETH_CFG_ETH_TXD_DELAY_MASK)
+#define ETH_CFG_ETH_TXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_ETH_RXDV_DELAY_MSB                                   17
+#define ETH_CFG_ETH_RXDV_DELAY_LSB                                   16
+#define ETH_CFG_ETH_RXDV_DELAY_MASK                                  0x00030000
+#define ETH_CFG_ETH_RXDV_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_RXDV_DELAY_MASK) >> ETH_CFG_ETH_RXDV_DELAY_LSB)
+#define ETH_CFG_ETH_RXDV_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_RXDV_DELAY_LSB) & ETH_CFG_ETH_RXDV_DELAY_MASK)
+#define ETH_CFG_ETH_RXDV_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_RXD_DELAY_MSB                                    15
+#define ETH_CFG_ETH_RXD_DELAY_LSB                                    14
+#define ETH_CFG_ETH_RXD_DELAY_MASK                                   0x0000c000
+#define ETH_CFG_ETH_RXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_RXD_DELAY_MASK) >> ETH_CFG_ETH_RXD_DELAY_LSB)
+#define ETH_CFG_ETH_RXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_RXD_DELAY_LSB) & ETH_CFG_ETH_RXD_DELAY_MASK)
+#define ETH_CFG_ETH_RXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_RMII_GE0_MASTER_MSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_LSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_MASK                                 0x00001000
+#define ETH_CFG_RMII_GE0_MASTER_GET(x)                               (((x) & ETH_CFG_RMII_GE0_MASTER_MASK) >> ETH_CFG_RMII_GE0_MASTER_LSB)
+#define ETH_CFG_RMII_GE0_MASTER_SET(x)                               (((x) << ETH_CFG_RMII_GE0_MASTER_LSB) & ETH_CFG_RMII_GE0_MASTER_MASK)
+#define ETH_CFG_RMII_GE0_MASTER_RESET                                0x1 // 1
+#define ETH_CFG_MII_CNTL_SPEED_MSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_LSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_MASK                                  0x00000800
+#define ETH_CFG_MII_CNTL_SPEED_GET(x)                                (((x) & ETH_CFG_MII_CNTL_SPEED_MASK) >> ETH_CFG_MII_CNTL_SPEED_LSB)
+#define ETH_CFG_MII_CNTL_SPEED_SET(x)                                (((x) << ETH_CFG_MII_CNTL_SPEED_LSB) & ETH_CFG_MII_CNTL_SPEED_MASK)
+#define ETH_CFG_MII_CNTL_SPEED_RESET                                 0x0 // 0
+#define ETH_CFG_RMII_GE0_MSB                                         10
+#define ETH_CFG_RMII_GE0_LSB                                         10
+#define ETH_CFG_RMII_GE0_MASK                                        0x00000400
+#define ETH_CFG_RMII_GE0_GET(x)                                      (((x) & ETH_CFG_RMII_GE0_MASK) >> ETH_CFG_RMII_GE0_LSB)
+#define ETH_CFG_RMII_GE0_SET(x)                                      (((x) << ETH_CFG_RMII_GE0_LSB) & ETH_CFG_RMII_GE0_MASK)
+#define ETH_CFG_RMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_GE0_SGMII_MSB                                        6
+#define ETH_CFG_GE0_SGMII_LSB                                        6
+#define ETH_CFG_GE0_SGMII_MASK                                       0x00000040
+#define ETH_CFG_GE0_SGMII_GET(x)                                     (((x) & ETH_CFG_GE0_SGMII_MASK) >> ETH_CFG_GE0_SGMII_LSB)
+#define ETH_CFG_GE0_SGMII_SET(x)                                     (((x) << ETH_CFG_GE0_SGMII_LSB) & ETH_CFG_GE0_SGMII_MASK)
+#define ETH_CFG_GE0_SGMII_RESET                                      0x0 // 0
+#define ETH_CFG_GE0_ERR_EN_MSB                                       5
+#define ETH_CFG_GE0_ERR_EN_LSB                                       5
+#define ETH_CFG_GE0_ERR_EN_MASK                                      0x00000020
+#define ETH_CFG_GE0_ERR_EN_GET(x)                                    (((x) & ETH_CFG_GE0_ERR_EN_MASK) >> ETH_CFG_GE0_ERR_EN_LSB)
+#define ETH_CFG_GE0_ERR_EN_SET(x)                                    (((x) << ETH_CFG_GE0_ERR_EN_LSB) & ETH_CFG_GE0_ERR_EN_MASK)
+#define ETH_CFG_GE0_ERR_EN_RESET                                     0x0 // 0
+#define ETH_CFG_MII_GE0_SLAVE_MSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_LSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_MASK                                   0x00000010
+#define ETH_CFG_MII_GE0_SLAVE_GET(x)                                 (((x) & ETH_CFG_MII_GE0_SLAVE_MASK) >> ETH_CFG_MII_GE0_SLAVE_LSB)
+#define ETH_CFG_MII_GE0_SLAVE_SET(x)                                 (((x) << ETH_CFG_MII_GE0_SLAVE_LSB) & ETH_CFG_MII_GE0_SLAVE_MASK)
+#define ETH_CFG_MII_GE0_SLAVE_RESET                                  0x0 // 0
+#define ETH_CFG_MII_GE0_MASTER_MSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_LSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_MASK                                  0x00000008
+#define ETH_CFG_MII_GE0_MASTER_GET(x)                                (((x) & ETH_CFG_MII_GE0_MASTER_MASK) >> ETH_CFG_MII_GE0_MASTER_LSB)
+#define ETH_CFG_MII_GE0_MASTER_SET(x)                                (((x) << ETH_CFG_MII_GE0_MASTER_LSB) & ETH_CFG_MII_GE0_MASTER_MASK)
+#define ETH_CFG_MII_GE0_MASTER_RESET                                 0x0 // 0
+#define ETH_CFG_GMII_GE0_MSB                                         2
+#define ETH_CFG_GMII_GE0_LSB                                         2
+#define ETH_CFG_GMII_GE0_MASK                                        0x00000004
+#define ETH_CFG_GMII_GE0_GET(x)                                      (((x) & ETH_CFG_GMII_GE0_MASK) >> ETH_CFG_GMII_GE0_LSB)
+#define ETH_CFG_GMII_GE0_SET(x)                                      (((x) << ETH_CFG_GMII_GE0_LSB) & ETH_CFG_GMII_GE0_MASK)
+#define ETH_CFG_GMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_MII_GE0_MSB                                          1
+#define ETH_CFG_MII_GE0_LSB                                          1
+#define ETH_CFG_MII_GE0_MASK                                         0x00000002
+#define ETH_CFG_MII_GE0_GET(x)                                       (((x) & ETH_CFG_MII_GE0_MASK) >> ETH_CFG_MII_GE0_LSB)
+#define ETH_CFG_MII_GE0_SET(x)                                       (((x) << ETH_CFG_MII_GE0_LSB) & ETH_CFG_MII_GE0_MASK)
+#define ETH_CFG_MII_GE0_RESET                                        0x0 // 0
+#define ETH_CFG_RGMII_GE0_MSB                                        0
+#define ETH_CFG_RGMII_GE0_LSB                                        0
+#define ETH_CFG_RGMII_GE0_MASK                                       0x00000001
+#define ETH_CFG_RGMII_GE0_GET(x)                                     (((x) & ETH_CFG_RGMII_GE0_MASK) >> ETH_CFG_RGMII_GE0_LSB)
+#define ETH_CFG_RGMII_GE0_SET(x)                                     (((x) << ETH_CFG_RGMII_GE0_LSB) & ETH_CFG_RGMII_GE0_MASK)
+#define ETH_CFG_RGMII_GE0_RESET                                      0x0 // 0
+#define ETH_CFG_ADDRESS                                              0x18070000
+
+
+
+
+/*
+ * ownership of descriptors between DMA and cpu
+ */
+#define ath_gmac_rx_owned_by_dma(_ds)	((_ds)->is_empty == 1)
+#define ath_gmac_rx_give_to_dma(_ds)	((_ds)->is_empty = 1)
+#define ath_gmac_tx_owned_by_dma(_ds)	((_ds)->is_empty == 0)
+#define ath_gmac_tx_give_to_dma(_ds)	((_ds)->is_empty = 0)
+#define ath_gmac_tx_own(_ds)		((_ds)->is_empty = 1)
+
+/*
+ * link settings
+ */
+#define ath_gmac_set_mac_duplex(_mac, _fdx)	do {	\
+	if ((_fdx)) {					\
+		ath_gmac_reg_rmw_set(_mac,		\
+			ATH_MAC_CFG2, ATH_MAC_CFG2_FDX);\
+	} else {					\
+		ath_gmac_reg_rmw_clear(_mac,		\
+			ATH_MAC_CFG2, ATH_MAC_CFG2_FDX);\
+	}						\
+} while (0)
+
+#define ath_gmac_set_mac_if(_mac, _isXGMII)	do {		\
+	ath_gmac_reg_rmw_clear(_mac, ATH_MAC_CFG2,		\
+				ATH_MAC_CFG2_IF_1000 |		\
+				ATH_MAC_CFG2_IF_10_100);	\
+	if ((_isXGMII)) {					\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_CFG2,	\
+				ATH_MAC_CFG2_IF_1000);		\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_FIFO_CFG_5,	\
+				ATH_BYTE_PER_CLK_EN);		\
+	} else {						\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_CFG2,	\
+				ATH_MAC_CFG2_IF_10_100);	\
+		ath_gmac_reg_rmw_clear(_mac, ATH_MAC_FIFO_CFG_5,\
+				ATH_BYTE_PER_CLK_EN);		\
+	}							\
+} while (0)
+
+#define ath_gmac_set_mac_speed(_mac, _is100)	do {		\
+	if ((_is100)) {						\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_IFCTL,	\
+					ATH_MAC_IFCTL_SPEED);	\
+	} else {						\
+		ath_gmac_reg_rmw_clear(_mac, ATH_MAC_IFCTL,	\
+					ATH_MAC_IFCTL_SPEED);	\
+	}							\
+} while (0)
+
+#endif
diff --git a/board/atheros/common/qca-eth-955x_phy.h b/board/atheros/common/qca-eth-955x_phy.h
new file mode 100644
index 0000000000..3f498aa732
--- /dev/null
+++ b/board/atheros/common/qca-eth-955x_phy.h
@@ -0,0 +1,102 @@
+#ifndef _QCA_ETH_955x_PHY_H
+#define _QCA_ETH_955x_PHY_H
+#include <miiphy.h>
+
+
+#ifdef CONFIG_ATHR_8033_PHY
+extern int athrs_ar8033_reg_init(void *arg);
+extern int athrs_ar8033_phy_setup(void  *arg);
+extern int athrs_ar8033_phy_is_fdx(int ethUnit);
+extern int athrs_ar8033_phy_is_link_alive(int phyUnit);
+extern int athrs_ar8033_phy_is_up(int ethUnit);
+extern int athrs_ar8033_phy_speed(int ethUnit,int phyUnit);
+#endif
+
+#ifdef CONFIG_ATHRS17_PHY
+extern int athrs17_phy_setup(int ethUnit);
+extern int athrs17_phy_is_up(int ethUnit);
+extern int athrs17_phy_is_fdx(int ethUnit);
+extern int athrs17_phy_speed(int ethUnit);
+#endif
+
+static inline void ath_gmac_phy_setup(int unit)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			athrs17_phy_setup(unit);
+		} else
+#endif
+		{
+#ifdef CONFIG_VIR_PHY
+			athr_vir_phy_setup(unit);
+#endif
+#if defined(CONFIG_ATHRS17_PHY) && !defined (CFG_DUAL_PHY_SUPPORT)
+			athrs17_phy_setup(unit);
+#endif
+
+		}
+}
+
+static inline void ath_gmac_phy_link(int unit, int *link)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			*link = athrs17_phy_is_up(unit);
+		} else
+#endif
+		{
+#ifdef CONFIG_VIR_PHY
+			*link = athr_vir_phy_is_up(unit);
+#endif
+#ifdef CONFIG_ATHR_8033_PHY
+			*link = athrs_ar8033_phy_is_up(unit);
+#endif
+#if defined(CONFIG_ATHRS17_PHY) && !defined (CFG_DUAL_PHY_SUPPORT)
+			*link = athrs17_phy_is_up(unit);
+#endif
+
+		}
+}
+
+static inline void ath_gmac_phy_duplex(int unit, int *duplex)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			*duplex = athrs17_phy_is_fdx(unit);
+		} else
+#endif
+		{
+#ifdef CONFIG_VIR_PHY
+			*duplex = athr_vir_phy_is_fdx(unit);
+#endif
+#ifdef CONFIG_ATHR_8033_PHY
+			*duplex = athrs_ar8033_phy_is_fdx(unit);
+#endif
+#if defined(CONFIG_ATHRS17_PHY) && !defined(CFG_DUAL_PHY_SUPPORT)
+			*duplex = athrs17_phy_is_fdx(unit);
+#endif
+		}
+}
+
+static inline void ath_gmac_phy_speed(int unit, int *speed)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			*speed = _1000BASET;
+		} else
+#endif
+		{
+#ifdef CONFIG_VIR_PHY
+			*speed = athr_vir_phy_speed(unit);
+#endif
+#ifdef CONFIG_ATHR_8033_PHY
+			*speed = athrs_ar8033_phy_speed(unit, 5);
+#endif
+
+#if defined(CONFIG_ATHRS17_PHY) && !defined (CFG_DUAL_PHY_SUPPORT)
+			*speed = _1000BASET;
+#endif
+		}
+}
+
+#endif /* _QCA_ETH_955x_PHY_H */
diff --git a/board/atheros/common/rgmii-cal-955x.c b/board/atheros/common/rgmii-cal-955x.c
new file mode 100644
index 0000000000..c2d2d39b6a
--- /dev/null
+++ b/board/atheros/common/rgmii-cal-955x.c
@@ -0,0 +1,600 @@
+//#include <gmac_defines.h>
+//#include <prototypes.h>
+
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#include <atheros.h>
+#include "qca-eth-955x.h"
+#include "qca-eth-955x_phy.h"
+
+#ifdef ATH_RGMII_CAL
+
+#define NUM_DESCRIPTORS		10	//Number of packets to be looped back
+#define node_tx_buf_len		100	// No of bytes per packet to be looped back
+
+#define DEBUG		0
+#define DEBUG_1 	1
+
+#define GE0_PEMSTAT_RBYT	(0x9c + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RPKT	(0xA0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RFCS	(0xA4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RMCA	(0xA8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RBCA	(0xAC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RXCF	(0xB0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RXPF	(0xB4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RXUO	(0xB8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RALN	(0xBC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RFLR	(0xC0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RCDE	(0xC4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RCSE	(0xC8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RUND	(0xCC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_ROVR	(0xD0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RFRG	(0xD4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RJBR	(0xD8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RDRP	(0xDC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_TPKT	(0xE0 + ATH_GE0_BASE)
+
+#define NUM_DESCS 10
+
+void init_s17_lpbk(void);
+uint32_t athrs17_reg_read(uint32_t reg_addr);
+void athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val);
+
+int results[5] = { 0, 1, 1, 1, 0 };
+
+int find;
+
+void big_del(void)
+{
+	int i;
+	for (i = 0; i < 10000; i++) ;
+}
+
+// This should tell us what the best of the 4 values is. It should also tell us what the longest sequence is.
+// Since only four bits are used the best of 4 values can be easily arrived at by a truth table.
+// Presently we have an algorithm though.
+int find_value(void)
+{
+	int i;
+	int start_ok = 9;
+	int end_ok = 9;
+	int longest_start_ok = 0;
+	int longest_end_ok = 0;
+	int longest_ok_cnt = -1;
+	int first = 0;
+
+	for (i = 0; i < 5; i++) {
+#if DEBUG
+		printf("results [%d]: %d\n", i, results[i]);
+#endif
+		if (results[i] == 1) {
+			if (start_ok == 9) {
+				start_ok = i;
+				if (first == 0) {
+					longest_start_ok = i;
+					longest_end_ok = i;
+					first = 1;
+				}
+			}
+		}
+		if (results[i] == 0) {
+			if (end_ok == 9) {
+				end_ok = i - 1;
+			}
+			if ((end_ok - start_ok) > longest_ok_cnt) {
+				longest_start_ok = start_ok;
+				longest_end_ok = end_ok;
+				longest_ok_cnt = (end_ok - start_ok);
+			}
+			start_ok = 9;
+			end_ok = 9;
+		}
+	}
+
+#if DEBUG
+	printf("FINAL VALUE - ");
+#endif
+	find = (longest_end_ok + longest_start_ok) / 2;
+#if DEBUG
+	printf("find - %d\n", find);
+	printf("FINAL OK COUNT - %d\n", longest_ok_cnt + 1);
+#endif
+	return (longest_ok_cnt + 1);
+}
+
+int pkt_compare_data(void)
+{
+	unsigned int i, j;
+	//unsigned int k,rddata;
+	unsigned int node_rx_buf_len;
+	//unsigned int * node_tx_desc_ptr = (unsigned int *) 0xa0280000;
+	unsigned int *node_rx_desc_ptr = (unsigned int *)0xa0380000;
+	unsigned int *node_tx_buf_addr = (unsigned int *)0xa0680000;
+	unsigned int *node_rx_buf_addr = (unsigned int *)0xa0580000;
+	unsigned int error = 0;
+	unsigned pkt_err[NUM_DESCS];
+
+	node_rx_buf_len = (*(node_rx_desc_ptr + 0x1) & 0xfff) - 0x4;
+	// node_tx_buf_len = *(node_tx_desc_ptr + (NUM_DESCS-1)*0x3+0x1) & 0xfff;
+
+	for (j = 0; j < NUM_DESCS; j++) {
+		node_rx_buf_len = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & 0xfff) - 0x4;
+		pkt_err[j] = 0;
+		for (i = 0; i < (node_rx_buf_len / 4); i++) {
+			if (((*(node_rx_buf_addr + i + (j * 0x100))) != *(node_tx_buf_addr + i))) {
+				error = error + 0x1;
+				pkt_err[j] = 1;
+			}
+		}
+		//node_rx_buf_addr = node_rx_buf_addr + 0x100;
+	}
+	if (error == 0) {
+		return 0;
+	} else {
+		for (j = 0; j < NUM_DESCS; j++) {
+			node_rx_buf_len = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & 0xfff) - 0x4;
+			if (pkt_err[j] == 1) {
+#if DEBUG
+				printf("PKT %d\n", j);
+				printf("---------------------------------\n");
+
+				for (i = 0; i < (node_rx_buf_len / 4); i++) {
+					//if(((*(node_rx_buf_addr + i )) != *(node_tx_buf_addr + i)))
+					if (((*(node_rx_buf_addr + i + (j * 0x100))) != *(node_tx_buf_addr + i))) {
+						printf("->");
+					} else {
+						printf("  ");
+					}
+					printf("%x", (*(node_rx_buf_addr + i + (j * 0x100))));
+					printf("  ");
+					printf("%x\n", (*(node_tx_buf_addr + i)));
+				}
+				printf("---------------------------------\n");
+#endif
+			}
+			//node_rx_buf_addr = node_rx_buf_addr + 0x100;
+		}
+		return 1;
+	}
+}
+
+void rgmii_calib(ath_gmac_mac_t * mac)
+{
+
+	unsigned int i;
+	unsigned int j;
+	unsigned int k, l, m;
+	unsigned int rddata, error = 0;
+	unsigned int node_rx_buf_len = 1600;
+	unsigned int node_rx_buf_len1;
+	unsigned int *node_tx_desc_ptr = (unsigned int *)0xa0280000;
+	unsigned int *node_rx_desc_ptr = (unsigned int *)0xa0380000;
+	unsigned int *node_rx_buf_addr = (unsigned int *)0xa0580000;
+	unsigned int *node_tx_buf_addr = (unsigned int *)0xa0680000;
+	unsigned int *node_comp_result = (unsigned int *)0xa0200000;
+	unsigned int s17_tx_pkt = 0;
+	unsigned int s17_rx_pkt = 0;
+	unsigned int to;
+	unsigned int pass = 1;
+	unsigned int fail = 0;
+	int lgst = 0;
+	int old_lgst = 0;
+	unsigned int xmii[16];
+	unsigned int eth_cfg[16];
+	unsigned int xmii_val = 0;
+	unsigned int eth_cfg_val = 1;
+	unsigned int tx_fix = 0;
+
+
+	// GIGE Enable
+	ath_reg_wr(ETH_XMII_ADDRESS,	ETH_XMII_TX_INVERT_SET(0x1) |
+					ETH_XMII_RX_DELAY_SET(0x2) |
+					ETH_XMII_TX_DELAY_SET(0x1) |
+					ETH_XMII_GIGE_SET(0x1));
+
+	while ((ath_reg_rd(SGMII_SERDES_ADDRESS) & SGMII_SERDES_LOCK_DETECT_STATUS_SET(1)) == 0) {
+		printf("TEST: WAIT FOR LOCK\n");
+	}
+
+	big_del();
+
+	// MAC INITS
+	// RGMII Enable on GE0
+	//eth_init();
+	init_s17_lpbk();
+	athrs17_reg_write(0x30, 1);
+
+	ath_reg_wr(ETH_CFG_ADDRESS,	ETH_CFG_ETH_RXDV_DELAY_SET(0x3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(0x3) |
+					ETH_CFG_RGMII_GE0_SET(0x1));
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_GE0_MAC_RESET_MASK);	// Bringing GE0 out of RESET
+	ath_gmac_reg_wr(mac, ATH_MAC_CFG2, 0x7235);	//for 1000mbps
+	//ath_reg_wr(GE0_MAC_CONFIG_2,0x7135);  //for 100mbps
+	ath_gmac_reg_wr(mac, ATH_MAC_IFCTL, 0x00000);
+	ath_gmac_reg_wr(mac, ATH_MAC_CFG1, 0x005);
+	//ath_reg_wr(GE0_MAC_CONFIG_1,0x105);  // For MAC Loopback
+	ath_gmac_reg_wr(mac, ATH_DMA_INTR_MASK, 0);	// Disable interrupt mask
+	ath_gmac_reg_wr(mac, ATH_GE_MAC_ADDR1, 0x003fffff);	//ethernet mac address
+	ath_gmac_reg_wr(mac, ATH_GE_MAC_ADDR2, 0xfffe0000);	//ethernet mac address
+	ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, 0x6);	//clock/20= 2MHz
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);	// Enable the FIFO modules
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_1, 0x10ffff);
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_3, 0x1f00140);
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_4, 0x1000);
+	//ath_reg_wr(GE0_FIFO_CFG_REG_5, 0xbefff); //enable drop
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_5, 0xfffff);	//for 1000Mbps
+	//ath_reg_wr(GE0_FIFO_CFG_REG_5, 0x7ffff);//for 100Mbps
+
+	//************
+	// PACKETS
+	//***********
+
+	// Initialise Data in Memory for TX and RX
+	for (i = 0; i < node_tx_buf_len; i++)
+		*(node_tx_buf_addr + i) = i | (i + 1) << 8 | (i + 2) << 16 | (i + 3) << 24;
+
+#if DEBUG
+	printf("TEST: Inits Done\n");
+#endif
+	// Set Up Transmit Descriptor Table
+
+	for (i = 0; i < NUM_DESCRIPTORS; i++) {
+		*(node_tx_desc_ptr + (i * 0x3)) = ((unsigned int)node_tx_buf_addr & 0x0fffffff);
+		*(node_tx_desc_ptr + (i * 0x3) + 0x1) = (node_tx_buf_len & 0x7fffffff);
+
+		if (i == (NUM_DESCRIPTORS - 1))
+			*(node_tx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_tx_desc_ptr & 0x0fffffff);
+		else
+			*(node_tx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_tx_desc_ptr & 0x0fffffff) + (i * 0xc) + 0xc;
+	}
+
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_DESC, ((unsigned int)node_tx_desc_ptr & 0x0fffffff));
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_STATUS, 0xfffffff);	// clear dma status
+
+	for (i = 0; i < NUM_DESCRIPTORS; i++) {
+		*(node_rx_desc_ptr + (i * 0x3)) = ((unsigned int)node_rx_buf_addr & 0x0fffffff);
+		*(node_rx_desc_ptr + (i * 0x3) + 0x1) = (node_rx_buf_len & 0xfff) | (1 << 31);
+		if (i == (NUM_DESCRIPTORS - 1))
+			*(node_rx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_rx_desc_ptr & 0x0fffffff);
+		else
+			*(node_rx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_rx_desc_ptr & 0x0fffffff) + (i * 0xc) + 0xc;
+		node_rx_buf_addr = node_rx_buf_addr + 0x100;
+
+	}
+
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, ((unsigned int)node_rx_desc_ptr & 0x0fffffff));
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_STATUS, 0xfffffff);	// clear dma status
+
+	k = 0;
+
+	// Enable TX and RX MAC
+	ath_gmac_reg_wr(mac, ATH_MAC_CFG1, 0x005);
+
+	// This routine will go through 16 combinations to find the best value for TX_DELAY, GIGE_QUAD, TX_INVERT
+	for (l = 0; l < 16; l++) {
+		// initialize pass. this will be made zero if there is a failure in packet reception compare
+		pass = 1;
+		// fail due to checks in rx etc. this is not the same as !pass
+		fail = 0;
+
+		// GIGE_QUAD  - 0
+		// TX_INVERT  - 0
+		// TX_DELAY   - 0,1,2,3
+		if (l < 4) {
+			// GIGE Enable and TX_DELAY
+			rddata = ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		// GIGE_QUAD  - 1
+		// TX_INVERT  - 0
+		// TX_DELAY   - 0,1,2,3
+		if ((l < 8) && (l > 3)) {
+			// GIGE Enable and TX_DELAY & GIGE_QUAD
+			rddata = ETH_XMII_GIGE_QUAD_SET(0x1) |
+				ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		// GIGE_QUAD  - 0
+		// TX_INVERT  - 1
+		// TX_DELAY   - 0,1,2,3
+		if ((l < 12) && (l > 7)) {
+			// GIGE Enable and TX_DELAY and TX_INVERT
+			rddata = ETH_XMII_TX_INVERT_SET(0x1) |
+				ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		// GIGE_QUAD  - 0
+		// TX_INVERT  - 1
+		// TX_DELAY   - 0,1,2,3
+		if ((l < 16) && (l > 11)) {
+			// GIGE Enable and TX_DELAY and TX_INVERT and GIGE_QUAD
+			rddata = ETH_XMII_TX_INVERT_SET(0x1) |
+				ETH_XMII_GIGE_QUAD_SET(0x1) |
+				ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		xmii[l] = rddata;
+
+		// counts when to print out counter stats
+		k++;
+		// Set Up Receive Descriptor Table
+		node_rx_buf_len = 0x0;
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, 0x1);	// enable dma rx
+		ath_gmac_reg_wr(mac, ATH_DMA_TX_CTRL, 0x1);	// enable dma tx
+
+		rddata = (*(node_tx_desc_ptr + (NUM_DESCRIPTORS - 1) * 0x3 + 0x1) & (1 << 31));
+		while (rddata != (1 << 31))
+			rddata = (*(node_tx_desc_ptr + (NUM_DESCRIPTORS - 1) * 0x3 + 0x1) & (1 << 31));
+#if DEBUG
+		printf("TEST: Tx Done \n");
+#endif
+
+		to = 0;
+		rddata = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & (1 << 31));
+		while (rddata != 0x0) {
+			rddata = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & (1 << 31));
+			to++;
+			if (to > 100000) {
+#if DEBUG
+				printf("TEST: ERROR!! Atleast 1 packet in GE0 not seen.\n");
+#endif
+				fail = 1;
+				break;
+			}
+		}
+#if DEBUG
+		printf("TEST: Rx Done \n");
+#endif
+
+		if (k % 1 == 0) {
+			for (j = GE0_PEMSTAT_RBYT; j <= GE0_PEMSTAT_RDRP; j = j + 4) {
+				rddata = ath_reg_rd(j);
+				switch (j) {
+#if DEBUG
+				case GE0_PEMSTAT_RPKT:
+					printf("TEST: RPKT - 0x%08x\n", rddata);
+					break;
+				case GE0_PEMSTAT_TPKT:
+					printf("TEST: TPKT - 0x%08x\n", rddata);
+					break;
+#endif
+				}
+			}
+#ifdef ATH_S17_MAC0_SGMII
+			s17_rx_pkt = athrs17_reg_read(0x163c) + (athrs17_reg_read(0x1640) << 16);
+#else
+			s17_rx_pkt = athrs17_reg_read(0x103c) + (athrs17_reg_read(0x1040) << 16);
+#endif
+#if DEBUG
+			printf("TEST: RPKT in S17 0x%08x\n", s17_rx_pkt);
+#endif
+#ifdef ATH_S17_MAC0_SGMII
+			s17_tx_pkt = athrs17_reg_read(0x1684) + (athrs17_reg_read(0x1688) << 16);
+#else
+			s17_tx_pkt = athrs17_reg_read(0x1084) + (athrs17_reg_read(0x1088) << 16);
+#endif
+#if DEBUG
+			printf("TEST: TPKT in S17 0x%08x\n", s17_tx_pkt);
+#endif
+			// Compare BYTES in TX
+			if (s17_tx_pkt != 0x410) {
+#if DEBUG
+				printf("TEST: PKTS @ S17 - 0x%08x\n", rddata);
+#endif
+				pass = 0;
+				fail = 1;
+			}
+
+		}
+		if (fail == 0) {
+			error = pkt_compare_data();
+		}
+		if (error == 0) {
+#if DEBUG
+			printf("TEST: PACKET COMPARISON PASS\n");
+#endif
+		} else {
+#if DEBUG
+			printf("TEST: ERROR!! PACKET COMPARISON FAIL\n");
+#endif
+			fail = 1;
+		}
+
+		for (i = 0; i < NUM_DESCRIPTORS; i++) {
+			*(node_tx_desc_ptr + (i * 0x3) + 0x1) = (node_tx_buf_len & 0x7fffffff);
+			*(node_rx_desc_ptr + (i * 0x3) + 0x1) = (node_rx_buf_len & 0xfff) | (1 << 31);
+		}
+
+		// populate results and find the optimum value of programming
+		results[(l % 4)] = pass;
+		if (((l % 4) == 3)) {
+			lgst = find_value();
+			if (lgst > old_lgst) {
+				old_lgst = lgst;
+				xmii_val = xmii[(l - 3) + find];
+			}
+		}
+	}
+#if DEBUG_1
+	printf("TEST: FINAL REG VAL after TX Calibration - 0x%08x\n", xmii_val);
+#endif
+	tx_fix = xmii_val;
+
+	old_lgst = 0;
+
+	// Using the previously arrived at value of TX Calib we calibrate RX DELAYS. For this we use RX DAT and EN Delays
+	for (l = 0; l < 16; l++) {
+		// initialize pass. this will be made zero if there is a failure in packet reception compare
+		pass = 1;
+		// fail due to checks in rx etc. this is not the same as !pass
+		fail = 0;
+		rddata = ath_reg_rd(ETH_CFG_ADDRESS);
+#if DEBUG
+		printf("TEST: Initial ETH_CFG - 0x%08x\n", rddata);
+#endif
+
+		// RXD_DELAY  - l / 4 -> 0, 1, 2, 3
+		// RXEN_DELAY - l / 4 -> 0, 1, 2, 3
+		// RX_DELAY   - l & 3 -> 0, 1, 2, 3
+		ath_reg_rmw_clear(ETH_CFG_ADDRESS,
+					ETH_CFG_ETH_RXDV_DELAY_MASK |
+					ETH_CFG_ETH_RXD_DELAY_MASK);
+		ath_reg_rmw_set(ETH_CFG_ADDRESS,
+					ETH_CFG_ETH_RXDV_DELAY_SET(l / 4) |
+					ETH_CFG_ETH_RXD_DELAY_SET(l / 4));
+		rddata = ath_reg_rd(ETH_CFG_ADDRESS);
+#if DEBUG
+		printf("TEST: ETH_CFG - 0x%08x\n", rddata);
+#endif
+		eth_cfg[l] = rddata;
+		rddata = tx_fix | ETH_XMII_RX_DELAY_SET(l);
+		ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+
+		xmii[l] = rddata;
+
+		// counts when to print out counter stats
+		k++;
+		// Set Up Receive Descriptor Table
+		node_rx_buf_len = 0x0;
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, 0x1);	// enable dma rx
+		ath_gmac_reg_wr(mac, ATH_DMA_TX_CTRL, 0x1);	// enable dma tx
+
+		rddata = (*(node_tx_desc_ptr + (NUM_DESCRIPTORS - 1) * 0x3 + 0x1) & (1 << 31));
+		while (rddata != (1 << 31))
+			rddata = (*(node_tx_desc_ptr + (NUM_DESCRIPTORS - 1) * 0x3 + 0x1) & (1 << 31));
+#if DEBUG
+		printf("TEST: Tx Done \n");
+#endif
+
+		to = 0;
+		rddata = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & (1 << 31));
+		while (rddata != 0x0) {
+			rddata = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & (1 << 31));
+			to++;
+			if (to > 100000) {
+#if DEBUG
+				printf("TEST: ERROR!! Atleast 1 packet in GE0 not seen.\n");
+#endif
+				// This check for RX.
+				pass = 0;
+				fail = 1;
+				break;
+			}
+		}
+#if DEBUG
+		printf("TEST: Rx Done \n");
+#endif
+
+		if (k % 1 == 0) {
+			for (j = GE0_PEMSTAT_RBYT; j <= GE0_PEMSTAT_RDRP; j = j + 4) {
+				rddata = ath_reg_rd(j);
+				switch (j) {
+#if DEBUG
+				case GE0_PEMSTAT_RPKT:
+					printf("TEST: RPKT 0x%08x\n", rddata);
+					break;
+				case GE0_PEMSTAT_TPKT:
+					printf("TEST: TPKT 0x%08x\n", rddata);
+					break;
+#endif
+				}
+			}
+#ifdef ATH_S17_MAC0_SGMII
+			s17_rx_pkt = athrs17_reg_read(0x163c) + (athrs17_reg_read(0x1640) << 16);
+#else
+			s17_rx_pkt = athrs17_reg_read(0x103c) + (athrs17_reg_read(0x1040) << 16);
+#endif
+#if DEBUG
+			printf("TEST: RPKT in S17 0x%08x\n", s17_rx_pkt);
+#endif
+#ifdef ATH_S17_MAC0_SGMII
+			s17_tx_pkt = athrs17_reg_read(0x1684) + (athrs17_reg_read(0x1688) << 16);
+#else
+			s17_tx_pkt = athrs17_reg_read(0x1084) + (athrs17_reg_read(0x1088) << 16);
+#endif
+#if DEBUG
+			printf("TEST: TPKT in S17 0x%08x\n", s17_tx_pkt);
+#endif
+			// Compare BYTES in TX
+			if (s17_tx_pkt != 0x410) {
+#if DEBUG
+				printf("TEST: PKTS @ S17 - 0x%08x\n", rddata);
+#endif
+				pass = 0;
+				fail = 1;
+			}
+
+		}
+		if (fail == 0) {
+			error = pkt_compare_data();
+		}
+		if (error == 0) {
+			//printf("TEST: PACKET COMPARISON PASS\n");
+		} else {
+#if DEBUG
+			printf("TEST: ERROR!! PACKET COMPARISON FAIL\n");
+#endif
+			fail = 1;
+			// Different from TX. This ensures packets are received back properly for a valid config.
+			pass = 0;
+		}
+
+		for (i = 0; i < NUM_DESCRIPTORS; i++) {
+			*(node_tx_desc_ptr + (i * 0x3) + 0x1) = (node_tx_buf_len & 0x7fffffff);
+			*(node_rx_desc_ptr + (i * 0x3) + 0x1) = (node_rx_buf_len & 0xfff) | (1 << 31);
+		}
+
+		// populate results and find the optimum value of programming
+		// For every set of 4 configurations find longest valid configs and number.
+		results[(l % 4)] = pass;
+		if (((l % 4) == 3)) {
+			lgst = find_value();
+			if (lgst > old_lgst) {
+				old_lgst = lgst;
+				xmii_val = xmii[(l - 3) + find];
+				eth_cfg_val = eth_cfg[(l - 3) + find];
+			}
+		}
+	}
+	// And write to these registers.
+#if DEBUG_1
+	printf("TEST: FINAL XMII VAL after RX Calibration - 0x%08x\n", xmii_val);
+#endif
+	ath_reg_wr(ETH_XMII_ADDRESS, xmii_val);
+#if DEBUG_1
+	printf("TEST: FINAL ETH_CFG VAL after RX Calibration - 0x%08x\n", eth_cfg_val);
+#endif
+	ath_reg_wr(ETH_CFG_ADDRESS, eth_cfg_val);
+	ath_gmac_reg_wr(mac,ATH_MAC_CFG1,1<<31);
+
+}
+
+#endif /* #ifdef RGMII_CAL */
diff --git a/board/atheros/common/serial.c b/board/atheros/common/serial.c
new file mode 100644
index 0000000000..ae58e18d9d
--- /dev/null
+++ b/board/atheros/common/serial.c
@@ -0,0 +1,88 @@
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <config.h>
+#include <atheros.h>
+
+int serial_init(void)
+{
+//#if !defined(CONFIG_ATH_EMULATION)
+	uint32_t div, val;
+
+	div = ath_uart_freq() / (16 * CONFIG_BAUDRATE);
+#ifdef CONFIG_SCO_SLAVE_CONNECTED 
+	val = ath_reg_rd(GPIO_OE_ADDRESS) & (~0xcbf410u);
+#else
+	val = ath_reg_rd(GPIO_OE_ADDRESS) & (~0xcffc10u);
+#endif
+	ath_reg_wr(GPIO_OE_ADDRESS, val);
+
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION2_ADDRESS,
+			GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_SET(0x16));
+
+	ath_reg_rmw_clear(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_SET(0xff));
+
+	ath_reg_rmw_set(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_SET(0x9));
+
+	//val = ath_reg_rd(GPIO_OUT_ADDRESS) | 0xcffc10u;
+	//ath_reg_wr(GPIO_OUT_ADDRESS, val);
+
+	val = ath_reg_rd(GPIO_SPARE_ADDRESS);
+	ath_reg_wr(GPIO_SPARE_ADDRESS, (val | 0x8402));
+
+	//ath_reg_wr(GPIO_OUT_ADDRESS, 0x2f);
+
+	/*
+	 * set DIAB bit
+	 */
+	ath_uart_wr(OFS_LINE_CONTROL, 0x80);
+
+	/* set divisor */
+	ath_uart_wr(OFS_DIVISOR_LSB, (div & 0xff));
+	ath_uart_wr(OFS_DIVISOR_MSB, ((div >> 8) & 0xff));
+
+	/* clear DIAB bit*/
+	ath_uart_wr(OFS_LINE_CONTROL, 0x00);
+
+	/* set data format */
+	ath_uart_wr(OFS_DATA_FORMAT, 0x3);
+
+	ath_uart_wr(OFS_INTR_ENABLE, 0);
+//#endif
+	return 0;
+}
+
+int serial_tstc (void)
+{
+	return(ath_uart_rd(OFS_LINE_STATUS) & 0x1);
+}
+
+u8 serial_getc(void)
+{
+	while(!serial_tstc());
+
+	return ath_uart_rd(OFS_RCV_BUFFER);
+}
+
+
+void serial_putc(u8 byte)
+{
+	if (byte == '\n') serial_putc ('\r');
+
+	while (((ath_uart_rd(OFS_LINE_STATUS)) & 0x20) == 0x0);
+
+	ath_uart_wr(OFS_SEND_BUFFER, byte);
+}
+
+void serial_setbrg (void)
+{
+}
+
+void serial_puts (const char *s)
+{
+	while (*s)
+	{
+		serial_putc (*s++);
+	}
+}
diff --git a/board/atheros/common/tap-953x.S b/board/atheros/common/tap-953x.S
new file mode 100755
index 0000000000..a1e24d65d0
--- /dev/null
+++ b/board/atheros/common/tap-953x.S
@@ -0,0 +1,182 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+.globl ath_ddr_tap_cal
+	.type	ath_ddr_tap_cal,	@function
+	.text
+	.align 4
+ath_ddr_tap_cal:
+	li	a0,	0xbd001f00
+	sw	zero,	0x0(a0)			// Place where the tap values are saved and used for SWEEP
+	sw	zero,	0x4(a0)			// Place where the number of passing taps are saved.
+	sw	zero,	0x14(a0)		// Place where the last pass tap value is stored
+	li	a1,	0xaa55aa55		// Indicates that the First pass tap value is not found
+	sw	a1,	0x10(a0)		// Place where the First pass tap value is stored
+	nop
+
+	li	a0,	0xb8060000		// RESET_BASE_ADDRESS
+	lw	a1,	0x1c(a0)		// Reading the RST_RESET_ADDRESS
+	li	a2,	0x08000000		// Setting the RST_RESET_RTC_RESET
+	or	a1,	a1,	a2
+	sw	a1,	0x1c(a0)
+
+	li	a3,	0xffffffff
+	xor	a2,	a2,	a3
+	and	a1,	a1,	a2
+	sw	a1,	0x1c(a0)		// Taking the RTC out of RESET
+	nop
+
+	li	a0,	0xb8107000		// RTC_BASE_ADDRESS
+	li	a1,	0x1
+	sw	a1,	0x0040(a0)		// RTC_SYNC_RESET_ADDRESS
+
+	li	a2,	0x2
+
+_poll_for_RTC_ON:
+	lw	a1,	0x0044(a0)		// RTC_SYNC_STATUS_ADDRESS
+	and	a1,	a2,	a1
+	bne	a1,	a2,	_poll_for_RTC_ON
+
+
+_CHANGE_TAPS:
+
+	li	t0,	0xbd001f00		// Read the current value of the TAP for programming
+	lw	t1,	0x0(t0)
+	li	t2,	0x00000000
+	or	t3,	t1,	t2
+
+
+	li	t0,	0xb8000000		// DDR_BASE_ADDRESS
+
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	li	t1,	0x00000010		// Running the test 8 times
+	sw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+
+	li	t1,	0xfa5de83f		// 4 Row Address Bits, 4 Column Address Bits, 2 BA bits
+	sw	t1,	0x002c(t0)		// PERF_MASK_ADDR_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0070(t0)		// PERF_COMP_AHB_GE0_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0040(t0)		// PERF_COMP_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0078(t0)		// PERF_COMP_AHB_GE1_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0034(t0)		// PERF_MASK_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x006c(t0)		// PERF_MASK_AHB_GE0_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x003c(t0)		// PERF_MASK_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0074(t0)		// PERF_MASK_AHB_GE1_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0038(t0)		// PERF_COMP_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x00000001
+	sw	t1,	0x011c(t0)		// DDR_BIST_ADDRESS
+
+	li	t2,	0x1
+_bist_done_poll:
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	and	t1,	t1,	t2
+	bne	t1,	t2,	_bist_done_poll
+
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	li	t4,	0x000001fe
+	and	t2,	t1,	t4
+	srl	t2,	t2,	0x1		// no. of Pass Runs
+
+	li	t5,	0x00000000
+	sw	t5,	0x011c(t0)		//DDR_BIST_ADDRESS	- Stop the DDR BIST test
+
+	li	t5,	0x0001fe00
+	and	t5,	t5,	t1
+	bnez	t5,	_iterate_tap		// This is a redundant compare but nevertheless - Comparing the FAILS
+
+	lw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+	li	t3,	0x000001fe
+	and	t3,	t3,	t1
+	srl	t3,	t3,	0x1		// No. of runs in the config register.
+
+	bne	t3,	t2,	_iterate_tap
+
+pass_tap:
+	li	t0,	0xbd001f00
+	lw	t1,	0x4(t0)
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x4(t0)
+
+	li	t0,	0xbd001f10
+	lw	t1,	0x0(t0)
+	li	t2,	0xaa55aa55
+	beq	t1,	t2,	_first_pass
+	nop
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd001f10
+	sw	t1,	0x4(t0)
+	nop
+	b	_iterate_tap
+	nop
+
+_first_pass:
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd001f10
+	sw	t1,	0x0(t0)
+	sw	t1,	0x4(t0)
+	nop
+
+_iterate_tap:
+
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t2,	0x3f
+	beq	t1,	t2,	_STOP_TEST
+	nop
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x0(t0)
+	nop
+	b	_CHANGE_TAPS
+
+_STOP_TEST:
+	li	t0,	0xbd001f00
+	lw	t1,	0x4(t0)
+	bnez	t1,	_load_center_tap
+	nop
+	li	t3,	0x8			// Default Tap to be used
+	b	_load_tap_into_reg
+
+_load_center_tap:
+	li	t0,	0xbd001f10
+	lw	t1,	0x0(t0)
+	lw	t2,	0x4(t0)
+	add	t3,	t1,	t2
+	srl	t3,	t3,	0x1
+	li	t4,	0x3f
+	and	t3,	t3,	t4
+_load_tap_into_reg:
+	li	t0,	0xb8000000
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	jr	ra
+	nop
+
diff --git a/board/atheros/common/tap-955x.S b/board/atheros/common/tap-955x.S
new file mode 100644
index 0000000000..30f7954229
--- /dev/null
+++ b/board/atheros/common/tap-955x.S
@@ -0,0 +1,184 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+.globl ath_ddr_tap_cal
+	.type	ath_ddr_tap_cal,	@function
+	.text
+	.align 4
+ath_ddr_tap_cal:
+
+	li	a0,	0xbd007f00
+	sw	zero,	0x0(a0)			// Place where the tap values are saved and used for SWEEP
+	sw	zero,	0x4(a0)			// Place where the number of passing taps are saved.
+	sw	zero,	0x14(a0)		// Place where the last pass tap value is stored
+	li	a1,	0xaa55aa55		// Indicates that the First pass tap value is not found
+	sw	a1,	0x10(a0)		// Place where the First pass tap value is stored
+	nop
+
+	li	a0,	0xb8060000		// RESET_BASE_ADDRESS
+	lw	a1,	0x1c(a0)		// Reading the RST_RESET_ADDRESS
+	li	a2,	0x08000000		// Setting the RST_RESET_RTC_RESET
+	or	a1,	a1,	a2
+	sw	a1,	0x1c(a0)
+
+	li	a3,	0xffffffff
+	xor	a2,	a2,	a3
+	and	a1,	a1,	a2
+	sw	a1,	0x1c(a0)		// Taking the RTC out of RESET
+	nop
+
+	li	a0,	0xb8107000		// RTC_BASE_ADDRESS
+	li	a1,	0x1
+	sw	a1,	0x0040(a0)		// RTC_SYNC_RESET_ADDRESS
+
+	li	a2,	0x2
+
+_poll_for_RTC_ON:
+	lw	a1,	0x0044(a0)		// RTC_SYNC_STATUS_ADDRESS
+	and	a1,	a2,	a1
+	bne	a1,	a2,	_poll_for_RTC_ON
+
+
+_CHANGE_TAPS:
+
+	li	t0,	0xbd007f00		// Read the current value of the TAP for programming
+	lw	t1,	0x0(t0)
+	li	t2,	0x00000000
+	or	t3,	t1,	t2
+
+
+	li	t0,	0xb8000000		// DDR_BASE_ADDRESS
+
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	li	t1,	0x00000010		// Running the test 8 times
+	sw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+
+	li	t1,	0xfa5de83f		// 4 Row Address Bits, 4 Column Address Bits, 2 BA bits
+	sw	t1,	0x002c(t0)		// PERF_MASK_ADDR_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0070(t0)		// PERF_COMP_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0040(t0)		// PERF_COMP_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0078(t0)		// PERF_COMP_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0034(t0)		// PERF_MASK_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x006c(t0)		// PERF_MASK_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x003c(t0)		// PERF_MASK_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0074(t0)		// PERF_MASK_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0038(t0)		// PERF_COMP_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x00000001
+	sw	t1,	0x011c(t0)		// DDR_BIST_ADDRESS
+
+	li	t2,	0x1
+_bist_done_poll:
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	and	t1,	t1,	t2
+	bne	t1,	t2,	_bist_done_poll
+
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	li	t4,	0x000001fe
+	and	t2,	t1,	t4
+	srl	t2,	t2,	0x1		// no. of Pass Runs
+
+	li	t5,	0x00000000
+	sw	t5,	0x011c(t0)		//DDR_BIST_ADDRESS	- Stop the DDR BIST test
+
+	li	t5,	0x0001fe00
+	and	t5,	t5,	t1
+	bnez	t5,	_iterate_tap		// This is a redundant compare but nevertheless - Comparing the FAILS
+
+	lw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+	li	t3,	0x000001fe
+	and	t3,	t3,	t1
+	srl	t3,	t3,	0x1		// No. of runs in the config register.
+
+	bne	t3,	t2,	_iterate_tap
+
+pass_tap:
+	li	t0,	0xbd007f00
+	lw	t1,	0x4(t0)
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x4(t0)
+
+	li	t0,	0xbd007f10
+	lw	t1,	0x0(t0)
+	li	t2,	0xaa55aa55
+	beq	t1,	t2,	_first_pass
+	nop
+	li	t0,	0xbd007f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd007f10
+	sw	t1,	0x4(t0)
+	nop
+	b	_iterate_tap
+	nop
+
+_first_pass:
+	li	t0,	0xbd007f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd007f10
+	sw	t1,	0x0(t0)
+	sw	t1,	0x4(t0)
+	nop
+
+_iterate_tap:
+
+	li	t0,	0xbd007f00
+	lw	t1,	0x0(t0)
+	li	t2,	0x3f
+	beq	t1,	t2,	_STOP_TEST
+	nop
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x0(t0)
+	nop
+	b	_CHANGE_TAPS
+
+_STOP_TEST:
+	li	t0,	0xbd007f00
+	lw	t1,	0x4(t0)
+	bnez	t1,	_load_center_tap
+	nop
+	li	t3,	0x8			// Default Tap to be used
+	b	_load_tap_into_reg
+
+_load_center_tap:
+	li	t0,	0xbd007f10
+	lw	t1,	0x0(t0)
+	lw	t2,	0x4(t0)
+	add	t3,	t1,	t2
+	srl	t3,	t3,	0x1
+	li	t4,	0x3f
+	and	t3,	t3,	t4
+
+_load_tap_into_reg:
+	li	t0,	0xb8000000
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	jr	ra
+	nop
+
diff --git a/board/atheros/scoemu/Makefile b/board/atheros/scoemu/Makefile
new file mode 100644
index 0000000000..7bb150b1b0
--- /dev/null
+++ b/board/atheros/scoemu/Makefile
@@ -0,0 +1,73 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	=			\
+	$(BOARD).o		\
+	flash.o			\
+	../common/init-955x.o	\
+	../common/serial.o	\
+	../common/ath_pci.o	\
+	../common/qca-eth-955x.o
+
+ifeq ($(BOOT_FROM_NAND),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ath_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/955x.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/atheros/scoemu/config.mk b/board/atheros/scoemu/config.mk
new file mode 100755
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/atheros/scoemu/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/atheros/scoemu/flash.c b/board/atheros/scoemu/flash.c
new file mode 100644
index 0000000000..ffcbf7fe4f
--- /dev/null
+++ b/board/atheros/scoemu/flash.c
@@ -0,0 +1,32 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+#ifndef CONFIG_ATH_NAND_BR
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
+#endif /* CONFIG_ATH_NAND_BR */
diff --git a/board/atheros/scoemu/scoemu.c b/board/atheros/scoemu/scoemu.c
new file mode 100644
index 0000000000..7ac5b6ca4c
--- /dev/null
+++ b/board/atheros/scoemu/scoemu.c
@@ -0,0 +1,121 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+extern int ath_ddr_initial_config(uint32_t refresh);
+extern int ath_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(x)	strcpy(s, x)
+#	define CHECKBOARD_PARAMS	char *s
+#else
+#	define prmsg	printf
+#	define CHECKBOARD_PARAMS	void
+#endif
+
+void
+ath_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if (RST_BOOTSTRAP_REF_CLK_GET(ath_reg_rd(RST_BOOTSTRAP_ADDRESS)) == 0) {
+		ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+			ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+			ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ath_reg_wr(RST_RESET_ADDRESS,
+		ath_reg_rd(RST_RESET_ADDRESS) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_wr(RST_RESET_ADDRESS,
+		ath_reg_rd(RST_RESET_ADDRESS) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ath_reg_wr(RST_RESET_ADDRESS,
+		ath_reg_rd(RST_RESET_ADDRESS) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ath_reg_wr(RST_RESET_ADDRESS,
+		ath_reg_rd(RST_RESET_ADDRESS) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ath_reg_wr(0xb8116c84 ,
+			ath_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void ath_gpio_config(void)
+{
+#if 0
+	/* Disable clock obs */
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+int
+ath_mem_config(void)
+{
+	unsigned int type, reg32;
+
+#if !defined(CONFIG_ATH_EMULATION)
+	type = ath_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+	reg32 = reg32 &  ~RST_RESET_RTC_RESET_SET(1);
+	ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+
+	/* Switching regulator settings */
+	ath_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+#if !defined(CONFIG_ATH_NAND_BR)
+	if (ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf) {
+		if (type == 2) {
+			// ddr1
+			ath_reg_wr_nf(0x18116c44, 0x10000000); /* AR_PHY_PMU2 */
+		} else {
+			// ddr2 & sdram
+			ath_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+		}
+	} else {
+		ath_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+	}
+#endif
+
+	ath_usb_initial_config();
+
+	ath_gpio_config();
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+
+	reg32 = ath_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (ath_mem_config());
+}
+
+int	checkboard(CHECKBOARD_PARAMS)
+{
+	prmsg("U-boot Scorpion Emulation\n");
+	return 0;
+}
diff --git a/board/atheros/scoemu/u-boot.lds b/board/atheros/scoemu/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/atheros/scoemu/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/atheros/tb6xx/Makefile b/board/atheros/tb6xx/Makefile
new file mode 100644
index 0000000000..057f11eac1
--- /dev/null
+++ b/board/atheros/tb6xx/Makefile
@@ -0,0 +1,73 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	=			\
+	$(BOARD).o		\
+	flash.o			\
+	../common/init-955x.o	\
+	../common/serial.o	\
+	../common/ath_pci.o	\
+	../common/qca-eth-955x.o
+
+ifeq ($(BOOT_FROM_NAND),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ath_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/955x.o ../common/tap-955x.S
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/atheros/tb6xx/config.mk b/board/atheros/tb6xx/config.mk
new file mode 100755
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/atheros/tb6xx/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/atheros/tb6xx/flash.c b/board/atheros/tb6xx/flash.c
new file mode 100644
index 0000000000..ffcbf7fe4f
--- /dev/null
+++ b/board/atheros/tb6xx/flash.c
@@ -0,0 +1,32 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+#ifndef CONFIG_ATH_NAND_BR
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
+#endif /* CONFIG_ATH_NAND_BR */
diff --git a/board/atheros/tb6xx/tb6xx.c b/board/atheros/tb6xx/tb6xx.c
new file mode 100644
index 0000000000..6e1995a6bf
--- /dev/null
+++ b/board/atheros/tb6xx/tb6xx.c
@@ -0,0 +1,126 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+extern int ath_ddr_initial_config(uint32_t refresh);
+extern int ath_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(x)	strcpy(s, x)
+#	define CHECKBOARD_PARAMS	char *s
+#else
+#	define prmsg	printf
+#	define CHECKBOARD_PARAMS	void
+#endif
+
+void
+ath_usb1_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+		ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+		SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	udelay(1000);
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS,
+				RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_HOST_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB1_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+void
+ath_usb2_initial_config(void)
+{
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_MODE_SET(1));
+	udelay(10);
+	ath_reg_rmw_set(RST_RESET2_ADDRESS,
+				RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_HOST2_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+
+void ath_gpio_config(void)
+{
+#if 0
+	/* Disable clock obs */
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+int
+ath_mem_config(void)
+{
+	unsigned int type, reg32, *tap;
+	extern uint32_t *ath_ddr_tap_cal(void);
+
+#if !defined(CONFIG_ATH_EMULATION)
+	type = ath_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	tap = ath_ddr_tap_cal();
+	prmsg("tap = 0x%p\n", tap);
+
+	tap = (uint32_t *)0xbd007f10;
+	prmsg("Tap (low, high) = (0x%x, 0x%x)\n", tap[0], tap[1]);
+
+	tap = (uint32_t *)TAP_CONTROL_0_ADDRESS;
+	prmsg("Tap values = (0x%x, 0x%x, 0x%x, 0x%x)\n",
+		tap[0], tap[2], tap[2], tap[3]);
+
+	/* Take WMAC out of reset */
+	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+	reg32 = reg32 & ~RST_RESET_RTC_RESET_SET(1);
+	ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+
+	ath_usb1_initial_config();
+	ath_usb2_initial_config();
+
+	ath_gpio_config();
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+
+	return ath_ddr_find_size();
+}
+
+long int initdram(int board_type)
+{
+	return (ath_mem_config());
+}
+
+int	checkboard(CHECKBOARD_PARAMS)
+{
+	prmsg("U-boot Scorpion\n");
+	return 0;
+}
diff --git a/board/atheros/tb6xx/u-boot.lds b/board/atheros/tb6xx/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/atheros/tb6xx/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/mcc200/mcc200.c b/board/mcc200/mcc200.c
index 456411dd92..5fe239f234 100644
--- a/board/mcc200/mcc200.c
+++ b/board/mcc200/mcc200.c
@@ -238,6 +238,16 @@ int misc_init_r (void)
 			       &flash_info[CFG_MAX_FLASH_BANKS - 1]);
 	}
 
+	if (gd->bd->bi_flashsize > (32 << 20)) {
+		/* Unprotect the upper bank of the Flash */
+		*(volatile int*)MPC5XXX_CS0_CFG |= (1 << 6);
+		flash_protect (FLAG_PROTECT_CLEAR,
+			       flash_info[0].start[0],
+			       (flash_info[0].start[0] + flash_info[0].size) / 2 - 1,
+			       &flash_info[0]);
+		*(volatile int*)MPC5XXX_CS0_CFG &= ~(1 << 6);
+	}
+
 	return (0);
 }
 
diff --git a/common/Makefile b/common/Makefile
index eb0b5dadfe..de3be7c4fd 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -27,6 +27,26 @@ LIB	= libcommon.a
 
 AOBJS	=
 
+ifeq ($(COMPRESSED_UBOOT),1)
+COBJS	= main.o circbuf.o \
+	  cmd_boot.o cmd_bootm.o \
+	  cmd_cache.o cmd_console.o \
+	  cmd_date.o cmd_dcr.o cmd_display.o cmd_doc.o \
+	  cmd_eeprom.o \
+	  cmd_flash.o \
+	  cmd_immap.o cmd_itest.o \
+	  cmd_mem.o \
+	  cmd_mii.o cmd_misc.o \
+	  cmd_nand.o cmd_net.o cmd_nvedit.o \
+	  cmd_reginfo.o cmd_spi.o \
+	  command.o console.o devices.o dlmalloc.o docecc.o \
+	  environment.o env_common.o \
+	  env_nowhere.o \
+	  exports.o \
+	  hush.o lcd.o lists.o \
+	  memsize.o miiphybb.o miiphyutil.o \
+	  serial.o crc16.o
+else
 COBJS	= main.o ACEX1K.o altera.o bedbug.o circbuf.o \
 	  cmd_ace.o cmd_autoscript.o \
 	  cmd_bdinfo.o cmd_bedbug.o cmd_bmp.o cmd_boot.o cmd_bootm.o \
@@ -40,23 +60,41 @@ COBJS	= main.o ACEX1K.o altera.o bedbug.o circbuf.o \
 	  cmd_nand.o cmd_net.o cmd_nvedit.o \
 	  cmd_pci.o cmd_pcmcia.o cmd_portio.o \
 	  cmd_reginfo.o cmd_reiser.o cmd_scsi.o cmd_spi.o cmd_universe.o \
-	  cmd_usb.o cmd_vfd.o \
+	  cmd_usb.o cmd_vfd.o cmd_ethreg.o cmd_pll.o \
 	  command.o console.o devices.o dlmalloc.o docecc.o \
 	  environment.o env_common.o \
 	  env_nand.o env_dataflash.o env_flash.o env_eeprom.o \
 	  env_nvram.o env_nowhere.o \
 	  exports.o \
-	  flash.o fpga.o ft_build.o \
+	  fpga.o ft_build.o \
 	  hush.o kgdb.o lcd.o lists.o lynxkdi.o \
 	  memsize.o miiphybb.o miiphyutil.o \
 	  s_record.o serial.o soft_i2c.o soft_spi.o spartan2.o spartan3.o \
 	  usb.o usb_kbd.o usb_storage.o \
 	  virtex2.o xilinx.o crc16.o xyzModem.o
+endif
+
+ifndef BOOT_FROM_NAND
+COBJS	+= flash.o
+endif
+
+ifeq ($(VXWORKS_UBOOT),1)
+COBJS	+=  cmd_elf.o
+endif
+
+ifeq ($(TPWD_FOR_LINUX_CAL),1)
+COBJS	+=  cmd_elf.o
+endif
 
 OBJS	= $(AOBJS) $(COBJS)
 
 CPPFLAGS += -I..
 
+ifeq ($(DUAL_FIRMWAREIMAGE_SUPPORT),1)
+CFLAGS += -DCONFIG_DUALIMAGE_SUPPORT
+OBJS += cmd_bdr.o
+endif
+
 all:	$(LIB) $(AOBJS)
 
 $(LIB): .depend $(OBJS)
diff --git a/common/cmd_bdr.c b/common/cmd_bdr.c
new file mode 100644
index 0000000000..c673a7188d
--- /dev/null
+++ b/common/cmd_bdr.c
@@ -0,0 +1,427 @@
+/*     The module is designed to support a BDR with the highest sequence number in the flash.
+ *	If it is successfule, bootloader will choose the BDR to startup.
+ *  
+ *	Author Tos Xu		April 22, 2009
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <flash.h>
+#include <malloc.h>
+#include <configs/ap93-hgw.h>
+
+#define TOTALFLASHSIZE 		CFG_FLASH_SIZE
+#define FLASHSTARTADDRESS 	CFG_FLASH_BASE
+#define FLASH_BLOCK_SIZE	CFG_FLASH_SECTOR_SIZE
+/*
+* Boot description record definitions
+*/
+#define BDRWordSize 4
+
+#define BDRHeaderNWords 4
+#define BDRHeaderNBytes (BDRHeaderNWords * BDRWordSize)
+#define BDRHeader_OffsetMagic 0      /* bytes */
+#define BDRHeader_OffsetSize 4      /* bytes */
+#define BDRHeader_OffsetChecksum 8      /* bytes */
+#define BDRHeader_OffsetSequence 12      /* bytes */
+#define BDR_BeginMagic 0xFEEDCAFE
+
+#define BDRTailerNWords 4
+#define BDRTailerNBytes (BDRTailerNWords * BDRWordSize)
+#define BDRTailer_OffsetMagic 4      /* bytes before end */
+#define BDRTailer_OffsetSize 8      /* bytes before end */
+#define BDR_EndMagic   0xFEEDFADE
+
+#define TagWordToSelf(TagWord) (((TagWord)>>24)&0xff)
+#define TagWordToTag(TagWord) (((TagWord)>>16)&0xff)
+#define TagWordToNWords(TagWord) ((TagWord)&0x3fff)
+
+#define BDRTag_STOP 1
+#define BDRTag_BOOTADDR 2
+#define BDRTag_BOOTARGS 3
+#define BDRTag_REQUESTNUMBER 4
+
+#define BDR_SIZE	256
+
+unsigned int bdr_bootaddr = 0;
+unsigned int bdr_seq = 0; 
+char bdr_bootarg[512];
+
+extern flash_info_t flash_info[];
+/*
+* Boot description records can be written at begin and/or end of each
+*       64KB block of flash (regardless of erase block size)
+*/
+#define BDRBlockSize 0x10000
+
+#define flashaddr(x)	(char *)((volatile char *)0xbf000000+(x))
+
+
+/* big endian -- extract big endian integer from byte stream
+*/
+static inline unsigned big_endian(unsigned char *p)
+{
+    return ((p[0]<<24) | (p[1]<<16) | (p[2]<<8) | p[3]);
+}	
+
+/*
+ * fix endian
+ */
+static inline unsigned fix_endian(unsigned word)
+{
+	return word;
+}
+
+/*
+ * Big endian in the flash.
+ * 0:OK,-1:parameters error,-2: NO STOP tag.
+ */
+int parse_tag(int * bdrp,int size){
+
+	int tags = 0,tagname = 0,tagsize = 0,tagno = 0;
+	int i = 0;
+	unsigned data;
+
+	// Reset the value to prevent the failure of parsing the bdr.	
+	bdr_bootaddr = 0;
+	memset(bdr_bootarg,0,sizeof(bdr_bootarg));
+
+	for(i = 0;i<size;i++)
+	{
+		data = big_endian((char *)bdrp);
+		printf(" -Tag 0x%x.\n",*bdrp);
+		tagname = (data>>16)&0xff;
+		tagno = (data>>24)&0xff;
+		tagsize = (data & 0xffff) - 1;
+
+		if((tags != tagno)||(tagsize<0)) return -1;
+
+		switch(tagname)
+		{
+			case BDRTag_STOP:
+				if(tagsize==0) return 0;
+				else return -1;
+
+			case BDRTag_BOOTADDR:
+				bdrp++;
+				if(tagsize==1){
+					bdr_bootaddr = big_endian((char *)bdrp);
+					printf("  --Boot address:0x%x at sequence 0x%x.\n",bdr_bootaddr,bdr_seq);
+					bdrp++;
+					break;
+				}else return -1;
+
+			case BDRTag_BOOTARGS:
+				bdrp++;
+				if(tagsize < 130){
+					memcpy(bdr_bootarg,(char *)bdrp,tagsize * BDRWordSize);
+					bdrp += tagsize;
+					break;
+				}else return -1;
+
+			case BDRTag_REQUESTNUMBER:
+				bdrp += tagsize +1;
+				break;
+
+			default:
+				bdrp += tagsize + 1;
+				break;
+		}
+			
+		tags++;
+	}
+
+	return -2;
+}
+
+/* findBDRstart -- look for BDR at the beginning of 64KB of flash,
+*       return sequence no.
+*       Return 0 if not found (which is not a valid sequence number).
+*
+*       This is used for searching for existing sequence number so we
+*       can be sure to have a larger one.
+*       Sequence numbers are in BDRs (Boot Description Records) which
+*       can be at the begin or end of any 64KB section of flash
+*       (regardless of the erase block size).
+*/
+
+unsigned findBDRstart(int offset)
+{
+    unsigned magic1;
+    unsigned magic2;
+    unsigned size;
+    unsigned sequence;
+    unsigned char bottom[BDRHeaderNBytes];
+    unsigned char top[BDRTailerNBytes];
+    unsigned topoffset;
+    unsigned bdrblock[BDR_SIZE];
+
+    memcpy(bottom, flashaddr(offset),sizeof(bottom));
+    memcpy(bdrblock,flashaddr(offset),sizeof(bdrblock));
+    magic1 = big_endian(bottom + BDRHeader_OffsetMagic);
+
+    if (magic1 != BDR_BeginMagic)
+        return 0;
+
+    size = BDRWordSize*big_endian( bottom + BDRHeader_OffsetSize);
+
+    if (size <= BDRHeaderNBytes+BDRTailerNBytes)
+        return 0;
+
+    if (size >= BDRBlockSize)
+        return 0;
+
+    topoffset = offset + size;
+
+    memcpy(top, flashaddr(topoffset-sizeof(top)),sizeof(top));
+
+    magic2 = big_endian(top + sizeof(top)-BDRTailer_OffsetMagic);
+    if (magic2 != BDR_EndMagic)
+        return 0;
+
+    if (BDRWordSize*big_endian(
+                top+sizeof(top)-BDRTailer_OffsetSize) != size)
+        return 0;
+
+    sequence = big_endian(bottom + BDRHeader_OffsetSequence);
+
+    if (sequence == 0 || sequence == 0xffffffff)
+        return 0;       /* invalid */
+
+    printf("Found starting sequence: 0x%x in offset 0x%x.\n",sequence,offset);
+    if(sequence > bdr_seq){
+	bdr_seq = sequence;
+	parse_tag(bdrblock + BDRHeaderNWords,BDR_SIZE);
+    }
+
+    return sequence;
+}
+
+unsigned findBDRend(int offset) /* offset of begin of 64KB section */
+{
+    unsigned magic1;
+    unsigned magic2;
+    unsigned size;
+    unsigned sequence;
+    unsigned char bottom[BDRHeaderNBytes];
+    unsigned char top[BDRTailerNBytes];
+    unsigned topoffset;
+    unsigned bottomoffset;
+    unsigned bdrblock[BDR_SIZE];
+
+    topoffset = offset + BDRBlockSize;
+
+    memcpy(top, flashaddr(topoffset-sizeof(top)),sizeof(top));
+    memcpy(bdrblock, flashaddr(topoffset-sizeof(bdrblock)),sizeof(bdrblock));
+
+    magic2 = big_endian(top + sizeof(top)-BDRTailer_OffsetMagic);
+
+    if (magic2 != BDR_EndMagic)
+        return 0;
+
+    size = BDRWordSize*big_endian(top+sizeof(top)-BDRTailer_OffsetSize);
+
+    if (size <= BDRHeaderNBytes+BDRTailerNBytes)
+        return 0;
+
+    if (size >= BDRBlockSize)
+        return 0;
+
+    bottomoffset = topoffset - size;
+
+    memcpy(bottom, flashaddr(bottomoffset),sizeof(bottom));
+
+    magic1 = big_endian(bottom + BDRHeader_OffsetMagic);
+
+    if (magic1 != BDR_BeginMagic)
+        return 0;
+
+    if (BDRWordSize*big_endian(bottom + BDRHeader_OffsetSize) != size)
+        return 0;
+
+    sequence = big_endian(bottom+BDRHeader_OffsetSequence);
+
+    if (sequence == 0 || sequence == 0xffffffff)
+        return 0;       /* invalid */
+
+    printf("Found end sequence: 0x%x in offset 0x%x.\n",sequence,offset);
+    if(sequence > bdr_seq){
+	bdr_seq = sequence;
+	parse_tag(bdrblock + BDRTailerNWords,BDR_SIZE);
+    }
+	
+    return sequence;
+}
+
+
+/* return  0: no existing valid Boot Description Recorder
+ *         1: Found a valid DBR and set bootm and bootarg.
+ */
+unsigned findbdr(unsigned int flashaddr){
+	int offset = 0;
+	char buf[64];
+
+	if(flashaddr >= FLASHSTARTADDRESS) flashaddr -= FLASHSTARTADDRESS;
+
+	printf("findbdr flashaddr 0x%x.\n",flashaddr);
+	bdr_seq = 0;
+	bdr_bootaddr = 0xffffffff;
+	memset(bdr_bootarg,0,sizeof(bdr_bootarg));
+
+	for(offset =flashaddr;offset < TOTALFLASHSIZE;offset += BDRBlockSize)
+	{
+		findBDRstart(offset);
+		findBDRend(offset);		
+	}
+
+	// if bootaddr is equal to 0xffffffff or 0x0, it is not valid.
+	if(bdr_seq == 0||bdr_bootaddr==0xffffffff||bdr_bootaddr==0x0){
+		printf("Failed to find a good BDR at seq 0x%x.\n",bdr_seq);
+		return 0;
+	}
+	
+	if(bdr_bootaddr < TOTALFLASHSIZE) bdr_bootaddr |= FLASHSTARTADDRESS;
+	sprintf(buf,"%s 0x%x","bootm",bdr_bootaddr);
+	setenv("bootcmd",buf);
+	setenv("bootargs",bdr_bootarg);
+	printf("Got a good Boot Descriptor Record.\n  -Sequence:0x%x.\n",bdr_seq);
+	printf("  -Boot address: 0x%x.\n",bdr_bootaddr);
+	if(strlen(bdr_bootarg) < 512)	
+		printf("  -Boot arguments: %s.\n",bdr_bootarg);
+	return 1;
+
+}
+
+
+int do_findbdr (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int err = 0;
+
+	unsigned int addr;
+
+	if(argc < 2)
+		err = findbdr(0);
+	else{
+		addr = simple_strtoul(argv[1], NULL, 16);
+		err = findbdr(addr);
+	}
+	
+	return err;
+}
+/*
+ * flashaddr is the aboslute address.(0xbf.....)
+ */
+static unsigned writebdr(unsigned int flashaddr,unsigned bootaddr,char * cmdline){
+	unsigned bdrblock[BDR_SIZE];
+	unsigned * bdrp =  bdrblock;
+	unsigned flash_offset = flashaddr - FLASHSTARTADDRESS;
+	int err;
+	unsigned seq;
+	unsigned tags;
+	char * p;
+	char buffer[64];
+	
+	//Make sure the flashaddr is located at X*1024.
+	if(flashaddr &0x3ff) return 1;
+	
+	err = findbdr(0);
+	seq = bdr_seq + 1;
+
+	bdrp[0]	= fix_endian(BDR_BeginMagic);
+	bdrp[BDR_SIZE-1] = fix_endian(BDR_EndMagic);
+	bdrp[1] = bdrp[BDR_SIZE-2] = fix_endian(BDR_SIZE);
+	bdrp[2] = 0;
+	bdrp[3] = seq;
+	
+	bdrp += 4;
+	tags = 0;
+
+	*bdrp++ = fix_endian(tags++<<24| BDRTag_REQUESTNUMBER<<16|2);
+	*bdrp++ = fix_endian(0);//request number.
+
+	*bdrp++ = fix_endian(tags++<<24| BDRTag_BOOTADDR <<16|2);
+	*bdrp++ = fix_endian(bootaddr);//bootaddr.
+
+
+	*bdrp++ = fix_endian(tags++<<24| BDRTag_BOOTARGS <<16|(1+sizeof(bdr_bootarg)/sizeof(int)));
+	memcpy(bdrp,cmdline,sizeof(bdr_bootarg));
+	bdrp += sizeof(bdr_bootarg)/sizeof(int);//bootarg.	
+
+	*bdrp++ = fix_endian(tags++<<24| BDRTag_STOP<<16|1);//STOP tag
+	p = (char *)malloc(FLASH_BLOCK_SIZE);
+
+	memcpy(p,(char *)(((unsigned int )flashaddr/FLASH_BLOCK_SIZE )* FLASH_BLOCK_SIZE),FLASH_BLOCK_SIZE);
+	memcpy(p + ((unsigned int )flashaddr%FLASH_BLOCK_SIZE), bdrblock,BDR_SIZE * 4);
+
+	flash_erase(&flash_info[0],flash_offset/FLASH_BLOCK_SIZE,flash_offset/FLASH_BLOCK_SIZE);
+	err = flash_write(p,((unsigned int )flashaddr/FLASH_BLOCK_SIZE )* FLASH_BLOCK_SIZE, FLASH_BLOCK_SIZE);
+
+	free(p);
+
+	if(err){
+		flash_perror(err);
+		return 1;
+	}
+
+	if(memcmp((char *)flashaddr,bdrblock,BDR_SIZE * 4)){
+		printf("Error when writing bdr into flash.\n");
+		return 1;
+	}
+	
+	printf("BDR has been successfully written.\n");
+	printf("BDR boot address: 0x%x.\n",bootaddr);
+	printf("BDR boot arg: %s.\n",cmdline);
+
+	sprintf(buffer,"%s 0x%x","bootm",bootaddr);
+	setenv("bootcmd",buffer);
+	setenv("bootargs",cmdline);
+
+	return 0;
+}
+
+int do_writebdr (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int err = 0;
+
+	unsigned int flashaddr;
+	unsigned int bootaddr;
+	char cmd[512];
+
+	char * s = getenv("bootargs");
+	
+	printf("do_writebdr :: size %d bootargs = %s .\n",sizeof(s),s);
+	if(argc < 2)
+		return 1;
+	else{
+		flashaddr = simple_strtoul(argv[1], NULL, 16);
+		if(argc == 3 ) bootaddr = simple_strtoul(argv[2], NULL, 16);
+
+		if(flashaddr < TOTALFLASHSIZE) flashaddr |= FLASHSTARTADDRESS;
+		if(flashaddr < (FLASHSTARTADDRESS|0x80000)) return 1;
+		memset(cmd,0,sizeof(cmd));
+		memcpy(cmd,s,sizeof(cmd));
+		//printf("do_writebdr :: bdr_bootargs = %s size %d.\n",bdr_bootarg,sizeof(bdr_bootarg));		
+		err = writebdr(flashaddr,bootaddr,cmd);
+	}
+	
+	return err;
+}
+
+U_BOOT_CMD(
+ 	writebdr,	CFG_MAXARGS,	1,	do_writebdr,
+ 	"writebdr- write a valid bdr in the flash based on existing sequences\n",
+ 	"[writebdr [arg ...]]\n  write a valid bdr based on existing sequences at the designed address  - \n"
+ 	"\tpassing arguments 'flash_offset, bootaddr'; you may assign the flash address,\n"
+ 	"\t'bootaddr' can be ignored or set it.\n"
+);
+
+U_BOOT_CMD(
+ 	findbdr,	CFG_MAXARGS,	1,	do_findbdr,
+ 	"findbdr - find a valid bdr with the highest sequence in the flash\n",
+ 	"[findbdr [arg ...]]\n  find a valid bdr with the highest sequence in the flash from the starting address  - \n"
+ 	"\tpassing arguments 'arg ...'; you may assign the address or not,\n"
+ 	"\t'arg' can be the starting address of search.\n"
+);
+
+
diff --git a/common/cmd_boot.c b/common/cmd_boot.c
index e68f16f9da..c49c255b4e 100644
--- a/common/cmd_boot.c
+++ b/common/cmd_boot.c
@@ -28,10 +28,10 @@
 #include <command.h>
 #include <net.h>
 
-#if defined(CONFIG_I386)
+#if defined(CONFIG_I386) || defined(CONFIG_MIPS)
 DECLARE_GLOBAL_DATA_PTR;
 #endif
-
+#if (defined(TPWD_FOR_LINUX_CAL) || !defined(COMPRESSED_UBOOT))/*  by huangwenzhong, 10May13 */
 int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	ulong	addr, rc;
@@ -41,6 +41,11 @@ int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		printf ("Usage:\n%s\n", cmdtp->usage);
 		return 1;
 	}
+	/*  by huangwenzhong, 10May13 */
+	/* from zhengyongfei, for boot from vxWorks */
+	disable_interrupts();
+	mips_cache_flush();
+	mips_icache_flush_ix();
 
 	addr = simple_strtoul(argv[1], NULL, 16);
 
@@ -58,7 +63,12 @@ int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	argv[0] = (char *)gd;
 #endif
 #if !defined(CONFIG_NIOS)
-	rc = ((ulong (*)(int, char *[]))addr) (--argc, &argv[1]);
+	if (argc > 2 && argv[2][0] == 'b') {
+		printf ("## Board info at 0x%08lX ...\n", gd->bd);
+		rc = ((ulong (*)(int, int, int, int))addr)(gd->bd, 0, 0, 0);
+	} else {
+		rc = ((ulong (*)(int, char *[]))addr) (--argc, &argv[1]);
+	}
 #else
 	/*
 	 * Nios function pointers are address >> 1
@@ -79,7 +89,7 @@ U_BOOT_CMD(
 	"addr [arg ...]\n    - start application at address 'addr'\n"
 	"      passing 'arg' as arguments\n"
 );
-
+#endif /* #ifndef COMPRESSED_UBOOT */
 extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
 
 U_BOOT_CMD(
diff --git a/common/cmd_bootm.c b/common/cmd_bootm.c
index fdf7180a19..af8c0f3a0e 100644
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -31,6 +31,7 @@
 #include <malloc.h>
 #include <zlib.h>
 #include <bzlib.h>
+#include <LzmaWrapper.h>
 #include <environment.h>
 #include <asm/byteorder.h>
 
@@ -150,6 +151,13 @@ image_header_t header;
 
 ulong load_addr = CFG_LOAD_ADDR;		/* Default Load Address */
 
+#ifdef FW_RECOVERY
+ushort fw_recovery = 0;
+#endif
+
+#define CONFIG_LZMA 1
+
+#if 0
 int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	ulong	iflag;
@@ -180,7 +188,9 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		read_dataflash(addr, sizeof(image_header_t), (char *)&header);
 	} else
 #endif
-	memmove (&header, (char *)addr, sizeof(image_header_t));
+	{
+		memmove (&header, (char *)addr, sizeof(image_header_t));
+	}
 
 	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
 #ifdef __I386__	/* correct image format not implemented yet - fake it */
@@ -222,7 +232,6 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	}
 #endif
 
-
 	/* for multi-file images we need the data part, too */
 	print_image_hdr ((image_header_t *)addr);
 
@@ -230,7 +239,7 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	len  = ntohl(hdr->ih_size);
 
 	if (verify) {
-		puts ("   Verifying Checksum ... ");
+		printf("   Verifying Checksum at 0x%p ...", data);
 		if (crc32 (0, (uchar *)data, len) != ntohl(hdr->ih_dcrc)) {
 			printf ("Bad Data CRC\n");
 			SHOW_BOOT_PROGRESS (-3);
@@ -314,6 +323,17 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	dcache_disable();
 #endif
 
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
+	/*
+	 * Flush everything, restore caches for linux
+	 */
+	mips_cache_flush();
+	mips_icache_flush_ix();
+
+	/* XXX - this causes problems when booting from flash */
+	/* dcache_disable(); */
+#endif
+
 	switch (hdr->ih_comp) {
 	case IH_COMP_NONE:
 		if(ntohl(hdr->ih_load) == addr) {
@@ -339,6 +359,7 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 #endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
 		}
 		break;
+#ifndef COMPRESSED_UBOOT
 	case IH_COMP_GZIP:
 		printf ("   Uncompressing %s ... ", name);
 		if (gunzip ((void *)ntohl(hdr->ih_load), unc_len,
@@ -367,6 +388,19 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		}
 		break;
 #endif /* CONFIG_BZIP2 */
+#endif /* #ifndef COMPRESSED_UBOOT */
+#ifdef CONFIG_LZMA
+	case IH_COMP_LZMA:
+		printf ("   Uncompressing %s ... ", name);
+		i = lzma_inflate ((unsigned char *)data, len, (unsigned char*)ntohl(hdr->ih_load), &unc_len);
+		if (i != LZMA_RESULT_OK) {
+			printf ("LZMA ERROR %d - must RESET board to recover\n", i);
+			SHOW_BOOT_PROGRESS (-6);
+			udelay(100000);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+		break;
+#endif /* CONFIG_LZMA */
 	default:
 		if (iflag)
 			enable_interrupts();
@@ -459,6 +493,150 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	return 1;
 }
 
+#else
+
+/* changed by lqm, 18Jan08 */
+#include "tpLinuxTag.h"		/* support TP-LINK Linux Tag */
+
+// TODO: MACRO 
+LINUX_FLASH_STRUCT linuxFlash =
+						{
+							0x000000,	/* boot loader 	*/
+							0x01fc00,	/* mac address	*/
+							0x01fe00,	/* pin address	*/
+							0x020000,	/* kernel		*/
+							0x120000,	/* root fs		*/
+							0x3e0000,	/* config		*/
+							0x3f0000,	/* radio		*/
+						};
+
+/* added by lqm, 18Jan08, copy from fake_zimage_header() */
+image_header_t *fake_image_header(image_header_t *hdr, ulong kernelTextAddr, ulong entryPoint, int size)
+{
+	ulong checksum = 0;
+
+	memset(hdr, 0, sizeof(image_header_t));
+
+	/* Build new header */
+	hdr->ih_magic = htonl(IH_MAGIC);
+	hdr->ih_time  = 0;
+	hdr->ih_size  = htonl(size);
+	hdr->ih_load  = htonl(kernelTextAddr);
+	hdr->ih_ep    = htonl(entryPoint);
+	hdr->ih_dcrc  = htonl(checksum);
+	hdr->ih_os    = IH_OS_LINUX;
+	hdr->ih_arch  = IH_CPU_MIPS;
+	hdr->ih_type  = IH_TYPE_KERNEL;
+	hdr->ih_comp  = IH_COMP_GZIP;
+
+	strncpy((char *)hdr->ih_name, "(none)", IH_NMLEN);
+
+	hdr->ih_hcrc = htonl(checksum);
+
+	return hdr;
+}
+
+int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	ulong	iflag;
+	ulong	addr;
+	ulong	data, len, checksum;
+	ulong	kernelTextAddr, kernelEntryPoint, kernelLen;
+	ulong  *len_ptr;
+	uint	unc_len = CFG_BOOTM_LEN;
+	int	i, verify = 0;
+	char	*name, *s;
+	int	(*appl)(int, char *[]);
+	image_header_t *hdr = &header;
+
+	if (argc < 2) {
+		addr = load_addr;
+	} else {
+		addr = simple_strtoul(argv[1], NULL, 16);
+	}
+
+	SHOW_BOOT_PROGRESS (1);
+	printf ("## Booting image at %08lx ...\n", addr);
+
+    name = (char *) addr;
+
+	kernelTextAddr = *(ulong *)(name+116);
+	kernelEntryPoint = *(ulong *)(name+120);
+	kernelLen = *(ulong *)(name+132);
+
+	fake_image_header(hdr, kernelTextAddr, kernelEntryPoint, kernelLen);
+
+	data = addr + 512;
+	len  = ntohl(hdr->ih_size);
+
+	/* TODO: fileTag magic numberchecksum */
+	SHOW_BOOT_PROGRESS (2);
+
+	name = "Kernel Image";
+	SHOW_BOOT_PROGRESS (6);
+
+	/*
+	 * We have reached the point of no return: we are going to
+	 * overwrite all exception vector code, so we cannot easily
+	 * recover from any failures any more...
+	 */
+
+	iflag = disable_interrupts();
+
+#ifdef CONFIG_AMIGAONEG3SE
+	/*
+	 * We've possible left the caches enabled during
+	 * bios emulation, so turn them off again
+	 */
+	icache_disable();
+	invalidate_l1_instruction_cache();
+	flush_data_cache();
+	dcache_disable();
+#endif
+
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
+	/*
+	 * Flush everything, restore caches for linux
+	 */
+	mips_cache_flush();
+	mips_icache_flush_ix();
+
+	/* XXX - this causes problems when booting from flash */
+	/* dcache_disable(); */
+#endif
+
+#ifdef CONFIG_LZMA
+/*	case IH_COMP_LZMA:*/
+		printf ("   Uncompressing %s ... ", name);
+		i = lzma_inflate ((unsigned char *)data, len, (unsigned char*)ntohl(hdr->ih_load), &unc_len);
+		if (i != LZMA_RESULT_OK) {
+			printf ("LZMA ERROR %d - must RESET board to recover\n", i);
+			SHOW_BOOT_PROGRESS (-6);
+			//udelay(100000);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+/*		break;*/
+#endif /* CONFIG_LZMA */
+	puts ("OK\n");
+	SHOW_BOOT_PROGRESS (7);
+
+/*	case IH_OS_LINUX: */
+#ifdef CONFIG_SILENT_CONSOLE
+	    fixup_silent_linux();
+#endif
+	    do_bootm_linux  (cmdtp, flag, argc, argv,
+			     addr, len_ptr, verify);
+
+	SHOW_BOOT_PROGRESS (-9);
+#ifdef DEBUG
+	puts ("\n## Control returned to monitor - resetting...\n");
+	do_reset (cmdtp, flag, argc, argv);
+#endif
+	return 1;
+}
+
+#endif	/* 0 */
+
 U_BOOT_CMD(
  	bootm,	CFG_MAXARGS,	1,	do_bootm,
  	"bootm   - boot application image from memory\n",
@@ -1267,6 +1445,7 @@ print_type (image_header_t *hdr)
 	case IH_COMP_NONE:	comp = "uncompressed";		break;
 	case IH_COMP_GZIP:	comp = "gzip compressed";	break;
 	case IH_COMP_BZIP2:	comp = "bzip2 compressed";	break;
+	case IH_COMP_LZMA:	comp = "lzma compressed";	break;
 	default:		comp = "unknown compression";	break;
 	}
 
@@ -1299,7 +1478,7 @@ static void zfree(void *x, void *addr, unsigned nb)
 #define RESERVED	0xe0
 
 #define DEFLATED	8
-
+#ifndef COMPRESSED_UBOOT
 int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
 {
 	z_stream s;
@@ -1361,7 +1540,7 @@ void bz_internal_error(int errcode)
 	printf ("BZIP2 internal error %d\n", errcode);
 }
 #endif /* CONFIG_BZIP2 */
-
+#endif /* #ifndef COMPRESSED_UBOOT */
 static void
 do_bootm_rtems (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
 		ulong addr, ulong *len_ptr, int verify)
diff --git a/common/cmd_ddr.c b/common/cmd_ddr.c
new file mode 100644
index 0000000000..a050c6aeea
--- /dev/null
+++ b/common/cmd_ddr.c
@@ -0,0 +1,117 @@
+/*
+ * (C) Copyright 2002
+ * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * SPI Read/Write Utilities
+ */
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <config.h>
+#include <ar7240_soc.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_DDR)
+
+/*-----------------------------------------------------------------------
+ * Definitions
+ */
+
+static void prepare_flash(char **buff_ptr,long **val) 
+{
+	if((long)*buff_ptr % 4)
+		*buff_ptr = *buff_ptr + ((long)*buff_ptr % 4);
+        memcpy(*buff_ptr,(void *)((long)UBOOT_ENV_SEC_START),CFG_FLASH_SECTOR_SIZE);
+	flash_sect_erase(UBOOT_ENV_SEC_START,UBOOT_ENV_SEC_START + (CFG_FLASH_SECTOR_SIZE - 1));
+	*val = (long *)(*buff_ptr + CFG_FLASH_SECTOR_SIZE - 0x30);
+}
+
+int do_ddr (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	char  *buff,*buff_ptr = NULL;
+	int ddr_config,ddr_config2,ext_mod;
+	long *val;
+
+	/*
+	 * We use the last specified parameters, unless new ones are
+	 * entered.
+	 */
+
+	/* last sector of uboot 0xbf040000 - 0xbf050000
+	 * write MAGIC at 0xbf04ffe0 
+	 * write sector at 0xbf04ffe4
+	 * write size at   0xbf04ffe8
+         */
+
+	if ((flag & CMD_FLAG_REPEAT) == 0)
+	{
+		if (argc == 2) {
+			ddr_config = simple_strtoul(argv[1], NULL, 10);
+			ddr_config2 = CFG_DDR_CONFIG2_VAL;
+			ext_mod = CFG_DDR_EXT_MODE_VAL;
+		}
+		else if (argc == 3) {
+			ddr_config = simple_strtoul(argv[1], NULL, 10);
+			ddr_config2 = simple_strtoul(argv[2], NULL, 10);
+			ext_mod = CFG_DDR_EXT_MODE_VAL;
+		}
+		else if (argc == 4) {
+			ddr_config = simple_strtoul(argv[1], NULL, 10);
+			ddr_config2 = simple_strtoul(argv[2], NULL, 10);
+			ext_mod = simple_strtoul(argv[3], NULL, 10);
+		}
+		else {
+			printf("Invalid number of arguments:%d\n",argc);
+			return -1;
+		}
+	}
+
+	buff = (char *) malloc(CFG_FLASH_SECTOR_SIZE + 4);
+	buff_ptr = buff;
+
+	prepare_flash(&buff_ptr,&val);
+	*val++ = (long)CFG_DDR_MAGIC;
+	*val++ = ddr_config;
+	*val++ = ddr_config2;
+	*val   = ext_mod;
+
+        flash_write(buff_ptr,(long)(UBOOT_ENV_SEC_START),CFG_FLASH_SECTOR_SIZE);
+
+	printf("Programed values ext_mod:0x%0.8x ",*val--);
+	printf(" ddr_config2:0x%0.8x ddr_config:0x%0.8x \n",*val--,*val);
+	free(buff);
+
+	return 0;
+}
+
+/***************************************************/
+
+U_BOOT_CMD(
+	ddr,	6,	1,	do_ddr,
+	"fls    - Set to change DDR settings on reboot\n",
+	"<value>  - DDR CONFIG\n"
+	"<value>  - DDR CONFIG2\n"
+	"<value>  - EXT MOD\n"
+);
+
+#endif	/* CFG_CMD_SPI */
diff --git a/common/cmd_elf.c b/common/cmd_elf.c
index 1d92bb37d3..d17977bdf8 100644
--- a/common/cmd_elf.c
+++ b/common/cmd_elf.c
@@ -215,6 +215,12 @@ int do_bootvx ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 			(char *) bootaddr);
 	printf ("## Starting vxWorks at 0x%08lx ...\n", addr);
 
+	/*  by huangwenzhong, 10May13 */
+	/* from zhengyongfei, for boot from vxWorks */
+	disable_interrupts();
+	mips_cache_flush();
+	mips_icache_flush_ix();
+	
 	((void (*)(void)) addr) ();
 
 	puts ("## vxWorks terminated\n");
diff --git a/common/cmd_ethreg.c b/common/cmd_ethreg.c
new file mode 100644
index 0000000000..6bda1fe2ec
--- /dev/null
+++ b/common/cmd_ethreg.c
@@ -0,0 +1,197 @@
+/*
+ * (C) Copyright 2002
+ * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * SPI Read/Write Utilities
+ */
+
+#include <common.h>
+#include <command.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_ETHREG)
+
+/*-----------------------------------------------------------------------
+ * Definitions
+ */
+#ifdef CFG_ATHRS26_PHY
+extern unsigned int s26_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+extern void s26_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data);
+extern uint32_t athrs26_reg_read(uint32_t reg_addr);
+extern void athrs26_reg_write(uint32_t reg_addr, uint32_t reg_val);
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+extern unsigned int s27_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+extern void s27_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data);
+extern uint32_t athrs27_reg_read(uint32_t reg_addr);
+extern void athrs27_reg_write(uint32_t reg_addr, uint32_t reg_val);
+#endif
+
+#ifdef CONFIG_AR7242_S16_PHY
+extern uint32_t athrs16_reg_read(uint32_t reg_addr);
+extern void athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val);
+extern int  ag7240_miiphy_read(char *devname, uint32_t phaddr,
+                uint8_t reg);
+extern int  ag7240_miiphy_write(char *devname, uint32_t phaddr,
+                uint8_t reg, uint16_t data);
+#endif
+
+
+#define READ_MAC  0x01
+#define WRITE_MAC 0x02
+#define READ_PHY  0x10
+#define WRITE_PHY 0x20
+
+/*
+ * Values from last command.
+ */
+static int   reg;
+static int   val,rd_value;
+static int phyaddr;
+static int portnum;
+
+int do_ethreg (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int   rcode = 0;
+
+	/*
+	 * We use the last specified parameters, unless new ones are
+	 * entered.
+	 */
+
+	if ((flag & CMD_FLAG_REPEAT) == 0)
+	{
+		if (argc == 2) {
+			reg = simple_strtoul(argv[1], NULL, 10);
+			rcode = READ_MAC;
+		}
+		if (argc == 3) {
+			reg = simple_strtoul(argv[1], NULL, 10);
+			val = simple_strtoul(argv[2],NULL,10);
+			rcode = WRITE_MAC;
+		}
+		if (argc == 4) {
+    	                if(*argv[1] == 'p') {
+				portnum = simple_strtoul(argv[2], NULL, 10);
+				reg = simple_strtoul(argv[3],NULL,10);
+				rcode = READ_PHY; 
+			}
+			else
+			    return 1;
+		}
+        	if (argc == 5) {
+    	                if(*argv[1] == 'p') {
+				portnum = simple_strtoul(argv[2], NULL, 10);
+				reg = simple_strtoul(argv[3],NULL,10);
+				val = simple_strtoul(argv[4],NULL,10);
+				rcode = WRITE_PHY; 
+			}
+			else
+			    return 1;
+		}
+
+		if ((argc > 4) && (argc < 2))
+			return 1;
+	}
+#ifdef CONFIG_AR7242_S16_PHY
+   if(rcode == READ_PHY) {
+   	rd_value = ag7240_miiphy_read("eth0",portnum,reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode == READ_MAC) {
+        rd_value = athrs16_reg_read(reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode  == WRITE_PHY) {
+   	rd_value = ag7240_miiphy_read("eth0",portnum,reg);
+        ag7240_miiphy_write("eth0",portnum,reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else if(rcode == WRITE_MAC) {
+        rd_value = athrs16_reg_read(reg);
+        athrs16_reg_write(reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else
+	return 1;
+#endif
+#ifdef CFG_ATHRS26_PHY        
+   if(rcode == READ_PHY) {
+   	rd_value = s26_rd_phy(portnum,reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode == READ_MAC) {
+        rd_value = athrs26_reg_read(reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode  == WRITE_PHY) {
+   	rd_value = s26_rd_phy(portnum,reg);
+        s26_wr_phy(portnum,reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else if(rcode == WRITE_MAC) {
+        rd_value = athrs26_reg_read(reg);
+        athrs26_reg_write(reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else
+	return 1;
+#endif
+#ifdef CFG_ATHRS27_PHY        
+   if(rcode == READ_PHY) {
+   	rd_value = s27_rd_phy(portnum,reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode == READ_MAC) {
+        rd_value = athrs27_reg_read(reg);
+        printf("Read Reg: 0x%08x = 0x%08x\n",reg,rd_value);
+   }
+   else if(rcode  == WRITE_PHY) {
+   	rd_value = s27_rd_phy(portnum,reg);
+        s27_wr_phy(portnum,reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else if(rcode == WRITE_MAC) {
+        rd_value = athrs27_reg_read(reg);
+        athrs27_reg_write(reg,val);
+        printf("Write Reg: 0x%08x: Oldval = 0x%08x Newval = 0x%08x\n", reg, rd_value, val);
+   }
+   else
+	return 1;
+#endif
+   return 0;
+}
+
+/***************************************************/
+
+U_BOOT_CMD(
+	ethreg,	6,	1,	do_ethreg,
+	"ethreg    - S26 PHY Reg rd/wr  utility\n",
+	"<p> <phyaddr> <reg> <value> - Send <bit_len> bits from <dout> out the SPI\n"
+	"<p>  - operates on the phy; by default is rd/wr s26 mac registers\n"
+	"<phyaddr> - Address of the phy\n"
+	"<reg>    - Register offset\n"
+	"<value>  - value to write\n"
+);
+
+#endif	/* CFG_CMD_SPI */
diff --git a/common/cmd_flash.c b/common/cmd_flash.c
index 201f4e33d4..eeff0565c2 100644
--- a/common/cmd_flash.c
+++ b/common/cmd_flash.c
@@ -157,7 +157,6 @@ addr_spec(char *arg1, char *arg2, ulong *addr_first, ulong *addr_last)
 		 * boundary. We want to round such an address to the next
 		 * sector boundary, so that the commands don't fail later on.
 		 */
-
 		/* find the end addr of the sector where the *addr_last is */
 		for (bank = 0; bank < CFG_MAX_FLASH_BANKS && !found; ++bank){
 			int i;
@@ -276,7 +275,7 @@ flash_fill_sect_ranges (ulong addr_first, ulong addr_last,
 
 	return rcode;
 }
-
+#ifndef COMPRESSED_UBOOT
 int do_flinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	ulong bank;
@@ -304,6 +303,7 @@ int do_flinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	flash_print_info (&flash_info[bank-1]);
 	return 0;
 }
+#endif /* #ifndef COMPRESSED_UBOOT */
 
 int do_flerase (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
@@ -324,7 +324,9 @@ int do_flerase (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 
 	if (strcmp(argv[1], "all") == 0) {
 		for (bank=1; bank<=CFG_MAX_FLASH_BANKS; ++bank) {
+#ifdef FLASH_DEBUG
 			printf ("Erase Flash Bank # %ld ", bank);
+#endif
 			info = &flash_info[bank-1];
 			rcode = flash_erase (info, 0, info->sector_count-1);
 		}
@@ -336,8 +338,10 @@ int do_flerase (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 			puts ("Bad sector specification\n");
 			return 1;
 		}
+#ifdef FLASH_DEBUG
 		printf ("Erase Flash Sectors %d-%d in Bank # %d ",
 			sect_first, sect_last, (info-flash_info)+1);
+#endif
 		rcode = flash_erase(info, sect_first, sect_last);
 		return rcode;
 	}
@@ -352,12 +356,12 @@ int do_flerase (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 				info = &flash_info[bank];
 				addr_first = part->offset + info->start[0];
 				addr_last = addr_first + part->size - 1;
-
+#ifdef FLASH_DEBUG
 				printf ("Erase Flash Parition %s, "
 						"bank %d, 0x%08lx - 0x%08lx ",
 						argv[1], bank, addr_first,
 						addr_last);
-
+#endif
 				rcode = flash_sect_erase(addr_first, addr_last);
 				return rcode;
 			}
@@ -380,12 +384,13 @@ int do_flerase (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 				CFG_MAX_FLASH_BANKS);
 			return 1;
 		}
+#ifdef FLASH_DEBUG
 		printf ("Erase Flash Bank # %ld ", bank);
+#endif
 		info = &flash_info[bank-1];
 		rcode = flash_erase (info, 0, info->sector_count-1);
 		return rcode;
 	}
-
 	if (addr_spec(argv[1], argv[2], &addr_first, &addr_last) < 0){
 		printf ("Bad address format\n");
 		return 1;
@@ -422,6 +427,7 @@ int flash_sect_erase (ulong addr_first, ulong addr_last)
 		     ++bank, ++info) {
 			if (s_first[bank]>=0) {
 				erased += s_last[bank] - s_first[bank] + 1;
+#ifdef FLASH_DEBUG
 				debug ("Erase Flash from 0x%08lx to 0x%08lx "
 					"in Bank # %ld ",
 					info->start[s_first[bank]],
@@ -429,6 +435,9 @@ int flash_sect_erase (ulong addr_first, ulong addr_last)
 						info->start[0] + info->size - 1:
 						info->start[s_last[bank]+1] - 1,
 					bank+1);
+#else
+				printf( "Erasing flash... ");
+#endif
 				rcode = flash_erase (info, s_first[bank], s_last[bank]);
 			}
 		}
@@ -441,6 +450,7 @@ int flash_sect_erase (ulong addr_first, ulong addr_last)
 	return rcode;
 }
 
+#ifndef COMPRESSED_UBOOT
 int do_protect (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	flash_info_t *info;
@@ -670,7 +680,7 @@ int flash_sect_protect (int p, ulong addr_first, ulong addr_last)
 	}
 	return rcode;
 }
-
+#endif /* #ifndef COMPRESSED_UBOOT */
 
 /**************************************************/
 #if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
@@ -683,6 +693,7 @@ int flash_sect_protect (int p, ulong addr_first, ulong addr_last)
 # define TMP_PROT_OFF	/* empty */
 #endif
 
+#ifndef COMPRESSED_UBOOT
 U_BOOT_CMD(
 	flinfo,    2,    1,    do_flinfo,
 	"flinfo  - print FLASH memory information\n",
@@ -690,20 +701,6 @@ U_BOOT_CMD(
 	"flinfo N\n    - print information for FLASH memory bank # N\n"
 );
 
-U_BOOT_CMD(
-	erase,   3,   1,  do_flerase,
-	"erase   - erase FLASH memory\n",
-	"start end\n"
-	"    - erase FLASH from addr 'start' to addr 'end'\n"
-	"erase start +len\n"
-	"    - erase FLASH from addr 'start' to the end of sect "
-	"w/addr 'start'+'len'-1\n"
-	"erase N:SF[-SL]\n    - erase sectors SF-SL in FLASH bank # N\n"
-	"erase bank N\n    - erase FLASH bank # N\n"
-	TMP_ERASE
-	"erase all\n    - erase all FLASH banks\n"
-);
-
 U_BOOT_CMD(
 	protect,  4,  1,   do_protect,
 	"protect - enable or disable FLASH write protection\n",
@@ -729,6 +726,24 @@ U_BOOT_CMD(
 	"protect off all\n    - make all FLASH banks writable\n"
 );
 
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+U_BOOT_CMD(
+	erase,   3,   1,  do_flerase,
+	"erase   - erase FLASH memory\n",
+	"start end\n"
+	"    - erase FLASH from addr 'start' to addr 'end'\n"
+	"erase start +len\n"
+	"    - erase FLASH from addr 'start' to the end of sect "
+	"w/addr 'start'+'len'-1\n"
+	"erase N:SF[-SL]\n    - erase sectors SF-SL in FLASH bank # N\n"
+	"erase bank N\n    - erase FLASH bank # N\n"
+	TMP_ERASE
+	"erase all\n    - erase all FLASH banks\n"
+);
+
+
+
 #undef	TMP_ERASE
 #undef	TMP_PROT_ON
 #undef	TMP_PROT_OFF
diff --git a/common/cmd_load.c b/common/cmd_load.c
index 31fef8151b..7487fa8ca0 100644
--- a/common/cmd_load.c
+++ b/common/cmd_load.c
@@ -431,6 +431,7 @@ int  his_pad_count;  /* number of pad chars he needs */
 char his_pad_char;   /* pad chars he needs */
 char his_quote;      /* quote chars he'll use */
 
+#ifndef COMPRESSED_UBOOT
 int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	ulong offset = 0;
@@ -523,6 +524,7 @@ int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 #endif
 	return rcode;
 }
+#endif /* #ifndef COMPRESSED_UBOOT */
 
 
 static ulong load_serial_bin (ulong offset)
diff --git a/common/cmd_mem.c b/common/cmd_mem.c
index 0f4f9b73df..6fc38392a0 100644
--- a/common/cmd_mem.c
+++ b/common/cmd_mem.c
@@ -312,7 +312,7 @@ int do_mem_mwc ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	return 0;
 }
 #endif /* CONFIG_MX_CYCLIC */
-
+#ifndef COMPRESSED_UBOOT
 int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	ulong	addr1, addr2, count, ngood;
@@ -390,6 +390,8 @@ int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		ngood == 1 ? "" : "s");
 	return rcode;
 }
+#endif /* #ifndef COMPRESSED_UBOOT  */
+
 
 int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
@@ -419,7 +421,7 @@ int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		return 1;
 	}
 
-#ifndef CFG_NO_FLASH
+#if !defined(CFG_NO_FLASH) && !defined(CONFIG_ATH_NAND_BR)
 	/* check if we are copying to Flash */
 	if ( (addr2info(dest) != NULL)
 #ifdef CONFIG_HAS_DATAFLASH
@@ -527,6 +529,8 @@ int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	return 0;
 }
 
+
+#ifndef COMPRESSED_UBOOT
 int do_mem_base (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	if (argc > 1) {
@@ -684,6 +688,7 @@ int do_mem_loopw (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	}
 }
 #endif /* CONFIG_LOOPW */
+#endif /* #ifndef COMPRESSED_UBOOT */
 
 /*
  * Perform a memory test. A more complete alternative test can be
@@ -1098,6 +1103,9 @@ mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char *argv[])
 	return 0;
 }
 
+
+
+#ifndef COMPRESSED_UBOOT
 #ifndef CONFIG_CRC32_VERIFY
 
 int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
@@ -1185,40 +1193,6 @@ int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 }
 #endif	/* CONFIG_CRC32_VERIFY */
 
-/**************************************************/
-#if (CONFIG_COMMANDS & CFG_CMD_MEMORY)
-U_BOOT_CMD(
-	md,     3,     1,      do_mem_md,
-	"md      - memory display\n",
-	"[.b, .w, .l] address [# of objects]\n    - memory display\n"
-);
-
-
-U_BOOT_CMD(
-	mm,     2,      1,       do_mem_mm,
-	"mm      - memory modify (auto-incrementing)\n",
-	"[.b, .w, .l] address\n" "    - memory modify, auto increment address\n"
-);
-
-
-U_BOOT_CMD(
-	nm,     2,	    1,     	do_mem_nm,
-	"nm      - memory modify (constant address)\n",
-	"[.b, .w, .l] address\n    - memory modify, read and keep address\n"
-);
-
-U_BOOT_CMD(
-	mw,    4,    1,     do_mem_mw,
-	"mw      - memory write (fill)\n",
-	"[.b, .w, .l] address value [count]\n    - write memory\n"
-);
-
-U_BOOT_CMD(
-	cp,    4,    1,    do_mem_cp,
-	"cp      - memory copy\n",
-	"[.b, .w, .l] source target count\n    - copy memory\n"
-);
-
 U_BOOT_CMD(
 	cmp,    4,     1,     do_mem_cmp,
 	"cmp     - memory compare\n",
@@ -1267,12 +1241,6 @@ U_BOOT_CMD(
 );
 #endif /* CONFIG_LOOPW */
 
-U_BOOT_CMD(
-	mtest,    4,    1,     do_mem_mtest,
-	"mtest   - simple RAM test\n",
-	"[start [end [pattern]]]\n"
-	"    - simple RAM read/write test\n"
-);
 
 #ifdef CONFIG_MX_CYCLIC
 U_BOOT_CMD(
@@ -1288,5 +1256,45 @@ U_BOOT_CMD(
 );
 #endif /* CONFIG_MX_CYCLIC */
 
-#endif
+#endif /* #ifndef COMPRESSED_UBOOT */
+/**************************************************/
+U_BOOT_CMD(
+	md,     3,     1,      do_mem_md,
+	"md      - memory display\n",
+	"[.b, .w, .l] address [# of objects]\n    - memory display\n"
+);
+
+
+U_BOOT_CMD(
+	mm,     2,      1,       do_mem_mm,
+	"mm      - memory modify (auto-incrementing)\n",
+	"[.b, .w, .l] address\n" "    - memory modify, auto increment address\n"
+);
+
+
+U_BOOT_CMD(
+	nm,     2,	    1,     	do_mem_nm,
+	"nm      - memory modify (constant address)\n",
+	"[.b, .w, .l] address\n    - memory modify, read and keep address\n"
+);
+
+U_BOOT_CMD(
+	mw,    4,    1,     do_mem_mw,
+	"mw      - memory write (fill)\n",
+	"[.b, .w, .l] address value [count]\n    - write memory\n"
+);
+
+U_BOOT_CMD(
+	mtest,    4,    1,     do_mem_mtest,
+	"mtest   - simple RAM test\n",
+	"[start [end [pattern]]]\n"
+	"    - simple RAM read/write test\n"
+);
+
+U_BOOT_CMD(
+	cp,    4,    1,    do_mem_cp,
+	"cp      - memory copy\n",
+	"[.b, .w, .l] source target count\n    - copy memory\n"
+);
+
 #endif	/* CFG_CMD_MEMORY */
diff --git a/common/cmd_mii.c b/common/cmd_mii.c
index 48a4e77c55..e0b3ce9b09 100644
--- a/common/cmd_mii.c
+++ b/common/cmd_mii.c
@@ -28,6 +28,11 @@
 #include <common.h>
 #include <command.h>
 
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#ifndef COMPRESSED_UBOOT
 #if (CONFIG_COMMANDS & CFG_CMD_MII)
 #include <miiphy.h>
 
@@ -593,5 +598,271 @@ U_BOOT_CMD(
 );
 
 #endif /* CONFIG_TERSE_MII */
-
 #endif /* CFG_CMD_MII */
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef BOARDCAL
+extern flash_info_t flash_info[];	/* info for FLASH chips */
+
+/**********************************************************************************
+** do_mac_setting
+**
+** This is the executable portion of the progmac command.  This will process the
+** MAC address strings, and program them into the appropriate flash sector..
+**
+*/
+#ifdef CONFIG_ATH_NAND_BR
+
+#define ATH_NAND_NAND_PART              "ath-nand"
+
+
+unsigned long long
+ath_nand_get_cal_offset(const char *ba)
+{
+        char *mtdparts, ch, *pn, *end;
+        unsigned long long off = 0, size;
+
+        mtdparts = strstr(ba, ATH_NAND_NAND_PART);
+        if (!mtdparts) {
+                goto bad;
+        }
+        mtdparts = strstr(mtdparts, ":");
+        if (!mtdparts) {
+                goto bad;
+        }
+        end = strstr(mtdparts, " ");
+        if (!end) {
+                end = mtdparts + strlen(mtdparts);
+        }
+
+        for (;mtdparts && mtdparts < end;) {
+                mtdparts ++;
+                size = simple_strtoul(mtdparts, &mtdparts, 0);
+                ch = *mtdparts;
+                switch (ch) {
+                case 'g': case 'G': size = size * 1024;
+                case 'm': case 'M': size = size * 1024;
+                case 'k': case 'K': size = size * 1024;
+                }
+                pn = mtdparts + 2;
+                if (strncmp(pn, ATH_CAL_NAND_PARTITION,
+                        sizeof(ATH_CAL_NAND_PARTITION) - 1) == 0) {
+                        return off;
+                }
+                off += size;
+                mtdparts = strstr(mtdparts, ",");
+        }
+
+bad:
+        return ATH_CAL_OFF_INVAL;
+}
+
+/**********************************************************************************
+** do_mac_setting
+**
+** This is the executable portion of the progmac command.  This will process the
+** MAC address strings, and program them into the appropriate flash sector..
+**
+*/
+
+int do_mac (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	char    sectorBuff[256*1024];
+	int     serno;
+	int     product_id;
+	int     ret;
+	ulong   off, size;
+	nand_info_t *nand;
+		
+	/* 
+	 * caldata partition is of 128k 
+	 *
+	 */
+	nand = &nand_info[nand_curr_device];
+	size = nand->erasesize;
+	/*
+	 * Argv[1] contains the value string.  Convert to binary, and
+	 * program the values in flash
+	 */
+
+	serno = simple_strtoul(argv[1],0,10);
+
+	/*
+	 * If the serial number is less than 0, or greater than
+	 * 0x1fff, it's out of range
+	 */
+
+	if(serno < 0 || serno > 0x1fff) {
+		printf("Serno out of range\n",serno);
+		return 1;
+	}
+
+    if (argc > 2) {
+        product_id = simple_strtoul(argv[2], 0, 10);
+    } else {
+        product_id = ATHEROS_PRODUCT_ID;
+    } 
+
+	if(product_id < 0 || product_id > 0x7ff) {
+		printf("product id out of range %d\n", product_id);
+		return 1;
+	}
+
+	/*
+	 * Create the 24 bit number that composes the lower 3 bytes of
+	 * the MAC address
+	 */
+
+	serno = 0xFFFFFF & ( (product_id << 13) | (serno & 0x1fff));
+
+	/*
+	 * Get the Offset of Caldata partition
+	 */
+	off = ath_nand_get_cal_offset(getenv("bootargs"));
+	if(off == ATH_CAL_OFF_INVAL) {
+		printf("Invalid CAL offset \n");
+		return 1;
+	}
+	
+         
+	/*
+	 * Get the values from flash, and program into the MAC address
+	 * registers
+	 */
+	ret = nand_read(nand, (loff_t)off, &size, (u_char *)sectorBuff);
+	printf(" %d bytes %s: %s\n", size,
+		       "read", ret ? "ERROR" : "OK");
+	if(ret != 0 ) {
+		return 1;
+	}
+	
+	/*
+	 * Set the first and second values
+	 */
+
+	sectorBuff[0] = 0x00;
+	sectorBuff[1] = 0x03;
+	sectorBuff[2] = 0x7f;
+
+	sectorBuff[3] = 0xFF & (serno >> 16);
+	sectorBuff[4] = 0xFF & (serno >> 8);
+	sectorBuff[5] = 0xFF &  serno;
+
+	/*
+	 * Increment by 1 for the second MAC address
+	 */
+
+	serno++;
+	memcpy(&sectorBuff[6],&sectorBuff[0],3);
+	sectorBuff[9]  = 0xFF & (serno >> 16);
+	sectorBuff[10] = 0xFF & (serno >> 8);
+	sectorBuff[11] = 0xFF &  serno;
+	
+	ret = nand_erase(nand,(loff_t)off, size);
+	printf(" %d bytes %s: %s\n", size,
+		       "erase", ret ? "ERROR" : "OK");
+
+	if(ret != 0 ) {
+		return 1;
+	}
+
+	ret = nand_write(nand, (loff_t)off, &size, (u_char *)sectorBuff);
+	printf(" %d bytes %s: %s\n", size,
+		       "write", ret ? "ERROR" : "OK");
+	if(ret != 0 ) {
+		return 1;
+	}
+
+	return 0;
+}
+#else /*CONFIG_ATH_NAND_BR */
+
+int do_mac (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	uchar    sectorBuff[CFG_FLASH_SECTOR_SIZE];
+	int     serno;
+	int     product_id;
+
+	/*
+	 * Argv[1] contains the value string.  Convert to binary, and
+	 * program the values in flash
+	 */
+
+	serno = simple_strtoul(argv[1],0,10);
+
+	/*
+	 * If the serial number is less than 0, or greater than
+	 * 0x1fff, it's out of range
+	 */
+
+	if(serno < 0 || serno > 0x1fff) {
+		printf("Serno out of range\n",serno);
+		return 1;
+	}
+
+    if (argc > 2) {
+        product_id = simple_strtoul(argv[2], 0, 10);
+    } else {
+        product_id = ATHEROS_PRODUCT_ID;
+    } 
+
+	if(product_id < 0 || product_id > 0x7ff) {
+		printf("product id out of range %d\n", product_id);
+		return 1;
+	}
+
+	/*
+	 * Create the 24 bit number that composes the lower 3 bytes of
+	 * the MAC address
+	 */
+
+	serno = 0xFFFFFF & ( (product_id << 13) | (serno & 0x1fff));
+
+	/*
+	 * Get the values from flash, and program into the MAC address
+	 * registers
+	 */
+
+	memcpy(sectorBuff,(void *)BOARDCAL, CFG_FLASH_SECTOR_SIZE);
+
+	/*
+	 * Set the first and second values
+	 */
+
+	sectorBuff[0] = 0x00;
+	sectorBuff[1] = 0x03;
+	sectorBuff[2] = 0x7f;
+
+	sectorBuff[3] = 0xFF & (serno >> 16);
+	sectorBuff[4] = 0xFF & (serno >> 8);
+	sectorBuff[5] = 0xFF &  serno;
+
+	/*
+	 * Increment by 1 for the second MAC address
+	 */
+
+	serno++;
+	memcpy(&sectorBuff[6],&sectorBuff[0],3);
+	sectorBuff[9]  = 0xFF & (serno >> 16);
+	sectorBuff[10] = 0xFF & (serno >> 8);
+	sectorBuff[11] = 0xFF &  serno;
+
+	flash_erase(flash_info,CAL_SECTOR,CAL_SECTOR);
+	write_buff(flash_info,sectorBuff, BOARDCAL, CFG_FLASH_SECTOR_SIZE);
+
+	return 0;
+}
+#endif /*CONFIG_ATH_NAND_BR */
+
+U_BOOT_CMD(
+    progmac, 3, 0, do_mac,
+    "progmac - Set ethernet MAC addresses\n",
+    "progmac <serno> [<product_id>] - Program the MAC addresses\n"
+    "                <serno> is the value of the last\n"
+    "                4 digits (decimal) of the serial number.\n"
+    "                Optional parameter <product_id> specifies\n"
+    "                the board's product ID (decimal)\n"
+);
+
+#endif /* BOARDCAL */
+
diff --git a/common/cmd_nand.c b/common/cmd_nand.c
index 21adb1b478..29ad09b273 100644
--- a/common/cmd_nand.c
+++ b/common/cmd_nand.c
@@ -38,12 +38,7 @@
 
 extern nand_info_t nand_info[];       /* info for NAND chips */
 
-static int nand_dump_oob(nand_info_t *nand, ulong off)
-{
-	return 0;
-}
-
-static int nand_dump(nand_info_t *nand, ulong off)
+static int nand_raw_dump(nand_info_t *nand, ulong off, int page)
 {
 	int i;
 	u_char *buf, *p;
@@ -63,10 +58,12 @@ static int nand_dump(nand_info_t *nand, ulong off)
 	printf("Page %08x dump:\n", off);
 	i = nand->oobblock >> 4; p = buf;
 	while (i--) {
-		printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x"
-			"  %02x %02x %02x %02x %02x %02x %02x %02x\n",
-			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
-			p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+		if (page) {
+			printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x"
+				"  %02x %02x %02x %02x %02x %02x %02x %02x\n",
+				p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+				p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+		}
 		p += 16;
 	}
 	puts("OOB:\n");
@@ -81,6 +78,16 @@ static int nand_dump(nand_info_t *nand, ulong off)
 	return 0;
 }
 
+static int nand_dump_oob(nand_info_t *nand, ulong off)
+{
+	return nand_raw_dump(nand, off, 0);
+}
+
+static int nand_dump(nand_info_t *nand, ulong off)
+{
+	return nand_raw_dump(nand, off, 1);
+}
+
 /* ------------------------------------------------------------------------- */
 
 static void
@@ -205,7 +212,7 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 		printf("\nNAND erase: device %d offset 0x%x, size 0x%x ",
 		       nand_curr_device, off, size);
 		ret = nand_erase(nand, off, size);
-		printf("%s\n", ret ? "ERROR" : "OK");
+		printf("\n%s\n", ret ? "ERROR" : "OK");
 
 		return ret == 0 ? 0 : 1;
 	}
@@ -246,13 +253,13 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 			return 1;
 
 		i = strncmp(cmd, "read", 4) == 0;	/* 1 = read, 0 = write */
-		printf("\nNAND %s: device %d offset %u, size %u ... ",
+		printf("\nNAND %s: device %d offset 0x%x, size %u ... ",
 		       i ? "read" : "write", nand_curr_device, off, size);
 
 		if (i)
-			ret = nand_read(nand, off, &size, (u_char *)addr);
+			ret = nand_read(nand, (loff_t)off, &size, (u_char *)addr);
 		else
-			ret = nand_write(nand, off, &size, (u_char *)addr);
+			ret = nand_write(nand, (loff_t)off, &size, (u_char *)addr);
 
 		printf(" %d bytes %s: %s\n", size,
 		       i ? "read" : "written", ret ? "ERROR" : "OK");
@@ -361,20 +368,25 @@ int do_nandboot(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 	/* Loading ok, update default load address */
 
 	load_addr = addr;
-
+#ifndef CONFIG_ATH_NAND_SUPPORT
 	/* Check if we should attempt an auto-start */
 	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep, "yes") == 0)) {
+#endif
 		char *local_args[2];
 		extern int do_bootm(cmd_tbl_t *, int, int, char *[]);
 
 		local_args[0] = argv[0];
 		local_args[1] = NULL;
 
+#ifndef CONFIG_ATH_NAND_SUPPORT
 		printf("Automatic boot of image at addr 0x%08lx ...\n", addr);
+#endif
 
 		do_bootm(cmdtp, 0, 1, local_args);
 		return 1;
+#ifndef CONFIG_ATH_NAND_SUPPORT
 	}
+#endif
 	return 0;
 }
 
diff --git a/common/cmd_net.c b/common/cmd_net.c
index 2cb2c5d34b..3e76fcfe46 100644
--- a/common/cmd_net.c
+++ b/common/cmd_net.c
@@ -32,9 +32,12 @@
 
 
 extern int do_bootm (cmd_tbl_t *, int, int, char *[]);
+#ifdef FW_RECOVERY
+extern ushort fw_recovery;
+#endif
 
 static int netboot_common (proto_t, cmd_tbl_t *, int , char *[]);
-
+#ifndef COMPRESSED_UBOOT
 int do_bootp (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	return netboot_common (BOOTP, cmdtp, argc, argv);
@@ -46,25 +49,25 @@ U_BOOT_CMD(
 	"[loadAddress] [bootfilename]\n"
 );
 
-int do_tftpb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+int do_rarpb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	return netboot_common (TFTP, cmdtp, argc, argv);
+	return netboot_common (RARP, cmdtp, argc, argv);
 }
 
 U_BOOT_CMD(
-	tftpboot,	3,	1,	do_tftpb,
-	"tftpboot- boot image via network using TFTP protocol\n",
+	rarpboot,	3,	1,	do_rarpb,
+	"rarpboot- boot image via network using RARP/TFTP protocol\n",
 	"[loadAddress] [bootfilename]\n"
 );
-
-int do_rarpb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+#endif /* #ifndef COMPRESSED_UBOOT */
+int do_tftpb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	return netboot_common (RARP, cmdtp, argc, argv);
+	return netboot_common (TFTP, cmdtp, argc, argv);
 }
 
 U_BOOT_CMD(
-	rarpboot,	3,	1,	do_rarpb,
-	"rarpboot- boot image via network using RARP/TFTP protocol\n",
+	tftpboot,	3,	1,	do_tftpb,
+	"tftpboot- boot image via network using TFTP protocol\n",
 	"[loadAddress] [bootfilename]\n"
 );
 
@@ -183,7 +186,7 @@ netboot_common (proto_t proto, cmd_tbl_t *cmdtp, int argc, char *argv[])
 
 		break;
 
-	default: printf ("Usage:\n%s\n", cmdtp->usage);
+	default: printf ("Usage(%d):\n%s\n", argc, cmdtp->usage);
 		return 1;
 	}
 
@@ -247,6 +250,26 @@ U_BOOT_CMD(
 	"ping\t- send ICMP ECHO_REQUEST to network host\n",
 	"pingAddress\n"
 );
+
+#ifdef TPWD_FOR_LINUX_CAL
+int pingTest(char* ip)
+{
+	NetPingIP = string_to_ip(ip);
+	if (NetPingIP == 0)
+		{		
+			printf("ping parameter ERROR. --debug by HouXB\n");
+			return -1;
+		}
+	if (NetLoop(PING) < 0)
+	{
+		printf("host %s is NOT alive. --debug by HouXB\n", ip);
+		return 1;
+	}
+	printf("host %s is alive. --debug by HouXB\n", ip);
+	return 0;
+}
+#endif
+
 #endif	/* CFG_CMD_PING */
 
 #if (CONFIG_COMMANDS & CFG_CMD_CDP)
diff --git a/common/cmd_nvedit.c b/common/cmd_nvedit.c
index 6257fbd23e..eecf908c90 100644
--- a/common/cmd_nvedit.c
+++ b/common/cmd_nvedit.c
@@ -88,7 +88,6 @@ static int envmatch (uchar *, int);
 static const unsigned long baudrate_table[] = CFG_BAUDRATE_TABLE;
 #define	N_BAUDRATES (sizeof(baudrate_table) / sizeof(baudrate_table[0]))
 
-
 /************************************************************************
  * Command interface: print one or all environment variables
  */
@@ -570,7 +569,6 @@ envmatch (uchar *s1, int i2)
 
 
 /**************************************************/
-
 U_BOOT_CMD(
 	printenv, CFG_MAXARGS, 1,	do_printenv,
 	"printenv- print environment variables\n",
diff --git a/common/cmd_pll.c b/common/cmd_pll.c
new file mode 100644
index 0000000000..72724b28a9
--- /dev/null
+++ b/common/cmd_pll.c
@@ -0,0 +1,309 @@
+/*
+ * (C) Copyright 2002
+ * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <environment.h>
+#include <command.h>
+#include <config.h>
+#ifndef CONFIG_ATHEROS
+#include <ar7240_soc.h>
+#endif
+
+#ifndef CONFIG_ATH_EMULATION
+#if (CONFIG_COMMANDS & CFG_CMD_PLL)
+#if defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x)
+int do_pll (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	extern env_t	*env_ptr;
+	extern int saveenv(void);
+	extern void env_crc_update (void);
+
+	unsigned	*val;
+
+	if (argc != 2 && argc != 5) {
+		printf(cmdtp->usage);
+		return -1;
+	}
+
+	val = (unsigned *)env_ptr->data +
+		(sizeof(env_ptr->data) / sizeof(*val)) - (32 / sizeof(*val));
+
+	if (strcmp(argv[1], "erase") == 0) {
+		printf("Erasing flash setting\n");
+		val[0] = val[1] =
+		val[2] = val[3] =
+		val[4] = val[5] = 0xffffffffu;
+	} else if (strcmp(argv[1], "get") == 0) {
+		printf("pll 0x%x 0x%x 0x%x 0x%x\n", val[1], val[2], val[3], val[4]);
+		return 0;
+	} else if (argc > 2) {
+		val[0] = PLL_MAGIC;
+
+		val[1] = simple_strtoul(argv[1], NULL, 16);
+		val[2] = simple_strtoul(argv[2], NULL, 16);
+		val[3] = simple_strtoul(argv[3], NULL, 16);
+		val[4] = simple_strtoul(argv[4], NULL, 16);
+		printf("Setting 0x%x 0x%x 0x%x 0x%x\n", val[1], val[2], val[3], val[4]);
+	} else {
+		printf(cmdtp->usage);
+		return -1;
+	}
+
+	env_crc_update();
+	saveenv();
+
+	return 0;
+
+}
+
+U_BOOT_CMD(
+	pll,	5,	0,	do_pll,
+#ifdef COMPRESSED_UBOOT
+	NULL, NULL
+#else
+	"pll cpu-pll dither ddr-pll dither - Set to change CPU & DDR speed\npll erase\npll get\n", NULL
+#endif
+);
+
+#elif defined(CONFIG_WASP_SUPPORT)
+#include <asm/addrspace.h>
+
+int do_srifpll (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	extern env_t	*env_ptr;
+	extern int saveenv(void);
+	extern void env_crc_update (void);
+
+	unsigned	*val;
+
+	if (argc != 2 && argc != 3) {
+		printf(cmdtp->usage);
+		return -1;
+	}
+
+	val = env_ptr->data + sizeof(env_ptr->data) - 0x20 - 0xc;
+
+	if (strcmp(argv[1], "erase") == 0) {
+		printf("Erasing flash setting\n");
+		val[0] = val[1] = val[2] = 0xffffffffu;
+	} else if (strcmp(argv[1], "get") == 0) {
+		printf("srifpll 0x%x 0x%x\n", val[1], val[2]);
+		return 0;
+	} else if (argc > 2) {
+		val[0] = SRIF_PLL_MAGIC;
+
+		val[1] = simple_strtoul(argv[1], NULL, 16);
+		val[2] = simple_strtoul(argv[2], NULL, 16);
+		printf("Setting 0x%x 0x%x\n", val[1], val[2]);
+	} else {
+		printf(cmdtp->usage);
+		return -1;
+	}
+
+	env_crc_update();
+	saveenv();
+
+	return 0;
+
+}
+
+int do_pll (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	extern env_t	*env_ptr;
+	extern int saveenv(void);
+	extern void env_crc_update (void);
+
+	unsigned	*val;
+
+	if (argc != 2 && argc != 6) {
+		printf(cmdtp->usage);
+		return -1;
+	}
+
+	val = (unsigned *)env_ptr->data +
+		(sizeof(env_ptr->data) / sizeof(*val)) - (32 / sizeof(*val));
+
+	if (strcmp(argv[1], "erase") == 0) {
+		printf("Erasing flash setting\n");
+		val[0] = val[1] =
+		val[2] = val[3] =
+		val[4] = val[5] = 0xffffffffu;
+	} else if (strcmp(argv[1], "get") == 0) {
+		printf("pll 0x%x 0x%x 0x%x 0x%x 0x%x\n", val[1], val[2], val[3], val[4], val[5]);
+		return 0;
+	} else if (argc > 2) {
+		val[0] = PLL_MAGIC;
+
+		val[1] = simple_strtoul(argv[1], NULL, 16);
+		val[2] = simple_strtoul(argv[2], NULL, 16);
+		val[3] = simple_strtoul(argv[3], NULL, 16);
+		val[4] = simple_strtoul(argv[4], NULL, 16);
+		val[5] = simple_strtoul(argv[5], NULL, 16);
+		printf("Setting 0x%x 0x%x 0x%x 0x%x 0x%x\n", val[1], val[2], val[3], val[4], val[5]);
+	} else {
+		printf(cmdtp->usage);
+		return -1;
+	}
+
+	env_crc_update();
+	saveenv();
+
+	return 0;
+
+}
+
+U_BOOT_CMD(
+	pll,	6,	0,	do_pll,
+#ifdef COMPRESSED_UBOOT
+	NULL, NULL
+#else
+	"pll cpu-pll dither ddr-pll dither - Set to change CPU & DDR speed\npll erase\npll get\n", NULL
+#endif
+);
+
+U_BOOT_CMD(
+	srifpll,	3,	0,	do_srifpll,
+#ifdef COMPRESSED_UBOOT
+	NULL, NULL
+#else
+	"srifpll cpu-pll ddr-pll - To change CPU & DDR speed through srif\nsrifpll erase\nsrifpll get\n", NULL
+#endif
+);
+#else	/* CONFIG_WASP_SUPPORT */
+typedef struct {
+	char		*freq;
+	unsigned	ddr,
+			ahb,
+			pll,
+			ref;
+} plldef_t;
+
+static plldef_t plldef[] = {
+	{ "400_400_200", 0x0u, 0x0u, 0x28u, 0x2u },
+	{ "400_400_100", 0x0u, 0x1u, 0x28u, 0x2u },
+	{ "360_360_180", 0x0u, 0x0u, 0x24u, 0x2u },
+	{ "350_350_175", 0x0u, 0x0u, 0x23u, 0x2u },
+	{ "340_340_170", 0x0u, 0x0u, 0x22u, 0x2u },
+	{ "320_320_160", 0x0u, 0x0u, 0x20u, 0x2u },
+	{ "320_320_80",  0x0u, 0x1u, 0x20u, 0x2u },
+	{ "300_300_150", 0x0u, 0x0u, 0x1eu, 0x2u },
+	{ "300_300_75",  0x0u, 0x1u, 0x1eu, 0x2u },
+	{ "200_200_100", 0x0u, 0x0u, 0x14u, 0x2u },
+	{ "370_370_185", 0x0u, 0x0u, 0x25u, 0x2u },
+	{ "380_380_190", 0x0u, 0x0u, 0x26u, 0x2u },
+	{ "390_390_195", 0x0u, 0x0u, 0x27u, 0x2u },
+	{ "410_410_205", 0x0u, 0x0u, 0x29u, 0x2u },
+	{ "420_420_210", 0x0u, 0x0u, 0x2au, 0x2u },
+	{ "430_430_215", 0x0u, 0x0u, 0x2bu, 0x2u },
+	{ NULL, 0x0u, 0x0u, 0x0u, 0x0u }	/* Terminator */
+};
+
+int do_pll (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	extern env_t	*env_ptr;
+	extern int saveenv(void);
+	extern void env_crc_update (void);
+
+	plldef_t	*p;
+	unsigned	*val;
+
+#ifndef COMPRESSED_UBOOT
+	if (argc == 1) {
+		/* list known frequencies */
+		printf("List of known frequencies:\n");
+		for (p = plldef; p->freq; p ++) {
+			printf("\t%s\n", p->freq);
+		}
+		return 0;
+	}
+#endif
+
+	if (argc != 2) {
+		printf(cmdtp->usage);
+		return -1;
+	}
+
+	val = (unsigned *)env_ptr->data;
+
+	/*
+	 * We use the last 16 bytes of envmt data.
+	 * Position the pointer appropriately.
+	 */
+	val += (sizeof(env_ptr->data) / sizeof(*val))
+		- (16 / sizeof(*val));
+
+	val[0] = PLL_MAGIC;
+
+	/*
+	 * XXX XXX XXX WARNING XXX XXX XXX
+	 * Doesn't detect arguments like aaa_bbb_ccc that
+	 * are not present in the above table. They will
+	 * get processed in strtoul, and an incorrect
+	 * value will be set, instead of flagging an error
+	 *
+	 * This does not take care of redefining CFG_HZ
+	 */
+	for (p = plldef; p->freq; p ++) {
+		if (strcmp(argv[1], p->freq) == 0) {
+			val[1] = (unsigned)(
+					(p->ddr << PLL_CONFIG_DDR_DIV_SHIFT) |
+					(p->ahb << PLL_CONFIG_AHB_DIV_SHIFT) |
+					(p->pll << PLL_CONFIG_PLL_DIV_SHIFT) |
+					(p->ref << PLL_CONFIG_PLL_REF_DIV_SHIFT));
+			break;
+		}
+	}
+	if (!p->freq) {
+		if (strcmp(argv[1], "erase") == 0) {
+			val[0] = 0xffffffffu;
+			val[1] = 0xffffffffu;
+		} else {
+			val[1] = simple_strtoul(argv[1], NULL, 10);
+		}
+	}
+
+#ifndef COMPRESSED_UBOOT
+	printf("magic: 0x%08x	value: 0x%08x\n", val[0], val[1]);
+#endif
+
+	env_crc_update();
+	saveenv();
+
+	return 0;
+}
+
+/***************************************************/
+
+U_BOOT_CMD(
+	pll,	2,	0,	do_pll,
+#ifdef COMPRESSED_UBOOT
+	NULL, NULL
+#else
+	"pll [<val>] - Set to change CPU/AHB/DDR speeds\n",
+	"<val> - 300_300_150\n"
+#endif
+);
+#endif /* CONFIG_WASP_SUPPORT */
+
+#endif	/* CFG_CMD_SPI */
+#endif // CONFIG_ATH_EMULATION
diff --git a/common/command.c b/common/command.c
index e917975a73..ac791697ff 100644
--- a/common/command.c
+++ b/common/command.c
@@ -78,6 +78,7 @@ U_BOOT_CMD(
 
 #endif	/*  CFG_CMD_ECHO */
 
+#ifndef COMPRESSED_UBOOT
 #ifdef CFG_HUSH_PARSER
 
 int
@@ -230,6 +231,7 @@ U_BOOT_CMD(
 
 
 #endif
+#endif /* #ifdef COMPRESSED_UBOOT */
 
 /*
  * Use puts() instead of printf() to avoid printf buffer overflow
diff --git a/common/env_common.c b/common/env_common.c
index eb33422af4..b269aff555 100644
--- a/common/env_common.c
+++ b/common/env_common.c
@@ -207,7 +207,7 @@ void env_relocate (void)
 	enable_nvram();
 #endif
 
-#ifdef ENV_IS_EMBEDDED
+#if defined(ENV_IS_EMBEDDED)
 	/*
 	 * The environment buffer is embedded with the text segment,
 	 * just relocate the environment pointer
diff --git a/common/env_flash.c b/common/env_flash.c
index 1674b30e11..295d3b8d9c 100644
--- a/common/env_flash.c
+++ b/common/env_flash.c
@@ -68,6 +68,7 @@ static env_t *flash_addr = (env_t *)CFG_ENV_ADDR;
 #else /* ! ENV_IS_EMBEDDED */
 
 env_t *env_ptr = (env_t *)CFG_ENV_ADDR;
+
 #ifdef CMD_SAVEENV
 static env_t *flash_addr = (env_t *)CFG_ENV_ADDR;
 #endif
diff --git a/common/main.c b/common/main.c
index 758ef8d32b..fc186829fc 100644
--- a/common/main.c
+++ b/common/main.c
@@ -34,12 +34,20 @@
 #include <hush.h>
 #endif
 
+#ifdef FW_RECOVERY/*  by huangwenzhong, 03May13 */
+#include "../board/atheros/common/ath_flash.h"
+#endif
+
 #include <post.h>
 
 #ifdef CONFIG_SILENT_CONSOLE
 DECLARE_GLOBAL_DATA_PTR;
 #endif
 
+#ifdef CONFIG_DUALIMAGE_SUPPORT
+extern unsigned findbdr(unsigned int flashaddr);
+#endif
+
 #if defined(CONFIG_BOOT_RETRY_TIME) && defined(CONFIG_RESET_TO_RETRY)
 extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);		/* for do_reset() prototype */
 #endif
@@ -288,6 +296,16 @@ static __inline__ int abortboot(int bootdelay)
 
 /****************************************************************************/
 
+#ifdef TPWD_FOR_LINUX_CAL
+int is_dev_calibrate()
+{
+	u16 *addr = (u16*)0x9f3f1000;
+	
+	return (*addr != 0xFFFF);
+
+}
+#endif
+
 void main_loop (void)
 {
 #ifndef CFG_HUSH_PARSER
@@ -382,7 +400,7 @@ void main_loop (void)
 	s = getenv ("bootdelay");
 	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
 
-	debug ("### main_loop entered: bootdelay=%d\n\n", bootdelay);
+//	debug ("### main_loop entered: bootdelay=%d\n\n", bootdelay);
 
 # ifdef CONFIG_BOOT_RETRY_TIME
 	init_cmd_timeout ();
@@ -397,8 +415,181 @@ void main_loop (void)
 	else
 #endif /* CONFIG_BOOTCOUNT_LIMIT */
 		s = getenv ("bootcmd");
+       if (!s) {
+#ifdef CONFIG_ROOTFS_FLASH
+           /* XXX if rootfs is in flash, expect uImage to be in flash */
+#ifdef CONFIG_AR7100
+           setenv ("bootcmd", "bootm 0xbf200000");
+#else
+           setenv ("bootcmd", "bootm 0xbf450000");
+#endif /* CONFIG_AR7100 */
+#else
+           setenv ("bootcmd", "tftpboot 0x8022c090 uImage; bootm 0x8022c090");
+#endif
+       }
+
+#ifdef CONFIG_DUALIMAGE_SUPPORT
+		findbdr(0);
+#endif
+
+/* Download vxWorks.bin ,then waiting for calculating */
+#ifdef TPWD_FOR_LINUX_CAL
+
+#define SERVER_IP1	"192.168.1.100"
+#define SERVER_IP2	"192.168.1.110"
+
+	if (!is_dev_calibrate())
+	{
+		/* wait for ethernet configure done */
+		udelay(2000*1000); 
+
+		/* detect tftp server IP address */
+		if (pingTest(SERVER_IP1) == 0)
+		{
+			setenv("serverip", SERVER_IP1);
+		}
+		else if (pingTest(SERVER_IP2) == 0)
+		{
+			setenv("serverip", SERVER_IP2);
+		}
+		else
+		{
+			printf("tftp server ip should be 192.168.1.100 or 192.168.1.110\n");
+		}
+		/* load vxWork.bin */
+		setenv("bootcmd", "tftpboot 80001000 vxWorks.bin; go 80001000");
+	}
+#endif
+
+#ifdef FW_RECOVERY/*  by huangwenzhong, 03May13 */
+
+#define ORG_FILE_BASE 			0x9F01F000
+#define ORG_PRODUCT_ID_POS 		(ORG_FILE_BASE + 0xD00)
+#define ORG_PRODUCT_VER_POS 	(ORG_FILE_BASE + 0xD04)
+		
+#define UP_FILE_BASE 			0x80800000
+#define UP_PRODUCT_ID_POS 		(UP_FILE_BASE + 0x40)
+#define UP_PRODUCT_VER_POS 		(UP_FILE_BASE + 0x44)
+		
+#define PRODUCT_ID_VER_LEN 		4
+#define FW_IMAGE_NAME			"_tp_recovery.bin"
+#define FW_IMAGE_UPLOAD_CMD		"tftp 0x80800000 "
+		
+			int is_auto_upload_firmware;
+			unsigned int original_product_id;	
+			unsigned int original_product_ver;	
+			unsigned int recovery_product_id;
+			unsigned int recovery_product_ver;
+			unsigned long file_size = 0;
+			extern ushort fw_recovery;
+			
+	
+			udelay(10 * 1000);
+			ath_auf_gpio_init();
+			
+			is_auto_upload_firmware = ath_is_rst_btn_pressed();
+			printf("is_auto_upload_firmware=%d\n", is_auto_upload_firmware);
+			
+			if (is_auto_upload_firmware)
+			{		
+				char image_name[32] = {0};
+				char upload_cmd[64] = {0};
+				
+				strcpy(upload_cmd, FW_IMAGE_UPLOAD_CMD);
+				strcpy(image_name, FW_RECOVERY_DEV);
+				strcat(image_name, FW_IMAGE_NAME);
+				strcat(upload_cmd, image_name);
+				
+				ath_fw_led_on();
+				
+				/* wait for ethernet config done. by HouXB, 28Apr11 */
+
+				udelay(2000*1000);
+
+				fw_recovery = 1;
+				
+				run_command("setenv serverip 192.168.0.66", 0);
+				run_command("setenv ipaddr 192.168.0.86", 0);
+				
+				run_command(upload_cmd, 0);
+		
+				memcpy(&original_product_id, ORG_PRODUCT_ID_POS, PRODUCT_ID_VER_LEN);
+				memcpy(&original_product_ver, ORG_PRODUCT_VER_POS, PRODUCT_ID_VER_LEN);
+				
+				memcpy(&recovery_product_id, UP_PRODUCT_ID_POS, PRODUCT_ID_VER_LEN);
+				memcpy(&recovery_product_ver, UP_PRODUCT_VER_POS, PRODUCT_ID_VER_LEN);
+	
+				if ((original_product_id == recovery_product_id)
+					 && (original_product_ver== recovery_product_ver))
+				{
+					s = getenv("filesize");
+
+					if (s)
+					{
+						file_size = simple_strtoul(s, NULL, 16);
+					}
+					printf("Firmware recovery: product id verify sucess!\n");
+					printf("Firmware recovery: filesize = 0x%x.\n", file_size);
+					if (FLASH_SIZE == 4)
+					{
+						if (file_size == 0x3c0000)
+						{
+							run_command("erase 0x9f020000 +3c0000; cp.b 0x80800000 0x9f020000 3c0000", 0);
+						}
+						else if (file_size == 0x3e0200)
+						{
+							run_command("erase 0x9f020000 +3c0000; cp.b 0x80820200 0x9f020000 3c0000", 0);
+						}
+					}
+					else if (FLASH_SIZE == 8)
+					{
+						if (file_size == 0x7c0000)
+						{
+							run_command("erase 0x9f020000 +7c0000; cp.b 0x80800000 0x9f020000 7c0000", 0);
+						}
+						else if (file_size == 0x7e0200)
+						{
+							run_command("erase 0x9f020000 +7c0000; cp.b 0x80820200 0x9f020000 7c0000", 0);
+						}
+					}
+					else if (FLASH_SIZE == 16)
+					{
+						if (file_size == 0xfc0000)
+						{
+							run_command("erase 0x9f020000 +fc0000; cp.b 0x80800000 0x9f020000 fc0000", 0);
+						}
+						else if (file_size == 0xfe0200)
+						{
+							run_command("erase 0x9f020000 +fc0000; cp.b 0x80820200 0x9f020000 fc0000", 0);
+						}
+					}
+					do_reset (NULL, 0, 0, NULL);
+				}
+				else
+				{
+					printf("auto update firmware: product id verify fail!\n");
+					ath_fw_led_off();
+				}
+			}
+			else
+			{
+				ath_fw_led_off();
+			}
+		
+#undef ORG_FILE_BASE
+#undef ORG_PRODUCT_ID_POS
+#undef ORG_PRODUCT_VER_POS
+#undef UP_FILE_BASE
+#undef UP_PRODUCT_ID_POS
+#undef UP_PRODUCT_VER_POS
+#undef PRODUCT_ID_VER_LEN
+#undef FW_IMAGE_NAME
+#undef FW_IMAGE_UPLOAD_CMD
+#endif
 
-	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");
+	s = getenv ("bootcmd");
+	
+	//	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");
 
 	if (bootdelay >= 0 && s && !abortboot (bootdelay)) {
 # ifdef CONFIG_AUTOBOOT_KEYED
diff --git a/config.mk b/config.mk
index dfbb1b7c6f..dfd830ed9f 100644
--- a/config.mk
+++ b/config.mk
@@ -89,6 +89,7 @@ endif
 HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
 HOSTSTRIP	= strip
 
+COMPRESS    = lzma
 #########################################################################
 #
 # Option checker (courtesy linux kernel) to ensure
@@ -111,6 +112,8 @@ OBJCOPY = $(CROSS_COMPILE)objcopy
 OBJDUMP = $(CROSS_COMPILE)objdump
 RANLIB	= $(CROSS_COMPILE)RANLIB
 
+.depend : CC = @$(CROSS_COMPILE)gcc
+
 RELFLAGS= $(PLATFORM_RELFLAGS)
 DBGFLAGS= -g #-DDEBUG
 OPTFLAGS= -Os #-fomit-frame-pointer
@@ -120,6 +123,8 @@ LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds
 endif
 OBJCFLAGS += --gap-fill=0xff
 
+LDSCRIPT_BOOTSTRAP := $(TOPDIR)/board/$(BOARDDIR)/u-boot-bootstrap.lds
+
 gccincdir := $(shell $(CC) -print-file-name=include)
 
 CPPFLAGS := $(DBGFLAGS) $(OPTFLAGS) $(RELFLAGS)		\
@@ -132,7 +137,31 @@ ifdef BUILD_TAG
 CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes \
 	-DBUILD_TAG='"$(BUILD_TAG)"'
 else
-CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes
+CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes 
+ifeq ($(COMPRESSED_UBOOT),1)
+CFLAGS += -DCOMPRESSED_UBOOT=1
+endif
+
+ifeq ($(BUILD_OPTIMIZED),y)
+CFLAGS += -Os -funit-at-a-time -mips32r2 -mtune=mips32r2
+endif
+endif
+
+ifeq ($(BUILD_TYPE),jffs2)
+CFLAGS += -DROOTFS=1
+else
+ifeq ($(BUILD_TYPE),squashfs)
+CFLAGS += -DROOTFS=2
+endif
+endif
+
+ifdef ATH_SST_FLASH
+CFLAGS += -DATH_SST_FLASH=1
+endif
+
+# which is used to load vxWorks.bin and run it for calibrate DUT
+ifeq ($(TPWD_FOR_LINUX_CAL),1)
+CFLAGS += -DTPWD_FOR_LINUX_CAL=1
 endif
 
 # avoid trigraph warnings while parsing pci.h (produced by NIOS gcc-2.9)
@@ -144,10 +173,19 @@ endif
 endif
 
 AFLAGS_DEBUG := -Wa,-gstabs
+
 AFLAGS := $(AFLAGS_DEBUG) -D__ASSEMBLY__ $(CPPFLAGS)
 
+ifeq ($(COMPRESSED_UBOOT),1)
+AFLAGS += -DCOMPRESSED_UBOOT=1
+endif
+
 LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE) $(PLATFORM_LDFLAGS)
 
+ifeq ($(COMPRESSED_UBOOT), 1)
+LDFLAGS_BOOTSTRAP += -Bstatic -T $(LDSCRIPT_BOOTSTRAP) -Ttext $(BOOTSTRAP_TEXT_BASE) $(PLATFORM_LDFLAGS)
+endif
+
 # Location of a usable BFD library, where we define "usable" as
 # "built for ${HOST}, supports ${TARGET}".  Sensible values are
 # - When cross-compiling: the root of the cross-environment
@@ -175,6 +213,8 @@ ifeq ($(PCI_CLOCK),PCI_66M)
 CFLAGS := $(CFLAGS) -DPCI_66M
 endif
 
+CFLAGS += $(UBOOT_GCC_4_3_3_EXTRA_CFLAGS) -g
+
 #########################################################################
 
 export	CONFIG_SHELL HPATH HOSTCC HOSTCFLAGS CROSS_COMPILE \
@@ -182,13 +222,32 @@ export	CONFIG_SHELL HPATH HOSTCC HOSTCFLAGS CROSS_COMPILE \
 	MAKE
 export	TEXT_BASE PLATFORM_CPPFLAGS PLATFORM_RELFLAGS CPPFLAGS CFLAGS AFLAGS
 
+ifeq ($(V),1)
+  Q =
+else
+  Q = @
+endif
+
+export quiet Q V
+
 #########################################################################
 
 %.s:	%.S
-	$(CPP) $(AFLAGS) -o $@ $(CURDIR)/$<
+ifneq ($(V),1)
+	@echo [CPP] $(abspath $(CURDIR)/$<)
+endif
+	$(Q)$(CPP) $(AFLAGS) -o $@ $(CURDIR)/$<
+
 %.o:	%.S
-	$(CC) $(AFLAGS) -c -o $@ $(CURDIR)/$<
+ifneq ($(V),1)
+	@echo [CC] $(abspath $(CURDIR)/$<)
+endif
+	$(Q)$(CC) $(AFLAGS) -c -o $@ $(CURDIR)/$<
+
 %.o:	%.c
-	$(CC) $(CFLAGS) -c -o $@ $<
+ifneq ($(V),1)
+	@echo [CC] $(abspath $(CURDIR)/$<)
+endif
+	$(Q)$(CC) $(CFLAGS) -c -o $@ $<
 
 #########################################################################
diff --git a/cpu/mips/Makefile b/cpu/mips/Makefile
index c8b30c7589..02114d7055 100644
--- a/cpu/mips/Makefile
+++ b/cpu/mips/Makefile
@@ -25,10 +25,14 @@ include $(TOPDIR)/config.mk
 
 LIB	= lib$(CPU).a
 
+ifeq ($(COMRESSED_UBOOT),1)
+START	= start.o start_bootstrap.o
+else
 START	= start.o
-OBJS	= asc_serial.o au1x00_serial.o au1x00_eth.o au1x00_usb_ohci.o \
-	  cpu.o interrupts.o incaip_clock.o
-SOBJS	= incaip_wdt.o cache.o
+endif
+
+OBJS	= cpu.o interrupts.o
+SOBJS	= cache.o
 
 all:	.depend $(START) $(LIB)
 
diff --git a/cpu/mips/Makefile.orig b/cpu/mips/Makefile.orig
new file mode 100644
index 0000000000..c8b30c7589
--- /dev/null
+++ b/cpu/mips/Makefile.orig
@@ -0,0 +1,45 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(CPU).a
+
+START	= start.o
+OBJS	= asc_serial.o au1x00_serial.o au1x00_eth.o au1x00_usb_ohci.o \
+	  cpu.o interrupts.o incaip_clock.o
+SOBJS	= incaip_wdt.o cache.o
+
+all:	.depend $(START) $(LIB)
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(START:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(START:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/cpu/mips/ar7100/Makefile b/cpu/mips/ar7100/Makefile
new file mode 100644
index 0000000000..d7bce6f9a9
--- /dev/null
+++ b/cpu/mips/ar7100/Makefile
@@ -0,0 +1,22 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(SOC).a
+
+START	=
+#OBJS	= ar7100_serial.o ag7100.o ar7100_flash.o meminit.o
+OBJS	= ar7100_serial.o ag7100.o meminit.o
+SOBJS	=
+
+all:	.depend $(START) $(LIB)
+
+$(LIB):	$(OBJS) $(SOBJS) $(OBJS-0)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(START:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(START:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/cpu/mips/ar7100/ag7100.c b/cpu/mips/ar7100/ag7100.c
new file mode 100644
index 0000000000..66e76492d6
--- /dev/null
+++ b/cpu/mips/ar7100/ag7100.c
@@ -0,0 +1,823 @@
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7100_soc.h"
+#include "ag7100.h"
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+#include <miiphy.h>
+#endif
+
+#include "ag7100_phy.h"
+
+#define ag7100_name2mac(name)	   (strcmp(name,"eth0") ? ag7100_unit2mac(1) : ag7100_unit2mac(0))
+
+int ag7100_miiphy_read(char *devname, unsigned char phaddr,
+	       unsigned char reg, unsigned short *value);
+int ag7100_miiphy_write(char *devname, unsigned char phaddr,
+	        unsigned char reg, unsigned short data);
+
+ag7100_mac_t *ag7100_macs[CFG_AG7100_NMACS];
+
+#ifdef AG7100_DEBUG
+int ag7100_txdbg = 0;
+int ag7100_rxdbg = 0;
+
+void pkt_dump(char *id, char *data,int pkt_size) {
+
+    int i;
+    printf("**********Packet dump (%s)******* %p size:%d\n", id, data, pkt_size);
+    for(i=0;i<=pkt_size;i++) {
+       if (!(i%4)) printf(" ");
+       printf("%2.2X", (unsigned)(data[i]&0xff));
+       if(!(i%32)) printf("\n");
+    }
+    printf("\n");
+    printf("***********end***************\n");
+}
+#endif
+pkt_push(uint8_t *pkt,int length)
+{
+   uint8_t *buf;
+   buf = (uint8_t *)malloc(length);
+   memcpy(buf, pkt, length);
+   memcpy(pkt + 2, buf, length);
+   free(buf);
+}
+
+
+ag7100_mac_t *ag7100_unit2mac(int unit)
+{
+    return (unit ? ag7100_macs[1] : ag7100_macs[0]);
+}
+
+static int
+ag7100_send(struct eth_device *dev, volatile void *packet, int length)
+{
+    int i;
+    ag7100_mac_t *mac = (ag7100_mac_t *)dev->priv;
+
+    ag7100_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+    uint8_t *pkt_buf;
+
+    pkt_buf = (uint8_t *) packet;
+    /* 
+     * Add normal packet headers if its not a control packet 
+     */
+    if (((pkt_buf[0] & 0xff) != 0x7f) && ((pkt_buf[1] & 0xff) != 0x5d)) {
+        pkt_push(pkt_buf,length);
+        length = length + ATHRHDR_LEN;
+        pkt_buf[0] = 0x10;  /* broadcast = 0; from_cpu = 0; reserved = 1; port_num = 0 */
+        pkt_buf[1] = 0x80;  /* reserved = 0b10; priority = 0; type = 0 (normal) */
+    }
+    else {
+        length  = (length - ATHRHDR_LEN);
+        pkt_buf = (uint8_t *) ((uint8_t *)pkt_buf + 2);
+    }
+    f->pkt_size = length;
+    f->pkt_start_addr = virt_to_phys(pkt_buf);
+#else
+    f->pkt_size = length;
+    f->pkt_start_addr = virt_to_phys(packet);
+#endif
+#ifdef AG7100_DEBUG
+    if (ag7100_txdbg) pkt_dump("Tx", packet, length);
+#endif
+    ag7100_tx_give_to_dma(f);
+    flush_cache((u32) packet, length);
+    ag7100_reg_wr(mac, AG7100_DMA_TX_DESC, virt_to_phys(f));
+    ag7100_reg_wr(mac, AG7100_DMA_TX_CTRL, AG7100_TXE);
+
+    for (i = 0; i < MAX_WAIT; i++) {
+        udelay(10);
+        if (!ag7100_tx_owned_by_dma(f))
+            break;
+    }
+    if (i == MAX_WAIT)
+        printf("Tx Timed out\n");
+
+    f->pkt_start_addr = 0;
+    f->pkt_size = 0;
+
+    if (++mac->next_tx >= NO_OF_TX_FIFOS)
+        mac->next_tx = 0;
+
+    return (0);
+}
+
+static int ag7100_recv(struct eth_device *dev)
+{
+    int length;
+    ag7100_desc_t *f;
+    ag7100_mac_t *mac;
+ 
+    mac = (ag7100_mac_t *)dev->priv;
+
+    for (;;) {
+        f = mac->fifo_rx[mac->next_rx];
+        if (ag7100_rx_owned_by_dma(f))
+            break;
+
+        length = f->pkt_size;
+
+#ifdef AG7100_DEBUG
+        if (ag7100_rxdbg) pkt_dump("Rx", NetRxPackets[mac->next_rx], length);
+#endif
+        NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+        flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+        ag7100_rx_give_to_dma(f);
+
+        if (++mac->next_rx >= NO_OF_RX_FIFOS)
+            mac->next_rx = 0;
+    }
+
+    if (!(ag7100_reg_rd(mac, AG7100_DMA_RX_CTRL))) {
+        ag7100_reg_wr(mac, AG7100_DMA_RX_DESC, virt_to_phys(f));
+        ag7100_reg_wr(mac, AG7100_DMA_RX_CTRL, 1);
+    }
+
+    return (0);
+}
+
+#if defined(CFG_ATHRS16_PHY) || defined(CFG_ATHRF1_PHY)
+/*
+ * program the usb pll (misnomer) to genrate appropriate clock
+ * Write 2 into control field
+ * Write pll value 
+ * Write 3 into control field
+ * Write 0 into control field
+ */ 
+#define ag7100_pll_shift(_mac)      (((_mac)->mac_unit) ? 19: 17)
+#define ag7100_pll_offset(_mac)     \
+    (((_mac)->mac_unit) ? AR7100_USB_PLL_GE1_OFFSET : \
+                          AR7100_USB_PLL_GE0_OFFSET)
+static void
+ag7100_set_pll(ag7100_mac_t *mac, unsigned int pll)
+{
+#define ETH_PLL_CONFIG AR7100_USB_PLL_CONFIG
+    uint32_t shift, reg, val;
+
+    shift = ag7100_pll_shift(mac);
+    reg   = ag7100_pll_offset(mac);
+
+    val  = ar7100_reg_rd(ETH_PLL_CONFIG);
+    val &= ~(3 << shift);
+    val |=  (2 << shift);
+    ar7100_reg_wr(ETH_PLL_CONFIG, val);
+    udelay(100);
+
+    ar7100_reg_wr(reg, pll);
+
+    val |=  (3 << shift);
+    ar7100_reg_wr(ETH_PLL_CONFIG, val);
+    udelay(100);
+
+    val &= ~(3 << shift);
+    ar7100_reg_wr(ETH_PLL_CONFIG, val);
+    udelay(100);
+
+    printf("pll reg %#x: %#x  ", reg, ar7100_reg_rd(reg));
+}
+#endif
+
+static void ag7100_hw_start(ag7100_mac_t *mac)
+{
+    u32 mii_ctrl_val;
+#if defined (CFG_AG7100_GE0_GMII)
+    u32 isXGMII0 = 1;
+#else
+    u32 isXGMII0 = 0;
+#endif
+#if defined (CFG_AG7100_GE1_GMII)
+    u32 isXGMII1 = 1;
+#else
+    u32 isXGMII1 = 0;
+#endif
+
+#if defined(CFG_MII0_RGMII)
+    mii_ctrl_val = 0x12; /* this value seems to be incorrect - JK */
+#elif defined(CFG_MII0_MII)
+    mii_ctrl_val = 0x11;
+#elif defined(CFG_MII0_RMII)
+    mii_ctrl_val = 0x13;
+#endif
+
+    ag7100_reg_wr(mac, AG7100_MAC_CFG1, (AG7100_MAC_CFG1_RX_EN |
+		    AG7100_MAC_CFG1_TX_EN));
+
+    ag7100_reg_rmw_set(mac, AG7100_MAC_CFG2, (AG7100_MAC_CFG2_PAD_CRC_EN |
+		         AG7100_MAC_CFG2_LEN_CHECK));
+
+    if (mac->mac_unit == 0) ag7100_set_mac_if(mac, isXGMII0);
+    if (mac->mac_unit == 1) ag7100_set_mac_if(mac, isXGMII1);
+
+    ag7100_reg_wr(mac, AG7100_MAC_FIFO_CFG_0, 0x1f00);
+
+#if !defined(CFG_BOARD_PB44) && !defined(CFG_BOARD_PB45) && !defined(CFG_BOARD_AP96) && !defined(CFG_BOARD_PB47)
+    if(mac->mac_unit == 0) {
+        ar7100_reg_wr(AR7100_MII0_CTRL, mii_ctrl_val);
+    } else {
+        ar7100_reg_wr(AR7100_MII1_CTRL, mii_ctrl_val);
+    }
+#else
+    /* this is a better way of setting the MII registers than immediately above */
+    //printf("%s: mii_if %#x\n", __func__, mii_if(mac));
+    ar7100_reg_wr(mii_reg(mac), mii_if(mac));
+#endif
+
+    //ag7100_reg_wr(mac, AG7100_MAC_IFCTL, 0x10000);
+    //ag7100_reg_wr(mac, AG7100_MAC_CFG1, 0x005);
+    ag7100_reg_wr(mac, AG7100_MAC_MII_MGMT_CFG, AG7100_MGMT_CFG_CLK_DIV_20);
+
+    ag7100_reg_rmw_set(mac, AG7100_MAC_FIFO_CFG_4, 0x3ffff);
+    ag7100_reg_rmw_set(mac, AG7100_MAC_FIFO_CFG_5, 0x7ffef);
+    ag7100_reg_rmw_clear(mac, AG7100_MAC_FIFO_CFG_5, (1 << 19));
+#ifdef AR9100
+    ag7100_reg_wr(mac, AG7100_MAC_FIFO_CFG_3, 0x780008);
+#else
+    ag7100_reg_wr(mac, AG7100_MAC_FIFO_CFG_3, 0x400fff);
+#endif
+    ag7100_reg_wr(mac, AG7100_MAC_FIFO_CFG_1, 0xfff0000);
+    ag7100_reg_wr(mac, AG7100_MAC_FIFO_CFG_2, 0x1fff);
+//printf(": cfg1 %#x cfg2 %#x\n", ag7100_reg_rd(mac, AG7100_MAC_CFG1),
+//        ag7100_reg_rd(mac, AG7100_MAC_CFG2));
+
+}
+
+#ifdef CFG_ATHRS16_PHY 
+static int is_setup_done = 0;
+#endif
+static void ag7100_set_mac_from_link(ag7100_mac_t *mac, int speed, int fdx)
+{
+    int is1000 = (speed == _1000BASET);
+    int is100 = (speed == _100BASET);
+
+#ifdef CFG_ATHRS16_PHY 
+    if(!is_setup_done && (mac->speed != speed || mac->duplex != fdx))
+    {
+       phy_mode_setup();
+       is_setup_done = 1;
+    }
+#endif
+
+    mac->speed = speed;
+    mac->duplex = fdx;
+
+    if (is1000) {
+        ag7100_set_mii_ctrl_speed(mac, 2);
+    }
+    else if (is100) {
+        ag7100_set_mii_ctrl_speed(mac, 1);
+    }
+    else {
+        ag7100_set_mii_ctrl_speed(mac, 0);
+    }
+    ag7100_set_mac_if(mac, is1000);
+    ag7100_set_mac_duplex(mac, fdx);
+
+    if (!is1000)
+        ag7100_set_mac_speed(mac, is100);
+    /*
+     * XXX program PLL
+     */
+#if defined(CFG_ATHRS16_PHY) || defined(CFG_ATHRF1_PHY)
+    if (is1000)
+        ag7100_set_pll(mac, 0x110000);
+    else if (is100)
+        ag7100_set_pll(mac, 0x0001099);
+    else
+        ag7100_set_pll(mac, 0x00991099);
+#endif
+
+    mac->link = 1;
+}
+
+static int ag7100_check_link(ag7100_mac_t *mac)
+{
+    u32 link, duplex, speed;
+
+#ifdef AR9100
+    u32 fdx, i;
+
+#if !defined(CFG_ATHRS26_PHY) && !defined(CFG_ATHRHDR_EN)
+    ag7100_phy_link(mac->mac_unit, link, duplex, speed);
+    ag7100_phy_duplex(mac->mac_unit,duplex);
+    ag7100_phy_speed(mac->mac_unit,speed);
+
+    mac->link = link;
+    if(!mac->link) {
+        printf("%s link down\n",mac->dev->name);
+        return 0;
+    }
+#else
+     duplex = FULL;
+     speed = _100BASET;
+#endif
+      if (speed == _1000BASET) {
+	    uint32_t shift, reg, val;
+
+        if(!mac->mac_unit){
+            ar7100_reg_wr(AR7100_MII0_CTRL, 0x22);
+	} else {
+	    ar7100_reg_wr(AR7100_MII1_CTRL, 0x22);
+	}
+
+        ag7100_reg_rmw_clear(mac, AG7100_MAC_CFG2, 0xffff);
+        ag7100_reg_rmw_set(mac, AG7100_MAC_CFG2, 0x7215);
+        ag7100_reg_wr(mac, AG7100_MAC_FIFO_CFG_3, 0x780fff);
+
+#define ag7100_pll_shift(_mac)	(((_mac)->mac_unit) ? 22: 20)
+#define ag7100_pll_offset(_mac)	(((_mac)->mac_unit) ? 0xb8050018 : 0xb8050014)
+#define ETH_PLL_CONFIG		0xb8050004
+
+	shift = ag7100_pll_shift(mac);
+	reg = ag7100_pll_offset(mac);
+
+	val  = ar7100_reg_rd(ETH_PLL_CONFIG);
+	val &= ~(3 << shift);
+	val |=  (2 << shift);
+	ar7100_reg_wr(ETH_PLL_CONFIG, val);
+	udelay(100);
+
+	if (mac->mac_unit) {
+#if defined(CFG_DUAL_F1E_PHY)
+        	*(volatile int *) 0xb8050018 = 0x1a000000;
+#else
+        	*(volatile int *) 0xb8050018 = 0x1f000000;
+#endif  
+	} else {
+        	*(volatile int *) 0xb8050014 = 0x1a000000;
+	}
+
+	val |=  (3 << shift);
+	ar7100_reg_wr(ETH_PLL_CONFIG, val);
+	udelay(100);
+
+	val &= ~(3 << shift);
+	ar7100_reg_wr(ETH_PLL_CONFIG, val);
+	udelay(100);
+
+
+        ag7100_reg_rmw_set(mac, AG7100_MAC_FIFO_CFG_5, (1 << 19));
+
+        if(mac->mac_unit == 0) {
+            miiphy_write(mac->dev->name, CFG_PHY_ADDR, 0x1f, 0x1);
+            miiphy_write(mac->dev->name, CFG_PHY_ADDR, 0x1c, 0x3000);
+            miiphy_write(mac->dev->name, CFG_PHY_ADDR, 0x1f, 0x0);
+       }
+    } else if (speed == _100BASET) {
+#define ag7100_pll_shift(_mac)	(((_mac)->mac_unit) ? 22: 20)
+#define ag7100_pll_offset(_mac)	(((_mac)->mac_unit) ? 0xb8050018 : 0xb8050014)
+#define ETH_PLL_CONFIG		0xb8050004
+	uint32_t shift, reg, val;
+
+	shift = ag7100_pll_shift(mac);
+	reg = ag7100_pll_offset(mac);
+
+	val  = ar7100_reg_rd(ETH_PLL_CONFIG);
+	val &= ~(3 << shift);
+	val |=  (2 << shift);
+	ar7100_reg_wr(ETH_PLL_CONFIG, val);
+	udelay(100);
+
+	if (mac->mac_unit) {
+#if defined(CFG_DUAL_F1E_PHY)
+        	*(volatile int *) 0xb8050018 = 0x13000a44;
+#else
+        	*(volatile int *) 0xb8050018 = 0x1f000000;
+#endif   
+	} else {
+        	*(volatile int *) 0xb8050014 = 0x13000a44;
+	}
+
+	val |=  (3 << shift);
+	ar7100_reg_wr(ETH_PLL_CONFIG, val);
+	udelay(100);
+
+	val &= ~(3 << shift);
+	ar7100_reg_wr(ETH_PLL_CONFIG, val);
+	udelay(100);
+
+	//printf(": pll reg %#x: %#x  ", reg, ar7100_reg_rd(reg));
+
+        ag7100_reg_rmw_clear(mac, AG7100_MAC_CFG2, 0xffff);
+        ag7100_reg_rmw_set(mac, AG7100_MAC_CFG2, 0x7115);
+    }
+    if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+                    return 1;
+    mac->duplex = duplex;
+    mac->speed = speed;
+    mac->link = 1;
+
+    fdx = (duplex == FULL) ? 1 : 0;
+    printf("dup %d speed %d\n", fdx, speed);
+
+    ag7100_set_mac_duplex(mac,fdx);
+
+    if (speed == _100BASET)
+        ag7100_set_mac_speed(mac, 1);
+    else if (speed == _10BASET)
+        ag7100_set_mac_speed(mac, 0);
+
+    return 1;
+#else
+    ag7100_get_link_status(mac->mac_unit, &link, &duplex, &speed);
+
+    mac->link = link;
+    
+    if(!mac->link) {
+        printf("%s link down\n",mac->dev->name);
+        return 0;
+    }
+
+    if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+        return 1;
+
+    ag7100_set_mac_from_link(mac, speed, duplex);
+    return 1;
+#endif
+
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ag7100_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+    int i;
+    ag7100_desc_t *fr;
+    ag7100_mac_t *mac = (ag7100_mac_t*)dev->priv;
+
+    if (!ag7100_check_link(mac))
+        return 0;
+
+    mac->next_rx = 0;
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        fr = mac->fifo_rx[i];
+        fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+        flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+        ag7100_rx_give_to_dma(fr);
+    }
+
+    ag7100_reg_wr(mac, AG7100_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+    ag7100_reg_wr(mac, AG7100_DMA_RX_CTRL, AG7100_RXE);	/* rx start */
+    udelay(2000);
+
+
+    return 1;
+
+}
+
+static int ag7100_alloc_fifo(int ndesc, ag7100_desc_t ** fifo)
+{
+    int i;
+    u32 size;
+    uchar *p = NULL;
+
+    size = sizeof(ag7100_desc_t) * ndesc;
+    size += CFG_CACHELINE_SIZE - 1;
+
+    if ((p = malloc(size)) == NULL) {
+        printf("Cant allocate fifos\n");
+        return -1;
+    }
+
+    p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+	   ~(CFG_CACHELINE_SIZE - 1));
+    p = UNCACHED_SDRAM(p);
+
+    for (i = 0; i < ndesc; i++)
+        fifo[i] = (ag7100_desc_t *) p + i;
+
+    return 0;
+}
+
+static int ag7100_setup_fifos(ag7100_mac_t *mac)
+{
+    int i;
+
+    if (ag7100_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+        return 1;
+
+    for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+        mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+        ag7100_tx_own(mac->fifo_tx[i]);
+    }
+
+    if (ag7100_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+        return 1;
+
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+    }
+
+    return (1);
+}
+
+static void ag7100_halt(struct eth_device *dev)
+{
+    ag7100_mac_t *mac = (ag7100_mac_t *)dev->priv;
+    ag7100_reg_wr(mac, AG7100_DMA_RX_CTRL, 0);
+    while (ag7100_reg_rd(mac, AG7100_DMA_RX_CTRL));
+}
+
+unsigned char *
+ag7100_mac_addr_loc(void)
+{
+	extern flash_info_t flash_info[];
+
+#ifdef BOARDCAL
+    /*
+    ** BOARDCAL environmental variable has the address of the cal sector
+    */
+    
+    return ((unsigned char *)BOARDCAL);
+    
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+		(KSEG1ADDR(AR7100_SPI_BASE) + (4 * 1024) +
+		flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+
+}
+
+static void ag7100_get_ethaddr(struct eth_device *dev)
+{
+    unsigned char *eeprom;
+    unsigned char *mac = dev->enetaddr;
+
+    eeprom = ag7100_mac_addr_loc();
+
+    if (strcmp(dev->name, "eth0") == 0) {
+        memcpy(mac, eeprom, 6);
+    } else if (strcmp(dev->name, "eth1") == 0) {
+        eeprom += 6;
+        memcpy(mac, eeprom, 6);
+    } else {
+        printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+        return;
+    }
+
+    /* Use fixed address if the above address is invalid */
+    if (mac[0] == 0xff && mac[5] == 0xff) {
+        mac[0] = 0x00;
+        mac[1] = 0x03;
+        mac[2] = 0x7f;
+        mac[3] = 0x09;
+        mac[4] = 0x0b;
+        mac[5] = 0xad;
+        printf("No valid address in Flash. Using fixed address\n");
+    }
+}
+
+#ifdef CONFIG_AR9100_MDIO_DEBUG
+int
+ag7100_dump_vsc_regs(ag7100_mac_t *mac)
+{
+
+	unsigned i;
+	unsigned short v;
+	char *fmt[] = {"\t", "\n"};
+
+	printf("IEEE & Standard registers\n");
+	for (i = 0; i < 0x20; i++) {
+		v = 0;
+		ag7100_miiphy_read(mac->dev->name, 0, i, &v);
+		printf("0x%02x: 0x%04x%s", i, v, fmt[i & 1]);
+	}
+
+	printf("Extended registers\n");
+
+	/* Enable extended register set access */
+	ag7100_miiphy_write(mac->dev->name, 0, 0x1f,  0x1);
+	for (i = 16; i <= 30; i++) {
+		v = 0;
+		ag7100_miiphy_read(mac->dev->name, 0, i, &v);
+		printf("0x%02x: 0x%04x%s", i, v, fmt[i & 1]);
+	}
+	ag7100_miiphy_write(mac->dev->name, 0, 0x1f,  0x0);
+	printf("\n");
+}
+#endif
+
+int ag7100_enet_initialize(bd_t * bis)
+{
+    struct eth_device *dev[CFG_AG7100_NMACS];
+    u32 mask, mac_h, mac_l;
+    int i;
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_SWITCH_FREQ)
+    u32 pll_value;
+#endif
+
+    printf("ag7100_enet_initialize...\n");
+
+#ifdef AR9100
+   /* Workaround to bring the TX_EN to low */
+
+     i = *(volatile int *) 0xb806001c ;
+    *(volatile int *) 0xb806001c = (i | 0x3300);
+    udelay(10 * 1000);
+     i = *(volatile int *) 0xb806001c ;
+    *(volatile int *) 0xb806001c = (i & 0xffffccff);
+    udelay(10 * 1000);
+    *(volatile int *) 0xb8070000 = 0x13;
+    *(volatile int *) 0xb8070004 = 0x11;
+    udelay(10 * 1000);
+    *(volatile int *) 0xb9000000 = 0x0;
+    *(volatile int *) 0xba000000 = 0x0;
+     i = *(volatile int *) 0xb806001c ;
+    *(volatile int *) 0xb806001c = (i | 0x3300);
+    udelay(10 * 1000);
+#endif
+
+    for (i = 0;i < CFG_AG7100_NMACS;i++) {
+
+    if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+	
+    if ((ag7100_macs[i] = (ag7100_mac_t *) malloc(sizeof (ag7100_mac_t))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+
+    memset(ag7100_macs[i], 0, sizeof(ag7100_macs[i]));
+    memset(dev[i], 0, sizeof(dev[i]));
+
+    sprintf(dev[i]->name, "eth%d", i);
+    ag7100_get_ethaddr(dev[i]);
+    
+    ag7100_macs[i]->mac_unit = i;
+    ag7100_macs[i]->mac_base = i ? AR7100_GE1_BASE : AR7100_GE0_BASE ;
+    ag7100_macs[i]->dev = dev[i];
+
+    dev[i]->iobase = 0;
+    dev[i]->init = ag7100_clean_rx;
+    dev[i]->halt = ag7100_halt;
+    dev[i]->send = ag7100_send;
+    dev[i]->recv = ag7100_recv;
+    dev[i]->priv = (void *)ag7100_macs[i];	
+
+    eth_register(dev[i]);
+
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+    athrs26_reg_dev(dev[i]);
+#endif
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+    miiphy_register(dev[i]->name, ag7100_miiphy_read, ag7100_miiphy_write);
+#endif
+        /*
+        ** This is the actual reset sequence
+        */
+        
+        mask = i ?(AR7100_RESET_GE1_MAC | AR7100_RESET_GE1_PHY) :
+                  (AR7100_RESET_GE0_MAC | AR7100_RESET_GE0_PHY);
+
+        ar7100_reg_rmw_set(AR7100_RESET, mask);
+        udelay(10000);
+
+        ar7100_reg_rmw_clear(AR7100_RESET, mask);
+        udelay(10000);
+
+    ag7100_hw_start(ag7100_macs[i]);
+    ag7100_setup_fifos(ag7100_macs[i]);
+
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_SWITCH_FREQ)
+    pll_value = ar7100_reg_rd(AR7100_CPU_PLL_CONFIG);
+    mask = pll_value & ~(PLL_CONFIG_PLL_FB_MASK | PLL_CONFIG_REF_DIV_MASK);
+    mask = mask | (0x64 << PLL_CONFIG_PLL_FB_SHIFT) |
+        (0x5 << PLL_CONFIG_REF_DIV_SHIFT) | (1 << PLL_CONFIG_AHB_DIV_SHIFT);
+
+    ar7100_reg_wr_nf(AR7100_CPU_PLL_CONFIG, mask);
+    udelay(10 * 1000);
+#endif
+
+    ag7100_phy_setup(ag7100_macs[i]->mac_unit);
+    udelay(10 * 1000);
+
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_SWITCH_FREQ)
+    ar7100_reg_wr_nf(AR7100_CPU_PLL_CONFIG, pll_value);
+    udelay(10 * 1000);
+#endif
+    {
+        unsigned char *mac = dev[i]->enetaddr;
+
+        printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+               mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+               mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+    }
+    mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+    mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+        (dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+    ag7100_reg_wr(ag7100_macs[i], AG7100_GE_MAC_ADDR1, mac_l);
+    ag7100_reg_wr(ag7100_macs[i], AG7100_GE_MAC_ADDR2, mac_h);
+
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+    /* if using header for register configuration, we have to     */
+    /* configure s26 register after frame transmission is enabled */
+    	athrs26_reg_init();
+#elif defined(CFG_ATHRS16_PHY)
+    if (ag7100_macs[i]->mac_unit == 1)
+        athrs16_reg_init();
+#endif
+
+    printf("%s up\n",dev[i]->name);
+    }
+
+#ifdef CONFIG_AR9100_MDIO_DEBUG
+    ag7100_dump_vsc_regs(ag7100_macs[i]);
+#endif
+
+    return 1;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+int ag7100_miiphy_read(char *devname, unsigned char phaddr,
+	       unsigned char reg, unsigned short *value)
+{
+    uint16_t addr = (phaddr << AG7100_ADDR_SHIFT) | reg;
+    volatile int rddata;
+    ag7100_mac_t *mac = ag7100_name2mac(devname);
+
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CMD, 0x0);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_ADDRESS, addr);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CMD, AG7100_MGMT_CMD_READ);
+
+    rddata = ag7100_reg_rd(mac, AG7100_MII_MGMT_IND) & 0x1;
+    while (rddata) {
+        rddata = ag7100_reg_rd(mac, AG7100_MII_MGMT_IND) & 0x1;
+    }
+
+    *value = ag7100_reg_rd(mac, AG7100_MII_MGMT_STATUS);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CMD, 0x0);
+
+    return 0;
+}
+
+int ag7100_miiphy_write(char *devname, unsigned char phaddr,
+	        unsigned char reg, unsigned short data)
+{
+    uint16_t addr = (phaddr << AG7100_ADDR_SHIFT) | reg;
+    volatile int rddata;
+    ag7100_mac_t *mac = ag7100_name2mac(devname);
+
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_ADDRESS, addr);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CTRL, data);
+
+    rddata = ag7100_reg_rd(mac, AG7100_MII_MGMT_IND) & 0x1;
+    while (rddata) {
+        rddata = ag7100_reg_rd(mac, AG7100_MII_MGMT_IND) & 0x1;
+    }
+    return 0;
+}
+
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+/***********************************************************************
+ * command line interface:To do individual phy reset
+ */
+
+int do_miiphyreset(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int phyUnit;
+	char *p;
+
+	if (argc == 1) {
+		printf("Usage:\n    miiphyreset phyUnit\n");
+		return -1;
+	}
+
+	*p = *argv[1];
+	phyUnit = *p - '0';
+
+	if (phyUnit > 4) {
+		printf("phyUnit to big!\n");
+		return -1;
+	}
+	individual_phyreset(phyUnit);
+	printf("Completed!\n");
+	return 0;
+}
+
+U_BOOT_CMD(
+    miiphyreset ,CFG_MAXARGS, 1, do_miiphyreset,
+    "miiphyreset - Reset phy\n",
+    " port no\n"
+    );
+#endif
+
+#endif		/* CONFIG_COMMANDS & CFG_CMD_MII */
+
diff --git a/cpu/mips/ar7100/ag7100.h b/cpu/mips/ar7100/ag7100.h
new file mode 100644
index 0000000000..3c0013aeb8
--- /dev/null
+++ b/cpu/mips/ar7100/ag7100.h
@@ -0,0 +1,239 @@
+#ifndef _AG7100_H
+#define _AG7100_H
+
+#include <linux/types.h>
+
+/*
+ * h/w descriptor
+ */
+typedef struct {
+    uint32_t    pkt_start_addr;
+
+    uint32_t    is_empty       :  1;
+    uint32_t    res1           : 10;
+    uint32_t    ftpp_override  :  5;
+    uint32_t    res2           :  4;
+    uint32_t    pkt_size       : 12;
+
+    uint32_t    next_desc      ;
+}ag7100_desc_t;
+
+#define NO_OF_TX_FIFOS  8
+#define NO_OF_RX_FIFOS  8
+
+typedef struct {
+    ag7100_desc_t *fifo_tx[NO_OF_TX_FIFOS];
+    ag7100_desc_t *fifo_rx[NO_OF_RX_FIFOS];
+    struct eth_device *dev;
+    u32            next_tx;
+    u32            next_rx;
+    u32            link;
+    u32            duplex;
+    u32            speed;
+    u32		   mac_unit;
+    u32 	   mac_base;
+    
+}ag7100_mac_t;
+
+#define ag7100_reg_wr(_mac, _x, _y)   ar7100_reg_wr(((_x) + _mac->mac_base), (_y))
+#define ag7100_reg_rd(_mac, _x)       ar7100_reg_rd(((_x) + _mac->mac_base))
+
+#define ag7100_reg_rmw_set(_mac, _x, _y)   \
+    ar7100_reg_rmw_set(((_x) + _mac->mac_base ), (_y))
+#define ag7100_reg_rmw_clear(_mac, _x, _y)    \
+    ar7100_reg_rmw_clear(((_x) + _mac->mac_base), (_y))
+
+/*
+ * spd is _1000BASET, _100BASET etc. defined in include/miiphy.h
+ */
+
+#if defined (CFG_AG7100_GE0_GMII)
+    #define     AG7100_MII0_INTERFACE   0x20
+#elif defined (CFG_AG7100_GE0_MII)
+    #define     AG7100_MII0_INTERFACE   0x11
+#elif defined (CFG_AG7100_GE0_RGMII)
+    #define     AG7100_MII0_INTERFACE   0x22
+#elif defined (CFG_AG7100_GE0_RMII)
+    #define     AG7100_MII0_INTERFACE   0x13
+#else
+    #error "GE0 MII type not defined"
+#endif /*defined (AG7100_GE0_GMII)*/
+
+/*
+ * Port 1 may or may not be connected
+ */
+#if defined (CFG_AG7100_GE1_RGMII)
+    #define AG7100_MII1_INTERFACE   0x20
+#elif defined (CFG_AG7100_GE1_RMII)
+    #define AG7100_MII1_INTERFACE   0x21
+#else
+    #define AG7100_MII1_INTERFACE   0xff
+#endif /*AG7100_GE1_RGMII*/
+
+#define mii_reg(_mac)   (AR7100_MII0_CTRL + ((_mac)->mac_unit * 4))
+#define mii_if(_mac)    (((_mac)->mac_unit == 0) ? AG7100_MII0_INTERFACE : AG7100_MII1_INTERFACE)
+
+#define ag7100_set_mii_ctrl_speed(_mac, _spd)   do {                        \
+    ar7100_reg_rmw_clear(mii_reg(_mac), (3 << 4));                          \
+    ar7100_reg_rmw_set(mii_reg(_mac), ((_spd) << 4));                       \
+}while(0);
+
+#if defined (CFG_MII0_GMII)
+#define ag7100_get_mii_if()             0
+#elif defined (CFG_MII0_MII)
+#define ag7100_get_mii_if()             0
+#elif defined (CFG_MII0_RGMII)
+#define ag7100_get_mii_if()             0
+#elif defined (CFG_MII0_RMII)
+#define ag7100_get_mii_if()             0
+#endif
+        
+#define MAX_WAIT        1000
+
+/*
+ * Config/Mac Register definitions
+ */
+#define AG7100_MAC_CFG1             0x00
+#define AG7100_MAC_CFG2             0x04
+#define AG7100_MAC_IFCTL            0x38
+
+/*
+ * fifo control registers
+ */
+#define AG7100_MAC_FIFO_CFG_0      0x48
+#define AG7100_MAC_FIFO_CFG_1      0x4c
+#define AG7100_MAC_FIFO_CFG_2      0x50
+#define AG7100_MAC_FIFO_CFG_3      0x54
+#define AG7100_MAC_FIFO_CFG_4      0x58
+
+#define AG7100_MAC_FIFO_CFG_5      0x5c
+#define AG7100_BYTE_PER_CLK_EN     (1 << 19)
+
+#define AG7100_MAC_FIFO_RAM_0      0x60
+#define AG7100_MAC_FIFO_RAM_1      0x64
+#define AG7100_MAC_FIFO_RAM_2      0x68
+#define AG7100_MAC_FIFO_RAM_3      0x6c
+#define AG7100_MAC_FIFO_RAM_4      0x70
+#define AG7100_MAC_FIFO_RAM_5      0x74
+#define AG7100_MAC_FIFO_RAM_6      0x78
+#define AG7100_MAC_FIFO_RAM_7      0x7c
+
+/*
+ * fields
+ */
+#define AG7100_MAC_CFG1_SOFT_RST       (1 << 31)
+#define AG7100_MAC_CFG1_LOOPBACK       (1 << 8)
+#define AG7100_MAC_CFG1_RX_EN          (1 << 2)
+#define AG7100_MAC_CFG1_TX_EN          (1 << 0)
+
+#define AG7100_MAC_CFG2_FDX            (1 << 0)
+#define AG7100_MAC_CFG2_PAD_CRC_EN     (1 << 2)
+#define AG7100_MAC_CFG2_LEN_CHECK      (1 << 4)
+#define AG7100_MAC_CFG2_HUGE_FRAME_EN  (1 << 5)
+#define AG7100_MAC_CFG2_IF_1000        (1 << 9)
+#define AG7100_MAC_CFG2_IF_10_100      (1 << 8)
+
+#define AG7100_MAC_IFCTL_SPEED         (1 << 16)
+
+/*
+ * DMA (tx/rx) register defines
+ */
+#define AG7100_DMA_TX_CTRL              0x180
+#define AG7100_DMA_TX_DESC              0x184
+#define AG7100_DMA_TX_STATUS            0x188
+#define AG7100_DMA_RX_CTRL              0x18c
+#define AG7100_DMA_RX_DESC              0x190
+#define AG7100_DMA_RX_STATUS            0x194
+#define AG7100_DMA_INTR_MASK            0x198
+#define AG7100_DMA_INTR                 0x19c
+
+/*
+ * tx/rx ctrl and status bits
+ */
+#define AG7100_TXE                      (1 << 0)
+#define AG7100_TX_STATUS_PKTCNT_SHIFT   16
+#define AG7100_TX_STATUS_PKT_SENT       0x1
+#define AG7100_TX_STATUS_URN            0x2
+#define AG7100_TX_STATUS_BUS_ERROR      0x8
+
+#define AG7100_RXE                      (1 << 0)
+
+#define AG7100_RX_STATUS_PKTCNT_MASK    0xff0000
+#define AG7100_RX_STATUS_PKT_RCVD       (1 << 0)
+#define AG7100_RX_STATUS_OVF            (1 << 2)
+#define AG7100_RX_STATUS_BUS_ERROR      (1 << 3)
+
+/*
+ * Int and int mask
+ */
+#define AG7100_INTR_TX                  (1 << 0)
+#define AG7100_INTR_TX_URN              (1 << 1)
+#define AG7100_INTR_TX_BUS_ERROR        (1 << 3)
+#define AG7100_INTR_RX                  (1 << 4)
+#define AG7100_INTR_RX_OVF              (1 << 6)
+#define AG7100_INTR_RX_BUS_ERROR        (1 << 7)
+
+/*
+ * MII registers
+ */
+#define AG7100_MAC_MII_MGMT_CFG         0x20
+#define AG7100_MGMT_CFG_CLK_DIV_20      0x06
+
+#define AG7100_MII_MGMT_CMD             0x24
+#define AG7100_MGMT_CMD_READ            0x1
+
+#define AG7100_MII_MGMT_ADDRESS         0x28
+#define AG7100_ADDR_SHIFT               8
+
+#define AG7100_MII_MGMT_CTRL            0x2c
+#define AG7100_MII_MGMT_STATUS          0x30
+
+#define AG7100_MII_MGMT_IND             0x34
+#define AG7100_MGMT_IND_BUSY            (1 << 0)
+#define AG7100_MGMT_IND_INVALID         (1 << 2)
+
+#define AG7100_GE_MAC_ADDR1             0x40
+#define AG7100_GE_MAC_ADDR2             0x44
+
+/*
+ *  * ownership of descriptors between DMA and cpu
+ *   */
+#define ag7100_rx_owned_by_dma(_ds)     ((_ds)->is_empty == 1)
+#define ag7100_rx_give_to_dma(_ds)      ((_ds)->is_empty = 1)
+#define ag7100_tx_owned_by_dma(_ds)     ((_ds)->is_empty == 0)
+#define ag7100_tx_give_to_dma(_ds)      ((_ds)->is_empty = 0)
+#define ag7100_tx_own(_ds)              ((_ds)->is_empty = 1)
+
+/*
+ * link settings
+ */
+#define ag7100_set_mac_duplex(_mac, _fdx)       do {                         \
+    if ((_fdx))                                                              \
+        ag7100_reg_rmw_set(_mac, AG7100_MAC_CFG2, AG7100_MAC_CFG2_FDX)     \
+    else                                                                     \
+        ag7100_reg_rmw_clear(_mac, AG7100_MAC_CFG2, AG7100_MAC_CFG2_FDX)   \
+}while(0)
+
+#define ag7100_set_mac_if(_mac, _isXGMII)    do {                              \
+    ag7100_reg_rmw_clear(_mac, AG7100_MAC_CFG2, AG7100_MAC_CFG2_IF_1000|      \
+                                          AG7100_MAC_CFG2_IF_10_100);   \
+    if ((_isXGMII)) {                                            \
+        ag7100_reg_rmw_set(_mac, AG7100_MAC_CFG2, AG7100_MAC_CFG2_IF_1000)  \
+        ag7100_reg_rmw_set(_mac, AG7100_MAC_FIFO_CFG_5, AG7100_BYTE_PER_CLK_EN);\
+    }                                                                       \
+    else {                                                              \
+        ag7100_reg_rmw_set(_mac, AG7100_MAC_CFG2, AG7100_MAC_CFG2_IF_10_100)\
+        ag7100_reg_rmw_clear(_mac, AG7100_MAC_FIFO_CFG_5, AG7100_BYTE_PER_CLK_EN);\
+    }                                                                       \
+}while(0)
+
+#define ag7100_set_mac_speed(_mac, _is100)   do {                             \
+    if ((_is100))                                                             \
+        ag7100_reg_rmw_set(_mac, AG7100_MAC_IFCTL, AG7100_MAC_IFCTL_SPEED)  \
+    else                                                                      \
+        ag7100_reg_rmw_clear(_mac, AG7100_MAC_IFCTL, AG7100_MAC_IFCTL_SPEED)\
+}while(0)
+
+ag7100_mac_t *ag7100_unit2mac(int unit);
+
+#endif
diff --git a/cpu/mips/ar7100/ag7100_phy.h b/cpu/mips/ar7100/ag7100_phy.h
new file mode 100644
index 0000000000..53301d522a
--- /dev/null
+++ b/cpu/mips/ar7100/ag7100_phy.h
@@ -0,0 +1,257 @@
+#ifndef _AG7100_PHY_H
+#define _AG7100_PHY_H
+
+#ifdef CFG_ATHRS26_PHY
+#ifndef AR9100
+#include "../board/ar7100/ap94/athrs26_phy.h"
+
+#define ag7100_phy_setup(unit)          athrs26_phy_setup (unit)
+#define ag7100_phy_is_up(unit)          athrs26_phy_is_up (unit)
+#define ag7100_phy_speed(unit)          athrs26_phy_speed (unit)
+#define ag7100_phy_is_fdx(unit)         athrs26_phy_is_fdx (unit)
+
+static inline unsigned int 
+ag7100_get_link_status(int unit, int *link, int *fdx, ag7100_phy_speed_t *speed)
+{
+  *link=ag7100_phy_is_up(unit);
+  *fdx=ag7100_phy_is_fdx(unit);
+  *speed=ag7100_phy_speed(unit);
+  return 0;
+}
+
+#else
+#define ag7100_phy_setup(unit) do { \
+if(!unit) \
+        athrs26_phy_setup(unit); \
+} while (0);
+
+#define ag7100_phy_link(unit,link,fdx,speed) do { \
+if(!unit) \
+        link=miiphy_link("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_duplex(unit,duplex) do { \
+if(!unit) \
+        duplex = miiphy_duplex("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_speed(unit,speed) do { \
+if(!unit) \
+        speed = miiphy_speed("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#endif // Hydra or Howl
+#endif
+
+#ifdef CFG_ATHRS16_PHY
+
+#include "../board/ar7100/common/athrs16_phy.h"
+
+#define ag7100_phy_setup(unit)          athrs16_phy_setup (unit)
+#define ag7100_phy_is_up(unit)          athrs16_phy_is_up (unit)
+#define ag7100_phy_speed(unit)          athrs16_phy_speed (unit)
+#define ag7100_phy_is_fdx(unit)         athrs16_phy_is_fdx (unit)
+/*
+#define ag7100_phy_ioctl(unit, args)    athr_ioctl(unit,args)
+#define ag7100_phy_is_lan_pkt           athr_is_lan_pkt
+#define ag7100_phy_set_pkt_port         athr_set_pkt_port
+#define ag7100_phy_tag_len              ATHR_VLAN_TAG_SIZE
+#define ag7100_phy_get_counters         athrs16_get_counters
+*/
+
+static inline unsigned int
+ag7100_get_link_status(int unit, int *link, int *fdx, ag7100_phy_speed_t *speed)
+{
+  *link=ag7100_phy_is_up(unit);
+  *fdx=ag7100_phy_is_fdx(unit);
+  *speed=ag7100_phy_speed(unit);
+  return 0;
+}
+
+static inline int
+ag7100_print_link_status(int unit)
+{
+  return -1;
+}
+
+#endif /* CFG_ATHRS16_PHY */
+
+#ifdef CFG_VSC8201_PHY
+
+#define ag7100_phy_setup(unit) do { \
+if(!unit) \
+        vsc_phy_setup(unit); \
+} while (0);
+
+#define ag7100_phy_link(unit,link,fdx,speed) do { \
+if(!unit) \
+        link=miiphy_link("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_duplex(unit,duplex) do { \
+if(!unit) \
+        duplex = miiphy_duplex("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_speed(unit,speed) do { \
+if(!unit) \
+        speed = miiphy_speed("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#endif
+
+#ifdef CFG_VSC8601_PHY
+
+#define ag7100_phy_setup(unit) do { \
+if(!unit) \
+        vsc8601_phy_setup(unit); \
+} while (0);
+
+#define ag7100_phy_link(unit,link,fdx,speed) do { \
+if(!unit) \
+        link=miiphy_link("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_duplex(unit,duplex) do { \
+if(!unit) \
+        duplex = miiphy_duplex("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_speed(unit,speed) do { \
+if(!unit) \
+        speed = miiphy_speed("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#endif
+
+#ifdef CFG_VITESSE_8601_7395_PHY
+
+#include "../board/ar7100/common/vsc73xx.h"
+
+#define ag7100_phy_setup(unit) do { \
+if(unit) \
+	vsc73xx_setup(unit); \
+else \
+	vsc8601_phy_setup(unit); \
+} while (0);
+
+#define ag7100_phy_link(unit,link,fdx,speed) do { \
+if(unit) \
+	vsc73xx_get_link_status(unit, &link, &fdx, &speed,0); \
+else \
+        link=miiphy_link("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_duplex(unit,duplex) do { \
+if(unit) \
+	vsc73xx_get_link_status(unit, 0, &duplex, 0,0); \
+else \
+	duplex = miiphy_duplex("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_speed(unit,speed) do { \
+if(unit) \
+	vsc73xx_get_link_status(unit, 0, 0, &speed,0); \
+else \
+	speed = miiphy_speed("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+static inline unsigned int
+ag7100_get_link_status(int unit, int *link, int *fdx, ag7100_phy_speed_t *speed)
+{
+    if (0==unit) {
+        ag7100_phy_link(unit,*link,*fdx,*speed);
+        ag7100_phy_duplex(unit,*fdx);
+        ag7100_phy_speed(unit,*speed);
+    } else
+        return vsc73xx_get_link_status(unit, link, fdx, speed, 0);
+
+    return -1;
+}
+
+#endif
+
+
+#ifdef CFG_IP175B_PHY
+
+#define ag7100_phy_setup(unit) do { \
+if(!unit) \
+        ip_phySetup(unit); \
+} while (0);
+
+#define ag7100_phy_link(unit,link,fdx,speed) do { \
+if(!unit) \
+        link=ip_phyIsUp(unit); \
+} while (0);
+
+#define ag7100_phy_duplex(unit,duplex) do { \
+if(!unit) \
+        duplex = ip_phyIsFullDuplex(unit); \
+} while (0);
+
+#define ag7100_phy_speed(unit,speed) do { \
+if(!unit) \
+        speed = ip_phySpeed(unit); \
+} while (0);
+
+#endif
+
+#ifdef CONFIG_ADMTEK_PHY
+
+#define ag7100_phy_setup(unit) do { \
+if(!unit) \
+        miiphy_reset("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_link(unit,link,fdx,speed) do { \
+if(!unit) \
+        link=miiphy_link("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_duplex(unit,duplex) do { \
+if(!unit) \
+        duplex = miiphy_duplex("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_speed(unit,speed) do { \
+if(!unit) \
+        speed = miiphy_speed("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#endif
+
+
+#ifdef CFG_ATHRF1_PHY
+
+#include "../board/ar7100/common/athr_phy.h"
+
+#define ag7100_phy_setup(unit) do { \
+	athr_phy_setup(unit); \
+} while (0);
+
+#define ag7100_phy_duplex(unit,duplex) do { \
+	duplex = athr_phy_is_fdx(unit); \
+} while (0);
+
+#define ag7100_phy_speed(unit,speed) do { \
+	speed = athr_phy_speed(unit); \
+} while (0);
+
+static inline unsigned int 
+ag7100_get_link_status(int unit, int *link, int *fdx, ag7100_phy_speed_t *speed)
+{
+  *link=athr_phy_is_up(unit); 
+  if (*link==0)
+    return 0;   
+  *fdx=athr_phy_is_fdx(unit);
+  *speed=athr_phy_speed(unit);
+  return 0;
+}
+
+#define ag7100_phy_link(unit,link,fdx,speed) do { \
+	ag7100_get_link_status(unit, &link, &fdx, &speed); \
+} while (0);
+
+#endif
+
+#endif /*_AG7100_PHY_H*/
diff --git a/cpu/mips/ar7100/ar7100_serial.c b/cpu/mips/ar7100/ar7100_serial.c
new file mode 100644
index 0000000000..3ef6d7ddd6
--- /dev/null
+++ b/cpu/mips/ar7100/ar7100_serial.c
@@ -0,0 +1,178 @@
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <config.h>
+#include <ar7100_soc.h>
+
+#define		REG_OFFSET		4
+
+/* === END OF CONFIG === */
+
+/* register offset */
+#define         OFS_RCV_BUFFER          (0*REG_OFFSET)
+#define         OFS_TRANS_HOLD          (0*REG_OFFSET)
+#define         OFS_SEND_BUFFER         (0*REG_OFFSET)
+#define         OFS_INTR_ENABLE         (1*REG_OFFSET)
+#define         OFS_INTR_ID             (2*REG_OFFSET)
+#define         OFS_DATA_FORMAT         (3*REG_OFFSET)
+#define         OFS_LINE_CONTROL        (3*REG_OFFSET)
+#define         OFS_MODEM_CONTROL       (4*REG_OFFSET)
+#define         OFS_RS232_OUTPUT        (4*REG_OFFSET)
+#define         OFS_LINE_STATUS         (5*REG_OFFSET)
+#define         OFS_MODEM_STATUS        (6*REG_OFFSET)
+#define         OFS_RS232_INPUT         (6*REG_OFFSET)
+#define         OFS_SCRATCH_PAD         (7*REG_OFFSET)
+
+#define         OFS_DIVISOR_LSB         (0*REG_OFFSET)
+#define         OFS_DIVISOR_MSB         (1*REG_OFFSET)
+
+#define         MY_WRITE(y, z)  ((*((volatile u32*)(y))) = z)
+#define         UART16550_READ(y)   ar7100_reg_rd((AR7100_UART_BASE+y))
+#define         UART16550_WRITE(x, z)  ar7100_reg_wr((AR7100_UART_BASE+x), z)
+
+void 
+ar7100_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq)
+{
+#ifndef AR9100
+    u32 pll, pll_div, cpu_div, ahb_div, ddr_div, freq;
+
+    pll = ar7100_reg_rd(AR7100_CPU_PLL_CONFIG);
+
+    pll_div = 
+        ((pll & PLL_CONFIG_PLL_FB_MASK) >> PLL_CONFIG_PLL_FB_SHIFT) + 1;
+
+    cpu_div = 
+        ((pll & PLL_CONFIG_CPU_DIV_MASK) >> PLL_CONFIG_CPU_DIV_SHIFT) + 1;
+
+    ddr_div = 
+        ((pll & PLL_CONFIG_DDR_DIV_MASK) >> PLL_CONFIG_DDR_DIV_SHIFT) + 1;
+
+    ahb_div = 
+       (((pll & PLL_CONFIG_AHB_DIV_MASK) >> PLL_CONFIG_AHB_DIV_SHIFT) + 1)*2;
+
+    freq = pll_div * 40000000; 
+
+    if (cpu_freq)
+        *cpu_freq = freq/cpu_div;
+
+    if (ddr_freq)
+        *ddr_freq = freq/ddr_div;
+
+    if (ahb_freq)
+        *ahb_freq = (freq/cpu_div)/ahb_div;
+
+    /*
+    printf ("cpu_freq = %d\n", freq/cpu_div);
+    printf ("ddr_freq = %d\n", freq/ddr_div);
+    printf ("ahb_freq = %d\n", (freq/cpu_div)/ahb_div);
+    */
+#else
+    u32 pll, pll_div, ahb_div, ddr_div, freq;
+
+    pll = ar7100_reg_rd(AR7100_CPU_PLL_CONFIG);
+
+    pll_div = 
+        ((pll & PLL_CONFIG_PLL_FB_MASK) >> PLL_CONFIG_PLL_FB_SHIFT);
+
+    ddr_div = 
+        ((pll & PLL_CONFIG_DDR_DIV_MASK) >> PLL_CONFIG_DDR_DIV_SHIFT) + 1;
+
+    ahb_div = 
+       (((pll & PLL_CONFIG_AHB_DIV_MASK) >> PLL_CONFIG_AHB_DIV_SHIFT) + 1)*2;
+
+    freq = pll_div * 5000000; 
+
+    if (cpu_freq)
+        *cpu_freq = freq;
+
+    if (ddr_freq)
+        *ddr_freq = freq/ddr_div;
+
+    if (ahb_freq)
+        *ahb_freq = freq/ahb_div;
+#endif
+}
+
+
+void serial_init()
+{
+    u32 div;
+    u32 ahb_freq = 100000000;
+
+    ar7100_sys_frequency  (0, 0, &ahb_freq);  
+    div  = ahb_freq/(16 * CONFIG_BAUDRATE);  
+
+    /*
+     * undocumented. confirm, why write to GPIO for uart?
+     */
+#if 0
+    ar7100_reg_wr(AR7100_GPIO_OE, 0xcff);
+    ar7100_reg_wr(AR7100_GPIO_OUT, 0x3b);
+
+    MY_WRITE(0xb8040028, 0x100);
+#else
+    MY_WRITE(0xb8040000, 0x47f);
+    MY_WRITE(0xb8040008, 0x7f);
+
+    MY_WRITE(0xb8040028, 0x100);
+#endif
+
+    /* 
+     * set DIAB bit 
+     */
+    UART16550_WRITE(OFS_LINE_CONTROL, 0x80);
+        
+    /* set divisor */
+    /*UART16550_WRITE(OFS_DIVISOR_LSB, 0x04);
+    UART16550_WRITE(OFS_DIVISOR_MSB, 0x01);*/
+#if 1
+    UART16550_WRITE(OFS_DIVISOR_LSB, (div & 0xff));
+    UART16550_WRITE(OFS_DIVISOR_MSB, ((div >> 8) & 0xff));
+#else
+    UART16550_WRITE(OFS_DIVISOR_LSB, (0x36 & 0xff));
+    UART16550_WRITE(OFS_DIVISOR_MSB, 0);
+#endif
+
+    /* clear DIAB bit*/ 
+    UART16550_WRITE(OFS_LINE_CONTROL, 0x00);
+
+    /* set data format */
+    UART16550_WRITE(OFS_DATA_FORMAT, 0x3);
+
+    UART16550_WRITE(OFS_INTR_ENABLE, 0);
+
+    //WRITE(0xb8020008, 0x7);
+    //WRITE(0xb8020010, 0x3);
+}
+
+int serial_tstc (void)
+{
+    return(UART16550_READ(OFS_LINE_STATUS) & 0x1);
+}
+
+u8 serial_getc()
+{
+    while(!serial_tstc());
+
+    return UART16550_READ(OFS_RCV_BUFFER);
+}
+
+
+void serial_putc(u8 byte)
+{
+    if (byte == '\n') serial_putc ('\r');
+
+    while (((UART16550_READ(OFS_LINE_STATUS)) & 0x20) == 0x0);
+    UART16550_WRITE(OFS_SEND_BUFFER, byte);
+}
+
+void serial_setbrg (void)
+{
+}
+
+void serial_puts (const char *s)
+{
+	while (*s)
+	{
+		serial_putc (*s++);
+	}
+}
diff --git a/cpu/mips/ar7100/meminit.c b/cpu/mips/ar7100/meminit.c
new file mode 100644
index 0000000000..2948f37054
--- /dev/null
+++ b/cpu/mips/ar7100/meminit.c
@@ -0,0 +1,297 @@
+/* 
+ * Memory controller config:
+ * Assumes that the caches are initialized.
+ *
+ * 0) Figah out the Tap controller settings.
+ * 1) Figure out whether the interface is 16bit or 32bit.
+ * 2) Size the DRAM
+ *
+ *  0) Tap controller settings
+ *  --------------------------
+ * The Table below provides all possible values of TAP controllers. We need to
+ * find the extreme left and extreme right of the spectrum (of max_udelay and
+ * min_udelay). We then program the TAP to be in the middle.
+ * Note for this we would need to be able to read and write memory. So, 
+ * initially we assume that a 16bit interface, which will always work unless
+ * there is exactly _1_ 32 bit part...for now we assume this is not the case.
+ * 
+ * The algo:
+ * 0) Program the controller in 16bit mode.
+ * 1) Start with the extreme left of the table
+ * 2) Write 0xa4, 0xb5, 0xc6, 0xd7 to 0, 2, 4, 6
+ * 3) Read 0 - this will fetch the entire cacheline.
+ * 4) If the value at address 4 is good, record this table entry, goto 6
+ * 5) Increment to get the next table entry. Goto 2.
+ * 6) Start with extreme right. Do the same as above.
+ *
+ * 1) 16bit or 32bit
+ * -----------------
+ *  31st bit of reg 0x1800_0000 will  determine the mode. By default, 
+ *  controller is set to 32-bit mode. In 32 bit mode, full data bus DQ [31:0] 
+ *  will be used to write 32 bit data. Suppose you have 16bit DDR memory
+ *  (it will have 16bit wide data bus). If you try to write 16 bit DDR in 32 
+ *  bit mode, you are going to miss upper 16 bits of data. Reading to that 
+ *  location will give you only lower 16 bits correctly, upper 16 bits will 
+ *  have some junk value. E.g.,
+ *
+ *  write to 0x0000_0000 0x12345678
+ *  write to 0x0000_1000 0x00000000 (just to discharge DQ[31:16] )
+ *  read from 0x0000_0000
+ *  if u see something like 0x0000_5678 (or XXXX_5678 but not equal to 
+ *  0x12345678) - its a 16 bit interface
+ *
+ *  2) Size the DRAM
+ *  -------------------
+ *  DDR wraps around. Write a pattern to 0x0000_0000. Write an address 
+ *  pattern at 4M, 8M, 16M etc. and check when 0x0000_0000 gets overwritten.
+ *
+ *
+ *  We can use #define's for all these addresses and patterns but its easier
+ *  to see what's going on without :)
+ */
+#include <common.h>
+#include <asm/addrspace.h>
+#include "ar7100_soc.h"
+
+
+uint8_t     tap_settings[] = 
+            {0x40, 0x41, 0x10, 0x12, 0x13, 0x15, 0x1a, 0x1c, 0x1f, 0x2f, 0x3f};
+
+uint16_t    tap_pattern[] = {0xa5, 0xb6, 0xc7, 0xd8};
+
+void
+ar7100_ddr_tap_set(uint8_t set)
+{
+    ar7100_reg_wr_nf(AR7100_DDR_TAP_CONTROL0, set);
+    ar7100_reg_wr_nf(AR7100_DDR_TAP_CONTROL1, set);
+    ar7100_reg_wr_nf(AR7100_DDR_TAP_CONTROL2, set);
+    ar7100_reg_wr_nf(AR7100_DDR_TAP_CONTROL3, set);
+}
+/*
+ * We use 0xa0003000, because the first way is locked into cache to give
+ * us a rudimentary stack
+ */
+void ar7100_ddr_tap_config(void)
+{
+    uint8_t set, prev, dummy;
+    int i, j, k, floor, ceiling;
+    uint16_t *p = 0xa0003000, *p_ca = 0x80003000;
+
+    ar7100_reg_rmw_set(AR7100_DDR_CONFIG, AR7100_DDR_CONFIG_16BIT);
+
+    for(i = 0; i < sizeof(tap_settings); i++) {
+        set = tap_settings[i];
+        ar7100_ddr_tap_set(set);
+
+#ifndef COMPRESSED_UBOOT
+        printf("trying %#x...", set);
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+        for(j = 0; j < 4; j++)
+            *(p + j) = tap_pattern[j];
+
+        /*
+         * get the cacheline
+         */
+        dummy = *p_ca;
+
+        if ((*(p_ca + 2)) == tap_pattern[2]) {
+            floor = i;
+#ifndef COMPRESSED_UBOOT
+            printf("worked; floor %d\n", i);
+#endif /* #ifndef COMPRESSED_UBOOT */
+            break;
+        }
+#ifndef COMPRESSED_UBOOT
+        printf("didnt work written %#x read %#x\n", tap_pattern[2], 
+                *(p_ca + 2));
+#endif /* #ifndef COMPRESSED_UBOOT */
+        flush_cache(p_ca, 8);
+    }
+
+    for(k = sizeof(tap_settings) - 1; k > i; k--) {
+        set = tap_settings[k];
+        ar7100_ddr_tap_set(set);
+
+#ifndef COMPRESSED_UBOOT
+        printf("trying %#x...", set);
+#endif /* #ifndef COMPRESSED_UBOOT */
+        for(j = 0; j < 4; j++)
+            *(p + j) = tap_pattern[j];
+
+        dummy = *p_ca;
+
+        if ((*(p_ca + 2)) == tap_pattern[2]) {
+            ceiling = k;
+#ifndef COMPRESSED_UBOOT
+            printf("worked; ceiling %d\n", k);
+#endif /* #ifndef COMPRESSED_UBOOT */
+            break;
+        }
+#ifndef COMPRESSED_UBOOT
+        printf("didnt work written %#x read %#x\n", tap_pattern[2], 
+                *(p_ca + 2));
+#endif /* #ifndef COMPRESSED_UBOOT */
+        flush_cache(p_ca, 8);
+    }
+    /*
+     * If the min and max delay both worked, lets pick a default
+     */
+#ifndef COMPRESSED_UBOOT
+    printf("floor %d ceil %d size-1 %d\n",
+            floor, ceiling, (sizeof(tap_settings) - 1));
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+    if ((floor == 0) && (ceiling == (sizeof(tap_settings) - 1))) 
+        set = AR7100_DDR_TAP_DEFAULT;
+    else {
+        i = ((ceiling - floor)/2) + floor;
+        set = tap_settings[i];
+#ifndef COMPRESSED_UBOOT
+        printf("i %d\n", i);
+#endif /* #ifndef COMPRESSED_UBOOT */
+    }
+
+#ifndef COMPRESSED_UBOOT
+    printf("Setting Tap to %#x\n", set);
+#endif /* #ifndef COMPRESSED_UBOOT */
+    ar7100_ddr_tap_set(set);
+    udelay(1);
+}
+
+ar7100_ddr_width_t
+ar7100_ddr_get_width()
+{
+    volatile uint32_t *p = 0xa0000000, *p1 = 0xa0001000;
+    uint32_t pat = 0x12345678, rd;
+
+    *p  = pat;
+    *p1 = 0;
+    asm("sync");
+    /*
+     * discharge DQ[31:16]
+     */
+    rd  = *p;
+
+    if (rd == pat)
+        return AR7100_DDR_32B;
+
+    if ((rd & 0xffff) == (pat & 0xffff))
+        return AR7100_DDR_16B_LOW;
+
+    if ((rd & 0xffff0000) == (pat & 0xffff0000))
+        return AR7100_DDR_16B_HIGH;
+
+    /*
+     * If Some'n's hosed this early cant do much; silence the compiler :)
+     */
+#ifndef COMPRESSED_UBOOT
+    printf("something's wrong. rd %#x pat %#x\n", rd, pat);
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+    return AR7100_DDR_32B;
+}
+ 
+/*
+ * We check for size in 4M increments
+ */
+#define AR7100_DDR_SIZE_INCR    (4*1024*1024)
+
+int sanity_mem_check(int mem_size) 
+{
+	int data=0xaaaa5555,i,ret=0;
+        volatile unsigned int *ptr = KSEG1;
+
+	for(i = 0; i < ((mem_size * AR7100_DDR_SIZE_INCR) / 4096) ; i++) {
+		
+		ptr[i] = (data ^ (1  << (i % 16)));
+		 if(i % 16  == 0) 
+			data = ~data;
+	} 
+        data = 0xaaaa5555;
+        for(i = 0; i < ((mem_size * AR7100_DDR_SIZE_INCR) / 4096) ; i++) {
+
+                if(ptr[i] != (data ^ (1  << (i % 16)))) {
+			ret = 1;
+			break;
+		 }
+                 if(i % 16 == 0)
+                        data = ~data;
+        }
+	return ret;
+}
+int
+ar7100_ddr_find_size()
+{
+    uint8_t  *p = KSEG1, pat = 0x77;
+    int i, incr = AR7100_DDR_SIZE_INCR;
+
+    *p = pat;
+
+    for(i = 1; ; i++) {
+        *(p + i * AR7100_DDR_SIZE_INCR) = (uint8_t)(i);
+        if (*p != pat) {
+            break;
+        }
+    }
+    if(i < 4) {
+	udelay(1000);
+        for (;;) {
+            ar7100_reg_wr(AR7100_RESET,
+                        (AR7100_RESET_FULL_CHIP | AR7100_RESET_DDR));
+        }
+    }
+    if(sanity_mem_check(i)) {
+        udelay(1000);
+        for (;;) {
+            ar7100_reg_wr(AR7100_RESET,
+                        (AR7100_RESET_FULL_CHIP | AR7100_RESET_DDR));
+        }
+    }
+    return (i*AR7100_DDR_SIZE_INCR);
+}
+
+void
+ar7100_ddr_initial_config(uint32_t refresh)
+{
+#ifndef COMPRESSED_UBOOT
+    printf("\nsri . . ");
+#endif /* #ifndef COMPRESSED_UBOOT */
+#if 0
+    ar7100_reg_wr(AR7100_RESET, AR7100_RESET_DDR);
+    udelay(10);
+#endif
+#ifndef COMPRESSED_UBOOT
+    ar7100_reg_wr_nf(AR7100_DDR_CONFIG, CFG_DDR_CONFIG_VAL);
+    udelay(1000);
+    ar7100_reg_wr_nf(AR7100_DDR_CONFIG2, CFG_DDR_CONFIG2_VAL);
+    udelay(1000);
+    ar7100_reg_wr_nf(AR7100_DDR_CONTROL, 0x8);
+    udelay(1000);
+#ifdef AR9100
+    ar7100_reg_wr_nf(AR7100_DDR_MODE, CFG_DDR_MODE_VAL_INIT);
+    udelay(1000);
+#endif
+    ar7100_reg_wr_nf(AR7100_DDR_CONTROL, 0x1);
+    udelay(1000);
+    ar7100_reg_wr_nf(AR7100_DDR_EXT_MODE, CFG_DDR_EXT_MODE_VAL);
+    udelay(1000);
+#endif /* #ifndef COMPRESSED_UBOOT */
+    ar7100_reg_wr_nf(AR7100_DDR_CONTROL, 0x2);
+    udelay(1000);
+    ar7100_reg_wr_nf(AR7100_DDR_CONTROL, 0x8);
+    udelay(1000);
+    ar7100_reg_wr_nf(AR7100_DDR_MODE, CFG_DDR_MODE_VAL);
+    udelay(10000);
+    ar7100_reg_wr_nf(AR7100_DDR_CONTROL, 0x1);
+    udelay(1000);
+    ar7100_reg_wr_nf(AR7100_DDR_REFRESH, refresh);
+    udelay(1000);
+    ar7100_reg_wr_nf(AR7100_DDR_RD_DATA_THIS_CYCLE,CFG_DDR_RD_DATA_THIS_CYCLE_VAL);
+    udelay(1000);
+}
+
+
+
+
+
diff --git a/cpu/mips/ar7240/Makefile b/cpu/mips/ar7240/Makefile
new file mode 100644
index 0000000000..47c71f56cd
--- /dev/null
+++ b/cpu/mips/ar7240/Makefile
@@ -0,0 +1,61 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(SOC).a
+
+START	=
+#OBJS	= ar7240_serial.o ag7240.o ar7240_flash.o meminit.o
+
+OBJS	= meminit.o 
+
+ifeq ($(BOARD), ap121)
+OBJS	+= hornet_serial.o
+SOBJS	+= hornet_ddr_init.o
+else
+OBJS	+= ar7240_serial.o
+endif
+
+ifneq ($(BUILD_EMU), )
+OBJS    += hornet_ag7240.o
+else
+ifneq ($(findstring db12x,$(BOARD)),)
+OBJS    += ag934x.o
+else
+ifneq ($(findstring reh132,$(BOARD)),)
+OBJS    += ag934x.o
+else
+ifneq ($(findstring dhp,$(BOARD)),)
+OBJS    += ag934x.o
+else
+ifneq ($(findstring aph,$(BOARD)),)
+OBJS    += ag934x.o
+else
+ifneq ($(findstring ap123,$(BOARD)),)
+OBJS    += ag934x.o
+else
+ifneq ($(findstring ap120,$(BOARD)),)
+OBJS    += ag934x.o
+else
+OBJS    += ag7240.o
+endif
+endif
+endif
+endif
+endif
+endif
+endif
+
+SOBJS	+= 
+
+all:	.depend $(START) $(LIB)
+
+$(LIB):	$(OBJS) $(SOBJS) $(OBJS-0)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(START:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(START:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/cpu/mips/ar7240/ag7240.c b/cpu/mips/ar7240/ag7240.c
new file mode 100644
index 0000000000..9d8475b9b2
--- /dev/null
+++ b/cpu/mips/ar7240/ag7240.c
@@ -0,0 +1,722 @@
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7240_soc.h"
+#include "ag7240.h"
+#include "ag7240_phy.h"
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ag7240_unit2mac(_unit)     ag7240_macs[(_unit)]
+#define ag7240_name2mac(name)	   strcmp(name,"eth0") ? ag7240_unit2mac(1) : ag7240_unit2mac(0)
+
+uint16_t ag7240_miiphy_read(char *devname, uint32_t phaddr,
+	       uint8_t reg);
+void  ag7240_miiphy_write(char *devname, uint32_t phaddr,
+	        uint8_t reg, uint16_t data);
+
+ag7240_mac_t *ag7240_macs[CFG_AG7240_NMACS];
+extern void ar7240_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq);
+
+#ifdef CFG_ATHRS26_PHY
+extern int athrs26_phy_setup(int unit);
+extern int athrs26_phy_is_up(int unit);
+extern int athrs26_phy_is_fdx(int unit);
+extern int athrs26_phy_speed(int unit);
+extern void athrs26_reg_init(void);
+extern void athrs26_reg_init_lan(void);
+extern int athrs26_mdc_check(void);
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+extern int athrs27_phy_setup(int unit);
+extern int athrs27_phy_is_up(int unit);
+extern int athrs27_phy_is_fdx(int unit);
+extern int athrs27_phy_speed(int unit);
+extern void athrs27_reg_init(void);
+extern void athrs27_reg_init_lan(void);
+extern int athrs27_mdc_check(void);
+#endif
+
+#ifdef CONFIG_F1E_PHY
+extern int athr_phy_setup(int unit);
+extern int athr_phy_is_up(int unit);
+extern int athr_phy_is_fdx(int unit);
+extern int athr_phy_speed(int unit);
+extern void athr_reg_init(void);
+#endif
+
+static int
+ag7240_send(struct eth_device *dev, volatile void *packet, int length)
+{
+    int i;
+
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+
+    ag7240_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+    f->pkt_size = length;
+    f->res1 = 0;
+    f->pkt_start_addr = virt_to_phys(packet);
+
+    ag7240_tx_give_to_dma(f);
+    flush_cache((u32) packet, length);
+    ag7240_reg_wr(mac, AG7240_DMA_TX_DESC, virt_to_phys(f));
+    ag7240_reg_wr(mac, AG7240_DMA_TX_CTRL, AG7240_TXE);
+
+    for (i = 0; i < MAX_WAIT; i++) {
+        udelay(10);
+        if (!ag7240_tx_owned_by_dma(f))
+            break;
+    }
+    if (i == MAX_WAIT)
+        printf("Tx Timed out\n");
+
+    f->pkt_start_addr = 0;
+    f->pkt_size = 0;
+
+    if (++mac->next_tx >= NO_OF_TX_FIFOS)
+        mac->next_tx = 0;
+
+    return (0);
+}
+
+static int ag7240_recv(struct eth_device *dev)
+{
+    int length;
+    ag7240_desc_t *f;
+    ag7240_mac_t *mac;
+ 
+    mac = (ag7240_mac_t *)dev->priv;
+
+    for (;;) {
+        f = mac->fifo_rx[mac->next_rx];
+        if (ag7240_rx_owned_by_dma(f))
+            break;
+
+        length = f->pkt_size;
+
+        NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+        flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+        ag7240_rx_give_to_dma(f);
+
+        if (++mac->next_rx >= NO_OF_RX_FIFOS)
+            mac->next_rx = 0;
+    }
+
+    if (!(ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL))) {
+        ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(f));
+        ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 1);
+    }
+
+    return (0);
+}
+
+void ag7240_mii_setup(ag7240_mac_t *mac)
+{
+    u32 mgmt_cfg_val;
+    u32 cpu_freq,ddr_freq,ahb_freq;
+    u32 check_cnt,revid_val;
+#ifdef CFG_ATHRS27_PHY
+    if (is_wasp()) {
+        printf("WASP ----> S27 PHY \n");
+        mgmt_cfg_val = 2;
+        ar7240_reg_wr(0xb8050024, 0x271);	// 25MHz ref clock
+        //ar7240_reg_wr(0xb8050024, 0x570);	// 40MHz ref clock
+        ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+        return;
+    }
+#endif
+#ifdef CONFIG_AR7242_S16_PHY
+    if (is_wasp()) {
+        printf("WASP  ----> S16 PHY *\n");
+        mgmt_cfg_val = 4;
+        if(mac->mac_unit == 0)
+            ar7240_reg_wr(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+
+        ar7240_reg_rmw_clear(AG7240_ETH_SWITCH_CLK_SPARE, (1 << 6));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+        return;
+    }
+#endif
+#ifdef CONFIG_F1E_PHY
+    if (is_wasp()) {
+        printf("WASP  ----> F1 PHY *\n");
+        mgmt_cfg_val = 6;
+        if(mac->mac_unit == 0)
+            ar7240_reg_wr(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+        return;
+    }
+#endif
+
+    if ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7240_REV_1_2) {
+        mgmt_cfg_val = 0x2;
+        if (mac->mac_unit == 0) {
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+        }
+    }
+    else {
+        ar7240_sys_frequency(&cpu_freq, &ddr_freq, &ahb_freq);
+        switch (ahb_freq/1000000) {
+            case 150:
+                     mgmt_cfg_val = 0x7;
+                     break;
+            case 175:
+                     mgmt_cfg_val = 0x5;
+                     break;
+            case 200:
+                     mgmt_cfg_val = 0x4;
+                     break;
+            case 210:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            case 220:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            default:
+                     mgmt_cfg_val = 0x7;
+        }
+        if ((is_ar7241() || is_ar7242())) {
+
+            /* External MII mode */
+            if (mac->mac_unit == 0 && is_ar7242()) {
+                 mgmt_cfg_val = 0x6;
+                 ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+                 ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                 ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            }
+            /* Virian */
+            mgmt_cfg_val = 0x4;
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            printf("Virian MDC CFG Value ==> %x\n",mgmt_cfg_val);
+
+        }
+      else if(is_ar933x()){
+                //GE0 receives Rx/Tx clock, and use S26 phy
+                ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_MII_GE0_SLAVE);
+                mgmt_cfg_val = 0xF;
+                if (mac->mac_unit == 1) {
+                        check_cnt = 0;
+                        while (check_cnt++ < 10) {
+                                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+#ifdef CFG_ATHRS26_PHY
+                                if(athrs26_mdc_check() == 0)
+                                        break;
+#endif
+                        }
+                        if(check_cnt == 11)
+                                printf("%s: MDC check failed\n", __func__);
+                }
+      }
+        else { /* Python 1.0 & 1.1 */
+             if (mac->mac_unit == 0) {
+                     check_cnt = 0;
+                     while (check_cnt++ < 10) {
+                             ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                             ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+#ifdef CFG_ATHRS26_PHY
+                             if(athrs26_mdc_check() == 0)
+                                     break;
+#endif
+                     }
+                     if(check_cnt == 11)
+                             printf("%s: MDC check failed\n", __func__);
+             }
+        }
+ 
+    }
+}
+
+static void ag7240_hw_start(ag7240_mac_t *mac)
+{
+
+    if(mac->mac_unit)
+    {
+        ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
+            AG7240_MAC_CFG1_TX_EN));
+        ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+            AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_1000));
+    }
+    else {
+
+    ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
+		    AG7240_MAC_CFG1_TX_EN));
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+		         AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_10_100));
+   }
+   ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_0, 0x1f00);
+
+   ag7240_mii_setup(mac);
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0x10ffff);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0xAAA0555);
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_4, 0x3ffff);
+    /* 
+     * Setting Drop CRC Errors, Pause Frames,Length Error frames 
+     * and Multi/Broad cast frames. 
+     */
+#ifdef AG7240_BROADCAST_ENABLE
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0xe6be2);
+#else
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0x7eccf);
+#endif
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_3, 0x1f00140);
+
+    printf(": cfg1 %#x cfg2 %#x\n", ag7240_reg_rd(mac, AG7240_MAC_CFG1),
+        ag7240_reg_rd(mac, AG7240_MAC_CFG2));
+
+}
+
+static int ag7240_check_link(ag7240_mac_t *mac)
+{
+    u32 link, duplex, speed, fdx;
+
+    ag7240_phy_link(mac->mac_unit, &link);
+    ag7240_phy_duplex(mac->mac_unit, &duplex);
+    ag7240_phy_speed(mac->mac_unit, &speed);
+
+    mac->link = link;
+#ifdef SUPPORT_PLC
+    if(strcmp(mac->dev->name, "eth0") == 0) {
+        printf("ag7240_check_link: %s link forced down\n",mac->dev->name);
+        return 0;
+    }
+#endif
+
+    if(!mac->link) {
+        printf("%s link down\n",mac->dev->name);
+        return 0;
+    }
+
+    switch (speed)
+    {
+       case _1000BASET:
+           ag7240_set_mac_if(mac, 1);
+           ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if (is_ar7242() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1c000000);
+	   }
+#ifdef CONFIG_F1E_PHY
+           if (is_wasp() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0e000000);
+	   }
+#else      
+           if (is_wasp() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x06000000);
+           }
+#endif
+           break;
+
+       case _100BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 1);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if ((is_ar7242() || is_wasp()) && (mac->mac_unit == 0))
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0101);
+           break;
+
+       case _10BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 0);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if ((is_ar7242() || is_wasp()) && (mac->mac_unit == 0))
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1616);
+           break;
+
+       default:
+          printf("Invalid speed detected\n");
+          return 0;
+    }
+
+   if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+        return 1; 
+
+    mac->duplex = duplex;
+    mac->speed = speed;
+
+    printf("dup %d speed %d\n", duplex, speed);
+
+    ag7240_set_mac_duplex(mac,duplex);
+
+    return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ag7240_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+    int i;
+    ag7240_desc_t *fr;
+    ag7240_mac_t *mac = (ag7240_mac_t*)dev->priv;
+
+    if (!ag7240_check_link(mac))
+        return 0;
+
+    mac->next_rx = 0;
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        fr = mac->fifo_rx[i];
+        fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+        flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+        ag7240_rx_give_to_dma(fr);
+    }
+
+    ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, AG7240_RXE);	/* rx start */
+    if(!is_ar933x())
+        udelay(1000 * 1000);
+
+
+    return 1;
+
+}
+
+static int ag7240_alloc_fifo(int ndesc, ag7240_desc_t ** fifo)
+{
+    int i;
+    u32 size;
+    uchar *p = NULL;
+
+    size = sizeof(ag7240_desc_t) * ndesc;
+    size += CFG_CACHELINE_SIZE - 1;
+
+    if ((p = malloc(size)) == NULL) {
+        printf("Cant allocate fifos\n");
+        return -1;
+    }
+
+    p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+	   ~(CFG_CACHELINE_SIZE - 1));
+    p = UNCACHED_SDRAM(p);
+
+    for (i = 0; i < ndesc; i++)
+        fifo[i] = (ag7240_desc_t *) p + i;
+
+    return 0;
+}
+
+static int ag7240_setup_fifos(ag7240_mac_t *mac)
+{
+    int i;
+
+    if (ag7240_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+        return 1;
+
+    for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+        mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+        ag7240_tx_own(mac->fifo_tx[i]);
+    }
+
+    if (ag7240_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+        return 1;
+
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+    }
+
+    return (1);
+}
+
+static void ag7240_halt(struct eth_device *dev)
+{
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 0);
+    while (ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL));
+}
+
+unsigned char *
+ag7240_mac_addr_loc(void)
+{
+	extern flash_info_t flash_info[];
+
+#ifdef BOARDCAL
+    /*
+    ** BOARDCAL environmental variable has the address of the cal sector
+    */
+    
+    return ((unsigned char *)BOARDCAL);
+    
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+		(KSEG1ADDR(AR7240_SPI_BASE) + (4 * 1024) +
+		flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+static void ag7240_get_ethaddr(struct eth_device *dev)
+{
+    unsigned char *eeprom;
+    unsigned char *mac = dev->enetaddr;
+#ifndef CONFIG_AR7240_EMU
+    eeprom = ag7240_mac_addr_loc();
+
+    if (strcmp(dev->name, "eth0") == 0) {
+        memcpy(mac, eeprom, 6);
+    } else if (strcmp(dev->name, "eth1") == 0) {
+        eeprom += 6;
+        memcpy(mac, eeprom, 6);
+    } else {
+        printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+        return;
+    }
+    /* Use fixed address if the above address is invalid */
+    if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff)) {
+#else
+    if (1) {
+#endif 
+        mac[0] = 0x00;
+        mac[1] = 0x03;
+        mac[2] = 0x7f;
+        mac[3] = 0x09;
+        mac[4] = 0x0b;
+        mac[5] = 0xad;
+        printf("No valid address in Flash. Using fixed address\n");
+    } else {
+        printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+    }
+}
+
+
+int ag7240_enet_initialize(bd_t * bis)
+{
+    struct eth_device *dev[CFG_AG7240_NMACS];
+    u32 mask, mac_h, mac_l;
+    int i;
+
+    printf("ag7240_enet_initialize...\n");
+
+    if(is_ar933x() ) {
+        u32 rd = 0x0;
+
+        /* 
+         * To get s26 out of reset, we have to...
+         * bit0~bit3: has to be deasserted
+         * bit4:      has to be asserted
+         */
+        rd = ar7240_reg_rd(AR7240_S26_CLK_CTRL_OFFSET) & ~(0x1f);
+        rd |= 0x10;
+        ar7240_reg_wr(AR7240_S26_CLK_CTRL_OFFSET, rd);
+
+        if(ar7240_reg_rd(AR7240_RESET)!=0)
+            ar7240_reg_wr(AR7240_RESET,0);
+    }
+
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+
+    if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+	
+    if ((ag7240_macs[i] = (ag7240_mac_t *) malloc(sizeof (ag7240_mac_t))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+
+    memset(ag7240_macs[i], 0, sizeof(ag7240_macs[i]));
+    memset(dev[i], 0, sizeof(dev[i]));
+
+    sprintf(dev[i]->name, "eth%d", i);
+    ag7240_get_ethaddr(dev[i]);
+    
+    ag7240_macs[i]->mac_unit = i;
+    ag7240_macs[i]->mac_base = i ? AR7240_GE1_BASE : AR7240_GE0_BASE ;
+    ag7240_macs[i]->dev = dev[i];
+
+    dev[i]->iobase = 0;
+    dev[i]->init = ag7240_clean_rx;
+    dev[i]->halt = ag7240_halt;
+    dev[i]->send = ag7240_send;
+    dev[i]->recv = ag7240_recv;
+    dev[i]->priv = (void *)ag7240_macs[i];
+    }
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+        eth_register(dev[i]);
+#if(CONFIG_COMMANDS & CFG_CMD_MII)
+        miiphy_register(dev[i]->name, ag7240_miiphy_read, ag7240_miiphy_write);
+#endif
+
+         ag7240_reg_rmw_set(ag7240_macs[i], AG7240_MAC_CFG1, AG7240_MAC_CFG1_SOFT_RST
+                | AG7240_MAC_CFG1_RX_RST | AG7240_MAC_CFG1_TX_RST);
+
+        if(!i) {
+           mask = (AR7240_RESET_GE0_MAC | AR7240_RESET_GE0_PHY |
+                    AR7240_RESET_GE1_MAC | AR7240_RESET_GE1_PHY);
+
+           if (is_ar7241() || is_ar7242() ||  is_wasp()) {
+                mask = mask | AR7240_RESET_GE0_MDIO | AR7240_RESET_GE1_MDIO;
+                printf(" wasp  reset mask:%x \n",mask);
+           }
+
+
+           ar7240_reg_rmw_set(AR7240_RESET, mask);
+           if(!is_ar933x())
+               udelay(1000 * 100);
+
+           ar7240_reg_rmw_clear(AR7240_RESET, mask);
+           if(!is_ar933x())
+               udelay(1000 * 100);
+
+           if(!is_ar933x())
+               udelay(10 * 1000);
+        }
+
+        ag7240_hw_start(ag7240_macs[i]);
+        ag7240_setup_fifos(ag7240_macs[i]);
+
+        if(!is_ar933x())
+            udelay(100 * 1000);
+
+        {
+            unsigned char *mac = dev[i]->enetaddr;
+
+            printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+                   mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+                   mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+        }
+        mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+        mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+            (dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+        ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR1, mac_l);
+        ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR2, mac_h);
+
+        /* if using header for register configuration, we have to     */
+        /* configure s26 register after frame transmission is enabled */
+
+        if (ag7240_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef CONFIG_AR7242_S16_PHY
+            if (is_ar7242() || is_wasp()) {
+                athrs16_reg_init();
+            } else
+#endif
+            {
+#ifdef CFG_ATHRS26_PHY
+                athrs26_reg_init();
+#endif
+#ifdef CFG_ATHRS27_PHY
+                printf("s27 reg init \n");
+                athrs27_reg_init();
+#endif
+#ifdef CONFIG_F1E_PHY
+               printf("F1Phy reg init \n");
+               athr_reg_init();
+#endif
+            }
+        } else {
+#ifdef CFG_ATHRS26_PHY
+                printf("athrs26_reg_init_lan\n");
+                athrs26_reg_init_lan();
+#endif
+#ifdef CFG_ATHRS27_PHY
+            printf("s27 reg init lan \n");
+            athrs27_reg_init_lan();
+#endif
+        }
+
+        ag7240_phy_setup(ag7240_macs[i]->mac_unit);
+        printf("%s up\n",dev[i]->name);
+    }
+
+    return 1;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+uint16_t
+ag7240_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg)
+{
+    ag7240_mac_t *mac   = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg, val;
+    volatile int           rddata;
+    uint16_t      ii = 0xFFFF;
+
+
+    /*
+     * Check for previous transactions are complete. Added to avoid
+     * race condition while running at higher frequencies.
+     */
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if (ii == 0)
+        printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, AG7240_MGMT_CMD_READ);
+
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+   if(ii==0)
+      printf("Error!!! Leave ag7240_miiphy_read without polling correct status!\n");
+
+    val = ag7240_reg_rd(mac, AG7240_MII_MGMT_STATUS);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+
+    return val;
+}
+
+void
+ag7240_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+    ag7240_mac_t *mac = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg;
+    volatile int rddata;
+    uint16_t      ii = 0xFFFF;
+
+     /*
+     * Check for previous transactions are complete. Added to avoid
+     * race condition while running at higher frequencies.
+     */
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if (ii == 0)
+        printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CTRL, data);
+
+    do
+    {
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if(ii==0)
+        printf("Error!!! Leave ag7240_miiphy_write without polling correct status!\n");
+}
+#endif		/* CONFIG_COMMANDS & CFG_CMD_MII */
diff --git a/cpu/mips/ar7240/ag7240.h b/cpu/mips/ar7240/ag7240.h
new file mode 100644
index 0000000000..5f2a708377
--- /dev/null
+++ b/cpu/mips/ar7240/ag7240.h
@@ -0,0 +1,237 @@
+#ifndef _AG7240_H
+#define _AG7240_H
+
+#include <linux/types.h>
+
+/*
+ * h/w descriptor
+ */
+typedef struct {
+    uint32_t    pkt_start_addr;
+
+    uint32_t    is_empty       :  1;
+    uint32_t    res1           : 10;
+    uint32_t    ftpp_override  :  5;
+    uint32_t    res2           :  4;
+    uint32_t    pkt_size       : 12;
+
+    uint32_t    next_desc      ;
+}ag7240_desc_t;
+
+#define NO_OF_TX_FIFOS  8
+#define NO_OF_RX_FIFOS  8
+
+typedef struct {
+    ag7240_desc_t *fifo_tx[NO_OF_TX_FIFOS];
+    ag7240_desc_t *fifo_rx[NO_OF_RX_FIFOS];
+    struct eth_device *dev;
+    u32            next_tx;
+    u32            next_rx;
+    u32            link;
+    u32            duplex;
+    u32            speed;
+    u32		   mac_unit;
+    u32 	   mac_base;
+    
+}ag7240_mac_t;
+
+#define ag7240_reg_wr(_mac, _x, _y)   ar7240_reg_wr(((_x) + _mac->mac_base), (_y))
+#define ag7240_reg_rd(_mac, _x)       ar7240_reg_rd(((_x) + _mac->mac_base))
+
+#define ag7240_reg_rmw_set(_mac, _x, _y)   \
+    ar7240_reg_rmw_set(((_x) + _mac->mac_base ), (_y))
+#define ag7240_reg_rmw_clear(_mac, _x, _y)    \
+    ar7240_reg_rmw_clear(((_x) + _mac->mac_base), (_y))
+
+#ifdef COMPRESSED_UBOOT
+#define _1000BASET 1000
+#define _100BASET 100
+#define _10BASET 10
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/*
+ * spd is _1000BASET, _100BASET etc. defined in include/miiphy.h
+ */
+#define mii_reg(_mac)   (AR7240_MII0_CTRL + ((_mac)->mac_unit * 4))
+#define mii_if(_mac)    (((_mac)->mac_unit == 0) ? mii0_if : mii1_if)
+
+#define ag7240_set_mii_ctrl_speed(_mac, _spd)   do {                        \
+    ar7240_reg_rmw_clear(mii_reg(_mac), (3 << 4));                          \
+    ar7240_reg_rmw_set(mii_reg(_mac), ((_spd) << 4));                       \
+}while(0);
+
+#if defined (CFG_MII0_GMII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_MII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_RGMII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_RMII)
+#define ag7240_get_mii_if()             0
+#endif
+        
+#define MAX_WAIT        1000
+
+/*
+ * Config/Mac Register definitions
+ */
+#define AG7240_MAC_CFG1             0x00
+#define AG7240_MAC_CFG2             0x04
+#define AG7240_MAC_IFCTL            0x38
+
+/*
+ * fifo control registers
+ */
+#define AG7240_MAC_FIFO_CFG_0      0x48
+#define AG7240_MAC_FIFO_CFG_1      0x4c
+#define AG7240_MAC_FIFO_CFG_2      0x50
+#define AG7240_MAC_FIFO_CFG_3      0x54
+#define AG7240_MAC_FIFO_CFG_4      0x58
+
+#define AG7240_MAC_FIFO_CFG_5      0x5c
+#define AG7240_BYTE_PER_CLK_EN     (1 << 19)
+
+#define AG7240_MAC_FIFO_RAM_0      0x60
+#define AG7240_MAC_FIFO_RAM_1      0x64
+#define AG7240_MAC_FIFO_RAM_2      0x68
+#define AG7240_MAC_FIFO_RAM_3      0x6c
+#define AG7240_MAC_FIFO_RAM_4      0x70
+#define AG7240_MAC_FIFO_RAM_5      0x74
+#define AG7240_MAC_FIFO_RAM_6      0x78
+#define AG7240_MAC_FIFO_RAM_7      0x7c
+
+/*
+ * fields
+ */
+#define AG7240_MAC_CFG1_SOFT_RST       (1 << 31)
+#define AG7240_MAC_CFG1_RX_RST         (1 << 19)
+#define AG7240_MAC_CFG1_TX_RST         (1 << 18)
+#define AG7240_MAC_CFG1_LOOPBACK       (1 << 8)
+#define AG7240_MAC_CFG1_RX_EN          (1 << 2)
+#define AG7240_MAC_CFG1_TX_EN          (1 << 0)
+
+#define AG7240_MAC_CFG2_FDX            (1 << 0)
+#define AG7240_MAC_CFG2_PAD_CRC_EN     (1 << 2)
+#define AG7240_MAC_CFG2_LEN_CHECK      (1 << 4)
+#define AG7240_MAC_CFG2_HUGE_FRAME_EN  (1 << 5)
+#define AG7240_MAC_CFG2_IF_1000        (1 << 9)
+#define AG7240_MAC_CFG2_IF_10_100      (1 << 8)
+
+#define AG7240_MAC_IFCTL_SPEED         (1 << 16)
+
+/*
+ * DMA (tx/rx) register defines
+ */
+#define AG7240_DMA_TX_CTRL              0x180
+#define AG7240_DMA_TX_DESC              0x184
+#define AG7240_DMA_TX_STATUS            0x188
+#define AG7240_DMA_RX_CTRL              0x18c
+#define AG7240_DMA_RX_DESC              0x190
+#define AG7240_DMA_RX_STATUS            0x194
+#define AG7240_DMA_INTR_MASK            0x198
+#define AG7240_DMA_INTR                 0x19c
+
+/*
+ * tx/rx ctrl and status bits
+ */
+#define AG7240_TXE                      (1 << 0)
+#define AG7240_TX_STATUS_PKTCNT_SHIFT   16
+#define AG7240_TX_STATUS_PKT_SENT       0x1
+#define AG7240_TX_STATUS_URN            0x2
+#define AG7240_TX_STATUS_BUS_ERROR      0x8
+
+#define AG7240_RXE                      (1 << 0)
+
+#define AG7240_RX_STATUS_PKTCNT_MASK    0xff0000
+#define AG7240_RX_STATUS_PKT_RCVD       (1 << 0)
+#define AG7240_RX_STATUS_OVF            (1 << 2)
+#define AG7240_RX_STATUS_BUS_ERROR      (1 << 3)
+
+/*
+ * Int and int mask
+ */
+#define AG7240_INTR_TX                  (1 << 0)
+#define AG7240_INTR_TX_URN              (1 << 1)
+#define AG7240_INTR_TX_BUS_ERROR        (1 << 3)
+#define AG7240_INTR_RX                  (1 << 4)
+#define AG7240_INTR_RX_OVF              (1 << 6)
+#define AG7240_INTR_RX_BUS_ERROR        (1 << 7)
+
+/*
+ * MII registers
+ */
+#define AG7240_MAC_MII_MGMT_CFG         0x20
+#define AG7240_MGMT_CFG_CLK_DIV_20      0x07
+
+#define AG7240_MII_MGMT_CMD             0x24
+#define AG7240_MGMT_CMD_READ            0x1
+
+#define AG7240_MII_MGMT_ADDRESS         0x28
+#define AG7240_ADDR_SHIFT               8
+
+#define AG7240_MII_MGMT_CTRL            0x2c
+#define AG7240_MII_MGMT_STATUS          0x30
+
+#define AG7240_MII_MGMT_IND             0x34
+#define AG7240_MGMT_IND_BUSY            (1 << 0)
+#define AG7240_MGMT_IND_INVALID         (1 << 2)
+
+#define AG7240_GE_MAC_ADDR1             0x40
+#define AG7240_GE_MAC_ADDR2             0x44
+
+/*
+ * Ethernet config registers
+ */
+#define AG7240_ETH_CFG                  0x18070000
+#define AG7240_ETH_CFG_RGMII_GE0        (1<<0)
+#define AG7240_ETH_CFG_MII_GE0          (1<<1)
+#define AG7240_ETH_CFG_GMII_GE0         (1<<2)
+#define AG7240_ETH_CFG_MII_GE0_MASTER   (1<<3)
+#define AG7240_ETH_CFG_MII_GE0_SLAVE    (1<<4)
+#define AG7240_ETH_CFG_GE0_ERR_EN       (1<<5)
+#define AG7240_ETH_CFG_SW_ONLY_MODE     (1<<6)
+#define AG7240_ETH_CFG_SW_PHY_SWAP      (1<<7)
+#define AG7240_ETH_CFG_SW_PHY_ADDR_SWAP (1<<8)
+#define AG7240_ETH_SWITCH_CLK_SPARE     0x18050024
+
+
+/*
+ *  * ownership of descriptors between DMA and cpu
+ *   */
+#define ag7240_rx_owned_by_dma(_ds)     ((_ds)->is_empty == 1)
+#define ag7240_rx_give_to_dma(_ds)      ((_ds)->is_empty = 1)
+#define ag7240_tx_owned_by_dma(_ds)     ((_ds)->is_empty == 0)
+#define ag7240_tx_give_to_dma(_ds)      ((_ds)->is_empty = 0)
+#define ag7240_tx_own(_ds)              ((_ds)->is_empty = 1)
+
+/*
+ * link settings
+ */
+#define ag7240_set_mac_duplex(_mac, _fdx)       do {                         \
+    if ((_fdx))                                                              \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_FDX)     \
+    else                                                                     \
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_FDX)   \
+}while(0)
+
+#define ag7240_set_mac_if(_mac, _isXGMII)    do {                              \
+    ag7240_reg_rmw_clear(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_1000|      \
+                                          AG7240_MAC_CFG2_IF_10_100);   \
+    if ((_isXGMII)) {                                            \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_1000)  \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_FIFO_CFG_5, AG7240_BYTE_PER_CLK_EN);\
+    }                                                                       \
+    else {                                                              \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_10_100)\
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_FIFO_CFG_5, AG7240_BYTE_PER_CLK_EN);\
+    }                                                                       \
+}while(0)
+
+#define ag7240_set_mac_speed(_mac, _is100)   do {                             \
+    if ((_is100))                                                             \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_IFCTL, AG7240_MAC_IFCTL_SPEED)  \
+    else                                                                      \
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_IFCTL, AG7240_MAC_IFCTL_SPEED)\
+}while(0)
+
+#endif
diff --git a/cpu/mips/ar7240/ag7240_phy.h b/cpu/mips/ar7240/ag7240_phy.h
new file mode 100644
index 0000000000..02ea970a2f
--- /dev/null
+++ b/cpu/mips/ar7240/ag7240_phy.h
@@ -0,0 +1,69 @@
+#ifndef _AG7240_PHY_H
+#define _AG7240_PHY_H
+
+static inline void ag7240_phy_setup(int unit)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        athrs16_phy_setup(unit);
+    } else
+#endif
+    {
+        athrs26_phy_setup(unit);
+#ifdef CONFIG_F1E_PHY
+        athr_phy_setup(unit);
+#endif
+    }
+}
+
+static inline void ag7240_phy_link(int unit, int *link)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+         *link = athrs16_phy_is_up(unit);
+    } else
+#endif
+    {
+#ifdef CFG_ATHRS27_PHY
+         *link = athrs27_phy_is_up(unit);
+#endif
+#ifdef CFG_ATHRS26_PHY
+         *link = athrs26_phy_is_up(unit);
+#endif
+#ifdef CONFIG_F1E_PHY
+         *link = athr_phy_is_up(unit);
+#endif
+    }
+}
+
+static inline void ag7240_phy_duplex(int unit, int *duplex)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        *duplex = athrs16_phy_is_fdx(unit);
+    } else
+#endif
+    {
+        *duplex = athrs26_phy_is_fdx(unit);
+#ifdef CONFIG_F1E_PHY
+        *duplex = athr_phy_is_fdx(unit);
+#endif
+    }
+}
+
+static inline void ag7240_phy_speed(int unit, int *speed)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        *speed = athrs16_phy_speed(unit);
+    } else
+#endif
+    {
+        *speed = athrs26_phy_speed(unit);
+#ifdef CONFIG_F1E_PHY
+        *speed = athr_phy_speed(unit);
+#endif
+    }
+}
+
+#endif /*_AG7240_PHY_H*/
diff --git a/cpu/mips/ar7240/ag934x.c b/cpu/mips/ar7240/ag934x.c
new file mode 100644
index 0000000000..5de8900f19
--- /dev/null
+++ b/cpu/mips/ar7240/ag934x.c
@@ -0,0 +1,877 @@
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#include "ar7240_soc.h"
+#include "ag934x.h"
+#include "ag934x_phy.h"
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ag7240_unit2mac(_unit)     ag7240_macs[(_unit)]
+#define ag7240_name2mac(name)	   strcmp(name,"eth0") ? ag7240_unit2mac(1) : ag7240_unit2mac(0)
+
+uint16_t ag7240_miiphy_read(char *devname, uint32_t phaddr,
+	       uint8_t reg);
+void  ag7240_miiphy_write(char *devname, uint32_t phaddr,
+	        uint8_t reg, uint16_t data);
+
+ag7240_mac_t *ag7240_macs[CFG_AG7240_NMACS];
+extern void ar7240_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq);
+
+#ifdef CFG_ATHRS26_PHY
+extern int athrs26_phy_setup(int unit);
+extern int athrs26_phy_is_up(int unit);
+extern int athrs26_phy_is_fdx(int unit);
+extern int athrs26_phy_speed(int unit);
+extern void athrs26_reg_init(void);
+extern void athrs26_reg_init_lan(void);
+extern int athrs26_mdc_check(void);
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+extern int athrs27_phy_setup(int unit);
+extern int athrs27_phy_is_up(int unit);
+extern int athrs27_phy_is_fdx(int unit);
+extern int athrs27_phy_speed(int unit);
+extern void athrs27_reg_init(void);
+extern void athrs27_reg_init_lan(void);
+extern int athrs27_mdc_check(void);
+#endif
+
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_F2E_PHY)
+extern int athr_phy_setup(int unit);
+extern int athr_phy_is_up(int unit);
+extern int athr_phy_is_fdx(int unit);
+extern int athr_phy_speed(int unit);
+extern void athr_reg_init(void);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+extern int athr_vir_phy_setup(int unit);
+extern int athr_vir_phy_is_up(int unit);
+extern int athr_vir_phy_is_fdx(int unit);
+extern int athr_vir_phy_speed(int unit);
+extern void athr_vir_reg_init(void);
+#endif
+
+#ifdef CONFIG_ATH_NAND_BR
+
+#define ATH_ETH_MAC_READ_SIZE 4096
+extern unsigned long long 
+ath_nand_get_cal_offset(const char *ba);
+#endif
+
+static int
+ag7240_send(struct eth_device *dev, volatile void *packet, int length)
+{
+    int i;
+
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+
+    ag7240_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+    f->pkt_size = length;
+    f->res1 = 0;
+    f->pkt_start_addr = virt_to_phys(packet);
+
+    ag7240_tx_give_to_dma(f);
+    flush_cache((u32) packet, length);
+    ag7240_reg_wr(mac, AG7240_DMA_TX_DESC, virt_to_phys(f));
+    ag7240_reg_wr(mac, AG7240_DMA_TX_CTRL, AG7240_TXE);
+
+    for (i = 0; i < MAX_WAIT; i++) {
+        udelay(10);
+        if (!ag7240_tx_owned_by_dma(f))
+            break;
+    }
+    if (i == MAX_WAIT)
+        printf("Tx Timed out\n");
+
+    f->pkt_start_addr = 0;
+    f->pkt_size = 0;
+
+    if (++mac->next_tx >= NO_OF_TX_FIFOS)
+        mac->next_tx = 0;
+
+    return (0);
+}
+
+static int ag7240_recv(struct eth_device *dev)
+{
+    int length;
+    ag7240_desc_t *f;
+    ag7240_mac_t *mac;
+ 
+    mac = (ag7240_mac_t *)dev->priv;
+
+    for (;;) {
+        f = mac->fifo_rx[mac->next_rx];
+        if (ag7240_rx_owned_by_dma(f))
+            break;
+
+        length = f->pkt_size;
+
+        NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+        flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+        ag7240_rx_give_to_dma(f);
+
+        if (++mac->next_rx >= NO_OF_RX_FIFOS)
+            mac->next_rx = 0;
+    }
+
+    if (!(ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL))) {
+        ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(f));
+        ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 1);
+    }
+
+    return (0);
+}
+
+void ag7240_mii_setup(ag7240_mac_t *mac)
+{
+    u32 mgmt_cfg_val;
+    u32 cpu_freq,ddr_freq,ahb_freq;
+    u32 check_cnt,revid_val;
+
+    if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+#ifndef CFG_DUAL_PHY_SUPPORT
+        ar7240_reg_wr(AR934X_SWITCH_CLOCK_SPARE, 0x271);
+#endif
+    } else {
+        ar7240_reg_wr(AR934X_SWITCH_CLOCK_SPARE, 0x570);
+    }
+
+#if defined(CONFIG_AR7242_S16_PHY) || defined(CONFIG_ATHRS17_PHY)
+    if (is_wasp() && mac->mac_unit == 0) {
+#ifdef CONFIG_AR7242_S16_PHY
+        printf("WASP  ----> S16 PHY *\n");
+#else
+        printf("WASP  ----> S17 PHY *\n");
+#endif
+        mgmt_cfg_val = 4;
+        if(mac->mac_unit == 0)
+            ar7240_reg_wr(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+
+        udelay(1000);
+
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+        return;
+    }
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+    if (is_wasp()) {
+        printf("WASP ----> S27 PHY \n");
+        mgmt_cfg_val = 2;
+        ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+        return;
+    }
+#endif
+
+#ifdef CONFIG_F2E_PHY
+    if (is_wasp()) {
+        printf("WASP  ----> F2 PHY *\n");
+        ar7240_reg_wr(AG7240_ETH_CFG, (AG7240_ETH_CFG_RMII_MASTER_MODE | AG7240_ETH_CFG_RMII_GE0 
+                      | AG7240_ETH_CFG_RMII_HISPD_GE0));
+
+        mgmt_cfg_val = 6;
+
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+        return;
+    }
+#endif
+
+
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_VIR_PHY)
+    if (is_wasp()) {
+#ifdef CONFIG_VIR_PHY
+        printf("WASP  ----> VIR PHY *\n");
+#else
+        printf("WASP  ----> F1 PHY *\n");
+#endif
+        if(mac->mac_unit == 0)
+            ar7240_reg_wr(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+
+        mgmt_cfg_val = 6;
+
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+        return;
+    }
+#endif
+
+    if ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7240_REV_1_2) {
+        mgmt_cfg_val = 0x2;
+        if (mac->mac_unit == 0) {
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+        }
+    }
+    else {
+        ar7240_sys_frequency(&cpu_freq, &ddr_freq, &ahb_freq);
+        switch (ahb_freq/1000000) {
+            case 150:
+                     mgmt_cfg_val = 0x7;
+                     break;
+            case 175:
+                     mgmt_cfg_val = 0x5;
+                     break;
+            case 200:
+                     mgmt_cfg_val = 0x4;
+                     break;
+            case 210:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            case 220:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            default:
+                     mgmt_cfg_val = 0x7;
+        }
+        if ((is_ar7241() || is_ar7242())) {
+
+            /* External MII mode */
+            if (mac->mac_unit == 0 && is_ar7242()) {
+                 mgmt_cfg_val = 0x6;
+                 ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+                 ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                 ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            }
+            /* Virian */
+            mgmt_cfg_val = 0x4;
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            printf("Virian MDC CFG Value ==> %x\n",mgmt_cfg_val);
+
+        }
+      else if(is_ar933x()){
+                //GE0 receives Rx/Tx clock, and use S26 phy
+                ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_MII_GE0_SLAVE);
+                mgmt_cfg_val = 0xF;
+                if (mac->mac_unit == 1) {
+                        check_cnt = 0;
+                        while (check_cnt++ < 10) {
+                                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+#ifdef CFG_ATHRS26_PHY
+                                if(athrs26_mdc_check() == 0)
+                                        break;
+#endif
+                        }
+                        if(check_cnt == 11)
+                                printf("%s: MDC check failed\n", __func__);
+                }
+      }
+        else { /* Python 1.0 & 1.1 */
+             if (mac->mac_unit == 0) {
+                     check_cnt = 0;
+                     while (check_cnt++ < 10) {
+                             ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                             ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+#ifdef CFG_ATHRS26_PHY
+                             if(athrs26_mdc_check() == 0)
+                                     break;
+#endif
+                     }
+                     if(check_cnt == 11)
+                             printf("%s: MDC check failed\n", __func__);
+             }
+        }
+ 
+    }
+}
+
+static void ag7240_hw_start(ag7240_mac_t *mac)
+{
+
+    if(mac->mac_unit)
+    {
+        ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+            AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_1000));
+    }
+    else {
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+		         AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_10_100));
+   }
+   ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_0, 0x1f00);
+
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0x10ffff);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0xAAA0555);
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_4, 0x3ffff);
+    /* 
+     * Setting Drop CRC Errors, Pause Frames,Length Error frames 
+     * and Multi/Broad cast frames. 
+     */
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0x7eccf);
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_3, 0x1f00140);
+
+    printf(": cfg1 %#x cfg2 %#x\n", ag7240_reg_rd(mac, AG7240_MAC_CFG1),
+        ag7240_reg_rd(mac, AG7240_MAC_CFG2));
+
+}
+
+static int ag7240_check_link(ag7240_mac_t *mac)
+{
+    u32 link, duplex, speed, fdx;
+
+    ag7240_phy_link(mac->mac_unit, &link);
+    ag7240_phy_duplex(mac->mac_unit, &duplex);
+    ag7240_phy_speed(mac->mac_unit, &speed);
+
+    mac->link = link;
+#ifdef SUPPORT_PLC
+    if(strcmp(mac->dev->name, "eth0") == 0) {
+        printf("ag7240_check_link: %s link forced down\n",mac->dev->name);
+        return 0;
+    }
+#endif
+
+    if(!mac->link) {
+        printf("%s link down\n",mac->dev->name);
+        return 0;
+    }
+
+    switch (speed)
+    {
+       case _1000BASET:
+           ag7240_set_mac_if(mac, 1);
+           ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if (is_ar7242() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1c000000);
+	   }
+#ifdef CONFIG_F1E_PHY
+           if (is_wasp() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0e000000);
+	   }
+#elif CONFIG_VIR_PHY
+           if (is_wasp() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x82000000);
+               ar7240_reg_wr(AG7240_ETH_CFG,0x000c0001);
+	   }
+#else      
+           if (is_wasp() && (mac->mac_unit == 0) && !is_f2e()) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x06000000);
+	   }
+#endif
+          if (is_wasp() && mac->mac_unit == 0 && is_f1e() ) {
+              ar7240_reg_rmw_set(AG7240_ETH_CFG,AG7240_ETH_CFG_RXD_DELAY);
+              ar7240_reg_rmw_set(AG7240_ETH_CFG,AG7240_ETH_CFG_RDV_DELAY);
+          }
+
+          break;
+
+       case _100BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 1);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if ((is_ar7242() || is_wasp()) && (mac->mac_unit == 0) && !is_f2e())
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0101);
+	
+           if (is_wasp() && mac->mac_unit == 0 && is_f1e()) {
+               ar7240_reg_rmw_clear(AG7240_ETH_CFG,AG7240_ETH_CFG_RXD_DELAY);
+               ar7240_reg_rmw_clear(AG7240_ETH_CFG,AG7240_ETH_CFG_RDV_DELAY);
+           }
+           break;
+
+       case _10BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 0);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+
+           if ((is_ar7242() || is_wasp()) && (mac->mac_unit == 0) && !is_f2e())
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1616);
+
+           if (is_wasp() && mac->mac_unit == 0 && is_f1e()) {
+               ar7240_reg_rmw_clear(AG7240_ETH_CFG,AG7240_ETH_CFG_RXD_DELAY);
+               ar7240_reg_rmw_clear(AG7240_ETH_CFG,AG7240_ETH_CFG_RDV_DELAY);
+	       ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1313);
+           }
+	   if (is_f2e()) {
+               ar7240_reg_rmw_clear(AG7240_ETH_CFG, AG7240_ETH_CFG_RMII_HISPD_GE0);
+           }
+           break;
+
+       default:
+          printf("Invalid speed detected\n");
+          return 0;
+    }
+
+   if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+        return 1; 
+
+    mac->duplex = duplex;
+    mac->speed = speed;
+
+    printf("dup %d speed %d\n", duplex, speed);
+
+    ag7240_set_mac_duplex(mac,duplex);
+
+    return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ag7240_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+    int i;
+    ag7240_desc_t *fr;
+    ag7240_mac_t *mac = (ag7240_mac_t*)dev->priv;
+
+    if (!ag7240_check_link(mac))
+        return 0;
+
+    mac->next_rx = 0;
+
+/** 
+ * @ when executing TFTP transfers at -10C
+ * @ time taken for auto negotiation and link to settled down
+ * @ is quite high. provide 3 Sec delay for s17 link to settle
+ * @ down. Works fine at room temparature, 0C -3C
+   @ Suggested by systems team.
+ */
+    
+#ifdef  CONFIG_ATHRS17_PHY 
+    udelay(1000 * 3000);
+#endif
+    ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
+		    AG7240_MAC_CFG1_TX_EN));
+   
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        fr = mac->fifo_rx[i];
+        fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+        flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+        ag7240_rx_give_to_dma(fr);
+    }
+
+    ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, AG7240_RXE);	/* rx start */
+    udelay(1000 * 1000);
+
+
+    return 1;
+
+}
+
+static int ag7240_alloc_fifo(int ndesc, ag7240_desc_t ** fifo)
+{
+    int i;
+    u32 size;
+    uchar *p = NULL;
+
+    size = sizeof(ag7240_desc_t) * ndesc;
+    size += CFG_CACHELINE_SIZE - 1;
+
+    if ((p = malloc(size)) == NULL) {
+        printf("Cant allocate fifos\n");
+        return -1;
+    }
+
+    p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+	   ~(CFG_CACHELINE_SIZE - 1));
+    p = UNCACHED_SDRAM(p);
+
+    for (i = 0; i < ndesc; i++)
+        fifo[i] = (ag7240_desc_t *) p + i;
+
+    return 0;
+}
+
+static int ag7240_setup_fifos(ag7240_mac_t *mac)
+{
+    int i;
+
+    if (ag7240_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+        return 1;
+
+    for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+        mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+        ag7240_tx_own(mac->fifo_tx[i]);
+    }
+
+    if (ag7240_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+        return 1;
+
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+    }
+
+    return (1);
+}
+
+static void ag7240_halt(struct eth_device *dev)
+{
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 0);
+    while (ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL));
+}
+
+#ifdef CONFIG_ATH_NAND_BR
+
+unsigned char *
+ath_eth_mac_addr(unsigned char *sectorBuff)
+{
+    ulong   off, size;
+    nand_info_t *nand;
+    unsigned char ret;
+    	
+    /* 
+     * caldata partition is of 128k 
+     *
+     */
+    nand = &nand_info[nand_curr_device];
+    size = ATH_ETH_MAC_READ_SIZE; /* To read 4k setting size as 4k */
+    
+    /*
+     * Get the Offset of Caldata partition
+     */
+    off = ath_nand_get_cal_offset(getenv("bootargs"));
+    if(off == ATH_CAL_OFF_INVAL) {
+    	printf("Invalid CAL offset \n");
+    	return NULL;
+    }
+    /*
+     * Get the values from flash, and program into the MAC address
+     * registers
+     */
+    ret = nand_read(nand, (loff_t)off, &size, (u_char *)sectorBuff);
+    printf(" %d bytes %s: %s\n", size,
+    	       "read", ret ? "ERROR" : "OK");
+    if(ret != 0 ) {
+    	return NULL;
+    }
+
+    return sectorBuff;
+}
+
+#else  /* CONFIG_ATH_NAND_BR */
+
+unsigned char *
+ag7240_mac_addr_loc(void)
+{
+	extern flash_info_t flash_info[];
+
+#ifdef BOARDCAL
+    /*
+    ** BOARDCAL environmental variable has the address of the cal sector
+    */
+    
+    return ((unsigned char *)BOARDCAL);
+    
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+		(KSEG1ADDR(AR7240_SPI_BASE) + (4 * 1024) +
+		flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+#endif  /* CONFIG_ATH_NAND_BR */
+
+static void ag7240_get_ethaddr(struct eth_device *dev)
+{
+    unsigned char *eeprom;
+    unsigned char *mac = dev->enetaddr;
+#ifndef CONFIG_AR7240_EMU
+
+#ifdef CONFIG_ATH_NAND_BR
+    unsigned char sectorBuff[ATH_ETH_MAC_READ_SIZE];
+
+    eeprom = ath_eth_mac_addr(sectorBuff);
+    if(eeprom == NULL) {
+        /* mac address will be set to default mac address */
+        mac[0] = 0xff;
+    }
+    else {
+#else  /* CONFIG_ATH_NAND_BR */
+        eeprom = ag7240_mac_addr_loc();
+#endif  /* CONFIG_ATH_NAND_BR */
+
+        if (strcmp(dev->name, "eth0") == 0) {
+            memcpy(mac, eeprom, 6);
+        } else if (strcmp(dev->name, "eth1") == 0) {
+            eeprom += 6;
+            memcpy(mac, eeprom, 6);
+        } else {
+            printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+            return;
+        }
+#ifdef CONFIG_ATH_NAND_BR
+    }
+#endif  /* CONFIG_ATH_NAND_BR */
+    /* Use fixed address if the above address is invalid */
+    if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff)) {
+#else
+    if (1) {
+#endif 
+        mac[0] = 0x00;
+        mac[1] = 0x03;
+        mac[2] = 0x7f;
+        mac[3] = 0x09;
+        mac[4] = 0x0b;
+        mac[5] = 0xad;
+        printf("No valid address in Flash. Using fixed address\n");
+    } else {
+        printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+    }
+}
+
+
+int ag7240_enet_initialize(bd_t * bis)
+{
+    struct eth_device *dev[CFG_AG7240_NMACS];
+    u32 mask, mac_h, mac_l;
+    int i;
+
+    printf("ag934x_enet_initialize...\n");
+
+    if(is_ar933x() && (ar7240_reg_rd(AR7240_RESET)!=0))
+         ar7240_reg_wr(AR7240_RESET,0);
+   
+    if(is_ar933x())  //Turn on LED
+        ar7240_reg_wr(AR7240_GPIO_BASE + 0x28 , ar7240_reg_rd(AR7240_GPIO_BASE + 0x28)  | (0xF8));
+
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+
+    if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+	
+    if ((ag7240_macs[i] = (ag7240_mac_t *) malloc(sizeof (ag7240_mac_t))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+
+    memset(ag7240_macs[i], 0, sizeof(ag7240_macs[i]));
+    memset(dev[i], 0, sizeof(dev[i]));
+
+    sprintf(dev[i]->name, "eth%d", i);
+    ag7240_get_ethaddr(dev[i]);
+
+    ag7240_macs[i]->mac_unit = i;
+    ag7240_macs[i]->mac_base = i ? AR7240_GE1_BASE : AR7240_GE0_BASE ;
+    ag7240_macs[i]->dev = dev[i];
+
+    dev[i]->iobase = 0;
+    dev[i]->init = ag7240_clean_rx;
+    dev[i]->halt = ag7240_halt;
+    dev[i]->send = ag7240_send;
+    dev[i]->recv = ag7240_recv;
+    dev[i]->priv = (void *)ag7240_macs[i];
+    }
+#if !defined(CONFIG_ATH_NAND_BR)
+    mask = AR7240_RESET_GE1_PHY;
+    ar7240_reg_rmw_set(AR7240_RESET, mask);
+    udelay(1000 * 100);
+    ar7240_reg_rmw_clear(AR7240_RESET, mask);
+    udelay(100);
+#endif
+    mask = AR7240_RESET_GE0_PHY;
+    ar7240_reg_rmw_set(AR7240_RESET, mask);
+    udelay(1000 * 100);
+    ar7240_reg_rmw_clear(AR7240_RESET, mask);
+    udelay(100);
+    
+    
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+        eth_register(dev[i]);
+#if(CONFIG_COMMANDS & CFG_CMD_MII)
+        miiphy_register(dev[i]->name, ag7240_miiphy_read, ag7240_miiphy_write);
+#endif
+
+         ag7240_reg_rmw_set(ag7240_macs[i], AG7240_MAC_CFG1, AG7240_MAC_CFG1_SOFT_RST
+                | AG7240_MAC_CFG1_RX_RST | AG7240_MAC_CFG1_TX_RST);
+
+        if(!i) {
+           mask = (AR7240_RESET_GE0_MAC  | AR7240_RESET_GE1_MAC);
+
+           if (is_ar7241() || is_ar7242() ||  is_wasp())
+               mask = mask | AR7240_RESET_GE0_MDIO | AR7240_RESET_GE1_MDIO;
+
+    	   printf(" wasp  reset mask:%x \n",mask);
+
+           ar7240_reg_rmw_set(AR7240_RESET, mask);
+           udelay(1000 * 100);
+
+           ar7240_reg_rmw_clear(AR7240_RESET, mask);
+           udelay(1000 * 100);
+
+           udelay(10 * 1000);
+        }
+
+	ag7240_mii_setup(ag7240_macs[i]);
+
+        /* if using header for register configuration, we have to     */
+        /* configure s26 register after frame transmission is enabled */
+
+        if (ag7240_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef CONFIG_AR7242_S16_PHY
+            if (is_ar7242() || is_wasp()) {
+                athrs16_reg_init();
+            } else
+#endif
+            {
+#ifdef  CONFIG_ATHRS17_PHY
+                athrs17_reg_init();
+#endif
+
+#ifdef CFG_ATHRS26_PHY
+                athrs26_reg_init();
+#endif
+#ifdef CFG_ATHRS27_PHY
+                printf("s27 reg init \n");
+                athrs27_reg_init();
+#endif
+#ifdef CONFIG_F1E_PHY
+               printf("F1Phy reg init \n");
+               athr_reg_init();
+#endif
+#ifdef CONFIG_VIR_PHY
+               printf("VIRPhy reg init \n");
+               athr_vir_reg_init();
+#endif
+#ifdef CONFIG_F2E_PHY
+               printf("F2Phy reg init \n");
+               athr_reg_init();
+#endif
+
+            }
+        } else {
+#ifdef CFG_ATHRS26_PHY
+                athrs26_reg_init_lan();
+#endif
+#ifdef CFG_ATHRS27_PHY
+            printf("s27 reg init lan \n");
+            athrs27_reg_init_lan();
+#endif
+        }
+        ag7240_hw_start(ag7240_macs[i]);
+        ag7240_setup_fifos(ag7240_macs[i]);
+
+        udelay(100 * 1000);
+
+        {
+            unsigned char *mac = dev[i]->enetaddr;
+
+            printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+                   mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+                   mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+        }
+        mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+        mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+            (dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+        ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR1, mac_l);
+        ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR2, mac_h);
+
+
+        ag7240_phy_setup(ag7240_macs[i]->mac_unit);
+        printf("%s up\n",dev[i]->name);
+    }
+
+    return 1;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+uint16_t
+ag7240_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg)
+{
+    ag7240_mac_t *mac   = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg, val;
+    volatile int           rddata;
+    uint16_t      ii = 0xFFFF;
+
+
+    /*
+     * Check for previous transactions are complete. Added to avoid
+     * race condition while running at higher frequencies.
+     */
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if (ii == 0)
+        printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, AG7240_MGMT_CMD_READ);
+
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+   if(ii==0)
+      printf("Error!!! Leave ag7240_miiphy_read without polling correct status!\n");
+
+    val = ag7240_reg_rd(mac, AG7240_MII_MGMT_STATUS);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+
+    return val;
+}
+
+void
+ag7240_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+    ag7240_mac_t *mac = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg;
+    volatile int rddata;
+    uint16_t      ii = 0xFFFF;
+
+     /*
+     * Check for previous transactions are complete. Added to avoid
+     * race condition while running at higher frequencies.
+     */
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if (ii == 0)
+        printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CTRL, data);
+
+    do
+    {
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if(ii==0)
+        printf("Error!!! Leave ag7240_miiphy_write without polling correct status!\n");
+}
+#endif		/* CONFIG_COMMANDS & CFG_CMD_MII */
diff --git a/cpu/mips/ar7240/ag934x.h b/cpu/mips/ar7240/ag934x.h
new file mode 100644
index 0000000000..7a9b476068
--- /dev/null
+++ b/cpu/mips/ar7240/ag934x.h
@@ -0,0 +1,242 @@
+#ifndef _AG7240_H
+#define _AG7240_H
+
+#include <linux/types.h>
+
+/*
+ * h/w descriptor
+ */
+typedef struct {
+    uint32_t    pkt_start_addr;
+
+    uint32_t    is_empty       :  1;
+    uint32_t    res1           : 10;
+    uint32_t    ftpp_override  :  5;
+    uint32_t    res2           :  4;
+    uint32_t    pkt_size       : 12;
+
+    uint32_t    next_desc      ;
+}ag7240_desc_t;
+
+#define NO_OF_TX_FIFOS  8
+#define NO_OF_RX_FIFOS  8
+
+typedef struct {
+    ag7240_desc_t *fifo_tx[NO_OF_TX_FIFOS];
+    ag7240_desc_t *fifo_rx[NO_OF_RX_FIFOS];
+    struct eth_device *dev;
+    u32            next_tx;
+    u32            next_rx;
+    u32            link;
+    u32            duplex;
+    u32            speed;
+    u32		   mac_unit;
+    u32 	   mac_base;
+    
+}ag7240_mac_t;
+
+#define ag7240_reg_wr(_mac, _x, _y)   ar7240_reg_wr(((_x) + _mac->mac_base), (_y))
+#define ag7240_reg_rd(_mac, _x)       ar7240_reg_rd(((_x) + _mac->mac_base))
+
+#define ag7240_reg_rmw_set(_mac, _x, _y)   \
+    ar7240_reg_rmw_set(((_x) + _mac->mac_base ), (_y))
+#define ag7240_reg_rmw_clear(_mac, _x, _y)    \
+    ar7240_reg_rmw_clear(((_x) + _mac->mac_base), (_y))
+
+#ifdef COMPRESSED_UBOOT
+#define _1000BASET 1000
+#define _100BASET 100
+#define _10BASET 10
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/*
+ * spd is _1000BASET, _100BASET etc. defined in include/miiphy.h
+ */
+#define mii_reg(_mac)   (AR7240_MII0_CTRL + ((_mac)->mac_unit * 4))
+#define mii_if(_mac)    (((_mac)->mac_unit == 0) ? mii0_if : mii1_if)
+
+#define ag7240_set_mii_ctrl_speed(_mac, _spd)   do {                        \
+    ar7240_reg_rmw_clear(mii_reg(_mac), (3 << 4));                          \
+    ar7240_reg_rmw_set(mii_reg(_mac), ((_spd) << 4));                       \
+}while(0);
+
+#if defined (CFG_MII0_GMII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_MII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_RGMII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_RMII)
+#define ag7240_get_mii_if()             0
+#endif
+        
+#define MAX_WAIT        1000
+
+/*
+ * Config/Mac Register definitions
+ */
+#define AG7240_MAC_CFG1             0x00
+#define AG7240_MAC_CFG2             0x04
+#define AG7240_MAC_IFCTL            0x38
+
+/*
+ * fifo control registers
+ */
+#define AG7240_MAC_FIFO_CFG_0      0x48
+#define AG7240_MAC_FIFO_CFG_1      0x4c
+#define AG7240_MAC_FIFO_CFG_2      0x50
+#define AG7240_MAC_FIFO_CFG_3      0x54
+#define AG7240_MAC_FIFO_CFG_4      0x58
+
+#define AG7240_MAC_FIFO_CFG_5      0x5c
+#define AG7240_BYTE_PER_CLK_EN     (1 << 19)
+
+#define AG7240_MAC_FIFO_RAM_0      0x60
+#define AG7240_MAC_FIFO_RAM_1      0x64
+#define AG7240_MAC_FIFO_RAM_2      0x68
+#define AG7240_MAC_FIFO_RAM_3      0x6c
+#define AG7240_MAC_FIFO_RAM_4      0x70
+#define AG7240_MAC_FIFO_RAM_5      0x74
+#define AG7240_MAC_FIFO_RAM_6      0x78
+#define AG7240_MAC_FIFO_RAM_7      0x7c
+
+/*
+ * fields
+ */
+#define AG7240_MAC_CFG1_SOFT_RST       (1 << 31)
+#define AG7240_MAC_CFG1_RX_RST         (1 << 19)
+#define AG7240_MAC_CFG1_TX_RST         (1 << 18)
+#define AG7240_MAC_CFG1_LOOPBACK       (1 << 8)
+#define AG7240_MAC_CFG1_RX_EN          (1 << 2)
+#define AG7240_MAC_CFG1_TX_EN          (1 << 0)
+
+#define AG7240_MAC_CFG2_FDX            (1 << 0)
+#define AG7240_MAC_CFG2_PAD_CRC_EN     (1 << 2)
+#define AG7240_MAC_CFG2_LEN_CHECK      (1 << 4)
+#define AG7240_MAC_CFG2_HUGE_FRAME_EN  (1 << 5)
+#define AG7240_MAC_CFG2_IF_1000        (1 << 9)
+#define AG7240_MAC_CFG2_IF_10_100      (1 << 8)
+
+#define AG7240_MAC_IFCTL_SPEED         (1 << 16)
+
+/*
+ * DMA (tx/rx) register defines
+ */
+#define AG7240_DMA_TX_CTRL              0x180
+#define AG7240_DMA_TX_DESC              0x184
+#define AG7240_DMA_TX_STATUS            0x188
+#define AG7240_DMA_RX_CTRL              0x18c
+#define AG7240_DMA_RX_DESC              0x190
+#define AG7240_DMA_RX_STATUS            0x194
+#define AG7240_DMA_INTR_MASK            0x198
+#define AG7240_DMA_INTR                 0x19c
+
+/*
+ * tx/rx ctrl and status bits
+ */
+#define AG7240_TXE                      (1 << 0)
+#define AG7240_TX_STATUS_PKTCNT_SHIFT   16
+#define AG7240_TX_STATUS_PKT_SENT       0x1
+#define AG7240_TX_STATUS_URN            0x2
+#define AG7240_TX_STATUS_BUS_ERROR      0x8
+
+#define AG7240_RXE                      (1 << 0)
+
+#define AG7240_RX_STATUS_PKTCNT_MASK    0xff0000
+#define AG7240_RX_STATUS_PKT_RCVD       (1 << 0)
+#define AG7240_RX_STATUS_OVF            (1 << 2)
+#define AG7240_RX_STATUS_BUS_ERROR      (1 << 3)
+
+/*
+ * Int and int mask
+ */
+#define AG7240_INTR_TX                  (1 << 0)
+#define AG7240_INTR_TX_URN              (1 << 1)
+#define AG7240_INTR_TX_BUS_ERROR        (1 << 3)
+#define AG7240_INTR_RX                  (1 << 4)
+#define AG7240_INTR_RX_OVF              (1 << 6)
+#define AG7240_INTR_RX_BUS_ERROR        (1 << 7)
+
+/*
+ * MII registers
+ */
+#define AG7240_MAC_MII_MGMT_CFG         0x20
+#define AG7240_MGMT_CFG_CLK_DIV_20      0x07
+
+#define AG7240_MII_MGMT_CMD             0x24
+#define AG7240_MGMT_CMD_READ            0x1
+
+#define AG7240_MII_MGMT_ADDRESS         0x28
+#define AG7240_ADDR_SHIFT               8
+
+#define AG7240_MII_MGMT_CTRL            0x2c
+#define AG7240_MII_MGMT_STATUS          0x30
+
+#define AG7240_MII_MGMT_IND             0x34
+#define AG7240_MGMT_IND_BUSY            (1 << 0)
+#define AG7240_MGMT_IND_INVALID         (1 << 2)
+
+#define AG7240_GE_MAC_ADDR1             0x40
+#define AG7240_GE_MAC_ADDR2             0x44
+
+/*
+ * Ethernet config registers
+ */
+#define AG7240_ETH_CFG                  0x18070000
+#define AG7240_ETH_CFG_RGMII_GE0        (1<<0)
+#define AG7240_ETH_CFG_MII_GE0          (1<<1)
+#define AG7240_ETH_CFG_GMII_GE0         (1<<2)
+#define AG7240_ETH_CFG_RMII_GE0         (1<<10)
+#define AG7240_ETH_CFG_RMII_HISPD_GE0   (1<<11)
+#define AG7240_ETH_CFG_RMII_MASTER_MODE (1<<12)
+#define AG7240_ETH_CFG_MII_GE0_MASTER   (1<<3)
+#define AG7240_ETH_CFG_MII_GE0_SLAVE    (1<<4)
+#define AG7240_ETH_CFG_GE0_ERR_EN       (1<<5)
+#define AG7240_ETH_CFG_SW_ONLY_MODE     (1<<6)
+#define AG7240_ETH_CFG_SW_PHY_SWAP      (1<<7)
+#define AG7240_ETH_CFG_SW_PHY_ADDR_SWAP (1<<8)
+#define AG7240_ETH_CFG_RXD_DELAY	(1 << 14)
+#define AG7240_ETH_CFG_RDV_DELAY        (1 << 16)
+#define AG7240_ETH_SWITCH_CLK_SPARE     0x18050024
+
+
+/*
+ *  * ownership of descriptors between DMA and cpu
+ *   */
+#define ag7240_rx_owned_by_dma(_ds)     ((_ds)->is_empty == 1)
+#define ag7240_rx_give_to_dma(_ds)      ((_ds)->is_empty = 1)
+#define ag7240_tx_owned_by_dma(_ds)     ((_ds)->is_empty == 0)
+#define ag7240_tx_give_to_dma(_ds)      ((_ds)->is_empty = 0)
+#define ag7240_tx_own(_ds)              ((_ds)->is_empty = 1)
+
+/*
+ * link settings
+ */
+#define ag7240_set_mac_duplex(_mac, _fdx)       do {                         \
+    if ((_fdx))                                                              \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_FDX)     \
+    else                                                                     \
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_FDX)   \
+}while(0)
+
+#define ag7240_set_mac_if(_mac, _isXGMII)    do {                              \
+    ag7240_reg_rmw_clear(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_1000|      \
+                                          AG7240_MAC_CFG2_IF_10_100);   \
+    if ((_isXGMII)) {                                            \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_1000)  \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_FIFO_CFG_5, AG7240_BYTE_PER_CLK_EN);\
+    }                                                                       \
+    else {                                                              \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_10_100)\
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_FIFO_CFG_5, AG7240_BYTE_PER_CLK_EN);\
+    }                                                                       \
+}while(0)
+
+#define ag7240_set_mac_speed(_mac, _is100)   do {                             \
+    if ((_is100))                                                             \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_IFCTL, AG7240_MAC_IFCTL_SPEED)  \
+    else                                                                      \
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_IFCTL, AG7240_MAC_IFCTL_SPEED)\
+}while(0)
+
+#endif
diff --git a/cpu/mips/ar7240/ag934x_phy.h b/cpu/mips/ar7240/ag934x_phy.h
new file mode 100644
index 0000000000..715939c130
--- /dev/null
+++ b/cpu/mips/ar7240/ag934x_phy.h
@@ -0,0 +1,117 @@
+#ifndef _AG7240_PHY_H
+#define _AG7240_PHY_H
+
+static inline void ag7240_phy_setup(int unit)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        athrs16_phy_setup(unit);
+    } else
+#endif
+#ifdef CONFIG_ATHRS17_PHY
+    if (unit == 0) {
+        athrs17_phy_setup(unit);
+    } else
+#endif
+    {
+#ifdef CFG_ATHRS27_PHY
+        athrs27_phy_setup(unit);
+#endif
+#ifdef CFG_ATHRS26_PHY
+        athrs26_phy_setup(unit);
+#endif
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_F2E_PHY)
+        athr_phy_setup(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+        athr_vir_phy_setup(unit);
+#endif
+
+    }
+}
+
+static inline void ag7240_phy_link(int unit, int *link)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+         *link = athrs16_phy_is_up(unit);
+    } else
+#endif
+#ifdef CONFIG_ATHRS17_PHY
+    if (unit == 0) {
+         *link = athrs17_phy_is_up(unit);
+    } else
+#endif
+    {
+#ifdef CFG_ATHRS27_PHY
+         *link = athrs27_phy_is_up(unit);
+#endif
+#ifdef CFG_ATHRS26_PHY
+         *link = athrs26_phy_is_up(unit);
+#endif
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_F2E_PHY)
+         *link = athr_phy_is_up(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+         *link = athr_vir_phy_is_up(unit);
+#endif
+    }
+}
+
+static inline void ag7240_phy_duplex(int unit, int *duplex)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        *duplex = athrs16_phy_is_fdx(unit);
+    } else
+#endif
+#ifdef CONFIG_ATHRS17_PHY
+    if (unit == 0) {
+        *duplex = athrs17_phy_is_fdx(unit);
+    } else
+#endif
+   {
+#ifdef CFG_ATHRS27_PHY
+        *duplex = athrs27_phy_is_fdx(unit);
+#endif
+#ifdef CFG_ATHRS26_PHY
+        *duplex = athrs26_phy_is_fdx(unit);
+#endif
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_F2E_PHY)
+        *duplex = athr_phy_is_fdx(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+        *duplex = athr_vir_phy_is_fdx(unit);
+#endif
+    }
+}
+
+static inline void ag7240_phy_speed(int unit, int *speed)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        *speed = athrs16_phy_speed(unit);
+    } else
+#endif
+#ifdef CONFIG_ATHRS17_PHY
+    if (unit == 0) {
+        *speed = athrs17_phy_speed(unit);
+    } else
+#endif
+    {
+#ifdef CFG_ATHRS27_PHY
+        *speed = athrs27_phy_speed(unit);
+#endif
+#ifdef CFG_ATHRS26_PHY
+        *speed = athrs26_phy_speed(unit);
+#endif
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_F2E_PHY)
+        *speed = athr_phy_speed(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+        *speed = athr_vir_phy_speed(unit);
+#endif
+    }
+}
+
+#endif /*_AG7240_PHY_H*/
diff --git a/cpu/mips/ar7240/ar7240_serial.c b/cpu/mips/ar7240/ar7240_serial.c
new file mode 100644
index 0000000000..91a553a935
--- /dev/null
+++ b/cpu/mips/ar7240/ar7240_serial.c
@@ -0,0 +1,142 @@
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <config.h>
+#include <ar7240_soc.h>
+
+#define		REG_OFFSET		4
+
+/* === END OF CONFIG === */
+
+/* register offset */
+#define         OFS_RCV_BUFFER          (0*REG_OFFSET)
+#define         OFS_TRANS_HOLD          (0*REG_OFFSET)
+#define         OFS_SEND_BUFFER         (0*REG_OFFSET)
+#define         OFS_INTR_ENABLE         (1*REG_OFFSET)
+#define         OFS_INTR_ID             (2*REG_OFFSET)
+#define         OFS_DATA_FORMAT         (3*REG_OFFSET)
+#define         OFS_LINE_CONTROL        (3*REG_OFFSET)
+#define         OFS_MODEM_CONTROL       (4*REG_OFFSET)
+#define         OFS_RS232_OUTPUT        (4*REG_OFFSET)
+#define         OFS_LINE_STATUS         (5*REG_OFFSET)
+#define         OFS_MODEM_STATUS        (6*REG_OFFSET)
+#define         OFS_RS232_INPUT         (6*REG_OFFSET)
+#define         OFS_SCRATCH_PAD         (7*REG_OFFSET)
+
+#define         OFS_DIVISOR_LSB         (0*REG_OFFSET)
+#define         OFS_DIVISOR_MSB         (1*REG_OFFSET)
+
+#define         MY_WRITE(y, z)  ((*((volatile u32*)(y))) = z)
+#define         UART16550_READ(y)   ar7240_reg_rd((AR7240_UART_BASE+y))
+#define         UART16550_WRITE(x, z)  ar7240_reg_wr((AR7240_UART_BASE+x), z)
+
+void
+ar7240_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq)
+{
+    u32 pll, pll_div, ref_div, ahb_div, ddr_div, freq;
+
+    pll = ar7240_reg_rd(AR7240_CPU_PLL_CONFIG);
+
+    pll_div =
+        ((pll & PLL_CONFIG_PLL_DIV_MASK) >> PLL_CONFIG_PLL_DIV_SHIFT);
+
+    ref_div =
+        ((pll & PLL_CONFIG_PLL_REF_DIV_MASK) >> PLL_CONFIG_PLL_REF_DIV_SHIFT);
+
+    ddr_div =
+        ((pll & PLL_CONFIG_DDR_DIV_MASK) >> PLL_CONFIG_DDR_DIV_SHIFT) + 1;
+
+    ahb_div =
+       (((pll & PLL_CONFIG_AHB_DIV_MASK) >> PLL_CONFIG_AHB_DIV_SHIFT) + 1)*2;
+
+    freq = pll_div * ref_div * 5000000;
+
+    if (cpu_freq)
+        *cpu_freq = freq;
+
+    if (ddr_freq)
+        *ddr_freq = freq/ddr_div;
+
+    if (ahb_freq)
+        *ahb_freq = freq/ahb_div;
+}
+
+int serial_init(void)
+{
+    u32 div,val;
+    u32 ahb_freq, ddr_freq, cpu_freq;
+
+#ifdef CONFIG_WASP
+    val = ar7240_reg_rd(WASP_BOOTSTRAP_REG);
+
+    if ((val & WASP_REF_CLK_25) == 0) {
+        div = (25 * 1000000) / (16 * CONFIG_BAUDRATE);
+    } else {
+        div = (40 * 1000000) / (16 * CONFIG_BAUDRATE);
+    }
+#else
+
+    ar7240_sys_frequency(&cpu_freq, &ddr_freq, &ahb_freq);
+
+    div  = ahb_freq/(16 * CONFIG_BAUDRATE);
+
+    MY_WRITE(0xb8040000, 0xcff);
+    MY_WRITE(0xb8040008, 0x3b);
+
+    val = ar7240_reg_rd(0xb8040028);
+    MY_WRITE(0xb8040028,(val | 0x8002));
+
+    MY_WRITE(0xb8040008, 0x2f);
+#endif
+
+    /*
+     * set DIAB bit
+     */
+    UART16550_WRITE(OFS_LINE_CONTROL, 0x80);
+
+    /* set divisor */
+    UART16550_WRITE(OFS_DIVISOR_LSB, (div & 0xff));
+    UART16550_WRITE(OFS_DIVISOR_MSB, ((div >> 8) & 0xff));
+
+    /* clear DIAB bit*/
+    UART16550_WRITE(OFS_LINE_CONTROL, 0x00);
+
+    /* set data format */
+    UART16550_WRITE(OFS_DATA_FORMAT, 0x3);
+
+    UART16550_WRITE(OFS_INTR_ENABLE, 0);
+
+    return 0;
+}
+
+int serial_tstc (void)
+{
+    return(UART16550_READ(OFS_LINE_STATUS) & 0x1);
+}
+
+u8 serial_getc(void)
+{
+    while(!serial_tstc());
+
+    return UART16550_READ(OFS_RCV_BUFFER);
+}
+
+
+void serial_putc(u8 byte)
+{
+    if (byte == '\n') serial_putc ('\r');
+
+    while (((UART16550_READ(OFS_LINE_STATUS)) & 0x20) == 0x0);
+    UART16550_WRITE(OFS_SEND_BUFFER, byte);
+}
+
+void serial_setbrg (void)
+{
+}
+
+void serial_puts (const char *s)
+{
+	while (*s)
+	{
+		serial_putc (*s++);
+	}
+}
diff --git a/cpu/mips/ar7240/hornet.h b/cpu/mips/ar7240/hornet.h
new file mode 100644
index 0000000000..d95094d1b2
--- /dev/null
+++ b/cpu/mips/ar7240/hornet.h
@@ -0,0 +1,34 @@
+#ifndef _HORNET_H
+#define _HORNET_H
+
+/*
+ * GE0 AR8021 phy address
+ */
+#define GE0_AR8021_PHY_ADDR             0x0
+
+/*
+ * Ethernet config registers
+ */
+#define AG7240_ETH_CFG                  0x18070000
+#define AG7240_ETH_CFG_RGMII_GE0        (1<<0)
+#define AG7240_ETH_CFG_MII_GE0          (1<<1)
+#define AG7240_ETH_CFG_GMII_GE0         (1<<2)
+#define AG7240_ETH_CFG_MII_GE0_MASTER   (1<<3)
+#define AG7240_ETH_CFG_MII_GE0_SLAVE    (1<<4)
+#define AG7240_ETH_CFG_GE0_ERR_EN       (1<<5)
+#define AG7240_ETH_CFG_SW_ONLY_MODE     (1<<6)
+#define AG7240_ETH_CFG_SW_PHY_SWAP      (1<<7)
+#define AG7240_ETH_CFG_SW_PHY_ADDR_SWAP (1<<8)
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_LATCH_LINK_PASS                  0x0004
+
+#ifndef ag7240_unit2name
+#define ag7240_unit2name(_unit) _unit ?  "eth1" : "eth0"
+#endif
+
+#endif
diff --git a/cpu/mips/ar7240/hornet_ag7240.c b/cpu/mips/ar7240/hornet_ag7240.c
new file mode 100644
index 0000000000..bec55fee00
--- /dev/null
+++ b/cpu/mips/ar7240/hornet_ag7240.c
@@ -0,0 +1,662 @@
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7240_soc.h"
+#include "ag7240.h"
+#include "ag7240_phy.h"
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ag7240_unit2mac(_unit)     ag7240_macs[(_unit)]
+#define ag7240_name2mac(name)	   strcmp(name,"eth0") ? ag7240_unit2mac(1) : ag7240_unit2mac(0)
+
+uint16_t ag7240_miiphy_read(char *devname, uint32_t phaddr,
+	       uint8_t reg);
+void  ag7240_miiphy_write(char *devname, uint32_t phaddr,
+	        uint8_t reg, uint16_t data);
+
+ag7240_mac_t *ag7240_macs[CFG_AG7240_NMACS];
+
+extern int athrs26_phy_setup(int unit);
+extern int athrs26_phy_is_up(int unit);
+extern int athrs26_phy_is_fdx(int unit);
+extern int athrs26_phy_speed(int unit);
+extern void athrs26_reg_init(void);
+extern void athrs26_reg_init_lan(void);
+extern void ar7240_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq);
+extern int athrs26_mdc_check(void);
+
+#ifdef CONFIG_HORNET_EMU
+#include "hornet.h"
+
+void ar8021_phy_setup(u32 ethUnit, u32 phyUnit);
+uint32_t ar8021_phy_is_link_alive(u32 ethUnit, u32 phyUnit);
+uint32_t ar8021_phy_is_fdx(u32 ethUnit, u32 phyUnit);
+uint32_t ar8021_phy_speed(u32 ethUnit, u32 phyUnit);
+#endif /* CONFIG_HORNET_EMU */
+
+static int
+ag7240_send(struct eth_device *dev, volatile void *packet, int length)
+{
+    int i;
+
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+
+    ag7240_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+    f->pkt_size = length;
+    f->res1 = 0;
+    f->pkt_start_addr = virt_to_phys(packet);
+
+    ag7240_tx_give_to_dma(f);
+    flush_cache((u32) packet, length);
+    ag7240_reg_wr(mac, AG7240_DMA_TX_DESC, virt_to_phys(f));
+    ag7240_reg_wr(mac, AG7240_DMA_TX_CTRL, AG7240_TXE);
+
+    for (i = 0; i < MAX_WAIT; i++) {
+        udelay(10);
+        if (!ag7240_tx_owned_by_dma(f))
+            break;
+    }
+    if (i == MAX_WAIT)
+        printf("Tx Timed out\n");
+
+    f->pkt_start_addr = 0;
+    f->pkt_size = 0;
+
+    if (++mac->next_tx >= NO_OF_TX_FIFOS)
+        mac->next_tx = 0;
+
+    return (0);
+}
+
+static int ag7240_recv(struct eth_device *dev)
+{
+    int length;
+    ag7240_desc_t *f;
+    ag7240_mac_t *mac;
+
+    mac = (ag7240_mac_t *)dev->priv;
+
+    for (;;) {
+        f = mac->fifo_rx[mac->next_rx];
+        if (ag7240_rx_owned_by_dma(f))
+            break;
+
+        length = f->pkt_size;
+
+        NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+        flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+        ag7240_rx_give_to_dma(f);
+
+        if (++mac->next_rx >= NO_OF_RX_FIFOS)
+            mac->next_rx = 0;
+    }
+
+    if (!(ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL))) {
+        ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(f));
+        ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 1);
+    }
+
+    return (0);
+}
+
+static void ag7240_hw_start(ag7240_mac_t *mac)
+{
+    u32 cpu_freq,ddr_freq,ahb_freq;
+    u32 mgmt_cfg_val;
+    u32 check_cnt,revid_val;
+
+    if(mac->mac_unit)
+    {
+        ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
+            AG7240_MAC_CFG1_TX_EN));
+        ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+            AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_1000));
+    }
+    else {
+
+    ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
+		    AG7240_MAC_CFG1_TX_EN));
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+		         AG7240_MAC_CFG2_LEN_CHECK));
+   }
+
+#ifdef AR7240_EMU
+    printf("AG7240_MAC_FIFO_CFG_4\n");
+    ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_4, 0x3ffff);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0x10ffff);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0xAAA0555);
+#else
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0xfff0000);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0x1fff);
+#endif
+if ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7240_REV_1_2) {
+        mgmt_cfg_val = 0x2;
+        if (mac->mac_unit == 0) {
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+        }
+    }
+    else {
+        ar7240_sys_frequency(&cpu_freq, &ddr_freq, &ahb_freq);
+        switch (ahb_freq/1000000) {
+            case 150:
+                     mgmt_cfg_val = 0x7;
+                     break;
+            case 175:
+                     mgmt_cfg_val = 0x5;
+                     break;
+            case 200:
+                     mgmt_cfg_val = 0x4;
+                     break;
+            case 210:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            case 220:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            default:
+                     mgmt_cfg_val = 0x7;
+        }
+        if ((is_ar7241() || is_ar7242())) {
+
+            /* External MII mode */
+            if (mac->mac_unit == 0 && is_ar7242()) {
+                mgmt_cfg_val = 0x6;
+                ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            }
+#ifndef CONFIG_HORNET_EMU
+            /* Virian */
+            mgmt_cfg_val = 0x4;
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            printf("Virian MDC CFG Value ==> %x\n",mgmt_cfg_val);
+#endif
+
+        }
+        else { /* Python 1.0 & 1.1 */
+            if (mac->mac_unit == 0) {
+                check_cnt = 0;
+                while (check_cnt++ < 10) {
+                    ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                    ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+                    if(athrs26_mdc_check() == 0)
+                        break;
+                }
+                if(check_cnt == 11)
+                    printf("%s: MDC check failed\n", __func__);
+            }
+        }
+    }
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_0, 0x1f00);
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_4, 0x3ffff);
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0x10ffff);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0xAAA0555);
+
+    /* 
+     * Setting Drop CRC Errors, Pause Frames,Length Error frames 
+     * and Multi/Broad cast frames. 
+     */
+
+#ifdef CONFIG_HORNET_EMU
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0xbefff);
+#else
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0x7eccf);
+#endif
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_3, 0x1f00140);
+
+    printf(": cfg1 %#x cfg2 %#x\n", ag7240_reg_rd(mac, AG7240_MAC_CFG1),
+        ag7240_reg_rd(mac, AG7240_MAC_CFG2));
+
+}
+
+static int ag7240_check_link(ag7240_mac_t *mac)
+{
+    u32 link, duplex, speed, fdx;
+
+#ifdef CONFIG_HORNET_EMU
+    link   = ar8021_phy_is_link_alive(0, GE0_AR8021_PHY_ADDR);
+    duplex = ar8021_phy_is_fdx(0, GE0_AR8021_PHY_ADDR);
+    speed  = ar8021_phy_speed(0, GE0_AR8021_PHY_ADDR);
+#else
+    ag7240_phy_link(mac->mac_unit, &link);
+    ag7240_phy_duplex(mac->mac_unit, &duplex);
+    ag7240_phy_speed(mac->mac_unit, &speed);
+#endif
+
+    mac->link = link;
+#ifdef SUPPORT_PLC
+    if(strcmp(mac->dev->name, "eth0") == 0) {
+        printf("ag7240_check_link: %s link forced down\n",mac->dev->name);
+        return 0;
+    }
+#endif
+
+    if(!mac->link) {
+        printf("%s link down\n",mac->dev->name);
+        return 0;
+    }
+
+    switch (speed)
+    {
+       case _1000BASET:
+           ag7240_set_mac_if(mac, 1);
+           ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if (is_ar7242() && (mac->mac_unit == 0))
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1c000000);
+           break;
+
+       case _100BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 1);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+#ifndef CONFIG_HORNET_EMU
+           if (is_ar7242() && (mac->mac_unit == 0))
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0101);
+#endif
+           break;
+
+       case _10BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 0);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if (is_ar7242() && (mac->mac_unit == 0))
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1616);
+           break;
+
+       default:
+          printf("Invalid speed detected\n");
+          return 0;
+    }
+
+   if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+        return 1; 
+
+    mac->duplex = duplex;
+    mac->speed = speed;
+
+    printf("dup %d speed %d\n", duplex, speed);
+
+    ag7240_set_mac_duplex(mac,duplex);
+
+    return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ag7240_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+    int i;
+    ag7240_desc_t *fr;
+    ag7240_mac_t *mac = (ag7240_mac_t*)dev->priv;
+
+    if (!ag7240_check_link(mac))
+        return 0;
+
+    mac->next_rx = 0;
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        fr = mac->fifo_rx[i];
+        fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+        flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+        ag7240_rx_give_to_dma(fr);
+    }
+
+    ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, AG7240_RXE);	/* rx start */
+    udelay(1000 * 1000);
+
+
+    return 1;
+
+}
+
+static int ag7240_alloc_fifo(int ndesc, ag7240_desc_t ** fifo)
+{
+    int i;
+    u32 size;
+    uchar *p = NULL;
+
+    size = sizeof(ag7240_desc_t) * ndesc;
+    size += CFG_CACHELINE_SIZE - 1;
+
+    if ((p = malloc(size)) == NULL) {
+        printf("Cant allocate fifos\n");
+        return -1;
+    }
+
+    p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+	   ~(CFG_CACHELINE_SIZE - 1));
+    p = UNCACHED_SDRAM(p);
+
+    for (i = 0; i < ndesc; i++)
+        fifo[i] = (ag7240_desc_t *) p + i;
+
+    return 0;
+}
+
+static int ag7240_setup_fifos(ag7240_mac_t *mac)
+{
+    int i;
+
+    if (ag7240_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+        return 1;
+
+    for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+        mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+        ag7240_tx_own(mac->fifo_tx[i]);
+    }
+
+    if (ag7240_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+        return 1;
+
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+    }
+
+    return (1);
+}
+
+static void ag7240_halt(struct eth_device *dev)
+{
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 0);
+    while (ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL));
+}
+
+unsigned char *
+ag7240_mac_addr_loc(void)
+{
+	extern flash_info_t flash_info[];
+
+#ifdef BOARDCAL
+    /*
+    ** BOARDCAL environmental variable has the address of the cal sector
+    */
+    
+    return ((unsigned char *)BOARDCAL);
+    
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+		(KSEG1ADDR(AR7240_SPI_BASE) + (4 * 1024) +
+		flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+static void ag7240_get_ethaddr(struct eth_device *dev)
+{
+    unsigned char *eeprom;
+    unsigned char *mac = dev->enetaddr;
+
+    eeprom = ag7240_mac_addr_loc();
+
+    if (strcmp(dev->name, "eth0") == 0) {
+        memcpy(mac, eeprom, 6);
+    } else if (strcmp(dev->name, "eth1") == 0) {
+        eeprom += 6;
+        memcpy(mac, eeprom, 6);
+    } else {
+        printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+        return;
+    }
+
+    /* Use fixed address if the above address is invalid */
+    if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff)) {
+        mac[0] = 0x00;
+        mac[1] = 0x03;
+        mac[2] = 0x7f;
+        mac[3] = 0x09;
+        mac[4] = 0x0b;
+        mac[5] = 0xad;
+        printf("No valid address in Flash. Using fixed address\n");
+    } else {
+        printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+    }
+}
+
+
+int ag7240_enet_initialize(bd_t * bis)
+{
+    struct eth_device *dev[CFG_AG7240_NMACS];
+    u32 mask, mac_h, mac_l;
+    int i;
+
+    printf("ag7240_enet_initialize...\n");
+
+#ifdef CONFIG_MACH_HORNET
+    ar7240_reg_wr(HORNET_BOOTSTRAP_STATUS, ar7240_reg_rd(HORNET_BOOTSTRAP_STATUS) & ~HORNET_BOOTSTRAP_MDIO_SLAVE_MASK);
+#endif
+
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+
+    if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+	
+    if ((ag7240_macs[i] = (ag7240_mac_t *) malloc(sizeof (ag7240_mac_t))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+
+    memset(ag7240_macs[i], 0, sizeof(ag7240_macs[i]));
+    memset(dev[i], 0, sizeof(dev[i]));
+
+    sprintf(dev[i]->name, "eth%d", i);
+    ag7240_get_ethaddr(dev[i]);
+    
+    ag7240_macs[i]->mac_unit = i;
+    ag7240_macs[i]->mac_base = i ? AR7240_GE1_BASE : AR7240_GE0_BASE ;
+    ag7240_macs[i]->dev = dev[i];
+
+    dev[i]->iobase = 0;
+    dev[i]->init = ag7240_clean_rx;
+    dev[i]->halt = ag7240_halt;
+    dev[i]->send = ag7240_send;
+    dev[i]->recv = ag7240_recv;
+    dev[i]->priv = (void *)ag7240_macs[i];
+    }
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+
+    eth_register(dev[i]);
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+    miiphy_register(dev[i]->name, ag7240_miiphy_read, ag7240_miiphy_write);
+#endif
+    if(!i) {
+        mask = (AR7240_RESET_GE0_MAC | AR7240_RESET_GE0_PHY |
+                AR7240_RESET_GE1_MAC | AR7240_RESET_GE1_PHY);
+
+    if ((is_ar7241() || is_ar7242())) 
+	mask = mask | AR7240_RESET_GE0_MDIO | AR7240_RESET_GE1_MDIO;
+
+
+        ar7240_reg_rmw_set(AR7240_RESET, mask);
+        udelay(1000 * 100);
+
+        ar7240_reg_rmw_clear(AR7240_RESET, mask);
+        udelay(1000 * 100);
+
+    udelay(10 * 1000);
+    }
+    ag7240_hw_start(ag7240_macs[i]);
+    ag7240_setup_fifos(ag7240_macs[i]);
+
+    udelay(100 * 1000);
+
+    {
+        unsigned char *mac = dev[i]->enetaddr;
+
+        printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+               mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+               mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+    }
+    mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+    mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+        (dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+    ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR1, mac_l);
+    ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR2, mac_h);
+
+    /* if using header for register configuration, we have to     */
+    /* configure s26 register after frame transmission is enabled */
+
+#ifdef CONFIG_HORNET_EMU
+    ar8021_phy_setup(0, GE0_AR8021_PHY_ADDR);
+#else
+    if (ag7240_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef CONFIG_AR7242_S16_PHY
+        if (is_ar7242()) {
+            athrs16_reg_init();
+        } else
+#endif
+        {
+            athrs26_reg_init();
+        }
+    } else {
+        athrs26_reg_init_lan();
+    }
+
+    ag7240_phy_setup(ag7240_macs[i]->mac_unit);
+#endif
+    printf("%s up\n",dev[i]->name);
+    }
+
+    return 1;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_MII)
+uint16_t
+ag7240_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg)
+{
+    ag7240_mac_t *mac   = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg, val;
+    volatile int           rddata;
+    uint16_t      ii = 0x1000;
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, AG7240_MGMT_CMD_READ);
+
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    val = ag7240_reg_rd(mac, AG7240_MII_MGMT_STATUS);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+
+    return val;
+}
+
+void
+ag7240_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+    ag7240_mac_t *mac = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg;
+    volatile int rddata;
+    uint16_t      ii = 0x1000;
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CTRL, data);
+
+    do
+    {
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+}
+#endif		/* CONFIG_COMMANDS & CFG_CMD_MII */
+
+#ifdef CONFIG_HORNET_EMU
+void
+ar8021_phy_setup(u32 ethUnit, u32 phyUnit)
+{
+    uint32_t phyid1, phyid2;
+
+    phyid1 = ag7240_miiphy_read(ag7240_unit2name(ethUnit), phyUnit, 0x2);
+    phyid2 = ag7240_miiphy_read(ag7240_unit2name(ethUnit), phyUnit, 0x3);
+
+    printf("%s Phy ID %x:%x\n", __FUNCTION__, phyid1, phyid2);
+
+    udelay(1000*1000);
+
+    ar7240_reg_rmw_set(AR7240_GPIO_BASE, 0x20);
+    ar7240_reg_rmw_set(AR7240_GPIO_BASE + 0x8, 0x20);
+
+    udelay(1000*1000);
+    ar7240_reg_rmw_clear(AR7240_GPIO_BASE + 0x8, 0x20);
+
+    udelay(1000*1000);
+}
+
+uint32_t
+ar8021_phy_is_link_alive(u32 ethUnit, u32 phyUnit)
+{
+    uint32_t phyHwStatus;
+
+    phyHwStatus = ag7240_miiphy_read(ag7240_unit2name(ethUnit), phyUnit, 0x11);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+       return 1;
+
+    return 0;
+}
+
+uint32_t
+ar8021_phy_speed(uint32_t ethUnit, uint32_t phyUnit)
+{
+    uint32_t phyHwStatus;
+
+    phyHwStatus = ag7240_miiphy_read(ag7240_unit2name(ethUnit), phyUnit, 0x11);
+
+    {
+        phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                       ATHER_STATUS_LINK_SHIFT);
+
+        switch(phyHwStatus) {
+        case 0:
+            return _10BASET;
+        case 1:
+            return _100BASET;
+        case 2:
+            return _1000BASET;
+        default:
+            printf("Unkown speed read!\n");
+        }
+    }
+
+    return _10BASET;
+}
+
+uint32_t
+ar8021_phy_is_fdx(u32 ethUnit, u32 phyUnit)
+{
+    uint32_t phyHwStatus;
+
+    phyHwStatus = ag7240_miiphy_read(ag7240_unit2name(ethUnit), phyUnit, 0x11);
+
+    if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+       return 1;
+
+    return 0;
+}
+#endif /* CONFIG_HORNET_EMU */
diff --git a/cpu/mips/ar7240/hornet_ddr_init.S b/cpu/mips/ar7240/hornet_ddr_init.S
new file mode 100755
index 0000000000..424754143a
--- /dev/null
+++ b/cpu/mips/ar7240/hornet_ddr_init.S
@@ -0,0 +1,4690 @@
+/*
+ *  Startup Code for MIPS32 CPU-core
+ *
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+
+	.globl hornet_ddr_init
+	.text
+	.align 4
+
+#define set_mem(_mem, _val)                         \
+    li  t9, _mem;                                   \
+    sw  _val, 0(t9);
+
+//============================================
+//   init DDR1 parameter before rel_start
+//===========================================
+hornet_ddr_init:
+
+    //--------DDR_Config_1--------   D.S 0xB8000000 %LONG 0x7fbc8cd0 
+    li t8, CFG_DDR_CONFIG_VAL;
+    set_mem(0xB8000000,t8);
+
+    //--------DDR_Config_2--------  D.S 0xB8000004 %LONG 0x99d0e6a8 
+    li t8, CFG_DDR_CONFIG2_VAL;
+    set_mem(0xB8000004,t8);
+
+    // DDR1 Paramters
+
+    //D.S 0xB8000010 %LONG 0x8           ;      // precharge
+    li t8,0x8;
+    set_mem(0xB8000010,t8);
+
+    //D.S 0xB8000008 %LONG 0x133         ;
+    li t8,CFG_DDR_MODE_VAL_INIT;
+    set_mem(0xB8000008,t8);
+
+    //D.S 0xB8000010 %LONG 0x1           ;      // Write Mode Word in DDR
+    li t8, 0x1;
+    set_mem( 0xB8000010, t8);
+    
+    //D.S 0xB800000C %LONG 0x2           ;      // Enable DLL, High drive strength from DDR
+    li t8, 0x2;
+    set_mem( 0xB800000C , t8);
+
+    //D.S 0xB8000010 %LONG 0x2           ;      // Write Extended Mode Word of DDR
+    li t8, 0x2;
+    set_mem( 0xB8000010, t8);
+
+    //D.S 0xB8000010 %LONG 0x8           ;      // precharge enabled
+    li t8, 0x8;
+    set_mem( 0xB8000010, t8);
+
+    // D.S 0xB8000008 %LONG 0x33          ;      // dll out of reset CAS Latency 3
+    li t8, CFG_DDR_MODE_VAL;
+    set_mem( 0xB8000008, t8);
+
+    //D.S 0xB8000010 %LONG 0x1           ;      // write mode word
+    li t8, 0x1;
+    set_mem( 0xB8000010, t8);
+
+    //D.S 0xB8000014 %LONG 0x4186/0x4270 ;      // Refresh control. Bit 14 is enable. Bits<13:0> Refresh time
+    li t8, CFG_DDR_REFRESH_VAL;
+    set_mem( 0xB8000014, t8);
+
+    //D.S 0xB800001C %LONG 0x08          ;       // DQS 0 Tap Control (needs tuning)
+    li t8, CFG_DDR_TAP0_VAL;
+    set_mem( 0xB800001C, t8);
+
+    //D.S 0xB8000020 %LONG 0x09          ;       // DQS 1 Tap Control (needs tuning)
+    li t8, CFG_DDR_TAP1_VAL;
+    set_mem( 0xB8000020, t8);
+
+    //D.S 0xB8000018 %LONG 0x00ff        ;      // For 16-bit DDR
+    li t8, 0x00ff;
+    set_mem( 0xB8000018, t8);
+
+	nop
+	jr 	ra
+    
+/*
+ * void hornet_ddr_tap_init(void)
+ *
+ * This "function" is used to find the tap settings for the DDR
+ */
+	.globl	hornet_ddr_tap_init
+	.ent	hornet_ddr_tap_init
+hornet_ddr_tap_init: /* { */
+
+#if NEW_DDR_TAP_CAL
+	li	t1,0x80500000 
+	li	t0,0xffffffff 
+	 
+	sw	t0,0x0(t1) 
+	sw	t0,0x4(t1) 
+	sw	t0,0x8(t1) 
+	sw	t0,0xc(t1) 
+	 
+	nop 
+	nop
+
+ddr_pat_init:
+	li 	t8, 0xa0002000
+	li	t0, 0x00
+	li	t1, 0x100	
+write_loop_start:
+	andi    t2, t0, 0x03
+pat_000:
+	li	t3, 0x00
+	bne	t2, t3,pat_001
+	li 	t9, 0x00000000
+	sw	t9, 0x0 (t8)
+	b	pat_004
+
+pat_001:
+	li	t3, 0x01
+	bne	t2, t3,pat_002
+	li 	t9, 0x0000ffff
+	sw	t9, 0x0 (t8)
+	b	pat_004
+
+pat_002:
+	li	t3, 0x02
+	bne	t2, t3,pat_003
+	li 	t9, 0xffff0000
+	sw	t9, 0x0 (t8)
+	b	pat_004
+
+pat_003:
+	li	t3, 0x03
+	bne	t2, t3,pat_004
+	li 	t9, 0xffffffff
+	sw	t9, 0x0 (t8)
+
+pat_004:
+	andi    t2, t0, 0x0c
+	li	t3, 0x00
+	bne	t2, t3,pat_005
+	li 	t9, 0x00000000
+	sw	t9, 0x4 (t8)
+	b	pat_008
+
+pat_005:
+	li	t3, 0x04
+	bne	t2, t3,pat_006
+	li 	t9, 0x0000ffff
+	sw	t9, 0x4 (t8)
+	b	pat_008
+
+pat_006:
+	li	t3, 0x08
+	bne	t2, t3,pat_007
+	li 	t9, 0xffff0000
+	sw	t9, 0x4 (t8)
+	b	pat_008
+
+pat_007:
+	li	t3, 0x0c
+	bne	t2, t3,pat_008
+	li 	t9, 0xffffffff
+	sw	t9, 0x4 (t8)
+
+pat_008:
+	andi    t2, t0, 0x30
+	li	t3, 0x00
+	bne	t2, t3,pat_009
+	li 	t9, 0x00000000
+	sw	t9, 0x8 (t8)
+	b	pat_00c
+
+pat_009:
+	li	t3, 0x10
+	bne	t2, t3,pat_00a
+	li 	t9, 0x0000ffff
+	sw	t9, 0x8 (t8)
+	b	pat_00c
+
+pat_00a:
+	li	t3, 0x20
+	bne	t2, t3,pat_00b
+	li 	t9, 0xffff0000
+	sw	t9, 0x8 (t8)
+	b	pat_00c
+
+pat_00b:
+	li	t3, 0x30
+	bne	t2, t3,pat_00c
+	li 	t9, 0xffffffff
+	sw	t9, 0x8 (t8)
+
+pat_00c:
+	andi    t2, t0, 0xc0
+	li	t3, 0x00
+	bne	t2, t3,pat_00d
+	li 	t9, 0x00000000
+	sw	t9, 0xc (t8)
+	b	pat_done
+
+pat_00d:
+	li	t3, 0x40
+	bne	t2, t3,pat_00e
+	li 	t9, 0x0000ffff
+	sw	t9, 0xc (t8)
+	b	pat_done
+
+pat_00e:
+	li	t3, 0x80
+	bne	t2, t3,pat_00f
+	li 	t9, 0xffff0000
+	sw	t9, 0xc (t8)
+	b	pat_done
+
+pat_00f:
+	li	t3, 0xc0
+	bne	t2, t3,pat_done
+	li 	t9, 0xffffffff
+	sw	t9, 0xc (t8)
+
+pat_done:
+
+	addiu	t0, t0, 0x1
+	addiu	t8, t8, 0x10
+	bne	t0, t1, write_loop_start
+	
+
+
+
+###### ddr init over #########
+
+	li	a0, 0xa0002000
+	li	a1, 0x80002000	     ### Start address of the pattern   200
+	li	a2, 0x80003000	     ### End Address of the pattern     220
+	li	t0, 0xb800001c	     ## Tap settings addr
+	lw	a3, 0x0(t0)	     ## loading default tap value
+	nop
+	ori	t0, a3, 0x0
+	nop
+	li	t1, 0x1	     ## $t1=1 indicates increasing tap value, 0 = decreasing
+
+load_tap:
+
+	li	t7, 0x2#li	$t7, 0x200	## No. of times read has to happen for 1 tap setting
+	li	t8, 0xb8000000	#### Loading Tap Setting
+	sw	t0, 0x1c(t8)
+	nop
+	sw	t0, 0x20(t8)
+	nop
+    #if 0 /* Hornet doesn't have DQS2, DQS3*/
+	sw	t0, 0x24(t8)
+	nop
+	sw	t0, 0x28(t8)
+	nop
+    #endif	
+
+###### t0 stores current tap setting under test
+###### t1 indicates increment or decrement of tap 
+
+pat_read:
+	ori	t2, a0, 0x0	
+	nop
+	ori	t3, a1, 0x0
+	nop
+	ori	t4, a2, 0x0
+	nop
+
+tap_addr_loop:
+	lw	t5, 0x0(t2)
+	nop
+	lw	t6, 0x0(t3)
+	nop
+	nop
+	
+	bne	t5, t6, tap_fail  # jump to fail if not equal
+	nop
+	nop
+	nop
+
+	addiu	t2, t2, 0x4  #incrementing addr
+	addiu	t3, t3, 0x4
+	nop
+	nop
+	
+	bne	t3, t4, tap_addr_loop # compare new addr if end addr not reached
+	nop	
+	
+	addiu	t7, t7, -1     # read passed for all locations once hence decrement t7
+	nop
+	bnez	t7, pat_read    # t7 = 0 represents passing of all locations for given tap
+	nop
+	nop
+	
+	bnez	t1, tap_incr     # increment tap if t1 = 1
+	nop
+	nop
+	
+	bnez	t0, tap_decr	  ## $t0=0 implies tap=0 works
+	nop		          ## so low limit=0, else decrement tap value
+	nop
+	li	t8, 0x80500000   ## assigning lower limit = 0
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0     ##adding lower limit to upper limit (used to calc mid value)
+	nop
+	nop
+	
+	b tap_calc
+	nop
+	nop
+
+tap_decr: 			# decrement t0 by 1 and move to loading this new tap
+	addiu	t0, t0 , -1
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_incr:
+	addiu	t0, t0 , 0x1
+	nop
+	xori	v1, t0, 0x20	# limiting upper limit to 0x20
+	nop
+	bnez	v1, load_tap
+	nop
+	nop
+	b up_limit
+	nop
+	nop
+
+tap_fail:
+	bnez	t1, up_limit 	# t1=0 means lower limit detected @ fail else upper limit
+	nop
+	nop
+	nop
+	addiu	t0, t0, 0x1
+	nop
+	li	t8, 0x80500000	# storing lower limit
+	nop
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0	# storing lower limit# adding lower limit and upper limit
+	nop
+	nop
+	nop
+	
+	b tap_calc
+	nop
+	nop
+
+up_limit:
+	addiu	t0, t0, -1 
+	li	t1, 0x0	 ## changing to decreasing tap mode	
+	li	t8, 0x80500000 ## storing upper limit
+	sw	t0, 0x4(t8)	
+	ori	t9, t0, 0x0	
+	nop
+	nop
+	nop
+	
+	ori	t0, a3, 0x0 	# loading default tap value 
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_calc:  ## calculating mid value of the tap, storing DQS0, DQS1 in 0x80500008, 0x8050000c resp.
+	li	t7, 0x2
+	nop
+	div	t9, t7
+	nop
+	mfhi	t6
+	mflo	t5
+	nop
+	nop
+	add	t6, t6, t5
+	li	t8, 0x80500000
+	nop
+	sw	t5, 0x8(t8)
+	nop
+	sw	t6, 0xc(t8)
+	nop
+	nop
+	li      t8, 0xb8000000  #### Loading Tap Setting
+	nop
+	sw      t5, 0x1c(t8)
+	nop
+	sw      t6, 0x20(t8)
+	nop
+    #if 0 /* Hornet doesn't have DQS2, DQS3*/	
+	sw      t5, 0x24(t8)
+	nop
+	sw      t6, 0x28(t8)
+	nop
+    #endif	
+	nop
+	nop
+#else /* NEW_DDR_TAP_CAL */
+	li	t1,0x80500000 
+	li	t0,0xffffffff 
+	 
+	sw	t0,0x0(t1) 
+	sw	t0,0x4(t1) 
+	sw	t0,0x8(t1) 
+	sw	t0,0xc(t1) 
+	 
+	nop 
+	nop
+
+ddr_pat_init:
+	li 	t0, 0xa0002000
+	
+	li 	t1, 0x00000000
+	sw 	t1, 0x0(t0)
+	nop
+	
+	li 	t1, 0x00000000
+	sw 	t1, 0x4(t0)
+	nop
+	
+	li 	t1, 0x00000000
+	sw	t1, 0x8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x14(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x18(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x24(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x28(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x34(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x38(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x44(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x48(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x54(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x58(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x64(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x68(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x74(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x78(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x84(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x88(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x94(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x98(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xbc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xdc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xfc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x100(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x104(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x108(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x10c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x110(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x114(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x118(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x11c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x120(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x124(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x128(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x12c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x130(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x134(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x138(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x13c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x140(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x144(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x148(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x14c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x150(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x154(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x158(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x15c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x160(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x164(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x168(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x16c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x170(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x174(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x178(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x17c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x180(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x184(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x188(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x18c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x190(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x194(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x198(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x19c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x1a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x1a4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1a8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x1b4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1b8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1c4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1c8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1d4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1d8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x1e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1e4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1e8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1f4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1f8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x200(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x204(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x208(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x20c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x210(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x214(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x218(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x21c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x220(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x224(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x228(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x22c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x230(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x234(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x238(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x23c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x240(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x244(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x248(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x24c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x250(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x254(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x258(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x25c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x260(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x264(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x268(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x26c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x270(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x274(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x278(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x27c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x280(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x284(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x288(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x28c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x290(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x294(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x298(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x29c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2a4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2a8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2b4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2b8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2c4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2c8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x2d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2d4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2d8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2e4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2e8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2f4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2f8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x300(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x304(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x308(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x30c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x310(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x314(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x318(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x31c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x320(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x324(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x328(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x32c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x330(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x334(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x338(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x33c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x340(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x344(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x348(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x34c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x350(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x354(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x358(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x35c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x360(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x364(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x368(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x36c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x370(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x374(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x378(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x37c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x380(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x384(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x388(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x38c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x390(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x394(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x398(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x39c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x3a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x3a4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3a8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x3b4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3b8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3c4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3c8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x3d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3d4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3d8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x3e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3e4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3e8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3f4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3f8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x400(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x404(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x408(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x40c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x410(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x414(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x418(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x41c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x420(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x424(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x428(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x42c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x430(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x434(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x438(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x43c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x440(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x444(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x448(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x44c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x450(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x454(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x458(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x45c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x460(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x464(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x468(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x46c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x470(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x474(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x478(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x47c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x480(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x484(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x488(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x48c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x490(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x494(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x498(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x49c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x4a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x4a4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4a8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x4b4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4b8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4c4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4c8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4d4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4d8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x4e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4e4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4e8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4f4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4f8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x500(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x504(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x508(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x50c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x510(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x514(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x518(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x51c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x520(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x524(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x528(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x52c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x530(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x534(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x538(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x53c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x540(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x544(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x548(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x54c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x550(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x554(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x558(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x55c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x560(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x564(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x568(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x56c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x570(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x574(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x578(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x57c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x580(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x584(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x588(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x58c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x590(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x594(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x598(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x59c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x5a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x5a4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5a8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x5b4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5b8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x5c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5c4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5c8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5d4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5d8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x5e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5e4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5e8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5f4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5f8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x600(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x604(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x608(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x60c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x610(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x614(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x618(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x61c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x620(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x624(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x628(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x62c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x630(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x634(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x638(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x63c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x640(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x644(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x648(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x64c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x650(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x654(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x658(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x65c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x660(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x664(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x668(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x66c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x670(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x674(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x678(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x67c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x680(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x684(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x688(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x68c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x690(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x694(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x698(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x69c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6a4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6a8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6b4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6b8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x6c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6c4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6c8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6d4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6d8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6e4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6e8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6f4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6f8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x700(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x704(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x708(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x70c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x710(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x714(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x718(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x71c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x720(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x724(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x728(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x72c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x730(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x734(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x738(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x73c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x740(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x744(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x748(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x74c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x750(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x754(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x758(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x75c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x760(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x764(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x768(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x76c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x770(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x774(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x778(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x77c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x780(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x784(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x788(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x78c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x790(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x794(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x798(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x79c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x7a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x7a4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7a8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x7b4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7b8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x7c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7c4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7c8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7d4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7d8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x7e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7e4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7e8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7f4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7f8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x800(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x804(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x808(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x80c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x810(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x814(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x818(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x81c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x820(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x824(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x828(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x82c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x830(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x834(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x838(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x83c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x840(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x844(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x848(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x84c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x850(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x854(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x858(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x85c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x860(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x864(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x868(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x86c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x870(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x874(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x878(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x87c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x880(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x884(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x888(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x88c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x890(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x894(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x898(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x89c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8a4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8a8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8b4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8b8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8c4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8c8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x8d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8d4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8d8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8e4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8e8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8f4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8f8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x900(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x904(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x908(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x90c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x910(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x914(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x918(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x91c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x920(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x924(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x928(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x92c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x930(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x934(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x938(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x93c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x940(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x944(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x948(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x94c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x950(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x954(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x958(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x95c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x960(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x964(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x968(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x96c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x970(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x974(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x978(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x97c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x980(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x984(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x988(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x98c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x990(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x994(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x998(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x99c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9a4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9a8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9b4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9b8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x9c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9c4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9c8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9d4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9d8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9e4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9e8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9f4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9f8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa04(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa08(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa14(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa18(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa24(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa28(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xa30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa34(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa38(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa44(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa48(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa54(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa58(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa64(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa68(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xa70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa74(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa78(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa84(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa88(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa94(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa98(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaa0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaa4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaa8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xab0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xab4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xab8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xabc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xac0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xac4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xac8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xacc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xad0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xad4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xad8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xadc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xae0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xae4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xae8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xaf0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xaf4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaf8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xafc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb04(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb08(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb14(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb18(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb24(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb28(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb34(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb38(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb44(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb48(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb54(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb58(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb64(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb68(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb74(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb78(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb84(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb88(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb94(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb98(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xba0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xba4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xba8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbb4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbb8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbbc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xbc0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbc4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbc8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbcc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xbd0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbd4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbd8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbdc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbe0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbe4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbe8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbf0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbf4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbf8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbfc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc04(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc08(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc14(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc18(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xc20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc24(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc28(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc34(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc38(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc44(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc48(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc54(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc58(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xc60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc64(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc68(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc74(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc78(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xc84(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc88(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xc94(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc98(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xca0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xca4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xca8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xcb4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcb8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcbc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcc0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcc4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcc8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xccc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xcd0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcd4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcd8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcdc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xce0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xce4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xce8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcf0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcf4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcf8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcfc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd04(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd08(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd14(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd18(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xd20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd24(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd28(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd34(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd38(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd44(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd48(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd54(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd58(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xd60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd64(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd68(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd74(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd78(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xd84(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd88(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xd94(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd98(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xda0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xda4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xda8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xdb4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xdb8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdbc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xdc0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdc4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xdc8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdcc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xdd0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdd4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xdd8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xddc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xde0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xde4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xde8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdf0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdf4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xdf8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdfc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe04(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe08(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe14(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe18(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe24(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe28(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe34(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe38(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe44(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe48(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe54(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe58(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe64(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe68(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe74(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe78(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe84(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe88(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe94(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe98(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xea0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xea4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xea8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xeac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xeb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xeb4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xeb8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xebc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xec0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xec4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xec8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xecc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xed0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xed4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xed8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xedc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xee0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xee4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xee8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xeec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xef0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xef4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xef8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xefc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf04(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf08(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf14(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf18(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xf20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf24(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf28(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf34(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf38(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf44(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf48(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf54(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf58(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xf60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf64(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf68(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf74(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf78(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xf84(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf88(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xf94(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf98(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xfa0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xfa4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfa8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xfb4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfb8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfbc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xfc0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfc4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfc8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfcc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xfd0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfd4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfd8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfdc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xfe0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfe4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfe8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xff0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xff4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xff8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xffc(t0)
+	nop
+
+
+//###### ddr init over #########
+
+	li	a0, 0xa0002000
+	li	a1, 0x80002000	     //### Start address of the pattern   200
+	li	a2, 0x80003000	     //### End Address of the pattern     220
+	li	t0, 0xb800001c	//## Tap settings addr
+	lw	a3, 0x0(t0)		//## loading default tap value
+	nop
+	ori	t0, a3, 0x0
+	nop
+	li	t1, 0x1		//# t1=1 indicates increasing tap value, 0 = decreasing
+
+load_tap:
+
+	li	t7, 0x200	//## No. of times read has to happen for 1 tap setting
+	li	t8, 0xb8000000	//#### Loading Tap Setting
+	sw	t0, 0x1c(t8)
+	nop
+	sw	t0, 0x20(t8)
+	nop
+
+pat_read:
+	ori	t2, a0, 0x0	
+	nop
+	ori	t3, a1, 0x0
+	nop
+	ori	t4, a2, 0x0
+	nop
+
+tap_addr_loop:
+	lw	t5, 0x0(t2)
+	nop
+	lw	t6, 0x0(t3)
+	nop
+	nop
+	
+	bne	t5, t6, tap_fail
+	nop
+	nop
+	nop
+
+	addiu	t2, t2, 0x4  //#incrementing addr
+	addiu	t3, t3, 0x4
+	nop
+	nop
+	
+	bne	t3, t4, tap_addr_loop
+	nop	
+	
+	addiu	t7, t7, -1
+	nop
+	bnez	t7, pat_read
+	nop
+	nop
+	
+	bnez	t1, tap_incr
+	nop
+	nop
+	
+	bnez	t0, tap_decr	//# t0=0 implies tap=0 works
+	nop		 //# so low limit=0, else decrement tap value
+	nop
+	li	t8, 0x80500000
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0 //#adding lower limit to upper limit (used to calc mid value)
+	nop
+	nop
+	
+	b tap_calc
+	nop
+	nop
+
+tap_decr:
+	addiu	t0, t0 , -1
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_incr:
+	addiu	t0, t0 , 0x1
+	nop
+	xori	v1, t0, 0x20
+	nop
+	bnez	v1, load_tap
+	nop
+	nop
+	b up_limit
+	nop
+	nop
+
+tap_fail:
+	bnez	t1, up_limit 
+	nop
+	nop
+	nop
+	addiu	t0, t0, 0x1
+	nop
+	li	t8, 0x80500000
+	nop
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0
+	nop
+	nop
+	nop
+	
+	b tap_calc
+	nop
+	nop
+
+up_limit:
+	addiu	t0, t0, -1 
+	li	t1, 0x0	 //## changing to decreasing tap mode	
+	li	t8, 0x80500000 //## storing upper limit
+	sw	t0, 0x4(t8)	
+	ori	t9, t0, 0x0	
+	nop
+	nop
+	nop
+	
+	ori	t0, a3, 0x0 	//# loading default tap value 
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_calc:  //## calculating mid value of the tap, storing DQS0, DQS1 in 0x80500008, 0x8050000c resp.
+	li	t7, 0x2
+	nop
+	div	t9, t7
+	nop
+	mfhi	t6
+	mflo	t5
+	nop
+	nop
+	add	t6, t6, t5
+	li	t8, 0x80500000
+	nop
+	sw	t5, 0x8(t8)
+	nop
+	sw	t6, 0xc(t8)
+	nop
+	nop
+        li      t8, 0xb8000000  //#### Loading Tap Setting
+	nop
+        sw      t5, 0x1c(t8)
+        nop
+        sw      t6, 0x20(t8)
+        nop
+	nop
+	nop
+#endif /* SIMPLE_DDR_TAP_CAL */
+
+end:
+	nop
+	nop
+	nop
+	jr 	ra
+
+	.end	hornet_ddr_tap_init
+/* } */
diff --git a/cpu/mips/ar7240/hornet_serial.c b/cpu/mips/ar7240/hornet_serial.c
new file mode 100644
index 0000000000..56d87461a9
--- /dev/null
+++ b/cpu/mips/ar7240/hornet_serial.c
@@ -0,0 +1,216 @@
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <config.h>
+#include <hornet_soc.h>
+
+#define uart_reg_read(x)        ar7240_reg_rd( (AR7240_UART_BASE+x) )
+#define uart_reg_write(x, y)    ar7240_reg_wr( (AR7240_UART_BASE+x), y)
+
+static int
+AthrUartGet(char *__ch_data)
+{
+    u32    rdata;    
+    
+    rdata = uart_reg_read(UARTDATA_ADDRESS);
+
+    if (UARTDATA_UARTRXCSR_GET(rdata)) {
+        *__ch_data = (char)UARTDATA_UARTTXRXDATA_GET(rdata);
+        rdata = UARTDATA_UARTRXCSR_SET(1);
+        uart_reg_write(UARTDATA_ADDRESS, rdata); 
+        return 1;
+    }
+    else {
+        return 0;        
+    }
+}
+
+static void
+AthrUartPut(char __ch_data)
+{
+    u32 rdata;
+
+    do {
+        rdata = uart_reg_read(UARTDATA_ADDRESS);
+    } while (UARTDATA_UARTTXCSR_GET(rdata) == 0);
+    
+    rdata = UARTDATA_UARTTXRXDATA_SET((u32)__ch_data);
+    rdata |= UARTDATA_UARTTXCSR_SET(1);
+
+    uart_reg_write(UARTDATA_ADDRESS, rdata);
+}
+
+void
+ar7240_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq)
+{
+#ifdef CONFIG_HORNET_EMU
+    #ifdef CONFIG_HORNET_EMU_HARDI_WLAN
+    *cpu_freq = 48 * 1000000;
+    *ddr_freq = 48 * 1000000;
+    *ahb_freq = 24 * 1000000;    
+    #else
+    *cpu_freq = 80 * 1000000;
+    *ddr_freq = 80 * 1000000;
+    *ahb_freq = 40 * 1000000;
+    #endif
+#else
+    u32     ref_clock_rate, pll_freq;
+    u32     pllreg, clockreg;
+    u32     nint, refdiv, outdiv;
+    u32     cpu_div, ahb_div, ddr_div;
+
+    if ( ar7240_reg_rd(HORNET_BOOTSTRAP_STATUS) & HORNET_BOOTSTRAP_SEL_25M_40M_MASK )
+        ref_clock_rate = 40 * 1000000;
+    else
+        ref_clock_rate = 25 * 1000000;
+
+    pllreg   = ar7240_reg_rd(AR7240_CPU_PLL_CONFIG);
+    clockreg = ar7240_reg_rd(AR7240_CPU_CLOCK_CONTROL);    
+    
+    if (clockreg & HORNET_CLOCK_CONTROL_BYPASS_MASK) {
+        /* Bypass PLL */ 
+        pll_freq = ref_clock_rate;
+        cpu_div = ahb_div = ddr_div = 1;
+    }
+    else {
+        nint = (pllreg & HORNET_PLL_CONFIG_NINT_MASK) >> HORNET_PLL_CONFIG_NINT_SHIFT;
+        refdiv = (pllreg & HORNET_PLL_CONFIG_REFDIV_MASK) >> HORNET_PLL_CONFIG_REFDIV_SHIFT;
+        outdiv = (pllreg & HORNET_PLL_CONFIG_OUTDIV_MASK) >> HORNET_PLL_CONFIG_OUTDIV_SHIFT;
+        
+        pll_freq = (ref_clock_rate / refdiv) * nint;
+        
+        if (outdiv == 1)
+            pll_freq /= 2;
+        else if (outdiv == 2)   
+            pll_freq /= 4;                    
+        else if (outdiv == 3)  
+            pll_freq /= 8;             
+        else if (outdiv == 4) 
+            pll_freq /= 16;                
+        else if (outdiv == 5) 
+            pll_freq /= 32;             
+        else if (outdiv == 6)  
+            pll_freq /= 64;              
+        else if (outdiv == 7)  
+            pll_freq /= 128;              
+        else /* outdiv == 0 --> illegal value */                                                                     
+            pll_freq /= 2;   
+            
+        cpu_div = (clockreg & HORNET_CLOCK_CONTROL_CPU_POST_DIV_MASK) >> HORNET_CLOCK_CONTROL_CPU_POST_DIV_SHIFT;
+        ddr_div = (clockreg & HORNET_CLOCK_CONTROL_DDR_POST_DIV_MASK) >> HORNET_CLOCK_CONTROL_DDR_POST_DIV_SFIFT;
+        ahb_div = (clockreg & HORNET_CLOCK_CONTROL_AHB_POST_DIV_MASK) >> HORNET_CLOCK_CONTROL_AHB_POST_DIV_SFIFT;
+        
+        /*
+         * b00 : div by 1, b01 : div by 2, b10 : div by 3, b11 : div by 4
+         */
+        cpu_div++;
+        ddr_div++;
+        ahb_div++;                              
+    }
+    
+    *cpu_freq = pll_freq / cpu_div;
+    *ddr_freq = pll_freq / ddr_div;
+    *ahb_freq = pll_freq / ahb_div;
+#endif
+}
+
+int serial_init(void)
+{
+    u32 rdata;
+    u32 baudRateDivisor, clock_step;
+    u32 fcEnable = 0; 
+    u32 ahb_freq, ddr_freq, cpu_freq;
+
+    ar7240_sys_frequency(&cpu_freq, &ddr_freq, &ahb_freq);    
+
+    /* GPIO Configuration */
+    ar7240_reg_wr(AR7240_GPIO_OE, 0xcff);
+    rdata = ar7240_reg_rd(AR7240_GPIO_OUT);
+    rdata |= 0x400; // GPIO 10 (UART_SOUT) must output 1
+    ar7240_reg_wr(AR7240_GPIO_OUT, rdata);
+
+    rdata = ar7240_reg_rd(AR7240_GPIO_FUNC);
+    /* GPIO_FUN, bit1/UART_EN, bit2/UART_RTS_CTS_EN, bit15(disable_s26_uart) */
+    rdata |= (0x3<<1)|(0x1<<15); 
+    ar7240_reg_wr(AR7240_GPIO_FUNC, rdata);
+    
+    /* Get reference clock rate, then set baud rate to 115200 */
+#ifndef CONFIG_HORNET_EMU
+
+    rdata = ar7240_reg_rd(HORNET_BOOTSTRAP_STATUS);
+    rdata &= HORNET_BOOTSTRAP_SEL_25M_40M_MASK;
+
+    if (rdata)
+        baudRateDivisor = ( 40000000 / (16*115200) ) - 1; // 40 MHz clock is taken as UART clock        
+    else
+        baudRateDivisor = ( 25000000 / (16*115200) ) - 1; // 25 MHz clock is taken as UART clock	        
+#else
+    baudRateDivisor = ( ahb_freq / (16*115200) ) - 1; // 40 MHz clock is taken as UART clock 
+#endif
+ 
+    clock_step = 8192;
+    
+	rdata = UARTCLOCK_UARTCLOCKSCALE_SET(baudRateDivisor) | UARTCLOCK_UARTCLOCKSTEP_SET(clock_step);
+	uart_reg_write(UARTCLOCK_ADDRESS, rdata);    
+    
+    /* Config Uart Controller */
+#if 1 /* No interrupt */
+	rdata = UARTCS_UARTDMAEN_SET(0) | UARTCS_UARTHOSTINTEN_SET(0) | UARTCS_UARTHOSTINT_SET(0)
+	        | UARTCS_UARTSERIATXREADY_SET(0) | UARTCS_UARTTXREADYORIDE_SET(~fcEnable) 
+	        | UARTCS_UARTRXREADYORIDE_SET(~fcEnable) | UARTCS_UARTHOSTINTEN_SET(0);
+#else    
+	rdata = UARTCS_UARTDMAEN_SET(0) | UARTCS_UARTHOSTINTEN_SET(0) | UARTCS_UARTHOSTINT_SET(0)
+	        | UARTCS_UARTSERIATXREADY_SET(0) | UARTCS_UARTTXREADYORIDE_SET(~fcEnable) 
+	        | UARTCS_UARTRXREADYORIDE_SET(~fcEnable) | UARTCS_UARTHOSTINTEN_SET(1);
+#endif	        	        
+	        
+    /* is_dte == 1 */
+    rdata = rdata | UARTCS_UARTINTERFACEMODE_SET(2);   
+    
+	if (fcEnable) {
+	   rdata = rdata | UARTCS_UARTFLOWCONTROLMODE_SET(2); 
+	}
+	
+    /* invert_fc ==0 (Inverted Flow Control) */
+    //rdata = rdata | UARTCS_UARTFLOWCONTROLMODE_SET(3);
+    
+    /* parityEnable == 0 */
+    //rdata = rdata | UARTCS_UARTPARITYMODE_SET(2); -->Parity Odd  
+    //rdata = rdata | UARTCS_UARTPARITYMODE_SET(3); -->Parity Even
+    uart_reg_write(UARTCS_ADDRESS, rdata);
+    
+    return 0;
+}
+
+int serial_tstc (void)
+{
+    return (UARTDATA_UARTRXCSR_GET(uart_reg_read(UARTDATA_ADDRESS)));
+}
+
+u8 serial_getc(void)
+{
+    char    ch_data;
+
+    while (!AthrUartGet(&ch_data))  ;
+
+    return (u8)ch_data;
+}
+
+
+void serial_putc(u8 byte)
+{
+    if (byte == '\n')   AthrUartPut('\r');
+
+    AthrUartPut((char)byte);
+}
+
+void serial_setbrg (void)
+{
+}
+
+void serial_puts (const char *s)
+{
+	while (*s)
+	{
+		serial_putc (*s++);
+	}
+}
diff --git a/cpu/mips/ar7240/meminit.c b/cpu/mips/ar7240/meminit.c
new file mode 100644
index 0000000000..4d9ebec82b
--- /dev/null
+++ b/cpu/mips/ar7240/meminit.c
@@ -0,0 +1,558 @@
+/* 
+ * Memory controller config:
+ * Assumes that the caches are initialized.
+ *
+ * 0) Figah out the Tap controller settings.
+ * 1) Figure out whether the interface is 16bit or 32bit.
+ * 2) Size the DRAM
+ *
+ *  0) Tap controller settings
+ *  --------------------------
+ * The Table below provides all possible values of TAP controllers. We need to
+ * find the extreme left and extreme right of the spectrum (of max_udelay and
+ * min_udelay). We then program the TAP to be in the middle.
+ * Note for this we would need to be able to read and write memory. So, 
+ * initially we assume that a 16bit interface, which will always work unless
+ * there is exactly _1_ 32 bit part...for now we assume this is not the case.
+ * 
+ * The algo:
+ * 0) Program the controller in 16bit mode.
+ * 1) Start with the extreme left of the table
+ * 2) Write 0xa4, 0xb5, 0xc6, 0xd7 to 0, 2, 4, 6
+ * 3) Read 0 - this will fetch the entire cacheline.
+ * 4) If the value at address 4 is good, record this table entry, goto 6
+ * 5) Increment to get the next table entry. Goto 2.
+ * 6) Start with extreme right. Do the same as above.
+ *
+ * 1) 16bit or 32bit
+ * -----------------
+ *  31st bit of reg 0x1800_0000 will  determine the mode. By default, 
+ *  controller is set to 32-bit mode. In 32 bit mode, full data bus DQ [31:0] 
+ *  will be used to write 32 bit data. Suppose you have 16bit DDR memory
+ *  (it will have 16bit wide data bus). If you try to write 16 bit DDR in 32 
+ *  bit mode, you are going to miss upper 16 bits of data. Reading to that 
+ *  location will give you only lower 16 bits correctly, upper 16 bits will 
+ *  have some junk value. E.g.,
+ *
+ *  write to 0x0000_0000 0x12345678
+ *  write to 0x0000_1000 0x00000000 (just to discharge DQ[31:16] )
+ *  read from 0x0000_0000
+ *  if u see something like 0x0000_5678 (or XXXX_5678 but not equal to 
+ *  0x12345678) - its a 16 bit interface
+ *
+ *  2) Size the DRAM
+ *  -------------------
+ *  DDR wraps around. Write a pattern to 0x0000_0000. Write an address 
+ *  pattern at 4M, 8M, 16M etc. and check when 0x0000_0000 gets overwritten.
+ *
+ *
+ *  We can use #define's for all these addresses and patterns but its easier
+ *  to see what's going on without :)
+ */
+#include <common.h>
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+uint8_t     tap_settings[] = 
+            {0x40, 0x41, 0x10, 0x12, 0x13, 0x15, 0x1a, 0x1c, 0x1f, 0x2f, 0x3f};
+
+uint16_t    tap_pattern[] = {0xa5, 0xb6, 0xc7, 0xd8};
+
+void
+ar7240_ddr_tap_set(uint8_t set)
+{
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL0, set);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL1, set);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL2, set);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL3, set);
+}
+
+/*
+ * We check for size in 4M increments
+ */
+#define AR7240_DDR_SIZE_INCR    (4*1024*1024)
+int
+ar7240_ddr_find_size(void)
+{
+    uint8_t  *p = (uint8_t *)KSEG1, pat = 0x77;
+    int i;
+
+    *p = pat;
+
+    for(i = 1; ; i++) {
+        *(p + i * AR7240_DDR_SIZE_INCR) = (uint8_t)(i);
+        if (*p != pat) {
+            break;
+        }
+    }
+
+    return (i*AR7240_DDR_SIZE_INCR);
+}
+
+#ifndef CONFIG_WASP
+void
+ar7240_ddr_initial_config(uint32_t refresh)
+{
+	int ddr2 = 0,ddr_config;
+	int ddr_config2,ext_mod,ddr2_ext_mod;
+	int mod_val,mod_val_init;
+
+	prmsg("\nsri\n");
+#if 0
+	ar7240_reg_wr(AR7240_RESET, AR7240_RESET_DDR);
+	udelay(10);
+#endif
+	ddr2 = ((ar7240_reg_rd(0xb8050020) & 0x1) == 0);
+#ifdef ENABLE_DYNAMIC_CONF
+	if(*(volatile int *)CFG_DDR_MAGIC_F == CFG_DDR_MAGIC){
+		ddr_config = CFG_DDR_CONFIG_VAL_F;
+		ddr_config2 = CFG_DDR_CONFIG2_VAL_F;
+		ext_mod = CFG_DDR_EXT_MODE_VAL_F;
+		ddr2_ext_mod = ext_mod;
+	}
+	else
+#endif
+	{
+#ifdef CONFIG_SUPPORT_AR7241
+		if (is_ar7241() || is_ar7242()) {
+			if (ddr2) {
+				prmsg("%s(%d): virian ddr2 init\n", __func__, __LINE__);
+				ddr_config	= CFG_7241_DDR2_CONFIG_VAL;
+				ddr_config2	= CFG_7241_DDR2_CONFIG2_VAL;
+				ext_mod		= CFG_7241_DDR2_EXT_MODE_VAL;
+				ddr2_ext_mod	= CFG_DDR2_EXT_MODE_VAL;
+				mod_val_init	= CFG_7241_DDR2_MODE_VAL_INIT;
+				mod_val		= CFG_7241_DDR2_MODE_VAL;
+			} else {
+				prmsg("%s(%d): virian ddr1 init\n", __func__, __LINE__);
+				ddr_config	= CFG_7241_DDR1_CONFIG_VAL;
+				ddr_config2	= CFG_7241_DDR1_CONFIG2_VAL;
+				ext_mod		= CFG_7241_DDR1_EXT_MODE_VAL;
+				ddr2_ext_mod	= CFG_DDR2_EXT_MODE_VAL;
+				mod_val_init	= CFG_7241_DDR1_MODE_VAL_INIT;
+				mod_val		= CFG_7241_DDR1_MODE_VAL;
+			}
+		}
+		else
+#endif
+		{
+			prmsg("%s(%d): python ddr init\n", __func__, __LINE__);
+			ddr_config = CFG_DDR_CONFIG_VAL;
+			ddr_config2 = CFG_DDR_CONFIG2_VAL;
+			ext_mod = CFG_DDR_EXT_MODE_VAL;
+#ifndef CONFIG_WASP_EMU
+			ddr2_ext_mod = CFG_DDR2_EXT_MODE_VAL;
+#endif
+			mod_val_init = CFG_DDR_MODE_VAL_INIT;
+			mod_val = CFG_DDR_MODE_VAL;
+		}
+	}
+
+	if (ddr2) {
+		ar7240_reg_wr_nf(0xb800008c, 0xA59);
+		udelay(100);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x10);
+		udelay(10);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x20);
+		udelay(10);
+	}
+
+	ar7240_reg_wr_nf(AR7240_DDR_CONFIG, ddr_config);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONFIG2, ddr_config2 | 0x80);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);
+	udelay(10);
+
+	ar7240_reg_wr_nf(AR7240_DDR_MODE, mod_val_init);
+	udelay(1000);
+
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);
+	udelay(10);
+
+	if (ddr2) {
+		ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, ddr2_ext_mod);
+	} else {
+		ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, ext_mod);
+	}
+
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2);
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_MODE, mod_val);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_REFRESH, refresh);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_RD_DATA_THIS_CYCLE,
+				CFG_DDR_RD_DATA_THIS_CYCLE_VAL);
+	udelay(100);
+}
+#else
+int /* ram type */
+wasp_ddr_initial_config(uint32_t refresh)
+{
+#if !defined(CONFIG_ATH_NAND_BR)
+	int		ddr_config, ddr_config2, ext_mod, mod_val,
+			mod_val_init, cycle_val, tap_val, type;
+	uint32_t	*pll = (unsigned *)PLL_CONFIG_VAL_F;
+
+	prmsg("\nsri\n");
+	prmsg("Wasp 1.%d\n", ar7240_reg_rd(AR7240_REV_ID) & 0xf);
+
+	switch(WASP_RAM_TYPE(ar7240_reg_rd(WASP_BOOTSTRAP_REG))) {
+	case 0:
+	case 1:	// SDRAM
+		/*
+		XXX XXX XXX XXX XXX XXX XXX XXX XXX
+		Boot strap select is not working. In some boards,
+		ddr2 shows up as sdram. Hence ignoring the foll.
+		break statement.
+		XXX XXX XXX XXX XXX XXX XXX XXX XXX
+		break;
+		*/
+		prmsg("%s(%d): Wasp sdram\n", __func__, __LINE__);
+		ddr_config	= CFG_934X_SDRAM_CONFIG_VAL;
+		ddr_config2	= CFG_934X_SDRAM_CONFIG2_VAL;
+		mod_val_init	= CFG_934X_SDRAM_MODE_VAL_INIT;
+		mod_val		= CFG_934X_SDRAM_MODE_VAL;
+		cycle_val	= CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL;
+		tap_val		= CFG_934X_SDRAM_TAP_VAL;
+
+		ar7240_reg_wr_nf(AR7240_DDR_CTL_CONFIG, 0x13b);
+		udelay(100);
+
+		ar7240_reg_wr_nf(AR7240_DDR_DEBUG_RD_CNTL, 0x3000001f);
+		udelay(100);
+
+		type = 0;
+
+		break;
+	case 2: // ddr2
+		ddr_config	= CFG_934X_DDR2_CONFIG_VAL;
+		ddr_config2	= CFG_934X_DDR2_CONFIG2_VAL;
+		ext_mod		= CFG_934X_DDR2_EXT_MODE_VAL;
+		mod_val_init	= CFG_934X_DDR2_MODE_VAL_INIT;
+		mod_val		= CFG_934X_DDR2_MODE_VAL;
+		cycle_val	= CFG_DDR2_RD_DATA_THIS_CYCLE_VAL;
+		tap_val		= CFG_934X_DDR2_TAP_VAL;
+
+		prmsg("%s(%d): (", __func__, __LINE__);
+		if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+							/* NAND Clear */
+			if (ar7240_reg_rd(WASP_BOOTSTRAP_REG) & (1 << 3)) {
+				prmsg("32");
+				cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32;
+				ar7240_reg_wr_nf(AR7240_DDR_CTL_CONFIG, (1 << 6));
+			} else {
+				prmsg("16");
+				cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16;
+				ar7240_reg_rmw_set(AR7240_DDR_CTL_CONFIG, (1 << 6));
+				ar7240_reg_rmw_clear(AR7240_DDR_CTL_CONFIG, (0xf << 2));
+			}
+		} else {
+#if DDR2_32BIT_SUPPORT
+			prmsg("32");
+			ar7240_reg_wr_nf(AR7240_DDR_CTL_CONFIG, 0);
+#else
+			prmsg("16");
+#endif
+		}
+		prmsg("bit) ddr2 init\n");
+		udelay(10);
+		type = 1;
+
+		break;
+	case 3: // ddr1
+		prmsg("%s(%d): Wasp (16bit) ddr1 init\n", __func__, __LINE__);
+		ddr_config	= CFG_934X_DDR1_CONFIG_VAL;
+		ddr_config2	= CFG_934X_DDR1_CONFIG2_VAL;
+		ext_mod		= CFG_934X_DDR1_EXT_MODE_VAL;
+		mod_val_init	= CFG_934X_DDR1_MODE_VAL_INIT;
+		mod_val		= CFG_934X_DDR1_MODE_VAL;
+		cycle_val	= CFG_DDR1_RD_DATA_THIS_CYCLE_VAL;
+		tap_val		= CFG_934X_DDR1_TAP_VAL;
+		type = 2;
+		break;
+	}
+#if 0
+	if (*pll == PLL_MAGIC) {
+		uint32_t cas = pll[5];
+		if (cas == 3 || cas == 4) {
+			cas = (cas * 2) + 1;
+			ddr_config &= ~(DDR_CONFIG_CAS_LATENCY_MSB_MASK |
+					DDR_CONFIG_CAS_LATENCY_MASK);
+			ddr_config |= DDR_CONFIG_CAS_LATENCY_SET(cas & 0x7) |
+				DDR_CONFIG_CAS_LATENCY_MSB_SET((cas >> 3) & 1);
+
+			cas = pll[5];
+
+			ddr_config2 &= ~DDR_CONFIG2_GATE_OPEN_LATENCY_MASK;
+			ddr_config2 |= DDR_CONFIG2_GATE_OPEN_LATENCY_SET(2 * cas);
+
+			if (type == 1) {
+				uint32_t tmp;
+				tmp = ar7240_reg_rd(AR7240_DDR_DDR2_CONFIG);
+				tmp &= ~DDR2_CONFIG_DDR2_TWL_MASK;
+				tmp |= DDR2_CONFIG_DDR2_TWL_SET(cas == 3 ? 3 : 5);
+				ar7240_reg_wr_nf(AR7240_DDR_DDR2_CONFIG, tmp);
+			}
+
+			mod_val = (cas == 3 ? 0x33 : 0x43);
+			mod_val_init = 0x100 | mod_val;
+		}
+	}
+#else
+	if (*pll == PLL_MAGIC) {
+		uint32_t cas = pll[5];
+		if (cas == 3 || cas == 4) {
+			cas = (cas * 2) + 2;
+			ddr_config &= ~(DDR_CONFIG_CAS_LATENCY_MSB_MASK |
+					DDR_CONFIG_CAS_LATENCY_MASK);
+			ddr_config |= DDR_CONFIG_CAS_LATENCY_SET(cas & 0x7) |
+				DDR_CONFIG_CAS_LATENCY_MSB_SET((cas >> 3) & 1);
+
+			cas = pll[5];
+
+			ddr_config2 &= ~DDR_CONFIG2_GATE_OPEN_LATENCY_MASK;
+			ddr_config2 |= DDR_CONFIG2_GATE_OPEN_LATENCY_SET((2 * cas) + 1);
+
+			if (type == 1) {
+				uint32_t tmp;
+				tmp = ar7240_reg_rd(AR7240_DDR_DDR2_CONFIG);
+				tmp &= ~DDR2_CONFIG_DDR2_TWL_MASK;
+				tmp |= DDR2_CONFIG_DDR2_TWL_SET(cas == 3 ? 3 : 5);
+				ar7240_reg_wr_nf(AR7240_DDR_DDR2_CONFIG, tmp);
+			}
+
+			mod_val = (cas == 3 ? 0x33 : 0x43);
+			mod_val_init = 0x100 | mod_val;
+		}
+	}
+#endif
+
+	ar7240_reg_wr_nf(AR7240_DDR_RD_DATA_THIS_CYCLE, cycle_val);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_BURST, 0x74444444);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_BURST2, 0x222);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_AHB_MASTER_TIMEOUT, 0xfffff);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONFIG, ddr_config);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONFIG2, ddr_config2);
+	udelay(100);
+	if (type == 1) {
+		ar7240_reg_wr_nf(AR7240_DDR_DDR2_CONFIG, CFG_934X_DDR2_EN_TWL_VAL);
+		udelay(100);
+	}
+	ar7240_reg_wr_nf(AR7240_DDR_CONFIG2, ddr_config2 | 0x80); // CKE enable
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8); // Precharge
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8); // Precharge
+	udelay(10);
+
+	if (type == 1) {
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x10); // EMR2
+		udelay(10);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x20); // EMR3
+		udelay(10);
+	}
+	if (type != 0) {
+		ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, 0x2);
+		udelay(100);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2); // EMR DLL enable
+		udelay(10);
+	}
+	ar7240_reg_wr_nf(AR7240_DDR_MODE, mod_val_init);
+	udelay(1000);
+
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1); // MR Write
+	udelay(10);
+
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8); // Precharge
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8); // Precharge
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x4); // Auto Refresh
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x4); // Auto Refresh
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_MODE, mod_val);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1); // MR Write
+	udelay(10);
+	if (type == 1) {
+		ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, CFG_934X_DDR2_EXT_MODE_VAL_INIT);
+		udelay(100);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2); // EMR write
+		udelay(100);
+		ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, CFG_934X_DDR2_EXT_MODE_VAL);
+		udelay(100);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2); // EMR write
+		udelay(100);
+	}
+
+	ar7240_reg_wr_nf(AR7240_DDR_REFRESH, refresh);
+	udelay(100);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, tap_val);
+	ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, tap_val);
+
+	if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+						/* NAND Clear */
+		if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & (1 << 3)) && type) {
+			ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, tap_val);
+			ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, tap_val);
+		}
+	} else {
+#if DDR2_32BIT_SUPPORT
+		if (type != 0) {
+			ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, tap_val);
+			ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, tap_val);
+		}
+#endif
+	}
+		prmsg("%s(%d): Wasp ddr init done\n", __func__, __LINE__);
+
+#if (CFG_PLL_FREQ == CFG_PLL_600_500_250) || \
+    (CFG_PLL_FREQ == CFG_PLL_500_500_250)
+	// PMU2 ddr ldo tune
+	ar7240_reg_rmw_set(0xb8116c44, (0x3 << 19));
+	udelay(100);
+#endif
+	return type;
+#else
+	return 0;
+#endif
+}
+#endif
+
+#ifdef CONFIG_HORNET_EMU
+void
+ar7240_ddr_initial_config_for_fpga(void)
+{
+ #ifdef CONFIG_HORNET_EMU_HARDI
+    /* HARDI FPGA board */
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x4);          /* Auto-Refresh */
+    udelay(10);      
+    ar7240_reg_wr_nf(AR7240_DDR_REFRESH, 0x4100);
+    udelay(10);  
+        
+    ar7240_reg_wr_nf(AR7240_DDR_CONFIG, 0x7fd68cd0);    /* Cas Latency 7 */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONFIG2, 0x959ec6a8);   /* Gate Open 5 */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_DDR2_CONFIG, 0x858);    /* Disable DDR2, set Write Latency */
+    udelay(10);    
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);          /* precharge all */
+    udelay(10);       
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);          /* precharge all */
+    udelay(10);       
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);          /* MR update */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_MODE, 0x133);           /* Mode Word Settings  */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, 0x0);         /* Extended Mode Word Settings */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_RD_DATA_THIS_CYCLE, 0xff);  /* DDR read data capture bit mask */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);          /* MR update */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2);          /* EMR update */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);          /* precharge all */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);          /* precharge all */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x4);          /* Auto-Refresh */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x4);          /* Auto-Refresh */
+    udelay(10);        
+    ar7240_reg_wr_nf(AR7240_DDR_MODE, 0x133);           /* Mode Word Settings  */
+    udelay(10);    
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);          /* MR update */    
+    udelay(10); 
+    ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, 0x382);       /* Extended Mode Word Settings */     
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2);          /* EMR update */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, 0x402);       /* Extended Mode Word Settings */     
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2);          /* EMR update */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_MODE, 0x33);            /* Mode Word Settings  */
+    udelay(10);    
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);          /* MR update */    
+    udelay(10);
+    #ifdef CONFIG_HORNET_EMU_HARDI_WLAN
+    /* 
+     * Emulation board reference clock is 48 MHz(20.833ns)
+     * DDR request 64ms has 8192 refresh
+     * So each refresh interval is 64ms/8192 = 7812.5 ns
+     * i.e ddr have to refresh in 7812.5/20.833 = 375 = 0x177 clock cycles     
+     */
+    ar7240_reg_wr_nf(AR7240_DDR_REFRESH, 0x4177);
+    #else
+    /* 
+     * Emulation board reference clock is 80 MHz(12.5ns)
+     * DDR request 64ms has 8192 refresh
+     * So each refresh interval is 64ms/8192 = 7812.5 ns
+     * i.e ddr have to refresh in 7812.5/12.5 = 625 = 0x271 clock cycles
+     */
+    ar7240_reg_wr_nf(AR7240_DDR_REFRESH, 0x4271);
+    #endif
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL0, 0x0);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL1, 0x0);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL2, 0x0);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL3, 0x0);
+    udelay(10);
+ #else
+    /* EBU FPGA board */
+    ar7240_reg_wr_nf(AR7240_DDR_CONFIG, 0xc7bc8cd0); /* Cas Latency 8 */
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_CONFIG2, 0x95d0e6a8); /* Gate Open 5 */
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_MODE, 0x123);
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, 0x1);
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_MODE, 0x23);
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);
+    udelay(10);
+    /* 
+     * Emulation board reference clock is 80 MHz(12.5ns)
+     * DDR request 64ms has 8192 refresh
+     * So each refresh interval is 64ms/8192 = 7812.5 ns
+     * i.e ddr have to refresh in 7812.5/12.5 = 625 = 0x271 clock cycles     
+     */
+    ar7240_reg_wr_nf(AR7240_DDR_REFRESH, 0x4271);
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_RD_DATA_THIS_CYCLE, 0x00ff);
+    udelay(100);
+ #endif
+}
+#endif
diff --git a/cpu/mips/cache.S b/cpu/mips/cache.S
index aad76e0afb..79a118afbb 100644
--- a/cpu/mips/cache.S
+++ b/cpu/mips/cache.S
@@ -31,10 +31,10 @@
 #include <asm/cacheops.h>
 
 
-	/* 16KB is the maximum size of instruction and data caches on
-	 * MIPS 4K.
+	/* 64K is the maximum size of instruction and data caches on
+	 * MIPS 24K.
 	 */
-#define MIPS_MAX_CACHE_SIZE	0x4000
+#define MIPS_MAX_CACHE_SIZE	65536
 
 
 /*
@@ -106,6 +106,41 @@
 #define icacheop(kva, n, cacheSize, cacheLineSize, op) \
    icacheopn(kva, n, cacheSize, cacheLineSize, 1, (op))
 
+
+.globl simple_mips_cache_reset
+.ent   simple_mips_cache_reset
+
+simple_mips_cache_reset:
+        li      t2, CFG_ICACHE_SIZE
+        li      t3, CFG_DCACHE_SIZE
+        li      t4, CFG_CACHELINE_SIZE
+
+        mtc0    zero, CP0_TAGLO
+#if defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA953x)
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+
+        li      t0, K0BASE
+    	add     t2, t2, t0
+
+_arai_icache_loop:
+    	cache   Index_Store_Tag_I, 0(t0)
+    	add     t0, t0, t4
+    	bne     t0, t2, _arai_icache_loop
+
+        li      t0, K0BASE
+    	add     t3, t3, t0
+_arai_dcache_loop:
+    	cache   Index_Store_Tag_D, 0(t0)
+    	add     t0, t0, t4
+    	bne     t0, t3, _arai_dcache_loop
+	
+	j  ra
+	.end  simple_mips_cache_reset
+	
+
 /*******************************************************************************
 *
 * mips_cache_reset - low level initialisation of the primary caches
@@ -154,7 +189,14 @@ mips_cache_reset:
 	/* Set invalid tag.
 	 */
 
+
 	mtc0	zero, CP0_TAGLO
+#ifdef CONFIG_WASP_SUPPORT
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+
 
    /*
     * The caches are probably in an indeterminate state,
@@ -183,6 +225,7 @@ mips_cache_reset:
 	move	a1, a2
 	icacheop(a0,a1,a2,a3,Index_Store_Tag_D)
 
+
 	/* 2: fill dcache.
 	 */
 
@@ -192,6 +235,7 @@ mips_cache_reset:
 	move	a1, a2
 	icacheopn(a0,a1,a2,a3,1lw,(dummy))
 
+
 	/* 3: clear dcache tags.
 	 */
 
@@ -201,6 +245,7 @@ mips_cache_reset:
 	move	a1, a2
 	icacheop(a0,a1,a2,a3,Index_Store_Tag_D)
 
+
 	j  ra
 	.end  mips_cache_reset
 
@@ -267,3 +312,132 @@ mips_cache_lock:
 
 	j	ra
 	.end	mips_cache_lock
+
+/*****************************************************************************
+ * flushes a range in dcache
+ * a0 = start
+ * a1 = end
+ */
+    .globl  dcache_flush_range
+    .ent    dcache_flush_range
+dcache_flush_range:
+    move    t0, a0
+    li      t1, CFG_CACHELINE_SIZE
+    move    t2, a1
+cache_loop_d_flush_range:
+    cache   Hit_Writeback_Inv_D, 0(t0)
+    addu    t0, t1
+    bne     t0, t2, cache_loop_d_flush_range
+    nop
+	j  ra
+    .end    dcache_flush_range
+
+/****************************************************************************
+ *
+ * mips_cache_flush_all - flushes entire I and D caches.
+ */
+
+    .globl  mips_cache_flush
+    .ent    mips_cache_flush
+mips_cache_flush:
+	/* Flush caches...
+	 */
+	li      t0, (CFG_DCACHE_SIZE)
+    li      t1, CFG_CACHELINE_SIZE
+    li      t2, KSEG0
+    addu    t3, t0, t2
+cache_loop_d_flush:
+    cache   Index_Writeback_Inv_D, 0(t2)
+	ehb
+    addu    t2, t1
+    bne     t2, t3, cache_loop_d_flush
+    nop
+
+    li      t0, (CFG_ICACHE_SIZE)
+    li      t1, CFG_CACHELINE_SIZE
+    li      t2, KSEG0
+    addu    t3, t0, t2
+/*    mtc0    zero, CP0_TAGLO	*/
+#ifdef CONFIG_WASP_SUPPORT
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+cache_loop_flush:
+    cache   Index_Invalidate_I, 0(t2)
+	ehb
+    addu    t2, t1
+    bne     t2, t3, cache_loop_flush
+    nop
+	j  ra
+	.end  mips_cache_flush
+
+/*
+ * Invalidate the I-Cache.
+ * Note:If this is executed from cached address space,
+ *      the cache would still have the addresses of this
+ *      function.
+ */
+	.globl	mips_icache_flush_ix
+	.ent	mips_icache_flush_ix
+
+mips_icache_flush_ix:	/* Flush caches Index Invalidate */
+	li	t0,	(CFG_ICACHE_SIZE)
+	li	t1,	CFG_CACHELINE_SIZE
+	li	t2,	KUSEG
+	addu	t3,	t0,	t2
+	mtc0	zero,	CP0_TAGLO
+#ifdef CONFIG_WASP_SUPPORT
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+icache_loop_flush_ix:
+	cache	Index_Invalidate_I,	0(t2)
+	addu	t2,	t1
+	bne	t2,	t3,	icache_loop_flush_ix
+	nop
+
+	j	ra
+	.end	mips_icache_flush_ix
+
+
+
+/*********************************************************
+ * mips_cache_lock_24k
+ */
+
+    .globl  mips_cache_lock_24k
+    .ent    mips_cache_lock_24k
+
+mips_cache_lock_24k:
+    li      t0, 7936 
+    li      t1, CFG_CACHELINE_SIZE
+    li      t2, KSEG0
+    addu    t3, t0, t2
+    mtc0    zero, CP0_TAGLO
+#ifdef CONFIG_WASP_SUPPORT
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+cache_loop_lock:
+
+    li      t5, 0xfffff000
+    and     t4, t2, t5
+    ori     t4, t4, (1 << 7)
+    mtc0    t4, CP0_TAGLO
+#ifdef CONFIG_WASP_SUPPORT
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+
+    cache   Index_Load_Tag_D, 0(t2)
+    cache   0x1d, 0(t2)
+    addu    t2, t1
+    bne     t2, t3, cache_loop_lock
+    nop
+	j  ra
+    .end    mips_cache_lock_24k
+
diff --git a/cpu/mips/config.mk b/cpu/mips/config.mk
index c357615c03..fb2ccf73ca 100644
--- a/cpu/mips/config.mk
+++ b/cpu/mips/config.mk
@@ -22,7 +22,7 @@
 #
 v=$(shell \
 mips-linux-as --version|grep "GNU assembler"|awk '{print $$3}'|awk -F . '{print $$2}')
-MIPSFLAGS=$(shell \
+#MIPSFLAGS=$(shell \
 if [ "$v" -lt "14" ]; then \
 	echo "-mcpu=4kc"; \
 else \
@@ -31,10 +31,10 @@ fi)
 
 ifneq (,$(findstring 4KCle,$(CROSS_COMPILE)))
 ENDIANNESS = -EL
-else
-ENDIANNESS = -EB
+#else
+#ENDIANNESS = -EB
 endif
 
-MIPSFLAGS += $(ENDIANNESS) -mabicalls
+MIPSFLAGS += $(ENDIANNESS) -mabicalls -march=mips32r2
 
 PLATFORM_CPPFLAGS += $(MIPSFLAGS)
diff --git a/cpu/mips/cpu.c b/cpu/mips/cpu.c
index f48675e996..9fdafde41e 100644
--- a/cpu/mips/cpu.c
+++ b/cpu/mips/cpu.c
@@ -26,22 +26,81 @@
 #include <asm/inca-ip.h>
 #include <asm/mipsregs.h>
 
+#if defined(CONFIG_AR7100)
+#include <asm/addrspace.h>
+#include <ar7100_soc.h>
+#endif
+
+#if defined(CONFIG_AR7240)
+#include <asm/addrspace.h>
+#include <ar7240_soc.h>
+#endif
+
+#if defined(CONFIG_ATHEROS)
+#include <asm/addrspace.h>
+#include <atheros.h>
+#endif
+
+
 int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-#if defined(CONFIG_INCA_IP)
+#if defined(CONFIG_ATHEROS)
+	while (1) {
+		ath_reg_wr(RST_RESET_ADDRESS, RST_RESET_FULL_CHIP_RESET_SET(1));
+	}
+#elif defined(CONFIG_INCA_IP)
 	*INCA_IP_WDT_RST_REQ = 0x3f;
 #elif defined(CONFIG_PURPLE) || defined(CONFIG_TB0229)
 	void (*f)(void) = (void *) 0xbfc00000;
 
 	f();
+#elif defined(CONFIG_AR7100)
+#ifndef COMPRESSED_UBOOT
+	fprintf(stdout, "\nResetting...\n");
+#endif  /* #ifndef COMPRESSED_UBOOT */
+	for (;;) {
+		ar7100_reg_wr(AR7100_RESET,
+			(AR7100_RESET_FULL_CHIP | AR7100_RESET_DDR));
+	}
+#elif defined(CONFIG_AR7240)
+#ifndef COMPRESSED_UBOOT
+	fprintf(stdout, "\nResetting...\n");
+#endif  /* #ifndef COMPRESSED_UBOOT */
+	for (;;) {
+#ifdef CONFIG_WASP
+		if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+			ar7240_reg_wr(AR7240_RESET,
+				(AR7240_RESET_FULL_CHIP | AR7240_RESET_DDR));
+		} else {
+			/*
+			 * WAR for full chip reset spi vs. boot-rom selection
+			 * bug in wasp 1.0
+			 */
+			ar7240_reg_wr (AR7240_GPIO_OE,
+				ar7240_reg_rd(AR7240_GPIO_OE) & (~(1 << 17)));
+		}
+#else
+		ar7240_reg_wr(AR7240_RESET,
+			(AR7240_RESET_FULL_CHIP | AR7240_RESET_DDR));
 #endif
+	}
+#endif
+#ifndef COMPRESSED_UBOOT
 	fprintf(stderr, "*** reset failed ***\n");
+#endif  /* #ifndef COMPRESSED_UBOOT */
 	return 0;
 }
 
 void flush_cache (ulong start_addr, ulong size)
 {
+	u32 end, a;
+    int i;
+
+    a = start_addr & ~(CFG_CACHELINE_SIZE - 1);
+    size = (size + CFG_CACHELINE_SIZE - 1) & ~(CFG_CACHELINE_SIZE - 1);
+    end = a + size;
 
+    dcache_flush_range(a, end);
 }
 
 void write_one_tlb( int index, u32 pagemask, u32 hi, u32 low0, u32 low1 ){
diff --git a/cpu/mips/start.S b/cpu/mips/start.S
index e91e2137d7..897ead6669 100644
--- a/cpu/mips/start.S
+++ b/cpu/mips/start.S
@@ -27,30 +27,34 @@
 #include <version.h>
 #include <asm/regdef.h>
 #include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#ifdef CONFIG_ATHEROS
+#	include <atheros.h>
+#else
+#	include <ar7240_soc.h>
+#	define ATH_SPI_CLOCK	0xbf000004
+#endif
 
 
-#define RVECENT(f,n) \
-   b f; nop
-#define XVECENT(f,bev) \
-   b f     ;           \
-   li k0,bev
+#define RVECENT(f,n)		\
+	b	f;	nop
+
+#define XVECENT(f,bev)		\
+	b	f;		\
+	li	k0,	bev
 
 	.set noreorder
+#ifdef COMPRESSED_UBOOT
+	.align 4
+#endif
 
 	.globl _start
 	.text
 _start:
+#ifndef COMPRESSED_UBOOT
 	RVECENT(reset,0)	/* U-boot entry point */
 	RVECENT(reset,1)	/* software reboot */
-#if defined(CONFIG_INCA_IP)
-	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
-	.word 0x00000000           /* phase of the flash                    */
-#elif defined(CONFIG_PURPLE)
-	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
-	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
-#else
 	RVECENT(romReserved,2)
-#endif
 	RVECENT(romReserved,3)
 	RVECENT(romReserved,4)
 	RVECENT(romReserved,5)
@@ -181,46 +185,119 @@ _start:
 	 * 128 * 8 == 1024 == 0x400
 	 * so this is address R_VEC+0x400 == 0xbfc00400
 	 */
-#ifdef CONFIG_PURPLE
-/* 0xbfc00400 */
-	.word	0xdc870000
-	.word	0xfca70000
-	.word	0x20840008
-	.word	0x20a50008
-	.word	0x20c6ffff
-	.word	0x14c0fffa
-	.word	0x00000000
-	.word	0x03e00008
-	.word	0x00000000
-	.word   0x00000000
-/* 0xbfc00428 */
-	.word	0xdc870000
-	.word	0xfca70000
-	.word	0x20840008
-	.word	0x20a50008
-	.word	0x20c6ffff
-	.word	0x14c0fffa
-	.word	0x00000000
-	.word	0x03e00008
-	.word	0x00000000
-	.word   0x00000000
-#endif /* CONFIG_PURPLE */
+
 	.align 4
 reset:
+#if !defined(CONFIG_ATH_NAND_BR)
+	/*
+	 * Clearing CP0 registers - This is generally required for the MIPS-24k
+	 * core used by Atheros.
+	 */
+	mtc0	zero, $0
+	mtc0	zero, $1
+	mtc0	zero, $2
+	mtc0	zero, $3
+	mtc0	zero, $4
+	mtc0	zero, $5
+	mtc0	zero, $6
+	mtc0	zero, $7
+	mtc0	zero, $8
+	mtc0	zero, $9
+	mtc0	zero, $10
+	mtc0	zero, $11
+	li	t0, 0x10000004
+	mtc0	t0, $12
+	mtc0	zero, $13
+	mtc0	zero, $14
+	mtc0	zero, $15
+	mtc0	zero, $16
+
+#ifdef CONFIG_MACH_QCA955x
+/*
+ * Workaround recommnded by MIPS for the Scorpion Freeze issue
+ */
+#define CONFIG_SCO_JRCD		1
+#define CONFIG_SCO_IAGN		!CONFIG_SCO_JRCD
+
+#if CONFIG_SCO_IAGN && CONFIG_SCO_JRCD
+#error Both CONFIG_SCO_IAGN and CONFIG_SCO_JRCD set
+#endif
+
+#if CONFIG_SCO_JRCD
+	/*
+	 * JR Cache Prediction Disable. Disables JR target address prediction.
+	 * Bit [0], CP0 Register 16, Select 6
+	 *	0 - JR cache target address prediction is enabled.
+	 *	1 - JR cache target address prediction is not enabled.
+	 */
+	mfc0	t0,	$16,	6
+	li	t1,	(1 << 0)
+	or	t0,	t0,	t1
+	mtc0	t0,	$16,	6
+#endif
+
+#if CONFIG_SCO_IAGN
+	/*
+	 * Bit [25], CP0 Register 16, Select 7
+	 * Selective control of out-of-order behavior: issue ALU-side or
+	 * load/store-side instructions (respectively) in program order.
+	 */
+	mfc0	t0,	$16,	7
+	li	t1,	(1 << 25)
+	or	t0,	t0,	t1
+	mtc0	t0,	$16,	7
+#endif
+#endif /* CONFIG_MACH_QCA955x */
+
+#define pref_on		0
+
+#if pref_on
+#define prefetch_val	3
+	mfc0	t0,	$16,	7
+	li	t1,	~(3 << 11)
+	and	t0,	t0,	t1
+	li	t1,	(prefetch_val << 11)
+	or	t0,	t0,	t1
+	mtc0	t0,	$16,	7
+#endif
+
+#if !defined(CONFIG_WASP_SUPPORT)
+	mtc0	zero, $17
+#endif
+	mtc0	zero, $18
+	mtc0	zero, $19
+#if !defined(CONFIG_WASP_SUPPORT)
+	mtc0	zero, $20
+	mtc0	zero, $21
+	mtc0	zero, $22
+#endif
+#ifndef CONFIG_HORNET_EMU
+	mtc0	zero, $23
+#endif
+	mtc0	zero, $24
+	mtc0	zero, $25
+	mtc0	zero, $26
+	mtc0	zero, $27
+	mtc0	zero, $28
+#if defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x)
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+
 
-	/* Clear watch registers.
+	/*
+	 * Clear watch registers.
 	 */
+
 	mtc0	zero, CP0_WATCHLO
 	mtc0	zero, CP0_WATCHHI
 
 	/* STATUS register */
-#ifdef  CONFIG_TB0229
-	li	k0, ST0_CU0
-#else
 	mfc0	k0, CP0_STATUS
-#endif
 	li	k1, ~ST0_IE
 	and	k0, k1
+        mtc0	zero, CP0_CAUSE
 	mtc0	k0, CP0_STATUS
 
 	/* CAUSE register */
@@ -233,9 +310,19 @@ reset:
 	/* CONFIG0 register */
 	li	t0, CONF_CM_UNCACHED
 	mtc0	t0, CP0_CONFIG
+#endif /* !defined(CONFIG_ATH_NAND_BR) */
+#endif /* #ifndef COMPRESSED_UBOOT */
 
-	/* Initialize GOT pointer.
-	*/
+#ifdef CONFIG_ATH_NAND_BR
+	/*
+	 * Clear WDT that was setup in first stage for
+	 * NAND Boot-ROM
+	 */
+	li	t0,	0xb8060008
+	sw	zero,	0(t0)
+#endif /* CONFIG_ATH_NAND_BR */
+
+    /* Initialize GOT pointer.*/
 	bal     1f
 	nop
 	.word   _GLOBAL_OFFSET_TABLE_
@@ -244,47 +331,158 @@ reset:
 	lw      t1, 0(ra)
 	move	gp, t1
 
-#ifdef CONFIG_INCA_IP
-	/* Disable INCA-IP Watchdog.
-	 */
-	la      t9, disable_incaip_wdt
-	jalr    t9
+#define DCACHE_16K	0
+#if DCACHE_16K && defined(CONFIG_WASP_SUPPORT)
+	mfc0	t2,	CP0_CONFIG
+	or	t2,	t2, 0x80000
+	mtc0	t2,	CP0_CONFIG
 	nop
-#endif
+
+	mfc0	t2,	CP0_CONFIG,	1
+	and	t2,	t2, ~(0xe000)
+	or	t2,	t2, 0x3000
+	mtc0	t2,	CP0_CONFIG,	1
+	nop
+
+	mfc0	t2,	CP0_CONFIG
+	and	t2,	t2, ~(0x80000)
+	mtc0	t2,	CP0_CONFIG
+
+#endif	/* DCACHE_16K */
+
+#ifndef COMPRESSED_UBOOT
+
+#if defined(CONFIG_MACH_HORNET) && defined(CONFIG_HORNET_1_1_WAR)
+/**************************************************************************/
+/*
+ * WAR: Hornet 1.1 currently need a reset once we boot to let the resetb has
+ *      enough time to stable, so that trigger reset at 1st boot, system team
+ *      is investigaing the issue, will remove in short
+ */
+
+do_reset_normal:
+
+    li  t7, 0xbd000000
+    lw  t8, 0(t7)            // t8 : value of 0xb8050024
+    li  t9, 0x12345678
+    sw  t9, 0(t7)
+    bne t8, t9, do_reset      // if 0xb8050024 == 0x19 , go to do_cpld
+    nop
+    b normal_path
+
+do_reset:
+    li t7, 0xb806001c       // load reset register 0x1806001c
+    lw t8, 0(t7)
+    li t9, 0x1000000        // bit24, fullchip reset
+    or t8, t8, t9         // t8:  set bit 18
+    sw t8, 0(t7)
+
+normal_path:
+#endif /* CONFIG_MACH_HORNET */
+
+/**************************************************************************/
 
 	/* Initialize any external memory.
 	 */
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
 	la      t9, lowlevel_init
 	jalr    t9
 	nop
+	nop
+
+#if defined(CONFIG_MACH_HORNET)
+	la      t9, hornet_ddr_init
+	jalr    t9
+	nop
+	nop
+#endif
+
+	la	t0, rel_start
+	j	t0
+	nop
+#endif
+
+rel_start:
+
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
+	/* REMAP_DISABLE */
+	li	a0,	KSEG1ADDR(ATH_SPI_CLOCK)
+#if defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x)
+	li	t0,	0x246
+#elif defined(CONFIG_WASP_SUPPORT)
+	li	t0,	0x243
+#else
+	li	t0,	0x43
+#endif
+	sw	t0,	0(a0)
+#endif
+
+
+#if defined(CONFIG_AR9100) && defined(CFG_HOWL_1_2)
+	/* Disable remap for parallel flash */
+	li	t7, AR9100_FLASH_CONFIG;
+	lw	t8, 0(t7);
+	li	t9, 0xffbf0000;
+	and	t8, t8, t9;
+	li	t9, 0x22fc;
+	or	t8, t8, t9;
+	li	t9, 0xffcfffff; /* scale = 0 */
+	and	t8, t8, t9;
+	sw	t8, 0(t7);
+#endif
 
 	/* Initialize caches...
 	 */
-	la      t9, mips_cache_reset
+	la      t9, simple_mips_cache_reset
 	jalr    t9
 	nop
 
 	/* ... and enable them.
 	 */
-	li	t0, CONF_CM_CACHABLE_NONCOHERENT
-	mtc0	t0, CP0_CONFIG
+#if defined(CONFIG_WASP_SUPPORT) && !defined(CONFIG_ATH_NAND_BR)
+	li	t7,	KSEG1ADDR(AR7240_REV_ID)
+	lw	t7,	0(t7)
+	andi	t9,	t7,	0xf
+	bne	zero,	t9,	1f
+	nop
+
+	li	t0,	CONF_CM_UNCACHED
+	j	2f
+	nop
+#endif
 
+1:	li	t0,	CONF_CM_CACHABLE_NONCOHERENT
+2:	mtc0	t0,	CP0_CONFIG
 
+#if !defined(CFG_INIT_STACK_IN_SRAM)
+#if !defined(CONFIG_AR7100) && !defined(CONFIG_AR7240)
 	/* Set up temporary stack.
 	 */
 	li	a0, CFG_INIT_SP_OFFSET
 	la      t9, mips_cache_lock
 	jalr    t9
 	nop
+#endif
+
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240)
+	la	t9, mips_cache_lock_24k
+	jalr	t9
+	nop
+#endif
+#endif /* !CFG_INIT_STACK_IN_SRAM */
+#endif /* #ifndef COMPRESSED_UBOOT */
 
+#if defined(CONFIG_WASP_SUPPORT) || defined(CFG_INIT_STACK_IN_SRAM)
+	li	t0, CFG_INIT_SRAM_SP_OFFSET	/* Setup stack in SRAM */
+#else
 	li	t0, CFG_SDRAM_BASE + CFG_INIT_SP_OFFSET
+#endif
 	la	sp, 0(t0)
 
 	la	t9, board_init_f
 	j	t9
 	nop
 
-
 /*
  * void relocate_code (addr_sp, gd, addr_moni)
  *
@@ -320,20 +518,17 @@ relocate_code:
 	 * t1 = target address
 	 * t2 = source end address
 	 */
-	/* On the purple board we copy the code earlier in a special way
-	 * in order to solve flash problems
-	 */
-#ifndef CONFIG_PURPLE
 1:
 	lw	t3, 0(t0)
 	sw	t3, 0(t1)
 	addu	t0, 4
 	ble	t0, t2, 1b
 	addu	t1, 4			/* delay slot			*/
-#endif
 
 	/* If caches were enabled, we would have to flush them here.
 	 */
+	bal mips_cache_flush
+	nop
 
 	/* Jump to where we've relocated ourselves.
 	 */
@@ -380,7 +575,4470 @@ in_ram:
 
 	.end	relocate_code
 
+#if !defined(CONFIG_MACH_QCA955x) && !defined(CONFIG_MACH_QCA953x)
+#if !defined(CONFIG_WASP_SUPPORT) && defined(CONFIG_AR7240)
+/*
+ * void ar7240_ddr_tap_init(void)
+ *
+ * This "function" is used to find the tap settings for the DDR
+ */
+	.globl	ar7240_ddr_tap_init
+	.ent	ar7240_ddr_tap_init
+ar7240_ddr_tap_init: /* { */
+	li	t1,0x80500000
+	li	t0,0xffffffff
+
+	sw	t0,0x0(t1)
+	sw	t0,0x4(t1)
+	sw	t0,0x8(t1)
+	sw	t0,0xc(t1)
+
+	nop
+	nop
+
+ddr_pat_init:
+	li 	t0, 0xa0002000
+
+	li 	t1, 0x00000000
+	sw 	t1, 0x0(t0)
+	nop
+
+	li 	t1, 0x00000000
+	sw 	t1, 0x4(t0)
+	nop
+
+	li 	t1, 0x00000000
+	sw	t1, 0x8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x10(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x14(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x18(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x20(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x24(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x28(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x30(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x34(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x38(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x40(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x44(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x48(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x50(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x54(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x58(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x5c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x60(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x64(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x68(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x6c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x70(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x74(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x78(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x7c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x80(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x84(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x88(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x90(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x94(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x98(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x9c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xbc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xcc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xdc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xfc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x100(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x104(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x108(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x10c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x110(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x114(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x118(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x11c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x120(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x124(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x128(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x12c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x130(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x134(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x138(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x13c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x140(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x144(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x148(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x14c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x150(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x154(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x158(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x15c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x160(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x164(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x168(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x16c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x170(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x174(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x178(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x17c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x180(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x184(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x188(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x18c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x190(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x194(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x198(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x19c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x1a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x1a4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x1a8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x1b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x1b4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x1b8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x1c4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x1c8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x1d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x1d4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x1d8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x1e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x1e4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x1e8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x1f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x1f4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x1f8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x1fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x200(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x204(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x208(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x20c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x210(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x214(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x218(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x21c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x220(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x224(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x228(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x22c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x230(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x234(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x238(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x23c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x240(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x244(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x248(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x24c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x250(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x254(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x258(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x25c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x260(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x264(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x268(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x26c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x270(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x274(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x278(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x27c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x280(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x284(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x288(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x28c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x290(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x294(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x298(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x29c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2a4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2a8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x2b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2b4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2b8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x2c4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2c8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x2d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x2d4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2d8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x2e4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2e8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x2f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x2f4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x2f8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x2fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x300(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x304(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x308(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x30c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x310(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x314(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x318(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x31c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x320(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x324(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x328(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x32c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x330(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x334(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x338(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x33c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x340(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x344(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x348(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x34c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x350(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x354(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x358(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x35c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x360(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x364(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x368(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x36c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x370(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x374(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x378(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x37c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x380(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x384(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x388(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x38c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x390(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x394(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x398(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x39c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x3a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x3a4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3a8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x3b4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3b8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3c4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3c8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x3d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3d4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3d8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x3e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3e4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3e8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3f4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x3f8(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x3fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x400(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x404(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x408(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x40c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x410(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x414(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x418(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x41c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x420(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x424(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x428(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x42c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x430(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x434(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x438(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x43c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x440(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x444(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x448(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x44c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x450(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x454(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x458(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x45c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x460(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x464(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x468(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x46c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x470(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x474(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x478(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x47c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x480(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x484(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x488(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x48c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x490(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x494(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x498(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x49c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x4a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x4a4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4a8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x4ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x4b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x4b4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4b8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x4bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x4c4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4c8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x4cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x4d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x4d4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4d8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x4dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x4e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x4e4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4e8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x4ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x4f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x4f4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x4f8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x4fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x500(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x504(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x508(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x50c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x510(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x514(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x518(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x51c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x520(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x524(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x528(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x52c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x530(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x534(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x538(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x53c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x540(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x544(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x548(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x54c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x550(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x554(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x558(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x55c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x560(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x564(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x568(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x56c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x570(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x574(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x578(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x57c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x580(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x584(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x588(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x58c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x590(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x594(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x598(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x59c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x5a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x5a4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5a8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x5b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x5b4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5b8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x5c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x5c4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5c8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x5d4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5d8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x5e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x5e4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5e8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x5f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x5f4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5f8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x5fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x600(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x604(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x608(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x60c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x610(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x614(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x618(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x61c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x620(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x624(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x628(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x62c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x630(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x634(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x638(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x63c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x640(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x644(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x648(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x64c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x650(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x654(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x658(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x65c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x660(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x664(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x668(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x66c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x670(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x674(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x678(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x67c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x680(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x684(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x688(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x68c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x690(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x694(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x698(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x69c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6a4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6a8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x6ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x6b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6b4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6b8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x6bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x6c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x6c4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6c8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x6cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x6d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x6d4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6d8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x6dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x6e4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6e8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x6ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x6f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x6f4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x6f8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x6fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x700(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x704(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x708(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x70c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x710(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x714(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x718(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x71c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x720(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x724(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x728(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x72c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x730(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x734(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x738(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x73c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x740(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x744(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x748(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x74c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x750(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x754(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x758(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x75c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x760(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x764(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x768(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x76c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x770(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x774(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x778(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x77c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x780(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x784(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x788(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x78c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x790(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x794(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x798(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x79c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x7a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x7a4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7a8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x7ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x7b4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7b8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x7bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x7c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7c4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7c8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x7cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x7d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7d4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7d8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x7dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x7e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7e4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7e8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x7ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7f4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x7f8(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x7fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x800(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x804(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x808(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x80c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x810(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x814(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x818(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x81c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x820(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x824(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x828(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x82c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x830(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x834(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x838(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x83c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x840(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x844(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x848(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x84c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x850(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x854(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x858(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x85c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x860(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x864(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x868(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x86c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x870(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x874(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x878(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x87c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x880(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x884(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x888(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x88c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x890(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x894(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x898(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x89c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8a4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8a8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x8b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8b4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8b8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x8c4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8c8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x8d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x8d4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8d8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x8e4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8e8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x8f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x8f4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x8f8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x8fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x900(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x904(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x908(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x90c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x910(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x914(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x918(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x91c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x920(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x924(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x928(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x92c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x930(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x934(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x938(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x93c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x940(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x944(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x948(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x94c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x950(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x954(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x958(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x95c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x960(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x964(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x968(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x96c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x970(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x974(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x978(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x97c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x980(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x984(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x988(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x98c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x990(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x994(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x998(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x99c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9a0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9a4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x9a8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9ac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x9b0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9b4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x9b8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9bc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0x9c0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x9c4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x9c8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9cc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x9d0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x9d4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x9d8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9dc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9e0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x9e4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x9e8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9ec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x9f0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0x9f4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0x9f8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0x9fc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa00(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa04(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa08(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa0c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xa10(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa14(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa18(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa1c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa20(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa24(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa28(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa2c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xa30(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa34(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa38(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa3c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa40(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xa44(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa48(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa4c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xa50(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xa54(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa58(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa5c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa60(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xa64(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa68(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa6c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xa70(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xa74(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa78(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa7c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xa80(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa84(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa88(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa8c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xa90(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa94(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa98(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xa9c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xaa0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xaa4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xaa8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xaac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xab0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xab4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xab8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xabc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xac0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xac4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xac8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xacc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xad0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xad4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xad8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xadc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xae0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xae4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xae8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xaec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xaf0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xaf4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xaf8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xafc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb00(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb04(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb08(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb0c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xb10(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb14(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb18(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb1c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb20(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb24(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb28(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb2c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb30(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb34(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb38(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb3c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb40(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xb44(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb48(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb4c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xb50(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xb54(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb58(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb5c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb60(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xb64(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb68(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb6c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb70(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xb74(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb78(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb7c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xb80(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb84(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb88(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb8c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xb90(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb94(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xb98(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xb9c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xba0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xba4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xba8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbb0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbb4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbb8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbbc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xbc0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbc4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbc8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbcc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xbd0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbd4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbd8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbdc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbe0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbe4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbe8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbf0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbf4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xbf8(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xbfc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc00(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc04(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc08(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc0c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xc10(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc14(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc18(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc1c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xc20(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc24(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc28(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc2c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc30(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc34(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc38(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc3c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc40(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xc44(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc48(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc4c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xc50(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xc54(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc58(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc5c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xc60(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xc64(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc68(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc6c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc70(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xc74(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc78(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc7c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc80(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xc84(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc88(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc8c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xc90(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xc94(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xc98(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xc9c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xca0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xca4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xca8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcb0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xcb4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xcb8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcbc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xcc0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcc4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xcc8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xccc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xcd0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcd4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xcd8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcdc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xce0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xce4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xce8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcf0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcf4(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xcf8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xcfc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd00(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd04(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd08(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd0c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd10(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd14(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd18(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd1c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xd20(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd24(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd28(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd2c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd30(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd34(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd38(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd3c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd40(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd44(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd48(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd4c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd50(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd54(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd58(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd5c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xd60(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd64(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd68(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd6c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd70(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd74(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd78(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd7c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xd80(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xd84(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd88(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd8c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd90(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xd94(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xd98(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xd9c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xda0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xda4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xda8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdb0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xdb4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xdb8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdbc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xdc0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdc4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xdc8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdcc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xdd0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdd4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xdd8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xddc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xde0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xde4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xde8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdf0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdf4(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xdf8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xdfc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe00(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe04(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe08(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe0c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xe10(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe14(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe18(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe1c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe20(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe24(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe28(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe2c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe30(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe34(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe38(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe3c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe40(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xe44(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe48(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe4c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xe50(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xe54(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe58(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe5c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe60(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xe64(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe68(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe6c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe70(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xe74(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe78(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe7c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xe80(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe84(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe88(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe8c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xe90(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe94(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xe98(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xe9c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xea0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xea4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xea8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xeac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xeb0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xeb4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xeb8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xebc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xec0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xec4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xec8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xecc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xed0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xed4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xed8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xedc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xee0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xee4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xee8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xeec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xef0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xef4(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xef8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xefc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf00(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf04(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf08(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf0c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xf10(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf14(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf18(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf1c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xf20(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf24(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf28(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf2c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf30(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf34(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf38(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf3c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf40(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xf44(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf48(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf4c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xf50(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xf54(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf58(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf5c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xf60(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xf64(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf68(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf6c(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf70(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xf74(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf78(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf7c(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xf80(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xf84(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf88(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf8c(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xf90(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xf94(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf98(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xf9c(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xfa0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xfa4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfa8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfac(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfb0(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xfb4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfb8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfbc(t0)
+	nop
+
+	li	t1, 0x00000000
+	sw	t1, 0xfc0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfc4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfc8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfcc(t0)
+	nop
+
+	li	t1, 0x0000ffff
+	sw	t1, 0xfd0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfd4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfd8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfdc(t0)
+	nop
+
+	li	t1, 0xffff0000
+	sw	t1, 0xfe0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfe4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfe8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xfec(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xff0(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xff4(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xff8(t0)
+	nop
+
+	li	t1, 0xffffffff
+	sw	t1, 0xffc(t0)
+	nop
+
+
+//###### ddr init over #########
+
+	li	a0, 0xa0002000
+	li	a1, 0x80002000	     //### Start address of the pattern   200
+	li	a2, 0x80003000	     //### End Address of the pattern     220
+	li	t0, 0xb800001c	//## Tap settings addr
+	lw	a3, 0x0(t0)		//## loading default tap value
+	nop
+	ori	t0, a3, 0x0
+	nop
+	li	t1, 0x1		//# t1=1 indicates increasing tap value, 0 = decreasing
+
+load_tap:
+
+	li	t7, 0x200	//## No. of times read has to happen for 1 tap setting
+	li	t8, 0xb8000000	//#### Loading Tap Setting
+	sw	t0, 0x1c(t8)
+	nop
+	sw	t0, 0x20(t8)
+	nop
+
+pat_read:
+	ori	t2, a0, 0x0
+	nop
+	ori	t3, a1, 0x0
+	nop
+	ori	t4, a2, 0x0
+	nop
+
+tap_addr_loop:
+	lw	t5, 0x0(t2)
+	nop
+	lw	t6, 0x0(t3)
+	nop
+	nop
+
+	bne	t5, t6, tap_fail
+	nop
+	nop
+	nop
+
+	addiu	t2, t2, 0x4  //#incrementing addr
+	addiu	t3, t3, 0x4
+	nop
+	nop
+
+	bne	t3, t4, tap_addr_loop
+	nop
+
+	addiu	t7, t7, -1
+	nop
+	bnez	t7, pat_read
+	nop
+	nop
+
+	bnez	t1, tap_incr
+	nop
+	nop
+
+	bnez	t0, tap_decr	//# t0=0 implies tap=0 works
+	nop		 //# so low limit=0, else decrement tap value
+	nop
+	li	t8, 0x80500000
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0 //#adding lower limit to upper limit (used to calc mid value)
+	nop
+	nop
+
+	b tap_calc
+	nop
+	nop
+
+tap_decr:
+	addiu	t0, t0 , -1
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_incr:
+	addiu	t0, t0 , 0x1
+	nop
+	xori	v1, t0, 0x20
+	nop
+	bnez	v1, load_tap
+	nop
+	nop
+	b up_limit
+	nop
+	nop
+
+tap_fail:
+	bnez	t1, up_limit
+	nop
+	nop
+	nop
+	addiu	t0, t0, 0x1
+	nop
+	li	t8, 0x80500000
+	nop
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0
+	nop
+	nop
+	nop
+
+	b tap_calc
+	nop
+	nop
+
+up_limit:
+	addiu	t0, t0, -1
+	li	t1, 0x0	 //## changing to decreasing tap mode
+	li	t8, 0x80500000 //## storing upper limit
+	sw	t0, 0x4(t8)
+	ori	t9, t0, 0x0
+	nop
+	nop
+	nop
+
+	ori	t0, a3, 0x0 	//# loading default tap value
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_calc:  //## calculating mid value of the tap, storing DQS0, DQS1 in 0x80500008, 0x8050000c resp.
+	li	t7, 0x2
+	nop
+	div	t9, t7
+	nop
+	mfhi	t6
+	mflo	t5
+	nop
+	nop
+	add	t6, t6, t5
+	li	t8, 0x80500000
+	nop
+	sw	t5, 0x8(t8)
+	nop
+	sw	t6, 0xc(t8)
+	nop
+	nop
+        li      t8, 0xb8000000  //#### Loading Tap Setting
+	nop
+        sw      t5, 0x1c(t8)
+        nop
+        sw      t6, 0x20(t8)
+        nop
+	nop
+	nop
+
+end:
+	nop
+	nop
+	nop
+	jr 	ra
+
+	.end	ar7240_ddr_tap_init
+/* } */
+#else
+
+.globl	ath_ddr_tap_cal
+.type   ath_ddr_tap_cal, @function
+
+ath_ddr_tap_cal:
+
+	li	a0,	0xbd007f00
+	sw	zero,	0x0(a0)			// Place where the tap values are saved and used for SWEEP
+	sw	zero,	0x4(a0)			// Place where the number of passing taps are saved.
+	sw	zero,	0x14(a0)		// Place where the last pass tap value is stored
+	li	a1,	0xaa55aa55		// Indicates that the First pass tap value is not found
+	sw	a1,	0x10(a0)		// Place where the First pass tap value is stored
+	nop
+
+	li	a0,	0xb8060000		// RESET_BASE_ADDRESS
+	lw	a1,	0x1c(a0)		// Reading the RST_RESET_ADDRESS
+	li	a2,	0x08000000		// Setting the RST_RESET_RTC_RESET
+	or	a1,	a1,	a2
+	sw	a1,	0x1c(a0)
+
+	li	a3,	0xffffffff
+	xor	a2,	a2,	a3
+	and	a1,	a1,	a2
+	sw	a1,	0x1c(a0)		// Taking the RTC out of RESET
+	nop
+
+	li	a0,	0xb8107000		// RTC_BASE_ADDRESS
+	li	a1,	0x1
+	sw	a1,	0x0040(a0)		// RTC_SYNC_RESET_ADDRESS
+
+	li	a2,	0x2
+
+_poll_for_RTC_ON:
+	lw	a1,	0x0044(a0)		// RTC_SYNC_STATUS_ADDRESS
+	and	a1,	a2,	a1
+	bne	a1,	a2,	_poll_for_RTC_ON
+
+
+_CHANGE_TAPS:
+
+	li	t0,	0xbd007f00		// Read the current value of the TAP for programming
+	lw	t1,	0x0(t0)
+	li	t2,	0x00000000
+	or	t3,	t1,	t2
+
+
+	li	t0,	0xb8000000		// DDR_BASE_ADDRESS
+
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	li	t1,	0x00000010		// Running the test 8 times
+	sw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+
+	li	t1,	0xfa5de83f		// 4 Row Address Bits, 4 Column Address Bits, 2 BA bits
+	sw	t1,	0x002c(t0)		// PERF_MASK_ADDR_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0070(t0)		// PERF_COMP_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0040(t0)		// PERF_COMP_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0078(t0)		// PERF_COMP_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0034(t0)		// PERF_MASK_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x006c(t0)		// PERF_MASK_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x003c(t0)		// PERF_MASK_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0074(t0)		// PERF_MASK_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0038(t0)		// PERF_COMP_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x00000001
+	sw	t1,	0x011c(t0)		// DDR_BIST_ADDRESS
+
+	li	t2,	0x1
+_bist_done_poll:
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	and	t1,	t1,	t2
+	bne	t1,	t2,	_bist_done_poll
+
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	li	t4,	0x000001fe
+	and	t2,	t1,	t4
+	srl	t2,	t2,	0x1		// no. of Pass Runs
+
+	li	t5,	0x00000000
+	sw	t5,	0x011c(t0)		//DDR_BIST_ADDRESS	- Stop the DDR BIST test
+
+	li	t5,	0x0001fe00
+	and	t5,	t5,	t1
+	bnez	t5,	_iterate_tap		// This is a redundant compare but nevertheless - Comparing the FAILS
+
+	lw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+	li	t3,	0x000001fe
+	and	t3,	t3,	t1
+	srl	t3,	t3,	0x1		// No. of runs in the config register.
+
+	bne	t3,	t2,	_iterate_tap
+
+pass_tap:
+	li	t0,	0xbd007f00
+	lw	t1,	0x4(t0)
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x4(t0)
+
+	li	t0,	0xbd007f10
+	lw	t1,	0x0(t0)
+	li	t2,	0xaa55aa55
+	beq	t1,	t2,	_first_pass
+	nop
+	li	t0,	0xbd007f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd007f10
+	sw	t1,	0x4(t0)
+	nop
+	b	_iterate_tap
+	nop
+
+_first_pass:
+	li	t0,	0xbd007f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd007f10
+	sw	t1,	0x0(t0)
+	sw	t1,	0x4(t0)
+	nop
+
+_iterate_tap:
+
+	li	t0,	0xbd007f00
+	lw	t1,	0x0(t0)
+	li	t2,	0x1f
+	beq	t1,	t2,	_STOP_TEST
+	nop
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x0(t0)
+	nop
+	b	_CHANGE_TAPS
+
+_STOP_TEST:
+	li	t0,	0xbd007f00
+	lw	t1,	0x4(t0)
+	bnez	t1,	_load_center_tap
+	nop
+	li	t3,	0x8			// Default Tap to be used
+	b	_load_tap_into_reg
+
+_load_center_tap:
+	li	t0,	0xbd007f10
+	lw	t1,	0x0(t0)
+	lw	t2,	0x4(t0)
+	add	t3,	t1,	t2
+	srl	t3,	t3,	0x1
+	li	t4,	0x1f
+	and	t3,	t3,	t4
+
+_load_tap_into_reg:
+	li	t0,	0xb8000000
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	jr	ra
+	nop
+
+
+#endif
+#endif /* !defined(CONFIG_MACH_QCA955x) && !defined(CONFIG_MACH_QCA953x) */
 
+#ifndef COMPRESSED_UBOOT
 	/* Exception handlers.
 	 */
 romReserved:
@@ -388,3 +5046,4 @@ romReserved:
 
 romExcHandle:
 	b romExcHandle
+#endif /* #ifndef COMPRESSED_UBOOT */
diff --git a/cpu/mips/start_bootstrap.S b/cpu/mips/start_bootstrap.S
new file mode 100644
index 0000000000..077e831d88
--- /dev/null
+++ b/cpu/mips/start_bootstrap.S
@@ -0,0 +1,795 @@
+/*
+ *  Startup Code for MIPS32 CPU-core
+ *
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+
+#define AR7100_SPI_CLOCK  0xbf000004
+
+#define ATH_APB_BASE				0xB8000000  /* KSEG1ADDR(0x18000000) */
+#define ATH_GPIO_BASE				(ATH_APB_BASE+0x00040000)
+#define ATH_GPIO_OE					(ATH_GPIO_BASE+0x0)
+#define ATH_GPIO_OUT				(ATH_GPIO_BASE+0x8)
+#define ATH_GPIO_OUT_FUNCTION0		(ATH_GPIO_BASE+0x2c)
+#define ATH_GPIO_OUT_FUNCTION1		(ATH_GPIO_BASE+0x30)
+#define ATH_GPIO_OUT_FUNCTION2		(ATH_GPIO_BASE+0x34)
+#define ATH_GPIO_OUT_FUNCTION3		(ATH_GPIO_BASE+0x38)
+#define ATH_GPIO_OUT_FUNCTION4		(ATH_GPIO_BASE+0x3c)
+#define ATH_GPIO_OUT_FUNCTION5		(ATH_GPIO_BASE+0x40)
+#define ATH_GPIO_FUNCTION			(ATH_GPIO_BASE+0X6C)
+
+#define RVECENT(f,n) \
+   b f; nop
+
+#define XVECENT(f,bev) \
+   b f     ;           \
+   li k0,bev
+
+	.set noreorder
+
+	.globl _start_bootstrap
+	.text
+_start_bootstrap:
+	RVECENT(reset,0)	/* U-boot entry point */
+	RVECENT(reset,1)	/* software reboot */
+	RVECENT(romReserved,2)
+	RVECENT(romReserved,3)
+	RVECENT(romReserved,4)
+	RVECENT(romReserved,5)
+	RVECENT(romReserved,6)
+	RVECENT(romReserved,7)
+	RVECENT(romReserved,8)
+	RVECENT(romReserved,9)
+	RVECENT(romReserved,10)
+	RVECENT(romReserved,11)
+	RVECENT(romReserved,12)
+	RVECENT(romReserved,13)
+	RVECENT(romReserved,14)
+	RVECENT(romReserved,15)
+	RVECENT(romReserved,16)
+	RVECENT(romReserved,17)
+	RVECENT(romReserved,18)
+	RVECENT(romReserved,19)
+	RVECENT(romReserved,20)
+	RVECENT(romReserved,21)
+	RVECENT(romReserved,22)
+	RVECENT(romReserved,23)
+	RVECENT(romReserved,24)
+	RVECENT(romReserved,25)
+	RVECENT(romReserved,26)
+	RVECENT(romReserved,27)
+	RVECENT(romReserved,28)
+	RVECENT(romReserved,29)
+	RVECENT(romReserved,30)
+	RVECENT(romReserved,31)
+	RVECENT(romReserved,32)
+	RVECENT(romReserved,33)
+	RVECENT(romReserved,34)
+	RVECENT(romReserved,35)
+	RVECENT(romReserved,36)
+	RVECENT(romReserved,37)
+	RVECENT(romReserved,38)
+	RVECENT(romReserved,39)
+	RVECENT(romReserved,40)
+	RVECENT(romReserved,41)
+	RVECENT(romReserved,42)
+	RVECENT(romReserved,43)
+	RVECENT(romReserved,44)
+	RVECENT(romReserved,45)
+	RVECENT(romReserved,46)
+	RVECENT(romReserved,47)
+	RVECENT(romReserved,48)
+	RVECENT(romReserved,49)
+	RVECENT(romReserved,50)
+	RVECENT(romReserved,51)
+	RVECENT(romReserved,52)
+	RVECENT(romReserved,53)
+	RVECENT(romReserved,54)
+	RVECENT(romReserved,55)
+	RVECENT(romReserved,56)
+	RVECENT(romReserved,57)
+	RVECENT(romReserved,58)
+	RVECENT(romReserved,59)
+	RVECENT(romReserved,60)
+	RVECENT(romReserved,61)
+	RVECENT(romReserved,62)
+	RVECENT(romReserved,63)
+	XVECENT(romExcHandle,0x200)	/* bfc00200: R4000 tlbmiss vector */
+	RVECENT(romReserved,65)
+	RVECENT(romReserved,66)
+	RVECENT(romReserved,67)
+	RVECENT(romReserved,68)
+	RVECENT(romReserved,69)
+	RVECENT(romReserved,70)
+	RVECENT(romReserved,71)
+	RVECENT(romReserved,72)
+	RVECENT(romReserved,73)
+	RVECENT(romReserved,74)
+	RVECENT(romReserved,75)
+	RVECENT(romReserved,76)
+	RVECENT(romReserved,77)
+	RVECENT(romReserved,78)
+	RVECENT(romReserved,79)
+	XVECENT(romExcHandle,0x280)	/* bfc00280: R4000 xtlbmiss vector */
+	RVECENT(romReserved,81)
+	RVECENT(romReserved,82)
+	RVECENT(romReserved,83)
+	RVECENT(romReserved,84)
+	RVECENT(romReserved,85)
+	RVECENT(romReserved,86)
+	RVECENT(romReserved,87)
+	RVECENT(romReserved,88)
+	RVECENT(romReserved,89)
+	RVECENT(romReserved,90)
+	RVECENT(romReserved,91)
+	RVECENT(romReserved,92)
+	RVECENT(romReserved,93)
+	RVECENT(romReserved,94)
+	RVECENT(romReserved,95)
+	XVECENT(romExcHandle,0x300)	/* bfc00300: R4000 cache vector */
+	RVECENT(romReserved,97)
+	RVECENT(romReserved,98)
+	RVECENT(romReserved,99)
+	RVECENT(romReserved,100)
+	RVECENT(romReserved,101)
+	RVECENT(romReserved,102)
+	RVECENT(romReserved,103)
+	RVECENT(romReserved,104)
+	RVECENT(romReserved,105)
+	RVECENT(romReserved,106)
+	RVECENT(romReserved,107)
+	RVECENT(romReserved,108)
+	RVECENT(romReserved,109)
+	RVECENT(romReserved,110)
+	RVECENT(romReserved,111)
+	XVECENT(romExcHandle,0x380)	/* bfc00380: R4000 general vector */
+	RVECENT(romReserved,113)
+	RVECENT(romReserved,114)
+	RVECENT(romReserved,115)
+	RVECENT(romReserved,116)
+	RVECENT(romReserved,116)
+	RVECENT(romReserved,118)
+	RVECENT(romReserved,119)
+	RVECENT(romReserved,120)
+	RVECENT(romReserved,121)
+	RVECENT(romReserved,122)
+	RVECENT(romReserved,123)
+	RVECENT(romReserved,124)
+	RVECENT(romReserved,125)
+	RVECENT(romReserved,126)
+	RVECENT(romReserved,127)
+
+	/* We hope there are no more reserved vectors!
+	 * 128 * 8 == 1024 == 0x400
+	 * so this is address R_VEC+0x400 == 0xbfc00400
+	 */
+	.align 4
+reset:
+#if 1/* below will turn on all leds for a while */
+	li	a1, ATH_GPIO_FUNCTION
+	lw	v1, 0(a1)
+	li	v0, (1 << 1)	/* we use GPIO3,so disable JTAG */
+	or	v1, v1, v0
+	sw	v1, 0(a1)
+	
+	li	a1, ATH_GPIO_FUNCTION
+	lw	v1, 0(a1)
+	li	v0, (~(1 << 6))	/* we use GPIO4,so disable AHB_CLK/2 */
+	and v1, v1, v0
+	sw	v1, 0(a1)	
+
+	/* GPIO init */
+	li	a1, ATH_GPIO_OE
+	lw	v1, 0(a1)
+	/* GPIO 3,4,11,13~16, but GPIO3 is not used yet */
+	li  v0, (~((1 << 3) | (1 << 4) | (1 << 11) | (1 << 13) | (1 << 14) | (1 << 15) | (1 << 16)))
+	and v1, v1, v0
+	sw	v1, 0(a1)		/* set v1 value to ATH_GPIO_OE */
+
+	/* set gpio funtion for gpio3 */
+	li	a1, ATH_GPIO_OUT_FUNCTION0
+	lw	v1, 0(a1)
+	li	v0, 0x00ffffff
+	and v1, v1, v0
+	sw	v1, 0(a1)	/* set v1 value to ATH_GPIO_OUT_FUNCTION0 */
+
+	/* set gpio funtion for gpio4 */
+	li	a1, ATH_GPIO_OUT_FUNCTION1
+	lw	v1, 0(a1)
+	li	v0, 0xffffff00
+	and v1, v1, v0
+	sw	v1, 0(a1)		/* set v1 value to ATH_GPIO_OUT_FUNCTION1 */
+
+
+	/* set gpio funtion for gpio11 */
+	li	a1, ATH_GPIO_OUT_FUNCTION2
+	lw	v1, 0(a1)
+	li	v0, 0x00ffffff
+	and v1, v1, v0
+	sw	v1, 0(a1)		/* set v1 value to ATH_GPIO_OUT_FUNCTION2 */
+
+	/* set gpio funtion for gpio13~15 */
+	li	a1, ATH_GPIO_OUT_FUNCTION3
+	lw	v1, 0(a1)
+	li	v0, 0x000000ff
+	and v1, v1, v0
+	sw	v1, 0(a1)		/* set v1 value to ATH_GPIO_OUT_FUNCTION3 */
+
+	/* set gpio funtion for gpio16 */
+	li	a1, ATH_GPIO_OUT_FUNCTION4
+	lw	v1, 0(a1)
+	li	v0, 0xffffff00
+	and v1, v1, v0
+	sw	v1, 0(a1)		/* set v1 value to ATH_GPIO_OUT_FUNCTION4 */
+
+	/* turn on leds */
+	li	a1, ATH_GPIO_OUT
+	lw	v1, 0(a1)
+	/*GPIO 3,4,11,13~16 */
+	li  v0, (~((1 << 3) | (1 << 4) | (1 << 11) | (1 << 13) | (1 << 14) | (1 << 15) | (1 << 16)))
+	and v1, v1, v0
+	sw	v1, 0(a1)		/* set v1 value to ATH_GPIO_OUT */
+
+	/* wait for a while, for leds' bootup blink*/
+	li a1, 0
+	li v1, 0x40000
+1:
+	addi a1, a1, 1
+	bne a1, v1, 1b
+	nop
+
+	/* turn off leds */
+	li	a1, ATH_GPIO_OUT
+	lw	v1, 0(a1)
+	/*GPIO 3,4,11,13~16 */
+	li  v0, ((1 << 3) | (1 << 4) | (1 << 11) | (1 << 13) | (1 << 14) | (1 << 15) | (1 << 16))
+	or	v1, v1, v0
+	sw	v1, 0(a1)		/* set v1 value to ATH_GPIO_OUT */
+#endif
+
+	/*
+	 * Clearing CP0 registers - This is generally required for the MIPS-24k
+     * core used by Atheros.
+	 */
+	mtc0	zero, $0
+	mtc0	zero, $1
+	mtc0	zero, $2
+	mtc0	zero, $3
+	mtc0	zero, $4
+	mtc0	zero, $5
+	mtc0	zero, $6
+	mtc0	zero, $7
+	mtc0	zero, $8
+	mtc0	zero, $9
+	mtc0	zero, $10
+	mtc0	zero, $11
+	li	t0, 0x10000004
+	mtc0	t0, $12
+	mtc0	zero, $13
+	mtc0	zero, $14
+	mtc0	zero, $15
+	mtc0	zero, $16
+	mtc0	zero, $17
+	mtc0	zero, $18
+	mtc0	zero, $19
+	mtc0	zero, $20
+	mtc0	zero, $21
+	mtc0	zero, $22
+#ifndef CONFIG_HORNET_EMU
+	mtc0	zero, $23
+#endif
+	mtc0	zero, $24
+	mtc0	zero, $25
+	mtc0	zero, $26
+	mtc0	zero, $27
+	mtc0	zero, $28
+#if defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x)
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+
+	/*
+	 * Clear watch registers.
+	 */
+
+	mtc0	zero, CP0_WATCHLO
+	mtc0	zero, CP0_WATCHHI
+
+	/* STATUS register */
+	mfc0	k0, CP0_STATUS
+	li	k1, ~ST0_IE
+	and	k0, k1
+        mtc0	zero, CP0_CAUSE
+	mtc0	k0, CP0_STATUS
+
+	/* CAUSE register */
+	mtc0	zero, CP0_CAUSE
+
+	/* Init Timer */
+	mtc0	zero, CP0_COUNT
+	mtc0	zero, CP0_COMPARE
+
+	/* CONFIG0 register */
+	li	t0, CONF_CM_UNCACHED
+	mtc0	t0, CP0_CONFIG
+
+
+    /* Initialize GOT pointer.*/
+	bal     1f
+	nop
+	.word   _GLOBAL_OFFSET_TABLE_
+	1:
+	move    gp, ra
+	lw      t1, 0(ra)
+	move	gp, t1
+
+#if defined(CONFIG_MACH_HORNET) && defined(CONFIG_HORNET_1_1_WAR)
+/**************************************************************************/
+/*
+ * WAR: Hornet 1.1 currently need a reset once we boot to let the resetb has
+ *      enough time to stable, so that trigger reset at 1st boot, system team
+ *      is investigaing the issue, will remove in short
+ */
+
+do_reset_normal:
+
+    li  t7, 0xbd000000
+    lw  t8, 0(t7)            // t8 : value of 0xbd000000
+    li  t9, 0x12345678
+    bne t8, t9, do_reset     // if value of 0xbd000000 != 0x12345678 , go to do_reset
+    nop
+    li  t9, 0xffffffff
+    sw  t9, 0(t7) 
+    b   normal_path
+    nop
+
+do_reset:
+    sw  t9, 0(t7)
+    li  t7, 0xb806001c       // load reset register 0x1806001c
+    lw  t8, 0(t7)
+    li  t9, 0x1000000        // bit24, fullchip reset
+    or  t8, t8, t9
+    sw  t8, 0(t7)
+do_reset_loop:    
+    b   do_reset_loop
+    nop
+
+normal_path:
+#endif /* CONFIG_MACH_HORNET */
+
+/**************************************************************************/
+
+	/* Initialize any external memory.
+	 */
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x)
+	la      t9, lowlevel_init
+	jalr    t9
+	nop
+	nop
+
+#if defined(CONFIG_MACH_HORNET)
+	la      t9, hornet_ddr_init
+	jalr    t9
+	nop
+	nop
+
+#if 0
+	la      t9, hornet_ddr_tap_init
+	jalr    t9
+	nop
+#endif
+
+#endif
+
+	la	t0, rel_start
+	j	t0
+	nop
+#endif
+
+rel_start:
+
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x)
+	/* REMAP_DISABLE */
+	li	a0, AR7100_SPI_CLOCK
+	li	t0, 0x43
+	sw	t0, 0(a0)
+#endif
+
+#if defined(CONFIG_AR9100) && defined(CFG_HOWL_1_2)
+    /* Disable remap for parallel flash */
+    li  t7, AR9100_FLASH_CONFIG;
+    lw  t8, 0(t7);
+    li  t9, 0xffbf0000;
+    and t8, t8, t9;
+    li  t9, 0x22fc;
+    or  t8, t8, t9;
+    li  t9, 0xffcfffff; /* scale = 0 */
+    and t8, t8, t9;
+    sw  t8, 0(t7);
+
+#endif
+
+	/* Initialize caches...
+	 */
+	la      t9, simple_mips_cache_reset
+	jalr    t9
+	nop
+
+	/* ... and enable them.
+	 */
+	li	t0, CONF_CM_CACHABLE_NONCOHERENT
+	mtc0	t0, CP0_CONFIG
+
+#if !defined(CFG_INIT_STACK_IN_SRAM)
+#if !defined(CONFIG_AR7100) && !defined(CONFIG_AR7240)
+	/* Set up temporary stack.
+	 */
+	li	a0, CFG_INIT_SP_OFFSET
+	la      t9, mips_cache_lock
+	jalr    t9
+	nop
+#endif
+
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240)
+	la	t9, mips_cache_lock_24k
+	jalr	t9
+	nop
+#endif
+#endif /* CFG_INIT_STACK_IN_SRAM */
+
+	li	t0, CFG_SDRAM_BASE + CFG_INIT_SP_OFFSET
+#ifdef CFG_INIT_STACK_IN_SRAM
+	li	t0, CFG_INIT_SRAM_SP_OFFSET	/* Setup stack in SRAM */
+#endif
+	la	sp, 0(t0)
+
+	la	t9, bootstrap_board_init_f
+	j	t9
+	nop
+
+
+/*
+ * void bootstrap_relocate_code (addr_sp, gd, addr_moni)
+ *
+ * This "function" does not return, instead it continues in RAM
+ * after relocating the monitor code.
+ *
+ * a0 = addr_sp
+ * a1 = gd
+ * a2 = destination address
+ */
+	.globl	bootstrap_relocate_code
+	.ent	bootstrap_relocate_code
+bootstrap_relocate_code:
+	move	sp, a0		/* Set new stack pointer		*/
+
+	li	t0, BOOTSTRAP_CFG_MONITOR_BASE
+	la	t3, in_ram
+	lw	t2, -12(t3)	/* t2 <-- uboot_end_data_bootsrap	*/
+
+	/*
+	 * Ideally, following line is not needed. However,
+	 * the behaviour is flaky without it. U-boot boots on
+	 * some boards, and doesn't on some boards. Even on the
+	 * boards it boots, it doesn't boot all the time.
+	 *
+	 * Adding 256k to what needs to be read in actually.
+	 * This introduces some delay that seems to help boot.
+	 */
+	/* if flush cache before jump to ddr, it will be ok.
+		so no need to add 256k, by huangwenzhong, 2013-10-10.
+	*/
+	/*
+	li	t3, (256 << 10)
+
+	add	t2, t3
+	*/
+	move	t1, a2
+
+	/*
+	 * Fix GOT pointer:
+	 *
+	 * New GOT-PTR = (old GOT-PTR - BOOTSTRAP_CFG_MONITOR_BASE) + Destination Address
+	 */
+	move	t6, gp
+	sub	gp, BOOTSTRAP_CFG_MONITOR_BASE
+	add	gp, a2			/* gp now adjusted		*/
+	sub	t6, gp, t6		/* t6 <-- relocation offset	*/
+
+	/*
+	 * t0 = source address
+	 * t1 = target address
+	 * t2 = source end address
+	 */
+1:
+	lw	t3, 0(t0)
+	sw	t3, 0(t1)
+	addu	t0, 4
+	ble	t0, t2, 1b
+	addu	t1, 4			/* delay slot			*/
+
+	/* If caches were enabled, we would have to flush them here.
+	 */
+	bal mips_cache_flush/*  by huangwenzhong, 10Oct13 */
+	nop
+
+	/* Jump to where we've relocated ourselves.
+	 */
+	addi	t0, a2, in_ram - _start_bootstrap
+	j	t0
+	nop
+
+	.word	uboot_end_data_bootstrap
+	.word	uboot_end_bootstrap
+	.word	num_got_entries
+
+in_ram:
+	/* Now we want to update GOT.
+	 */
+	lw	t3, -4(t0)	/* t3 <-- num_got_entries	*/
+	addi	t4, gp, 8	/* Skipping first two entries.	*/
+	li	t2, 2
+1:
+	lw	t1, 0(t4)
+	beqz	t1, 2f
+	add	t1, t6
+	sw	t1, 0(t4)
+2:
+	addi	t2, 1
+	blt	t2, t3, 1b
+	addi	t4, 4		/* delay slot			*/
+
+	/* Clear BSS.
+	 */
+	lw	t1, -12(t0)	/* t1 <-- uboot_end_data_bootstrap	*/
+	lw	t2, -8(t0)	/* t2 <-- uboot_end_bootstrap		*/
+	add	t1, t6		/* adjust pointers		*/
+	add	t2, t6
+
+	sub	t1, 4
+1:	addi	t1, 4
+	bltl	t1, t2, 1b
+	sw	zero, 0(t1)	/* delay slot			*/
+
+	move	a0, a1
+	la	t9, bootstrap_board_init_r
+	j	t9
+	move	a1, a2		/* delay slot			*/
+
+	.end	bootstrap_relocate_code
+
+
+
+.globl	ath_ddr_tap_cal
+.type   ath_ddr_tap_cal, @function
+
+ath_ddr_tap_cal:
+	li	a0,	0xbd001f00
+	sw	zero,	0x0(a0)			// Place where the tap values are saved and used for SWEEP
+	sw	zero,	0x4(a0)			// Place where the number of passing taps are saved.
+	sw	zero,	0x14(a0)		// Place where the last pass tap value is stored
+	li	a1,	0xaa55aa55		// Indicates that the First pass tap value is not found
+	sw	a1,	0x10(a0)		// Place where the First pass tap value is stored
+	nop
+
+	li	a0,	0xb8060000		// RESET_BASE_ADDRESS
+	lw	a1,	0x1c(a0)		// Reading the RST_RESET_ADDRESS
+	li	a2,	0x08000000		// Setting the RST_RESET_RTC_RESET
+	or	a1,	a1,	a2
+	sw	a1,	0x1c(a0)
+
+	li	a3,	0xffffffff
+	xor	a2,	a2,	a3
+	and	a1,	a1,	a2
+	sw	a1,	0x1c(a0)		// Taking the RTC out of RESET
+	nop
+
+	li	a0,	0xb8107000		// RTC_BASE_ADDRESS
+	li	a1,	0x1
+	sw	a1,	0x0040(a0)		// RTC_SYNC_RESET_ADDRESS
+
+	li	a2,	0x2
+
+_poll_for_RTC_ON:
+	lw	a1,	0x0044(a0)		// RTC_SYNC_STATUS_ADDRESS
+	and	a1,	a2,	a1
+	bne	a1,	a2,	_poll_for_RTC_ON
+
+
+_CHANGE_TAPS:
+
+	li	t0,	0xbd001f00		// Read the current value of the TAP for programming
+	lw	t1,	0x0(t0)
+	li	t2,	0x00000000
+	or	t3,	t1,	t2
+
+
+	li	t0,	0xb8000000		// DDR_BASE_ADDRESS
+
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	li	t1,	0x00000010		// Running the test 8 times
+	sw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+
+	li	t1,	0xfa5de83f		// 4 Row Address Bits, 4 Column Address Bits, 2 BA bits
+	sw	t1,	0x002c(t0)		// PERF_MASK_ADDR_0_ADDRESS
+
+#ifdef CONFIG_MACH_QCA953x
+	li	t1,	0x0000ffff
+	sw	t1,	0x0070(t0)		// PERF_COMP_AHB_GE0_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0040(t0)		// PERF_COMP_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0078(t0)		// PERF_COMP_AHB_GE1_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0034(t0)		// PERF_MASK_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x006c(t0)		// PERF_MASK_AHB_GE0_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x003c(t0)		// PERF_MASK_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0074(t0)		// PERF_MASK_AHB_GE1_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0038(t0)		// PERF_COMP_AHB_GE0_0_ADDRESS
+#else // Wasp & Scorpion ...
+	li	t1,	0x545fc332
+	sw	t1,	0x0070(t0)		// PERF_COMP_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0040(t0)		// PERF_COMP_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0078(t0)		// PERF_COMP_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0034(t0)		// PERF_MASK_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x006c(t0)		// PERF_MASK_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x003c(t0)		// PERF_MASK_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0074(t0)		// PERF_MASK_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0038(t0)		// PERF_COMP_AHB_GE0_0_ADDRESS
+#endif
+
+	li	t1,	0x00000001
+	sw	t1,	0x011c(t0)		// DDR_BIST_ADDRESS
+
+	li	t2,	0x1
+_bist_done_poll:
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	and	t1,	t1,	t2
+	bne	t1,	t2,	_bist_done_poll
+
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	li	t4,	0x000001fe
+	and	t2,	t1,	t4
+	srl	t2,	t2,	0x1		// no. of Pass Runs
+
+	li	t5,	0x00000000
+	sw	t5,	0x011c(t0)		//DDR_BIST_ADDRESS	- Stop the DDR BIST test
+
+	li	t5,	0x0001fe00
+	and	t5,	t5,	t1
+	bnez	t5,	_iterate_tap		// This is a redundant compare but nevertheless - Comparing the FAILS
+
+	lw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+	li	t3,	0x000001fe
+	and	t3,	t3,	t1
+	srl	t3,	t3,	0x1		// No. of runs in the config register.
+
+	bne	t3,	t2,	_iterate_tap
+
+pass_tap:
+	li	t0,	0xbd001f00
+	lw	t1,	0x4(t0)
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x4(t0)
+
+	li	t0,	0xbd001f10
+	lw	t1,	0x0(t0)
+	li	t2,	0xaa55aa55
+	beq	t1,	t2,	_first_pass
+	nop
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd001f10
+	sw	t1,	0x4(t0)
+	nop
+	b	_iterate_tap
+	nop
+
+_first_pass:
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd001f10
+	sw	t1,	0x0(t0)
+	sw	t1,	0x4(t0)
+	nop
+
+_iterate_tap:
+
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t2,	0x3f
+	beq	t1,	t2,	_STOP_TEST
+	nop
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x0(t0)
+	nop
+	b	_CHANGE_TAPS
+
+_STOP_TEST:
+	li	t0,	0xbd001f00
+	lw	t1,	0x4(t0)
+	bnez	t1,	_load_center_tap
+	nop
+	li	t3,	0x8			// Default Tap to be used
+	b	_load_tap_into_reg
+
+_load_center_tap:
+	li	t0,	0xbd001f10
+	lw	t1,	0x0(t0)
+	lw	t2,	0x4(t0)
+	add	t3,	t1,	t2
+	srl	t3,	t3,	0x1
+	li	t4,	0x3f
+	and	t3,	t3,	t4
+_load_tap_into_reg:
+	li	t0,	0xb8000000
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+	jr	ra
+	nop
+
+
+
+	/* Exception handlers.
+	 */
+romReserved:
+	b romReserved
+
+romExcHandle:
+	b romExcHandle
diff --git a/drivers/Makefile b/drivers/Makefile
index e6176ed86a..2b7f295070 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -27,7 +27,7 @@ include $(TOPDIR)/config.mk
 
 LIB	= libdrivers.a
 
-OBJS	= 3c589.o 5701rls.o ali512x.o \
+#OBJS	= 3c589.o 5701rls.o ali512x.o \
 	  bcm570x.o bcm570x_autoneg.o cfb_console.o cfi_flash.o \
 	  cs8900.o ct69000.o dataflash.o dc2114x.o dm9000x.o \
 	  e1000.o eepro100.o \
@@ -50,6 +50,8 @@ OBJS	= 3c589.o 5701rls.o ali512x.o \
 	  videomodes.o w83c553f.o \
 	  ks8695eth.o
 
+OBJS	=	pci.o
+
 all:	$(LIB)
 
 $(LIB): $(OBJS)
diff --git a/drivers/nand/nand_ids.c b/drivers/nand/nand_ids.c
index 3d4d372f17..852a706ef8 100644
--- a/drivers/nand/nand_ids.c
+++ b/drivers/nand/nand_ids.c
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2002 Thomas Gleixner (tglx@linutronix.de)
   *
- * $Id: nand_ids.c,v 1.10 2004/05/26 13:40:12 gleixner Exp $
+ * $Id: //depot/sw/releases/9.5.3/boot/u-boot/drivers/nand/nand_ids.c#1 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -127,6 +127,9 @@ struct nand_manufacturers nand_manuf_ids[] = {
 	{NAND_MFR_NATIONAL, "National"},
 	{NAND_MFR_RENESAS, "Renesas"},
 	{NAND_MFR_STMICRO, "ST Micro"},
+	{NAND_MFR_HYNIX, "Hynix"},
+	{NAND_MFR_MICRON, "Micron"},
+	{NAND_MFR_AMD, "AMD"},
 	{0x0, "Unknown"}
 };
 #endif
diff --git a/drivers/sk98lin/skge.c b/drivers/sk98lin/skge.c
index 61a6094230..ce92d26447 100644
--- a/drivers/sk98lin/skge.c
+++ b/drivers/sk98lin/skge.c
@@ -2,8 +2,8 @@
  *
  * Name:    skge.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.46 $
- * Date:       	$Date: 2003/02/25 14:16:36 $
+ * Version:	$Revision: #1 $
+ * Date:       	$Date: 2012/09/27 $
  * Purpose:	The main driver source module
  *
  ******************************************************************************/
diff --git a/drivers/sk98lin/skgemib.c b/drivers/sk98lin/skgemib.c
index 4a9e9e6af1..277a5050f5 100644
--- a/drivers/sk98lin/skgemib.c
+++ b/drivers/sk98lin/skgemib.c
@@ -2,8 +2,8 @@
  *
  * Name:	skgemib.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.7 $
- * Date:	$Date: 2002/12/16 09:04:34 $
+ * Version:	$Revision: #1 $
+ * Date:	$Date: 2012/09/27 $
  * Purpose:	Private Network Management Interface Management Database
  *
  ****************************************************************************/
diff --git a/drivers/sk98lin/skproc.c b/drivers/sk98lin/skproc.c
index 4e340730e5..d44f725f3b 100644
--- a/drivers/sk98lin/skproc.c
+++ b/drivers/sk98lin/skproc.c
@@ -2,8 +2,8 @@
  *
  * Name:    skproc.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.4 $
- * Date:    $Date: 2003/02/25 14:16:37 $
+ * Version:	$Revision: #1 $
+ * Date:    $Date: 2012/09/27 $
  * Purpose:	Funktions to display statictic data
  *
  ******************************************************************************/
diff --git a/examples/hello_world.s b/examples/hello_world.s
new file mode 100644
index 0000000000..3f7b99af8b
--- /dev/null
+++ b/examples/hello_world.s
@@ -0,0 +1,496 @@
+	.section .mdebug.abi32
+	.previous
+	.abicalls
+	.section	.debug_abbrev,"",@progbits
+$Ldebug_abbrev0:
+	.section	.debug_info,"",@progbits
+$Ldebug_info0:
+	.section	.debug_line,"",@progbits
+$Ldebug_line0:
+	.text
+$Ltext0:
+	.section	.rodata.str1.4,"aMS",@progbits,1
+	.align	2
+$LC0:
+	.ascii	"Example expects ABI version %d\n\000"
+	.align	2
+$LC1:
+	.ascii	"Actual U-Boot ABI version %d\n\000"
+	.align	2
+$LC2:
+	.ascii	"Hello World\n\000"
+	.align	2
+$LC3:
+	.ascii	"argc = %d\n\000"
+	.align	2
+$LC4:
+	.ascii	"argv[%d] = \"%s\"\n\000"
+	.align	2
+$LC5:
+	.ascii	"<NULL>\000"
+	.align	2
+$LC6:
+	.ascii	"Hit any key to exit ... \000"
+	.align	2
+$LC7:
+	.ascii	"\n\n\000"
+	.text
+	.align	2
+	.globl	hello_world
+	.ent	hello_world
+	.type	hello_world, @function
+hello_world:
+$LFB44:
+	.file 1 "hello_world.c"
+	.loc 1 28 0
+	.set	nomips16
+	.frame	$sp,40,$31		# vars= 0, regs= 4/0, args= 16, gp= 8
+	.mask	0x80070000,-4
+	.fmask	0x00000000,0
+	.set	noreorder
+	.cpload	$25
+	.set	nomacro
+	
+	addiu	$sp,$sp,-40
+$LCFI0:
+	sw	$31,36($sp)
+$LCFI1:
+	sw	$18,32($sp)
+$LCFI2:
+	sw	$17,28($sp)
+$LCFI3:
+	sw	$16,24($sp)
+$LCFI4:
+	.cprestore	16
+	.loc 1 32 0
+	lw	$25,%call16(app_startup)($28)
+	.loc 1 28 0
+	move	$18,$4
+	.loc 1 32 0
+	move	$4,$5
+	.loc 1 28 0
+	.loc 1 32 0
+	jalr	$25
+	move	$16,$5
+
+	lw	$28,16($sp)
+	.loc 1 33 0
+	li	$5,2			# 0x2
+	lw	$4,%got($LC0)($28)
+	lw	$25,%call16(printf)($28)
+	jalr	$25
+	addiu	$4,$4,%lo($LC0)
+
+	lw	$28,16($sp)
+	.loc 1 34 0
+	lw	$25,%call16(get_version)($28)
+	.loc 1 40 0
+	.loc 1 34 0
+	jalr	$25
+	move	$17,$0
+
+	lw	$28,16($sp)
+	move	$5,$2
+	lw	$4,%got($LC1)($28)
+	lw	$25,%call16(printf)($28)
+	jalr	$25
+	addiu	$4,$4,%lo($LC1)
+
+	lw	$28,16($sp)
+	.loc 1 36 0
+	lw	$4,%got($LC2)($28)
+	lw	$25,%call16(printf)($28)
+	jalr	$25
+	addiu	$4,$4,%lo($LC2)
+
+	lw	$28,16($sp)
+	.loc 1 38 0
+	move	$5,$18
+	lw	$4,%got($LC3)($28)
+	lw	$25,%call16(printf)($28)
+	jalr	$25
+	addiu	$4,$4,%lo($LC3)
+
+	.loc 1 40 0
+	bltz	$18,$L11
+	lw	$28,16($sp)
+
+$L7:
+	.loc 1 41 0
+	lw	$6,0($16)
+	lw	$4,%got($LC4)($28)
+	move	$5,$17
+	lw	$25,%call16(printf)($28)
+	.loc 1 40 0
+	addiu	$17,$17,1
+	addiu	$16,$16,4
+	.loc 1 41 0
+	bne	$6,$0,$L6
+	addiu	$4,$4,%lo($LC4)
+
+	lw	$2,%got($LC5)($28)
+	addiu	$6,$2,%lo($LC5)
+$L6:
+	jalr	$25
+	nop
+
+	.loc 1 40 0
+	slt	$2,$18,$17
+	.loc 1 41 0
+	.loc 1 40 0
+	beq	$2,$0,$L7
+	lw	$28,16($sp)
+
+$L11:
+	.loc 1 46 0
+	lw	$4,%got($LC6)($28)
+	lw	$25,%call16(printf)($28)
+	jalr	$25
+	addiu	$4,$4,%lo($LC6)
+
+	lw	$28,16($sp)
+$L8:
+	.loc 1 47 0
+	lw	$25,%call16(tstc)($28)
+	jalr	$25
+	nop
+
+	beq	$2,$0,$L8
+	lw	$28,16($sp)
+
+	.loc 1 50 0
+	lw	$25,%call16(getc)($28)
+	jalr	$25
+	nop
+
+	lw	$28,16($sp)
+	.loc 1 52 0
+	lw	$4,%got($LC7)($28)
+	lw	$25,%call16(printf)($28)
+	jalr	$25
+	addiu	$4,$4,%lo($LC7)
+
+	lw	$28,16($sp)
+	.loc 1 54 0
+	lw	$31,36($sp)
+	lw	$18,32($sp)
+	lw	$17,28($sp)
+	lw	$16,24($sp)
+	move	$2,$0
+	j	$31
+	addiu	$sp,$sp,40
+
+	.set	macro
+	.set	reorder
+$LFE44:
+	.end	hello_world
+	.section	.debug_frame,"",@progbits
+$Lframe0:
+	.4byte	$LECIE0-$LSCIE0
+$LSCIE0:
+	.4byte	0xffffffff
+	.byte	0x1
+	.ascii	"\000"
+	.uleb128 0x1
+	.sleb128 4
+	.byte	0x1f
+	.byte	0xc
+	.uleb128 0x1d
+	.uleb128 0x0
+	.align	2
+$LECIE0:
+$LSFDE0:
+	.4byte	$LEFDE0-$LASFDE0
+$LASFDE0:
+	.4byte	$Lframe0
+	.4byte	$LFB44
+	.4byte	$LFE44-$LFB44
+	.byte	0x4
+	.4byte	$LCFI0-$LFB44
+	.byte	0xe
+	.uleb128 0x28
+	.byte	0x4
+	.4byte	$LCFI4-$LCFI0
+	.byte	0x11
+	.uleb128 0x10
+	.sleb128 -4
+	.byte	0x11
+	.uleb128 0x11
+	.sleb128 -3
+	.byte	0x11
+	.uleb128 0x12
+	.sleb128 -2
+	.byte	0x11
+	.uleb128 0x1f
+	.sleb128 -1
+	.align	2
+$LEFDE0:
+	.align	0
+	.text
+$Letext0:
+	.section	.debug_info
+	.4byte	0xc7
+	.2byte	0x2
+	.4byte	$Ldebug_abbrev0
+	.byte	0x4
+	.uleb128 0x1
+	.4byte	$Ldebug_line0
+	.4byte	$Letext0
+	.4byte	$Ltext0
+	.4byte	$LASF12
+	.byte	0x1
+	.4byte	$LASF13
+	.4byte	$LASF14
+	.uleb128 0x2
+	.4byte	$LASF0
+	.byte	0x1
+	.byte	0x8
+	.uleb128 0x2
+	.4byte	$LASF1
+	.byte	0x4
+	.byte	0x7
+	.uleb128 0x2
+	.4byte	$LASF2
+	.byte	0x2
+	.byte	0x7
+	.uleb128 0x2
+	.4byte	$LASF3
+	.byte	0x4
+	.byte	0x7
+	.uleb128 0x3
+	.ascii	"int\000"
+	.byte	0x4
+	.byte	0x5
+	.uleb128 0x2
+	.4byte	$LASF3
+	.byte	0x4
+	.byte	0x7
+	.uleb128 0x2
+	.4byte	$LASF4
+	.byte	0x4
+	.byte	0x5
+	.uleb128 0x4
+	.byte	0x4
+	.4byte	0x5c
+	.uleb128 0x2
+	.4byte	$LASF5
+	.byte	0x1
+	.byte	0x6
+	.uleb128 0x2
+	.4byte	$LASF6
+	.byte	0x8
+	.byte	0x5
+	.uleb128 0x2
+	.4byte	$LASF7
+	.byte	0x1
+	.byte	0x6
+	.uleb128 0x2
+	.4byte	$LASF8
+	.byte	0x2
+	.byte	0x5
+	.uleb128 0x2
+	.4byte	$LASF9
+	.byte	0x8
+	.byte	0x7
+	.uleb128 0x5
+	.4byte	0xc4
+	.byte	0x1
+	.4byte	$LASF15
+	.byte	0x1
+	.byte	0x1c
+	.byte	0x1
+	.4byte	0x41
+	.4byte	$LFB44
+	.4byte	$LFE44
+	.4byte	$LSFDE0
+	.byte	0x1
+	.byte	0x6d
+	.uleb128 0x6
+	.4byte	$LASF10
+	.byte	0x1
+	.byte	0x1b
+	.4byte	0x41
+	.byte	0x1
+	.byte	0x62
+	.uleb128 0x6
+	.4byte	$LASF11
+	.byte	0x1
+	.byte	0x1b
+	.4byte	0xc4
+	.byte	0x1
+	.byte	0x60
+	.uleb128 0x7
+	.ascii	"i\000"
+	.byte	0x1
+	.byte	0x1d
+	.4byte	0x41
+	.byte	0x1
+	.byte	0x61
+	.byte	0x0
+	.uleb128 0x4
+	.byte	0x4
+	.4byte	0x56
+	.byte	0x0
+	.section	.debug_abbrev
+	.uleb128 0x1
+	.uleb128 0x11
+	.byte	0x1
+	.uleb128 0x10
+	.uleb128 0x6
+	.uleb128 0x12
+	.uleb128 0x1
+	.uleb128 0x11
+	.uleb128 0x1
+	.uleb128 0x25
+	.uleb128 0xe
+	.uleb128 0x13
+	.uleb128 0xb
+	.uleb128 0x3
+	.uleb128 0xe
+	.uleb128 0x1b
+	.uleb128 0xe
+	.byte	0x0
+	.byte	0x0
+	.uleb128 0x2
+	.uleb128 0x24
+	.byte	0x0
+	.uleb128 0x3
+	.uleb128 0xe
+	.uleb128 0xb
+	.uleb128 0xb
+	.uleb128 0x3e
+	.uleb128 0xb
+	.byte	0x0
+	.byte	0x0
+	.uleb128 0x3
+	.uleb128 0x24
+	.byte	0x0
+	.uleb128 0x3
+	.uleb128 0x8
+	.uleb128 0xb
+	.uleb128 0xb
+	.uleb128 0x3e
+	.uleb128 0xb
+	.byte	0x0
+	.byte	0x0
+	.uleb128 0x4
+	.uleb128 0xf
+	.byte	0x0
+	.uleb128 0xb
+	.uleb128 0xb
+	.uleb128 0x49
+	.uleb128 0x13
+	.byte	0x0
+	.byte	0x0
+	.uleb128 0x5
+	.uleb128 0x2e
+	.byte	0x1
+	.uleb128 0x1
+	.uleb128 0x13
+	.uleb128 0x3f
+	.uleb128 0xc
+	.uleb128 0x3
+	.uleb128 0xe
+	.uleb128 0x3a
+	.uleb128 0xb
+	.uleb128 0x3b
+	.uleb128 0xb
+	.uleb128 0x27
+	.uleb128 0xc
+	.uleb128 0x49
+	.uleb128 0x13
+	.uleb128 0x11
+	.uleb128 0x1
+	.uleb128 0x12
+	.uleb128 0x1
+	.uleb128 0x2001
+	.uleb128 0x6
+	.uleb128 0x40
+	.uleb128 0xa
+	.byte	0x0
+	.byte	0x0
+	.uleb128 0x6
+	.uleb128 0x5
+	.byte	0x0
+	.uleb128 0x3
+	.uleb128 0xe
+	.uleb128 0x3a
+	.uleb128 0xb
+	.uleb128 0x3b
+	.uleb128 0xb
+	.uleb128 0x49
+	.uleb128 0x13
+	.uleb128 0x2
+	.uleb128 0xa
+	.byte	0x0
+	.byte	0x0
+	.uleb128 0x7
+	.uleb128 0x34
+	.byte	0x0
+	.uleb128 0x3
+	.uleb128 0x8
+	.uleb128 0x3a
+	.uleb128 0xb
+	.uleb128 0x3b
+	.uleb128 0xb
+	.uleb128 0x49
+	.uleb128 0x13
+	.uleb128 0x2
+	.uleb128 0xa
+	.byte	0x0
+	.byte	0x0
+	.byte	0x0
+	.section	.debug_pubnames,"",@progbits
+	.4byte	0x1e
+	.2byte	0x2
+	.4byte	$Ldebug_info0
+	.4byte	0xcb
+	.4byte	0x7f
+	.ascii	"hello_world\000"
+	.4byte	0x0
+	.section	.debug_aranges,"",@progbits
+	.4byte	0x1c
+	.2byte	0x2
+	.4byte	$Ldebug_info0
+	.byte	0x4
+	.byte	0x0
+	.2byte	0x0
+	.2byte	0x0
+	.4byte	$Ltext0
+	.4byte	$Letext0-$Ltext0
+	.4byte	0x0
+	.4byte	0x0
+	.section	.debug_str,"MS",@progbits,1
+$LASF14:
+	.ascii	"/root/uboot/u-boot-2006-04-06-1725/examples\000"
+$LASF9:
+	.ascii	"long long unsigned int\000"
+$LASF6:
+	.ascii	"long long int\000"
+$LASF7:
+	.ascii	"signed char\000"
+$LASF1:
+	.ascii	"long unsigned int\000"
+$LASF4:
+	.ascii	"long int\000"
+$LASF2:
+	.ascii	"short unsigned int\000"
+$LASF13:
+	.ascii	"hello_world.c\000"
+$LASF3:
+	.ascii	"unsigned int\000"
+$LASF8:
+	.ascii	"short int\000"
+$LASF5:
+	.ascii	"char\000"
+$LASF12:
+	.ascii	"GNU C 3.4.4 mipssde-6.03.01-20051114 -g\000"
+$LASF0:
+	.ascii	"unsigned char\000"
+$LASF11:
+	.ascii	"argv\000"
+$LASF15:
+	.ascii	"hello_world\000"
+$LASF10:
+	.ascii	"argc\000"
+	.ident	"GCC: (GNU) 3.4.4 mipssde-6.03.01-20051114"
diff --git a/include/953x.h b/include/953x.h
new file mode 100755
index 0000000000..f323218e51
--- /dev/null
+++ b/include/953x.h
@@ -0,0 +1,4472 @@
+/*
+ * QCA 953x series processor SOC registers
+ *
+ * (C) Copyright 2008 Atheros Communications, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _QCA953X_H
+#define _QCA953X_H
+
+#ifndef __ASSEMBLY__
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <linux/types.h>
+#endif /* __ASSEMBLY__ */
+
+#undef is_qca953x
+#undef is_hb
+
+#define is_qca953x()	(1)
+#define is_hb()		(1)
+
+
+#define CPU_PLL_CONFIG_UPDATING_MSB                                  31
+#define CPU_PLL_CONFIG_UPDATING_LSB                                  31
+#define CPU_PLL_CONFIG_UPDATING_MASK                                 0x80000000
+#define CPU_PLL_CONFIG_UPDATING_GET(x)                               (((x) & CPU_PLL_CONFIG_UPDATING_MASK) >> CPU_PLL_CONFIG_UPDATING_LSB)
+#define CPU_PLL_CONFIG_UPDATING_SET(x)                               (((x) << CPU_PLL_CONFIG_UPDATING_LSB) & CPU_PLL_CONFIG_UPDATING_MASK)
+#define CPU_PLL_CONFIG_UPDATING_RESET                                0x1 // 1
+#define CPU_PLL_CONFIG_PLLPWD_MSB                                    30
+#define CPU_PLL_CONFIG_PLLPWD_LSB                                    30
+#define CPU_PLL_CONFIG_PLLPWD_MASK                                   0x40000000
+#define CPU_PLL_CONFIG_PLLPWD_GET(x)                                 (((x) & CPU_PLL_CONFIG_PLLPWD_MASK) >> CPU_PLL_CONFIG_PLLPWD_LSB)
+#define CPU_PLL_CONFIG_PLLPWD_SET(x)                                 (((x) << CPU_PLL_CONFIG_PLLPWD_LSB) & CPU_PLL_CONFIG_PLLPWD_MASK)
+#define CPU_PLL_CONFIG_PLLPWD_RESET                                  0x1 // 1
+#define CPU_PLL_CONFIG_SPARE_MSB                                     29
+#define CPU_PLL_CONFIG_SPARE_LSB                                     22
+#define CPU_PLL_CONFIG_SPARE_MASK                                    0x3fc00000
+#define CPU_PLL_CONFIG_SPARE_GET(x)                                  (((x) & CPU_PLL_CONFIG_SPARE_MASK) >> CPU_PLL_CONFIG_SPARE_LSB)
+#define CPU_PLL_CONFIG_SPARE_SET(x)                                  (((x) << CPU_PLL_CONFIG_SPARE_LSB) & CPU_PLL_CONFIG_SPARE_MASK)
+#define CPU_PLL_CONFIG_SPARE_RESET                                   0x0 // 0
+#define CPU_PLL_CONFIG_OUTDIV_MSB                                    21
+#define CPU_PLL_CONFIG_OUTDIV_LSB                                    19
+#define CPU_PLL_CONFIG_OUTDIV_MASK                                   0x00380000
+#define CPU_PLL_CONFIG_OUTDIV_GET(x)                                 (((x) & CPU_PLL_CONFIG_OUTDIV_MASK) >> CPU_PLL_CONFIG_OUTDIV_LSB)
+#define CPU_PLL_CONFIG_OUTDIV_SET(x)                                 (((x) << CPU_PLL_CONFIG_OUTDIV_LSB) & CPU_PLL_CONFIG_OUTDIV_MASK)
+#define CPU_PLL_CONFIG_OUTDIV_RESET                                  0x0 // 0
+#define CPU_PLL_CONFIG_RANGE_MSB                                     18
+#define CPU_PLL_CONFIG_RANGE_LSB                                     17
+#define CPU_PLL_CONFIG_RANGE_MASK                                    0x00060000
+#define CPU_PLL_CONFIG_RANGE_GET(x)                                  (((x) & CPU_PLL_CONFIG_RANGE_MASK) >> CPU_PLL_CONFIG_RANGE_LSB)
+#define CPU_PLL_CONFIG_RANGE_SET(x)                                  (((x) << CPU_PLL_CONFIG_RANGE_LSB) & CPU_PLL_CONFIG_RANGE_MASK)
+#define CPU_PLL_CONFIG_RANGE_RESET                                   0x3 // 3
+#define CPU_PLL_CONFIG_REFDIV_MSB                                    16
+#define CPU_PLL_CONFIG_REFDIV_LSB                                    12
+#define CPU_PLL_CONFIG_REFDIV_MASK                                   0x0001f000
+#define CPU_PLL_CONFIG_REFDIV_GET(x)                                 (((x) & CPU_PLL_CONFIG_REFDIV_MASK) >> CPU_PLL_CONFIG_REFDIV_LSB)
+#define CPU_PLL_CONFIG_REFDIV_SET(x)                                 (((x) << CPU_PLL_CONFIG_REFDIV_LSB) & CPU_PLL_CONFIG_REFDIV_MASK)
+#define CPU_PLL_CONFIG_REFDIV_RESET                                  0x2 // 2
+#define CPU_PLL_CONFIG_NINT_MSB                                      11
+#define CPU_PLL_CONFIG_NINT_LSB                                      6
+#define CPU_PLL_CONFIG_NINT_MASK                                     0x00000fc0
+#define CPU_PLL_CONFIG_NINT_GET(x)                                   (((x) & CPU_PLL_CONFIG_NINT_MASK) >> CPU_PLL_CONFIG_NINT_LSB)
+#define CPU_PLL_CONFIG_NINT_SET(x)                                   (((x) << CPU_PLL_CONFIG_NINT_LSB) & CPU_PLL_CONFIG_NINT_MASK)
+#define CPU_PLL_CONFIG_NINT_RESET                                    0x14 // 20
+#define CPU_PLL_CONFIG_NFRAC_MSB                                     5
+#define CPU_PLL_CONFIG_NFRAC_LSB                                     0
+#define CPU_PLL_CONFIG_NFRAC_MASK                                    0x0000003f
+#define CPU_PLL_CONFIG_NFRAC_GET(x)                                  (((x) & CPU_PLL_CONFIG_NFRAC_MASK) >> CPU_PLL_CONFIG_NFRAC_LSB)
+#define CPU_PLL_CONFIG_NFRAC_SET(x)                                  (((x) << CPU_PLL_CONFIG_NFRAC_LSB) & CPU_PLL_CONFIG_NFRAC_MASK)
+#define CPU_PLL_CONFIG_NFRAC_RESET                                   0x10 // 16
+#define CPU_PLL_CONFIG_ADDRESS                                       0x18050000
+#define DDR_PLL_CONFIG_UPDATING_MSB                                  31
+#define DDR_PLL_CONFIG_UPDATING_LSB                                  31
+#define DDR_PLL_CONFIG_UPDATING_MASK                                 0x80000000
+#define DDR_PLL_CONFIG_UPDATING_GET(x)                               (((x) & DDR_PLL_CONFIG_UPDATING_MASK) >> DDR_PLL_CONFIG_UPDATING_LSB)
+#define DDR_PLL_CONFIG_UPDATING_SET(x)                               (((x) << DDR_PLL_CONFIG_UPDATING_LSB) & DDR_PLL_CONFIG_UPDATING_MASK)
+#define DDR_PLL_CONFIG_UPDATING_RESET                                0x1 // 1
+#define DDR_PLL_CONFIG_PLLPWD_MSB                                    30
+#define DDR_PLL_CONFIG_PLLPWD_LSB                                    30
+#define DDR_PLL_CONFIG_PLLPWD_MASK                                   0x40000000
+#define DDR_PLL_CONFIG_PLLPWD_GET(x)                                 (((x) & DDR_PLL_CONFIG_PLLPWD_MASK) >> DDR_PLL_CONFIG_PLLPWD_LSB)
+#define DDR_PLL_CONFIG_PLLPWD_SET(x)                                 (((x) << DDR_PLL_CONFIG_PLLPWD_LSB) & DDR_PLL_CONFIG_PLLPWD_MASK)
+#define DDR_PLL_CONFIG_PLLPWD_RESET                                  0x1 // 1
+#define DDR_PLL_CONFIG_SPARE_MSB                                     29
+#define DDR_PLL_CONFIG_SPARE_LSB                                     26
+#define DDR_PLL_CONFIG_SPARE_MASK                                    0x3c000000
+#define DDR_PLL_CONFIG_SPARE_GET(x)                                  (((x) & DDR_PLL_CONFIG_SPARE_MASK) >> DDR_PLL_CONFIG_SPARE_LSB)
+#define DDR_PLL_CONFIG_SPARE_SET(x)                                  (((x) << DDR_PLL_CONFIG_SPARE_LSB) & DDR_PLL_CONFIG_SPARE_MASK)
+#define DDR_PLL_CONFIG_SPARE_RESET                                   0x0 // 0
+#define DDR_PLL_CONFIG_OUTDIV_MSB                                    25
+#define DDR_PLL_CONFIG_OUTDIV_LSB                                    23
+#define DDR_PLL_CONFIG_OUTDIV_MASK                                   0x03800000
+#define DDR_PLL_CONFIG_OUTDIV_GET(x)                                 (((x) & DDR_PLL_CONFIG_OUTDIV_MASK) >> DDR_PLL_CONFIG_OUTDIV_LSB)
+#define DDR_PLL_CONFIG_OUTDIV_SET(x)                                 (((x) << DDR_PLL_CONFIG_OUTDIV_LSB) & DDR_PLL_CONFIG_OUTDIV_MASK)
+#define DDR_PLL_CONFIG_OUTDIV_RESET                                  0x0 // 0
+#define DDR_PLL_CONFIG_RANGE_MSB                                     22
+#define DDR_PLL_CONFIG_RANGE_LSB                                     21
+#define DDR_PLL_CONFIG_RANGE_MASK                                    0x00600000
+#define DDR_PLL_CONFIG_RANGE_GET(x)                                  (((x) & DDR_PLL_CONFIG_RANGE_MASK) >> DDR_PLL_CONFIG_RANGE_LSB)
+#define DDR_PLL_CONFIG_RANGE_SET(x)                                  (((x) << DDR_PLL_CONFIG_RANGE_LSB) & DDR_PLL_CONFIG_RANGE_MASK)
+#define DDR_PLL_CONFIG_RANGE_RESET                                   0x3 // 3
+#define DDR_PLL_CONFIG_REFDIV_MSB                                    20
+#define DDR_PLL_CONFIG_REFDIV_LSB                                    16
+#define DDR_PLL_CONFIG_REFDIV_MASK                                   0x001f0000
+#define DDR_PLL_CONFIG_REFDIV_GET(x)                                 (((x) & DDR_PLL_CONFIG_REFDIV_MASK) >> DDR_PLL_CONFIG_REFDIV_LSB)
+#define DDR_PLL_CONFIG_REFDIV_SET(x)                                 (((x) << DDR_PLL_CONFIG_REFDIV_LSB) & DDR_PLL_CONFIG_REFDIV_MASK)
+#define DDR_PLL_CONFIG_REFDIV_RESET                                  0x2 // 2
+#define DDR_PLL_CONFIG_NINT_MSB                                      15
+#define DDR_PLL_CONFIG_NINT_LSB                                      10
+#define DDR_PLL_CONFIG_NINT_MASK                                     0x0000fc00
+#define DDR_PLL_CONFIG_NINT_GET(x)                                   (((x) & DDR_PLL_CONFIG_NINT_MASK) >> DDR_PLL_CONFIG_NINT_LSB)
+#define DDR_PLL_CONFIG_NINT_SET(x)                                   (((x) << DDR_PLL_CONFIG_NINT_LSB) & DDR_PLL_CONFIG_NINT_MASK)
+#define DDR_PLL_CONFIG_NINT_RESET                                    0x14 // 20
+#define DDR_PLL_CONFIG_NFRAC_MSB                                     9
+#define DDR_PLL_CONFIG_NFRAC_LSB                                     0
+#define DDR_PLL_CONFIG_NFRAC_MASK                                    0x000003ff
+#define DDR_PLL_CONFIG_NFRAC_GET(x)                                  (((x) & DDR_PLL_CONFIG_NFRAC_MASK) >> DDR_PLL_CONFIG_NFRAC_LSB)
+#define DDR_PLL_CONFIG_NFRAC_SET(x)                                  (((x) << DDR_PLL_CONFIG_NFRAC_LSB) & DDR_PLL_CONFIG_NFRAC_MASK)
+#define DDR_PLL_CONFIG_NFRAC_RESET                                   0x200 // 512
+#define DDR_PLL_CONFIG_ADDRESS                                       0x18050004
+
+#define DDR_CTL_CONFIG_SRAM_TSEL_MSB                                 31
+#define DDR_CTL_CONFIG_SRAM_TSEL_LSB                                 30
+#define DDR_CTL_CONFIG_SRAM_TSEL_MASK                                0xc0000000
+#define DDR_CTL_CONFIG_SRAM_TSEL_GET(x)                              (((x) & DDR_CTL_CONFIG_SRAM_TSEL_MASK) >> DDR_CTL_CONFIG_SRAM_TSEL_LSB)
+#define DDR_CTL_CONFIG_SRAM_TSEL_SET(x)                              (((x) << DDR_CTL_CONFIG_SRAM_TSEL_LSB) & DDR_CTL_CONFIG_SRAM_TSEL_MASK)
+#define DDR_CTL_CONFIG_SRAM_TSEL_RESET                               0x1 // 1
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MSB                           29
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB                           21
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK                          0x3fe00000
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_GET(x)                        (((x) & DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK) >> DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB)
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_SET(x)                        (((x) << DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB) & DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK)
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_RESET                         0x0 // 0
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_MSB                             20
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_LSB                             20
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_MASK                            0x00100000
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_GET(x)                          (((x) & DDR_CTL_CONFIG_GE0_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_GE0_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_SET(x)                          (((x) << DDR_CTL_CONFIG_GE0_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_GE0_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_RESET                           0x1 // 1
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_MSB                             19
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_LSB                             19
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_MASK                            0x00080000
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_GET(x)                          (((x) & DDR_CTL_CONFIG_GE1_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_GE1_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_SET(x)                          (((x) << DDR_CTL_CONFIG_GE1_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_GE1_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_RESET                           0x1 // 1
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_MSB                             18
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_LSB                             18
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_MASK                            0x00040000
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_GET(x)                          (((x) & DDR_CTL_CONFIG_USB_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_USB_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_SET(x)                          (((x) << DDR_CTL_CONFIG_USB_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_USB_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_RESET                           0x1 // 1
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MSB                            17
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_LSB                            17
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MASK                           0x00020000
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_GET(x)                         (((x) & DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_PCIE_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_SET(x)                         (((x) << DDR_CTL_CONFIG_PCIE_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_RESET                          0x1 // 1
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MSB                            16
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_LSB                            16
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MASK                           0x00010000
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_GET(x)                         (((x) & DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_WMAC_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_SET(x)                         (((x) << DDR_CTL_CONFIG_WMAC_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_RESET                          0x1 // 1
+#define DDR_CTL_CONFIG_SPARE_MSB                                     13
+#define DDR_CTL_CONFIG_SPARE_LSB                                     7
+#define DDR_CTL_CONFIG_SPARE_MASK                                    0x00003f80
+#define DDR_CTL_CONFIG_SPARE_GET(x)                                  (((x) & DDR_CTL_CONFIG_SPARE_MASK) >> DDR_CTL_CONFIG_SPARE_LSB)
+#define DDR_CTL_CONFIG_SPARE_SET(x)                                  (((x) << DDR_CTL_CONFIG_SPARE_LSB) & DDR_CTL_CONFIG_SPARE_MASK)
+#define DDR_CTL_CONFIG_SPARE_RESET                                   0x0 // 0
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_MSB                              6
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_LSB                              6
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_MASK                             0x00000040
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_GET(x)                           (((x) & DDR_CTL_CONFIG_PAD_DDR2_SEL_MASK) >> DDR_CTL_CONFIG_PAD_DDR2_SEL_LSB)
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_SET(x)                           (((x) << DDR_CTL_CONFIG_PAD_DDR2_SEL_LSB) & DDR_CTL_CONFIG_PAD_DDR2_SEL_MASK)
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_MSB                             4
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_LSB                             4
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_MASK                            0x00000010
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_GET(x)                          (((x) & DDR_CTL_CONFIG_GATE_SRAM_CLK_MASK) >> DDR_CTL_CONFIG_GATE_SRAM_CLK_LSB)
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_SET(x)                          (((x) << DDR_CTL_CONFIG_GATE_SRAM_CLK_LSB) & DDR_CTL_CONFIG_GATE_SRAM_CLK_MASK)
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_RESET                           0x0 // 0
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_MSB                              3
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_LSB                              3
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_MASK                             0x00000008
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_GET(x)                           (((x) & DDR_CTL_CONFIG_SRAM_REQ_ACK_MASK) >> DDR_CTL_CONFIG_SRAM_REQ_ACK_LSB)
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_SET(x)                           (((x) << DDR_CTL_CONFIG_SRAM_REQ_ACK_LSB) & DDR_CTL_CONFIG_SRAM_REQ_ACK_MASK)
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_MSB                              2
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_LSB                              2
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_MASK                             0x00000004
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_GET(x)                           (((x) & DDR_CTL_CONFIG_CPU_DDR_SYNC_MASK) >> DDR_CTL_CONFIG_CPU_DDR_SYNC_LSB)
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(x)                           (((x) << DDR_CTL_CONFIG_CPU_DDR_SYNC_LSB) & DDR_CTL_CONFIG_CPU_DDR_SYNC_MASK)
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_HALF_WIDTH_MSB                                1
+#define DDR_CTL_CONFIG_HALF_WIDTH_LSB                                1
+#define DDR_CTL_CONFIG_HALF_WIDTH_MASK                               0x00000002
+#define DDR_CTL_CONFIG_HALF_WIDTH_GET(x)                             (((x) & DDR_CTL_CONFIG_HALF_WIDTH_MASK) >> DDR_CTL_CONFIG_HALF_WIDTH_LSB)
+#define DDR_CTL_CONFIG_HALF_WIDTH_SET(x)                             (((x) << DDR_CTL_CONFIG_HALF_WIDTH_LSB) & DDR_CTL_CONFIG_HALF_WIDTH_MASK)
+#define DDR_CTL_CONFIG_HALF_WIDTH_RESET                              0x1 // 1
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_MSB                             0
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_LSB                             0
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_MASK                            0x00000001
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_GET(x)                          (((x) & DDR_CTL_CONFIG_SDRAM_MODE_EN_MASK) >> DDR_CTL_CONFIG_SDRAM_MODE_EN_LSB)
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_SET(x)                          (((x) << DDR_CTL_CONFIG_SDRAM_MODE_EN_LSB) & DDR_CTL_CONFIG_SDRAM_MODE_EN_MASK)
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_RESET                           0x0 // 0
+#define DDR_CTL_CONFIG_ADDRESS                                       0x18000108
+
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MSB                            31
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_LSB                            31
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MASK                           0x80000000
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_GET(x)                         (((x) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MASK) >> DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_LSB)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_SET(x)                         (((x) << DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_LSB) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MASK)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_RESET                          0x0 // 0
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MSB                           30
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_LSB                           30
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MASK                          0x40000000
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_GET(x)                        (((x) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MASK) >> DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_LSB)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_SET(x)                        (((x) << DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_LSB) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MASK)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_RESET                         0x0 // 0
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_MSB                             29
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_LSB                             29
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_MASK                            0x20000000
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_GET(x)                          (((x) & DDR_DEBUG_RD_CNTL_USE_LB_CLK_MASK) >> DDR_DEBUG_RD_CNTL_USE_LB_CLK_LSB)
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_SET(x)                          (((x) << DDR_DEBUG_RD_CNTL_USE_LB_CLK_LSB) & DDR_DEBUG_RD_CNTL_USE_LB_CLK_MASK)
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_RESET                           0x0 // 0
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MSB                            28
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_LSB                            28
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MASK                           0x10000000
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_GET(x)                         (((x) & DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MASK) >> DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_LSB)
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_SET(x)                         (((x) << DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_LSB) & DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MASK)
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_RESET                          0x1 // 1
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MSB                            27
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_LSB                            27
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MASK                           0x08000000
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_GET(x)                         (((x) & DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MASK) >> DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_LSB)
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_SET(x)                         (((x) << DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_LSB) & DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MASK)
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_RESET                          0x0 // 0
+#define DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_MSB                          16
+#define DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_LSB                          16
+#define DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_MASK                         0x00010000
+#define DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_GET(x)                       (((x) & DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_MASK) >> DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_LSB)
+#define DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_SET(x)                       (((x) << DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_LSB) & DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_MASK)
+#define DDR_DEBUG_RD_CNTL_CK_P_PDLY_BYP_RESET                        0x0 // 0
+#define DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_MSB                     15
+#define DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_LSB                     15
+#define DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_MASK                    0x00008000
+#define DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_GET(x)                  (((x) & DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_MASK) >> DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_LSB)
+#define DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_SET(x)                  (((x) << DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_LSB) & DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_MASK)
+#define DDR_DEBUG_RD_CNTL_GATE_OPEN_PDLY_BYP_RESET                   0x0 // 0
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MSB                          14
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_LSB                          13
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MASK                         0x00006000
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_GET(x)                       (((x) & DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MASK) >> DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_LSB)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_SET(x)                       (((x) << DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_LSB) & DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MASK)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_RESET                        0x0 // 0
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_MSB                               12
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_LSB                               8
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_MASK                              0x00001f00
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_GET(x)                            (((x) & DDR_DEBUG_RD_CNTL_GATE_TAP_MASK) >> DDR_DEBUG_RD_CNTL_GATE_TAP_LSB)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_SET(x)                            (((x) << DDR_DEBUG_RD_CNTL_GATE_TAP_LSB) & DDR_DEBUG_RD_CNTL_GATE_TAP_MASK)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_RESET                             0x1 // 1
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MSB                          6
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_LSB                          5
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MASK                         0x00000060
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_GET(x)                       (((x) & DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MASK) >> DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_LSB)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_SET(x)                       (((x) << DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_LSB) & DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MASK)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_RESET                        0x0 // 0
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_MSB                               4
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_LSB                               0
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_MASK                              0x0000001f
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_GET(x)                            (((x) & DDR_DEBUG_RD_CNTL_CK_P_TAP_MASK) >> DDR_DEBUG_RD_CNTL_CK_P_TAP_LSB)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_SET(x)                            (((x) << DDR_DEBUG_RD_CNTL_CK_P_TAP_LSB) & DDR_DEBUG_RD_CNTL_CK_P_TAP_MASK)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_RESET                             0x1 // 1
+#define DDR_DEBUG_RD_CNTL_ADDRESS                                    0x18000118
+
+#define DDR2_CONFIG_DDR2_TWL_MSB                                     13
+#define DDR2_CONFIG_DDR2_TWL_LSB                                     10
+#define DDR2_CONFIG_DDR2_TWL_MASK                                    0x00003c00
+#define DDR2_CONFIG_DDR2_TWL_GET(x)                                  (((x) & DDR2_CONFIG_DDR2_TWL_MASK) >> DDR2_CONFIG_DDR2_TWL_LSB)
+#define DDR2_CONFIG_DDR2_TWL_SET(x)                                  (((x) << DDR2_CONFIG_DDR2_TWL_LSB) & DDR2_CONFIG_DDR2_TWL_MASK)
+#define DDR2_CONFIG_DDR2_TWL_RESET                                   0x1 // 1
+#define DDR2_CONFIG_DDR2_ODT_MSB                                     9
+#define DDR2_CONFIG_DDR2_ODT_LSB                                     9
+#define DDR2_CONFIG_DDR2_ODT_MASK                                    0x00000200
+#define DDR2_CONFIG_DDR2_ODT_GET(x)                                  (((x) & DDR2_CONFIG_DDR2_ODT_MASK) >> DDR2_CONFIG_DDR2_ODT_LSB)
+#define DDR2_CONFIG_DDR2_ODT_SET(x)                                  (((x) << DDR2_CONFIG_DDR2_ODT_LSB) & DDR2_CONFIG_DDR2_ODT_MASK)
+#define DDR2_CONFIG_DDR2_ODT_RESET                                   0x1 // 1
+#define DDR2_CONFIG_TFAW_MSB                                         7
+#define DDR2_CONFIG_TFAW_LSB                                         2
+#define DDR2_CONFIG_TFAW_MASK                                        0x000000fc
+#define DDR2_CONFIG_TFAW_GET(x)                                      (((x) & DDR2_CONFIG_TFAW_MASK) >> DDR2_CONFIG_TFAW_LSB)
+#define DDR2_CONFIG_TFAW_SET(x)                                      (((x) << DDR2_CONFIG_TFAW_LSB) & DDR2_CONFIG_TFAW_MASK)
+#define DDR2_CONFIG_TFAW_RESET                                       0x16 // 22
+#define DDR2_CONFIG_ENABLE_DDR2_MSB                                  0
+#define DDR2_CONFIG_ENABLE_DDR2_LSB                                  0
+#define DDR2_CONFIG_ENABLE_DDR2_MASK                                 0x00000001
+#define DDR2_CONFIG_ENABLE_DDR2_GET(x)                               (((x) & DDR2_CONFIG_ENABLE_DDR2_MASK) >> DDR2_CONFIG_ENABLE_DDR2_LSB)
+#define DDR2_CONFIG_ENABLE_DDR2_SET(x)                               (((x) << DDR2_CONFIG_ENABLE_DDR2_LSB) & DDR2_CONFIG_ENABLE_DDR2_MASK)
+#define DDR2_CONFIG_ENABLE_DDR2_RESET                                0x0 // 0
+#define DDR2_CONFIG_ADDRESS                                          0x180000b8
+
+#define DDR_CONTROL_EMR3S_MSB                                        5
+#define DDR_CONTROL_EMR3S_LSB                                        5
+#define DDR_CONTROL_EMR3S_MASK                                       0x00000020
+#define DDR_CONTROL_EMR3S_GET(x)                                     (((x) & DDR_CONTROL_EMR3S_MASK) >> DDR_CONTROL_EMR3S_LSB)
+#define DDR_CONTROL_EMR3S_SET(x)                                     (((x) << DDR_CONTROL_EMR3S_LSB) & DDR_CONTROL_EMR3S_MASK)
+#define DDR_CONTROL_EMR3S_RESET                                      0x0 // 0
+#define DDR_CONTROL_EMR2S_MSB                                        4
+#define DDR_CONTROL_EMR2S_LSB                                        4
+#define DDR_CONTROL_EMR2S_MASK                                       0x00000010
+#define DDR_CONTROL_EMR2S_GET(x)                                     (((x) & DDR_CONTROL_EMR2S_MASK) >> DDR_CONTROL_EMR2S_LSB)
+#define DDR_CONTROL_EMR2S_SET(x)                                     (((x) << DDR_CONTROL_EMR2S_LSB) & DDR_CONTROL_EMR2S_MASK)
+#define DDR_CONTROL_EMR2S_RESET                                      0x0 // 0
+#define DDR_CONTROL_PREA_MSB                                         3
+#define DDR_CONTROL_PREA_LSB                                         3
+#define DDR_CONTROL_PREA_MASK                                        0x00000008
+#define DDR_CONTROL_PREA_GET(x)                                      (((x) & DDR_CONTROL_PREA_MASK) >> DDR_CONTROL_PREA_LSB)
+#define DDR_CONTROL_PREA_SET(x)                                      (((x) << DDR_CONTROL_PREA_LSB) & DDR_CONTROL_PREA_MASK)
+#define DDR_CONTROL_PREA_RESET                                       0x0 // 0
+#define DDR_CONTROL_REF_MSB                                          2
+#define DDR_CONTROL_REF_LSB                                          2
+#define DDR_CONTROL_REF_MASK                                         0x00000004
+#define DDR_CONTROL_REF_GET(x)                                       (((x) & DDR_CONTROL_REF_MASK) >> DDR_CONTROL_REF_LSB)
+#define DDR_CONTROL_REF_SET(x)                                       (((x) << DDR_CONTROL_REF_LSB) & DDR_CONTROL_REF_MASK)
+#define DDR_CONTROL_REF_RESET                                        0x0 // 0
+#define DDR_CONTROL_EMRS_MSB                                         1
+#define DDR_CONTROL_EMRS_LSB                                         1
+#define DDR_CONTROL_EMRS_MASK                                        0x00000002
+#define DDR_CONTROL_EMRS_GET(x)                                      (((x) & DDR_CONTROL_EMRS_MASK) >> DDR_CONTROL_EMRS_LSB)
+#define DDR_CONTROL_EMRS_SET(x)                                      (((x) << DDR_CONTROL_EMRS_LSB) & DDR_CONTROL_EMRS_MASK)
+#define DDR_CONTROL_EMRS_RESET                                       0x0 // 0
+#define DDR_CONTROL_MRS_MSB                                          0
+#define DDR_CONTROL_MRS_LSB                                          0
+#define DDR_CONTROL_MRS_MASK                                         0x00000001
+#define DDR_CONTROL_MRS_GET(x)                                       (((x) & DDR_CONTROL_MRS_MASK) >> DDR_CONTROL_MRS_LSB)
+#define DDR_CONTROL_MRS_SET(x)                                       (((x) << DDR_CONTROL_MRS_LSB) & DDR_CONTROL_MRS_MASK)
+#define DDR_CONTROL_MRS_RESET                                        0x0 // 0
+#define DDR_CONTROL_ADDRESS                                          0x18000010
+
+#define DDR_CONFIG_CAS_LATENCY_MSB_MSB                               31
+#define DDR_CONFIG_CAS_LATENCY_MSB_LSB                               31
+#define DDR_CONFIG_CAS_LATENCY_MSB_MASK                              0x80000000
+#define DDR_CONFIG_CAS_LATENCY_MSB_GET(x)                            (((x) & DDR_CONFIG_CAS_LATENCY_MSB_MASK) >> DDR_CONFIG_CAS_LATENCY_MSB_LSB)
+#define DDR_CONFIG_CAS_LATENCY_MSB_SET(x)                            (((x) << DDR_CONFIG_CAS_LATENCY_MSB_LSB) & DDR_CONFIG_CAS_LATENCY_MSB_MASK)
+#define DDR_CONFIG_CAS_LATENCY_MSB_RESET                             0x0 // 0
+#define DDR_CONFIG_OPEN_PAGE_MSB                                     30
+#define DDR_CONFIG_OPEN_PAGE_LSB                                     30
+#define DDR_CONFIG_OPEN_PAGE_MASK                                    0x40000000
+#define DDR_CONFIG_OPEN_PAGE_GET(x)                                  (((x) & DDR_CONFIG_OPEN_PAGE_MASK) >> DDR_CONFIG_OPEN_PAGE_LSB)
+#define DDR_CONFIG_OPEN_PAGE_SET(x)                                  (((x) << DDR_CONFIG_OPEN_PAGE_LSB) & DDR_CONFIG_OPEN_PAGE_MASK)
+#define DDR_CONFIG_OPEN_PAGE_RESET                                   0x1 // 1
+#define DDR_CONFIG_CAS_LATENCY_MSB                                   29
+#define DDR_CONFIG_CAS_LATENCY_LSB                                   27
+#define DDR_CONFIG_CAS_LATENCY_MASK                                  0x38000000
+#define DDR_CONFIG_CAS_LATENCY_GET(x)                                (((x) & DDR_CONFIG_CAS_LATENCY_MASK) >> DDR_CONFIG_CAS_LATENCY_LSB)
+#define DDR_CONFIG_CAS_LATENCY_SET(x)                                (((x) << DDR_CONFIG_CAS_LATENCY_LSB) & DDR_CONFIG_CAS_LATENCY_MASK)
+#define DDR_CONFIG_CAS_LATENCY_RESET                                 0x6 // 6
+#define DDR_CONFIG_TMRD_MSB                                          26
+#define DDR_CONFIG_TMRD_LSB                                          23
+#define DDR_CONFIG_TMRD_MASK                                         0x07800000
+#define DDR_CONFIG_TMRD_GET(x)                                       (((x) & DDR_CONFIG_TMRD_MASK) >> DDR_CONFIG_TMRD_LSB)
+#define DDR_CONFIG_TMRD_SET(x)                                       (((x) << DDR_CONFIG_TMRD_LSB) & DDR_CONFIG_TMRD_MASK)
+#define DDR_CONFIG_TMRD_RESET                                        0xf // 15
+#define DDR_CONFIG_TRFC_MSB                                          22
+#define DDR_CONFIG_TRFC_LSB                                          17
+#define DDR_CONFIG_TRFC_MASK                                         0x007e0000
+#define DDR_CONFIG_TRFC_GET(x)                                       (((x) & DDR_CONFIG_TRFC_MASK) >> DDR_CONFIG_TRFC_LSB)
+#define DDR_CONFIG_TRFC_SET(x)                                       (((x) << DDR_CONFIG_TRFC_LSB) & DDR_CONFIG_TRFC_MASK)
+#define DDR_CONFIG_TRFC_RESET                                        0x24 // 36
+#define DDR_CONFIG_TRRD_MSB                                          16
+#define DDR_CONFIG_TRRD_LSB                                          13
+#define DDR_CONFIG_TRRD_MASK                                         0x0001e000
+#define DDR_CONFIG_TRRD_GET(x)                                       (((x) & DDR_CONFIG_TRRD_MASK) >> DDR_CONFIG_TRRD_LSB)
+#define DDR_CONFIG_TRRD_SET(x)                                       (((x) << DDR_CONFIG_TRRD_LSB) & DDR_CONFIG_TRRD_MASK)
+#define DDR_CONFIG_TRRD_RESET                                        0x4 // 4
+#define DDR_CONFIG_TRP_MSB                                           12
+#define DDR_CONFIG_TRP_LSB                                           9
+#define DDR_CONFIG_TRP_MASK                                          0x00001e00
+#define DDR_CONFIG_TRP_GET(x)                                        (((x) & DDR_CONFIG_TRP_MASK) >> DDR_CONFIG_TRP_LSB)
+#define DDR_CONFIG_TRP_SET(x)                                        (((x) << DDR_CONFIG_TRP_LSB) & DDR_CONFIG_TRP_MASK)
+#define DDR_CONFIG_TRP_RESET                                         0x6 // 6
+#define DDR_CONFIG_TRCD_MSB                                          8
+#define DDR_CONFIG_TRCD_LSB                                          5
+#define DDR_CONFIG_TRCD_MASK                                         0x000001e0
+#define DDR_CONFIG_TRCD_GET(x)                                       (((x) & DDR_CONFIG_TRCD_MASK) >> DDR_CONFIG_TRCD_LSB)
+#define DDR_CONFIG_TRCD_SET(x)                                       (((x) << DDR_CONFIG_TRCD_LSB) & DDR_CONFIG_TRCD_MASK)
+#define DDR_CONFIG_TRCD_RESET                                        0x6 // 6
+#define DDR_CONFIG_TRAS_MSB                                          4
+#define DDR_CONFIG_TRAS_LSB                                          0
+#define DDR_CONFIG_TRAS_MASK                                         0x0000001f
+#define DDR_CONFIG_TRAS_GET(x)                                       (((x) & DDR_CONFIG_TRAS_MASK) >> DDR_CONFIG_TRAS_LSB)
+#define DDR_CONFIG_TRAS_SET(x)                                       (((x) << DDR_CONFIG_TRAS_LSB) & DDR_CONFIG_TRAS_MASK)
+#define DDR_CONFIG_TRAS_RESET                                        0x10 // 16
+#define DDR_CONFIG_ADDRESS                                           0x18000000
+
+#define DDR_CONFIG2_HALF_WIDTH_LOW_MSB                               31
+#define DDR_CONFIG2_HALF_WIDTH_LOW_LSB                               31
+#define DDR_CONFIG2_HALF_WIDTH_LOW_MASK                              0x80000000
+#define DDR_CONFIG2_HALF_WIDTH_LOW_GET(x)                            (((x) & DDR_CONFIG2_HALF_WIDTH_LOW_MASK) >> DDR_CONFIG2_HALF_WIDTH_LOW_LSB)
+#define DDR_CONFIG2_HALF_WIDTH_LOW_SET(x)                            (((x) << DDR_CONFIG2_HALF_WIDTH_LOW_LSB) & DDR_CONFIG2_HALF_WIDTH_LOW_MASK)
+#define DDR_CONFIG2_HALF_WIDTH_LOW_RESET                             0x1 // 1
+#define DDR_CONFIG2_SWAP_A26_A27_MSB                                 30
+#define DDR_CONFIG2_SWAP_A26_A27_LSB                                 30
+#define DDR_CONFIG2_SWAP_A26_A27_MASK                                0x40000000
+#define DDR_CONFIG2_SWAP_A26_A27_GET(x)                              (((x) & DDR_CONFIG2_SWAP_A26_A27_MASK) >> DDR_CONFIG2_SWAP_A26_A27_LSB)
+#define DDR_CONFIG2_SWAP_A26_A27_SET(x)                              (((x) << DDR_CONFIG2_SWAP_A26_A27_LSB) & DDR_CONFIG2_SWAP_A26_A27_MASK)
+#define DDR_CONFIG2_SWAP_A26_A27_RESET                               0x0 // 0
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_MSB                            29
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_LSB                            26
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_MASK                           0x3c000000
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_GET(x)                         (((x) & DDR_CONFIG2_GATE_OPEN_LATENCY_MASK) >> DDR_CONFIG2_GATE_OPEN_LATENCY_LSB)
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_SET(x)                         (((x) << DDR_CONFIG2_GATE_OPEN_LATENCY_LSB) & DDR_CONFIG2_GATE_OPEN_LATENCY_MASK)
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_RESET                          0x6 // 6
+#define DDR_CONFIG2_TWTR_MSB                                         25
+#define DDR_CONFIG2_TWTR_LSB                                         21
+#define DDR_CONFIG2_TWTR_MASK                                        0x03e00000
+#define DDR_CONFIG2_TWTR_GET(x)                                      (((x) & DDR_CONFIG2_TWTR_MASK) >> DDR_CONFIG2_TWTR_LSB)
+#define DDR_CONFIG2_TWTR_SET(x)                                      (((x) << DDR_CONFIG2_TWTR_LSB) & DDR_CONFIG2_TWTR_MASK)
+#define DDR_CONFIG2_TWTR_RESET                                       0xe // 14
+#define DDR_CONFIG2_TRTP_MSB                                         20
+#define DDR_CONFIG2_TRTP_LSB                                         17
+#define DDR_CONFIG2_TRTP_MASK                                        0x001e0000
+#define DDR_CONFIG2_TRTP_GET(x)                                      (((x) & DDR_CONFIG2_TRTP_MASK) >> DDR_CONFIG2_TRTP_LSB)
+#define DDR_CONFIG2_TRTP_SET(x)                                      (((x) << DDR_CONFIG2_TRTP_LSB) & DDR_CONFIG2_TRTP_MASK)
+#define DDR_CONFIG2_TRTP_RESET                                       0x8 // 8
+#define DDR_CONFIG2_TRTW_MSB                                         16
+#define DDR_CONFIG2_TRTW_LSB                                         12
+#define DDR_CONFIG2_TRTW_MASK                                        0x0001f000
+#define DDR_CONFIG2_TRTW_GET(x)                                      (((x) & DDR_CONFIG2_TRTW_MASK) >> DDR_CONFIG2_TRTW_LSB)
+#define DDR_CONFIG2_TRTW_SET(x)                                      (((x) << DDR_CONFIG2_TRTW_LSB) & DDR_CONFIG2_TRTW_MASK)
+#define DDR_CONFIG2_TRTW_RESET                                       0x10 // 16
+#define DDR_CONFIG2_TWR_MSB                                          11
+#define DDR_CONFIG2_TWR_LSB                                          8
+#define DDR_CONFIG2_TWR_MASK                                         0x00000f00
+#define DDR_CONFIG2_TWR_GET(x)                                       (((x) & DDR_CONFIG2_TWR_MASK) >> DDR_CONFIG2_TWR_LSB)
+#define DDR_CONFIG2_TWR_SET(x)                                       (((x) << DDR_CONFIG2_TWR_LSB) & DDR_CONFIG2_TWR_MASK)
+#define DDR_CONFIG2_TWR_RESET                                        0x6 // 6
+#define DDR_CONFIG2_CKE_MSB                                          7
+#define DDR_CONFIG2_CKE_LSB                                          7
+#define DDR_CONFIG2_CKE_MASK                                         0x00000080
+#define DDR_CONFIG2_CKE_GET(x)                                       (((x) & DDR_CONFIG2_CKE_MASK) >> DDR_CONFIG2_CKE_LSB)
+#define DDR_CONFIG2_CKE_SET(x)                                       (((x) << DDR_CONFIG2_CKE_LSB) & DDR_CONFIG2_CKE_MASK)
+#define DDR_CONFIG2_CKE_RESET                                        0x0 // 0
+#define DDR_CONFIG2_PHASE_SELECT_MSB                                 6
+#define DDR_CONFIG2_PHASE_SELECT_LSB                                 6
+#define DDR_CONFIG2_PHASE_SELECT_MASK                                0x00000040
+#define DDR_CONFIG2_PHASE_SELECT_GET(x)                              (((x) & DDR_CONFIG2_PHASE_SELECT_MASK) >> DDR_CONFIG2_PHASE_SELECT_LSB)
+#define DDR_CONFIG2_PHASE_SELECT_SET(x)                              (((x) << DDR_CONFIG2_PHASE_SELECT_LSB) & DDR_CONFIG2_PHASE_SELECT_MASK)
+#define DDR_CONFIG2_PHASE_SELECT_RESET                               0x0 // 0
+#define DDR_CONFIG2_CNTL_OE_EN_MSB                                   5
+#define DDR_CONFIG2_CNTL_OE_EN_LSB                                   5
+#define DDR_CONFIG2_CNTL_OE_EN_MASK                                  0x00000020
+#define DDR_CONFIG2_CNTL_OE_EN_GET(x)                                (((x) & DDR_CONFIG2_CNTL_OE_EN_MASK) >> DDR_CONFIG2_CNTL_OE_EN_LSB)
+#define DDR_CONFIG2_CNTL_OE_EN_SET(x)                                (((x) << DDR_CONFIG2_CNTL_OE_EN_LSB) & DDR_CONFIG2_CNTL_OE_EN_MASK)
+#define DDR_CONFIG2_CNTL_OE_EN_RESET                                 0x1 // 1
+#define DDR_CONFIG2_BURST_TYPE_MSB                                   4
+#define DDR_CONFIG2_BURST_TYPE_LSB                                   4
+#define DDR_CONFIG2_BURST_TYPE_MASK                                  0x00000010
+#define DDR_CONFIG2_BURST_TYPE_GET(x)                                (((x) & DDR_CONFIG2_BURST_TYPE_MASK) >> DDR_CONFIG2_BURST_TYPE_LSB)
+#define DDR_CONFIG2_BURST_TYPE_SET(x)                                (((x) << DDR_CONFIG2_BURST_TYPE_LSB) & DDR_CONFIG2_BURST_TYPE_MASK)
+#define DDR_CONFIG2_BURST_TYPE_RESET                                 0x0 // 0
+#define DDR_CONFIG2_BURST_LENGTH_MSB                                 3
+#define DDR_CONFIG2_BURST_LENGTH_LSB                                 0
+#define DDR_CONFIG2_BURST_LENGTH_MASK                                0x0000000f
+#define DDR_CONFIG2_BURST_LENGTH_GET(x)                              (((x) & DDR_CONFIG2_BURST_LENGTH_MASK) >> DDR_CONFIG2_BURST_LENGTH_LSB)
+#define DDR_CONFIG2_BURST_LENGTH_SET(x)                              (((x) << DDR_CONFIG2_BURST_LENGTH_LSB) & DDR_CONFIG2_BURST_LENGTH_MASK)
+#define DDR_CONFIG2_BURST_LENGTH_RESET                               0x8 // 8
+#define DDR_CONFIG2_ADDRESS                                          0x18000004
+
+#define DDR_CONFIG_3_SPARE_MSB                                       31
+#define DDR_CONFIG_3_SPARE_LSB                                       4
+#define DDR_CONFIG_3_SPARE_MASK                                      0xfffffff0
+#define DDR_CONFIG_3_SPARE_GET(x)                                    (((x) & DDR_CONFIG_3_SPARE_MASK) >> DDR_CONFIG_3_SPARE_LSB)
+#define DDR_CONFIG_3_SPARE_SET(x)                                    (((x) << DDR_CONFIG_3_SPARE_LSB) & DDR_CONFIG_3_SPARE_MASK)
+#define DDR_CONFIG_3_SPARE_RESET                                     0x0 // 0
+#define DDR_CONFIG_3_TWR_MSB_MSB                                     3
+#define DDR_CONFIG_3_TWR_MSB_LSB                                     3
+#define DDR_CONFIG_3_TWR_MSB_MASK                                    0x00000008
+#define DDR_CONFIG_3_TWR_MSB_GET(x)                                  (((x) & DDR_CONFIG_3_TWR_MSB_MASK) >> DDR_CONFIG_3_TWR_MSB_LSB)
+#define DDR_CONFIG_3_TWR_MSB_SET(x)                                  (((x) << DDR_CONFIG_3_TWR_MSB_LSB) & DDR_CONFIG_3_TWR_MSB_MASK)
+#define DDR_CONFIG_3_TWR_MSB_RESET                                   0x0 // 0
+#define DDR_CONFIG_3_TRAS_MSB_MSB                                    2
+#define DDR_CONFIG_3_TRAS_MSB_LSB                                    2
+#define DDR_CONFIG_3_TRAS_MSB_MASK                                   0x00000004
+#define DDR_CONFIG_3_TRAS_MSB_GET(x)                                 (((x) & DDR_CONFIG_3_TRAS_MSB_MASK) >> DDR_CONFIG_3_TRAS_MSB_LSB)
+#define DDR_CONFIG_3_TRAS_MSB_SET(x)                                 (((x) << DDR_CONFIG_3_TRAS_MSB_LSB) & DDR_CONFIG_3_TRAS_MSB_MASK)
+#define DDR_CONFIG_3_TRAS_MSB_RESET                                  0x0 // 0
+#define DDR_CONFIG_3_TRFC_LSB_MSB                                    1
+#define DDR_CONFIG_3_TRFC_LSB_LSB                                    0
+#define DDR_CONFIG_3_TRFC_LSB_MASK                                   0x00000003
+#define DDR_CONFIG_3_TRFC_LSB_GET(x)                                 (((x) & DDR_CONFIG_3_TRFC_LSB_MASK) >> DDR_CONFIG_3_TRFC_LSB_LSB)
+#define DDR_CONFIG_3_TRFC_LSB_SET(x)                                 (((x) << DDR_CONFIG_3_TRFC_LSB_LSB) & DDR_CONFIG_3_TRFC_LSB_MASK)
+#define DDR_CONFIG_3_TRFC_LSB_RESET                                  0x0 // 0
+#define DDR_CONFIG_3_ADDRESS                                         0x1800015c
+
+#define DDR_MODE_REGISTER_VALUE_MSB                                  13
+#define DDR_MODE_REGISTER_VALUE_LSB                                  0
+#define DDR_MODE_REGISTER_VALUE_MASK                                 0x00003fff
+#define DDR_MODE_REGISTER_VALUE_GET(x)                               (((x) & DDR_MODE_REGISTER_VALUE_MASK) >> DDR_MODE_REGISTER_VALUE_LSB)
+#define DDR_MODE_REGISTER_VALUE_SET(x)                               (((x) << DDR_MODE_REGISTER_VALUE_LSB) & DDR_MODE_REGISTER_VALUE_MASK)
+#define DDR_MODE_REGISTER_VALUE_RESET                                0x133 // 307
+#define DDR_MODE_REGISTER_ADDRESS                                    0x18000008
+
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_MSB                         13
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_LSB                         0
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_MASK                        0x00003fff
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_GET(x)                      (((x) & DDR_EXTENDED_MODE_REGISTER_VALUE_MASK) >> DDR_EXTENDED_MODE_REGISTER_VALUE_LSB)
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_SET(x)                      (((x) << DDR_EXTENDED_MODE_REGISTER_VALUE_LSB) & DDR_EXTENDED_MODE_REGISTER_VALUE_MASK)
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_RESET                       0x2 // 2
+#define DDR_EXTENDED_MODE_REGISTER_ADDRESS                           0x1800000c
+
+#define DDR_REFRESH_ENABLE_MSB                                       14
+#define DDR_REFRESH_ENABLE_LSB                                       14
+#define DDR_REFRESH_ENABLE_MASK                                      0x00004000
+#define DDR_REFRESH_ENABLE_GET(x)                                    (((x) & DDR_REFRESH_ENABLE_MASK) >> DDR_REFRESH_ENABLE_LSB)
+#define DDR_REFRESH_ENABLE_SET(x)                                    (((x) << DDR_REFRESH_ENABLE_LSB) & DDR_REFRESH_ENABLE_MASK)
+#define DDR_REFRESH_ENABLE_RESET                                     0x0 // 0
+#define DDR_REFRESH_PERIOD_MSB                                       13
+#define DDR_REFRESH_PERIOD_LSB                                       0
+#define DDR_REFRESH_PERIOD_MASK                                      0x00003fff
+#define DDR_REFRESH_PERIOD_GET(x)                                    (((x) & DDR_REFRESH_PERIOD_MASK) >> DDR_REFRESH_PERIOD_LSB)
+#define DDR_REFRESH_PERIOD_SET(x)                                    (((x) << DDR_REFRESH_PERIOD_LSB) & DDR_REFRESH_PERIOD_MASK)
+#define DDR_REFRESH_PERIOD_RESET                                     0x12c // 300
+#define DDR_REFRESH_ADDRESS                                          0x18000014
+
+#define BB_DPLL2_LOCAL_PLL_MSB                                       31
+#define BB_DPLL2_LOCAL_PLL_LSB                                       31
+#define BB_DPLL2_LOCAL_PLL_MASK                                      0x80000000
+#define BB_DPLL2_LOCAL_PLL_GET(x)                                    (((x) & BB_DPLL2_LOCAL_PLL_MASK) >> BB_DPLL2_LOCAL_PLL_LSB)
+#define BB_DPLL2_LOCAL_PLL_SET(x)                                    (((x) << BB_DPLL2_LOCAL_PLL_LSB) & BB_DPLL2_LOCAL_PLL_MASK)
+#define BB_DPLL2_LOCAL_PLL_RESET                                     0x0 // 0
+#define BB_DPLL2_KI_MSB                                              30
+#define BB_DPLL2_KI_LSB                                              29
+#define BB_DPLL2_KI_MASK                                             0x60000000
+#define BB_DPLL2_KI_GET(x)                                           (((x) & BB_DPLL2_KI_MASK) >> BB_DPLL2_KI_LSB)
+#define BB_DPLL2_KI_SET(x)                                           (((x) << BB_DPLL2_KI_LSB) & BB_DPLL2_KI_MASK)
+#define BB_DPLL2_KI_RESET                                            0x2 // 2
+#define BB_DPLL2_KD_MSB                                              28
+#define BB_DPLL2_KD_LSB                                              25
+#define BB_DPLL2_KD_MASK                                             0x1e000000
+#define BB_DPLL2_KD_GET(x)                                           (((x) & BB_DPLL2_KD_MASK) >> BB_DPLL2_KD_LSB)
+#define BB_DPLL2_KD_SET(x)                                           (((x) << BB_DPLL2_KD_LSB) & BB_DPLL2_KD_MASK)
+#define BB_DPLL2_KD_RESET                                            0xa // 10
+#define BB_DPLL2_EN_NEGTRIG_MSB                                      24
+#define BB_DPLL2_EN_NEGTRIG_LSB                                      24
+#define BB_DPLL2_EN_NEGTRIG_MASK                                     0x01000000
+#define BB_DPLL2_EN_NEGTRIG_GET(x)                                   (((x) & BB_DPLL2_EN_NEGTRIG_MASK) >> BB_DPLL2_EN_NEGTRIG_LSB)
+#define BB_DPLL2_EN_NEGTRIG_SET(x)                                   (((x) << BB_DPLL2_EN_NEGTRIG_LSB) & BB_DPLL2_EN_NEGTRIG_MASK)
+#define BB_DPLL2_EN_NEGTRIG_RESET                                    0x0 // 0
+#define BB_DPLL2_SEL_1SDM_MSB                                        23
+#define BB_DPLL2_SEL_1SDM_LSB                                        23
+#define BB_DPLL2_SEL_1SDM_MASK                                       0x00800000
+#define BB_DPLL2_SEL_1SDM_GET(x)                                     (((x) & BB_DPLL2_SEL_1SDM_MASK) >> BB_DPLL2_SEL_1SDM_LSB)
+#define BB_DPLL2_SEL_1SDM_SET(x)                                     (((x) << BB_DPLL2_SEL_1SDM_LSB) & BB_DPLL2_SEL_1SDM_MASK)
+#define BB_DPLL2_SEL_1SDM_RESET                                      0x0 // 0
+#define BB_DPLL2_PLL_PWD_MSB                                         22
+#define BB_DPLL2_PLL_PWD_LSB                                         22
+#define BB_DPLL2_PLL_PWD_MASK                                        0x00400000
+#define BB_DPLL2_PLL_PWD_GET(x)                                      (((x) & BB_DPLL2_PLL_PWD_MASK) >> BB_DPLL2_PLL_PWD_LSB)
+#define BB_DPLL2_PLL_PWD_SET(x)                                      (((x) << BB_DPLL2_PLL_PWD_LSB) & BB_DPLL2_PLL_PWD_MASK)
+#define BB_DPLL2_PLL_PWD_RESET                                       0x1 // 1
+#define BB_DPLL2_OUTDIV_MSB                                          21
+#define BB_DPLL2_OUTDIV_LSB                                          19
+#define BB_DPLL2_OUTDIV_MASK                                         0x00380000
+#define BB_DPLL2_OUTDIV_GET(x)                                       (((x) & BB_DPLL2_OUTDIV_MASK) >> BB_DPLL2_OUTDIV_LSB)
+#define BB_DPLL2_OUTDIV_SET(x)                                       (((x) << BB_DPLL2_OUTDIV_LSB) & BB_DPLL2_OUTDIV_MASK)
+#define BB_DPLL2_OUTDIV_RESET                                        0x1 // 1
+#define BB_DPLL2_PHASE_SHIFT_MSB                                     18
+#define BB_DPLL2_PHASE_SHIFT_LSB                                     12
+#define BB_DPLL2_PHASE_SHIFT_MASK                                    0x0007f000
+#define BB_DPLL2_PHASE_SHIFT_GET(x)                                  (((x) & BB_DPLL2_PHASE_SHIFT_MASK) >> BB_DPLL2_PHASE_SHIFT_LSB)
+#define BB_DPLL2_PHASE_SHIFT_SET(x)                                  (((x) << BB_DPLL2_PHASE_SHIFT_LSB) & BB_DPLL2_PHASE_SHIFT_MASK)
+#define BB_DPLL2_PHASE_SHIFT_RESET                                   0x0 // 0
+#define BB_DPLL2_TESTIN_MSB                                          11
+#define BB_DPLL2_TESTIN_LSB                                          2
+#define BB_DPLL2_TESTIN_MASK                                         0x00000ffc
+#define BB_DPLL2_TESTIN_GET(x)                                       (((x) & BB_DPLL2_TESTIN_MASK) >> BB_DPLL2_TESTIN_LSB)
+#define BB_DPLL2_TESTIN_SET(x)                                       (((x) << BB_DPLL2_TESTIN_LSB) & BB_DPLL2_TESTIN_MASK)
+#define BB_DPLL2_TESTIN_RESET                                        0x0 // 0
+#define BB_DPLL2_SEL_COUNT_MSB                                       1
+#define BB_DPLL2_SEL_COUNT_LSB                                       1
+#define BB_DPLL2_SEL_COUNT_MASK                                      0x00000002
+#define BB_DPLL2_SEL_COUNT_GET(x)                                    (((x) & BB_DPLL2_SEL_COUNT_MASK) >> BB_DPLL2_SEL_COUNT_LSB)
+#define BB_DPLL2_SEL_COUNT_SET(x)                                    (((x) << BB_DPLL2_SEL_COUNT_LSB) & BB_DPLL2_SEL_COUNT_MASK)
+#define BB_DPLL2_SEL_COUNT_RESET                                     0x0 // 0
+#define BB_DPLL2_RESET_TEST_MSB                                      0
+#define BB_DPLL2_RESET_TEST_LSB                                      0
+#define BB_DPLL2_RESET_TEST_MASK                                     0x00000001
+#define BB_DPLL2_RESET_TEST_GET(x)                                   (((x) & BB_DPLL2_RESET_TEST_MASK) >> BB_DPLL2_RESET_TEST_LSB)
+#define BB_DPLL2_RESET_TEST_SET(x)                                   (((x) << BB_DPLL2_RESET_TEST_LSB) & BB_DPLL2_RESET_TEST_MASK)
+#define BB_DPLL2_RESET_TEST_RESET                                    0x0 // 0
+#define BB_DPLL2_ADDRESS                                             0x18116184
+
+#define PCIe_DPLL2_LOCAL_PLL_MSB                                     31
+#define PCIe_DPLL2_LOCAL_PLL_LSB                                     31
+#define PCIe_DPLL2_LOCAL_PLL_MASK                                    0x80000000
+#define PCIe_DPLL2_LOCAL_PLL_GET(x)                                  (((x) & PCIe_DPLL2_LOCAL_PLL_MASK) >> PCIe_DPLL2_LOCAL_PLL_LSB)
+#define PCIe_DPLL2_LOCAL_PLL_SET(x)                                  (((x) << PCIe_DPLL2_LOCAL_PLL_LSB) & PCIe_DPLL2_LOCAL_PLL_MASK)
+#define PCIe_DPLL2_LOCAL_PLL_RESET                                   0x0 // 0
+#define PCIe_DPLL2_KI_MSB                                            30
+#define PCIe_DPLL2_KI_LSB                                            29
+#define PCIe_DPLL2_KI_MASK                                           0x60000000
+#define PCIe_DPLL2_KI_GET(x)                                         (((x) & PCIe_DPLL2_KI_MASK) >> PCIe_DPLL2_KI_LSB)
+#define PCIe_DPLL2_KI_SET(x)                                         (((x) << PCIe_DPLL2_KI_LSB) & PCIe_DPLL2_KI_MASK)
+#define PCIe_DPLL2_KI_RESET                                          0x2 // 2
+#define PCIe_DPLL2_KD_MSB                                            28
+#define PCIe_DPLL2_KD_LSB                                            25
+#define PCIe_DPLL2_KD_MASK                                           0x1e000000
+#define PCIe_DPLL2_KD_GET(x)                                         (((x) & PCIe_DPLL2_KD_MASK) >> PCIe_DPLL2_KD_LSB)
+#define PCIe_DPLL2_KD_SET(x)                                         (((x) << PCIe_DPLL2_KD_LSB) & PCIe_DPLL2_KD_MASK)
+#define PCIe_DPLL2_KD_RESET                                          0xa // 10
+#define PCIe_DPLL2_EN_NEGTRIG_MSB                                    24
+#define PCIe_DPLL2_EN_NEGTRIG_LSB                                    24
+#define PCIe_DPLL2_EN_NEGTRIG_MASK                                   0x01000000
+#define PCIe_DPLL2_EN_NEGTRIG_GET(x)                                 (((x) & PCIe_DPLL2_EN_NEGTRIG_MASK) >> PCIe_DPLL2_EN_NEGTRIG_LSB)
+#define PCIe_DPLL2_EN_NEGTRIG_SET(x)                                 (((x) << PCIe_DPLL2_EN_NEGTRIG_LSB) & PCIe_DPLL2_EN_NEGTRIG_MASK)
+#define PCIe_DPLL2_EN_NEGTRIG_RESET                                  0x0 // 0
+#define PCIe_DPLL2_SEL_1SDM_MSB                                      23
+#define PCIe_DPLL2_SEL_1SDM_LSB                                      23
+#define PCIe_DPLL2_SEL_1SDM_MASK                                     0x00800000
+#define PCIe_DPLL2_SEL_1SDM_GET(x)                                   (((x) & PCIe_DPLL2_SEL_1SDM_MASK) >> PCIe_DPLL2_SEL_1SDM_LSB)
+#define PCIe_DPLL2_SEL_1SDM_SET(x)                                   (((x) << PCIe_DPLL2_SEL_1SDM_LSB) & PCIe_DPLL2_SEL_1SDM_MASK)
+#define PCIe_DPLL2_SEL_1SDM_RESET                                    0x0 // 0
+#define PCIe_DPLL2_PLL_PWD_MSB                                       22
+#define PCIe_DPLL2_PLL_PWD_LSB                                       22
+#define PCIe_DPLL2_PLL_PWD_MASK                                      0x00400000
+#define PCIe_DPLL2_PLL_PWD_GET(x)                                    (((x) & PCIe_DPLL2_PLL_PWD_MASK) >> PCIe_DPLL2_PLL_PWD_LSB)
+#define PCIe_DPLL2_PLL_PWD_SET(x)                                    (((x) << PCIe_DPLL2_PLL_PWD_LSB) & PCIe_DPLL2_PLL_PWD_MASK)
+#define PCIe_DPLL2_PLL_PWD_RESET                                     0x1 // 1
+#define PCIe_DPLL2_OUTDIV_MSB                                        21
+#define PCIe_DPLL2_OUTDIV_LSB                                        19
+#define PCIe_DPLL2_OUTDIV_MASK                                       0x00380000
+#define PCIe_DPLL2_OUTDIV_GET(x)                                     (((x) & PCIe_DPLL2_OUTDIV_MASK) >> PCIe_DPLL2_OUTDIV_LSB)
+#define PCIe_DPLL2_OUTDIV_SET(x)                                     (((x) << PCIe_DPLL2_OUTDIV_LSB) & PCIe_DPLL2_OUTDIV_MASK)
+#define PCIe_DPLL2_OUTDIV_RESET                                      0x1 // 1
+#define PCIe_DPLL2_PHASE_SHIFT_MSB                                   18
+#define PCIe_DPLL2_PHASE_SHIFT_LSB                                   12
+#define PCIe_DPLL2_PHASE_SHIFT_MASK                                  0x0007f000
+#define PCIe_DPLL2_PHASE_SHIFT_GET(x)                                (((x) & PCIe_DPLL2_PHASE_SHIFT_MASK) >> PCIe_DPLL2_PHASE_SHIFT_LSB)
+#define PCIe_DPLL2_PHASE_SHIFT_SET(x)                                (((x) << PCIe_DPLL2_PHASE_SHIFT_LSB) & PCIe_DPLL2_PHASE_SHIFT_MASK)
+#define PCIe_DPLL2_PHASE_SHIFT_RESET                                 0x0 // 0
+#define PCIe_DPLL2_TESTIN_MSB                                        11
+#define PCIe_DPLL2_TESTIN_LSB                                        2
+#define PCIe_DPLL2_TESTIN_MASK                                       0x00000ffc
+#define PCIe_DPLL2_TESTIN_GET(x)                                     (((x) & PCIe_DPLL2_TESTIN_MASK) >> PCIe_DPLL2_TESTIN_LSB)
+#define PCIe_DPLL2_TESTIN_SET(x)                                     (((x) << PCIe_DPLL2_TESTIN_LSB) & PCIe_DPLL2_TESTIN_MASK)
+#define PCIe_DPLL2_TESTIN_RESET                                      0x0 // 0
+#define PCIe_DPLL2_SEL_COUNT_MSB                                     1
+#define PCIe_DPLL2_SEL_COUNT_LSB                                     1
+#define PCIe_DPLL2_SEL_COUNT_MASK                                    0x00000002
+#define PCIe_DPLL2_SEL_COUNT_GET(x)                                  (((x) & PCIe_DPLL2_SEL_COUNT_MASK) >> PCIe_DPLL2_SEL_COUNT_LSB)
+#define PCIe_DPLL2_SEL_COUNT_SET(x)                                  (((x) << PCIe_DPLL2_SEL_COUNT_LSB) & PCIe_DPLL2_SEL_COUNT_MASK)
+#define PCIe_DPLL2_SEL_COUNT_RESET                                   0x0 // 0
+#define PCIe_DPLL2_RESET_TEST_MSB                                    0
+#define PCIe_DPLL2_RESET_TEST_LSB                                    0
+#define PCIe_DPLL2_RESET_TEST_MASK                                   0x00000001
+#define PCIe_DPLL2_RESET_TEST_GET(x)                                 (((x) & PCIe_DPLL2_RESET_TEST_MASK) >> PCIe_DPLL2_RESET_TEST_LSB)
+#define PCIe_DPLL2_RESET_TEST_SET(x)                                 (((x) << PCIe_DPLL2_RESET_TEST_LSB) & PCIe_DPLL2_RESET_TEST_MASK)
+#define PCIe_DPLL2_RESET_TEST_RESET                                  0x0 // 0
+#define PCIe_DPLL2_ADDRESS                                           0x18116c04
+
+#define DDR_DPLL2_LOCAL_PLL_MSB                                      31
+#define DDR_DPLL2_LOCAL_PLL_LSB                                      31
+#define DDR_DPLL2_LOCAL_PLL_MASK                                     0x80000000
+#define DDR_DPLL2_LOCAL_PLL_GET(x)                                   (((x) & DDR_DPLL2_LOCAL_PLL_MASK) >> DDR_DPLL2_LOCAL_PLL_LSB)
+#define DDR_DPLL2_LOCAL_PLL_SET(x)                                   (((x) << DDR_DPLL2_LOCAL_PLL_LSB) & DDR_DPLL2_LOCAL_PLL_MASK)
+#define DDR_DPLL2_LOCAL_PLL_RESET                                    0x0 // 0
+#define DDR_DPLL2_KI_MSB                                             30
+#define DDR_DPLL2_KI_LSB                                             29
+#define DDR_DPLL2_KI_MASK                                            0x60000000
+#define DDR_DPLL2_KI_GET(x)                                          (((x) & DDR_DPLL2_KI_MASK) >> DDR_DPLL2_KI_LSB)
+#define DDR_DPLL2_KI_SET(x)                                          (((x) << DDR_DPLL2_KI_LSB) & DDR_DPLL2_KI_MASK)
+#define DDR_DPLL2_KI_RESET                                           0x2 // 2
+#define DDR_DPLL2_KD_MSB                                             28
+#define DDR_DPLL2_KD_LSB                                             25
+#define DDR_DPLL2_KD_MASK                                            0x1e000000
+#define DDR_DPLL2_KD_GET(x)                                          (((x) & DDR_DPLL2_KD_MASK) >> DDR_DPLL2_KD_LSB)
+#define DDR_DPLL2_KD_SET(x)                                          (((x) << DDR_DPLL2_KD_LSB) & DDR_DPLL2_KD_MASK)
+#define DDR_DPLL2_KD_RESET                                           0xa // 10
+#define DDR_DPLL2_EN_NEGTRIG_MSB                                     24
+#define DDR_DPLL2_EN_NEGTRIG_LSB                                     24
+#define DDR_DPLL2_EN_NEGTRIG_MASK                                    0x01000000
+#define DDR_DPLL2_EN_NEGTRIG_GET(x)                                  (((x) & DDR_DPLL2_EN_NEGTRIG_MASK) >> DDR_DPLL2_EN_NEGTRIG_LSB)
+#define DDR_DPLL2_EN_NEGTRIG_SET(x)                                  (((x) << DDR_DPLL2_EN_NEGTRIG_LSB) & DDR_DPLL2_EN_NEGTRIG_MASK)
+#define DDR_DPLL2_EN_NEGTRIG_RESET                                   0x0 // 0
+#define DDR_DPLL2_SEL_1SDM_MSB                                       23
+#define DDR_DPLL2_SEL_1SDM_LSB                                       23
+#define DDR_DPLL2_SEL_1SDM_MASK                                      0x00800000
+#define DDR_DPLL2_SEL_1SDM_GET(x)                                    (((x) & DDR_DPLL2_SEL_1SDM_MASK) >> DDR_DPLL2_SEL_1SDM_LSB)
+#define DDR_DPLL2_SEL_1SDM_SET(x)                                    (((x) << DDR_DPLL2_SEL_1SDM_LSB) & DDR_DPLL2_SEL_1SDM_MASK)
+#define DDR_DPLL2_SEL_1SDM_RESET                                     0x0 // 0
+#define DDR_DPLL2_PLL_PWD_MSB                                        22
+#define DDR_DPLL2_PLL_PWD_LSB                                        22
+#define DDR_DPLL2_PLL_PWD_MASK                                       0x00400000
+#define DDR_DPLL2_PLL_PWD_GET(x)                                     (((x) & DDR_DPLL2_PLL_PWD_MASK) >> DDR_DPLL2_PLL_PWD_LSB)
+#define DDR_DPLL2_PLL_PWD_SET(x)                                     (((x) << DDR_DPLL2_PLL_PWD_LSB) & DDR_DPLL2_PLL_PWD_MASK)
+#define DDR_DPLL2_PLL_PWD_RESET                                      0x1 // 1
+#define DDR_DPLL2_OUTDIV_MSB                                         21
+#define DDR_DPLL2_OUTDIV_LSB                                         19
+#define DDR_DPLL2_OUTDIV_MASK                                        0x00380000
+#define DDR_DPLL2_OUTDIV_GET(x)                                      (((x) & DDR_DPLL2_OUTDIV_MASK) >> DDR_DPLL2_OUTDIV_LSB)
+#define DDR_DPLL2_OUTDIV_SET(x)                                      (((x) << DDR_DPLL2_OUTDIV_LSB) & DDR_DPLL2_OUTDIV_MASK)
+#define DDR_DPLL2_OUTDIV_RESET                                       0x1 // 1
+#define DDR_DPLL2_PHASE_SHIFT_MSB                                    18
+#define DDR_DPLL2_PHASE_SHIFT_LSB                                    12
+#define DDR_DPLL2_PHASE_SHIFT_MASK                                   0x0007f000
+#define DDR_DPLL2_PHASE_SHIFT_GET(x)                                 (((x) & DDR_DPLL2_PHASE_SHIFT_MASK) >> DDR_DPLL2_PHASE_SHIFT_LSB)
+#define DDR_DPLL2_PHASE_SHIFT_SET(x)                                 (((x) << DDR_DPLL2_PHASE_SHIFT_LSB) & DDR_DPLL2_PHASE_SHIFT_MASK)
+#define DDR_DPLL2_PHASE_SHIFT_RESET                                  0x0 // 0
+#define DDR_DPLL2_TESTIN_MSB                                         11
+#define DDR_DPLL2_TESTIN_LSB                                         2
+#define DDR_DPLL2_TESTIN_MASK                                        0x00000ffc
+#define DDR_DPLL2_TESTIN_GET(x)                                      (((x) & DDR_DPLL2_TESTIN_MASK) >> DDR_DPLL2_TESTIN_LSB)
+#define DDR_DPLL2_TESTIN_SET(x)                                      (((x) << DDR_DPLL2_TESTIN_LSB) & DDR_DPLL2_TESTIN_MASK)
+#define DDR_DPLL2_TESTIN_RESET                                       0x0 // 0
+#define DDR_DPLL2_SEL_COUNT_MSB                                      1
+#define DDR_DPLL2_SEL_COUNT_LSB                                      1
+#define DDR_DPLL2_SEL_COUNT_MASK                                     0x00000002
+#define DDR_DPLL2_SEL_COUNT_GET(x)                                   (((x) & DDR_DPLL2_SEL_COUNT_MASK) >> DDR_DPLL2_SEL_COUNT_LSB)
+#define DDR_DPLL2_SEL_COUNT_SET(x)                                   (((x) << DDR_DPLL2_SEL_COUNT_LSB) & DDR_DPLL2_SEL_COUNT_MASK)
+#define DDR_DPLL2_SEL_COUNT_RESET                                    0x0 // 0
+#define DDR_DPLL2_RESET_TEST_MSB                                     0
+#define DDR_DPLL2_RESET_TEST_LSB                                     0
+#define DDR_DPLL2_RESET_TEST_MASK                                    0x00000001
+#define DDR_DPLL2_RESET_TEST_GET(x)                                  (((x) & DDR_DPLL2_RESET_TEST_MASK) >> DDR_DPLL2_RESET_TEST_LSB)
+#define DDR_DPLL2_RESET_TEST_SET(x)                                  (((x) << DDR_DPLL2_RESET_TEST_LSB) & DDR_DPLL2_RESET_TEST_MASK)
+#define DDR_DPLL2_RESET_TEST_RESET                                   0x0 // 0
+#define DDR_DPLL2_ADDRESS                                            0x18116244
+
+#define CPU_DPLL2_LOCAL_PLL_MSB                                      31
+#define CPU_DPLL2_LOCAL_PLL_LSB                                      31
+#define CPU_DPLL2_LOCAL_PLL_MASK                                     0x80000000
+#define CPU_DPLL2_LOCAL_PLL_GET(x)                                   (((x) & CPU_DPLL2_LOCAL_PLL_MASK) >> CPU_DPLL2_LOCAL_PLL_LSB)
+#define CPU_DPLL2_LOCAL_PLL_SET(x)                                   (((x) << CPU_DPLL2_LOCAL_PLL_LSB) & CPU_DPLL2_LOCAL_PLL_MASK)
+#define CPU_DPLL2_LOCAL_PLL_RESET                                    0x0 // 0
+#define CPU_DPLL2_KI_MSB                                             30
+#define CPU_DPLL2_KI_LSB                                             29
+#define CPU_DPLL2_KI_MASK                                            0x60000000
+#define CPU_DPLL2_KI_GET(x)                                          (((x) & CPU_DPLL2_KI_MASK) >> CPU_DPLL2_KI_LSB)
+#define CPU_DPLL2_KI_SET(x)                                          (((x) << CPU_DPLL2_KI_LSB) & CPU_DPLL2_KI_MASK)
+#define CPU_DPLL2_KI_RESET                                           0x2 // 2
+#define CPU_DPLL2_KD_MSB                                             28
+#define CPU_DPLL2_KD_LSB                                             25
+#define CPU_DPLL2_KD_MASK                                            0x1e000000
+#define CPU_DPLL2_KD_GET(x)                                          (((x) & CPU_DPLL2_KD_MASK) >> CPU_DPLL2_KD_LSB)
+#define CPU_DPLL2_KD_SET(x)                                          (((x) << CPU_DPLL2_KD_LSB) & CPU_DPLL2_KD_MASK)
+#define CPU_DPLL2_KD_RESET                                           0xa // 10
+#define CPU_DPLL2_EN_NEGTRIG_MSB                                     24
+#define CPU_DPLL2_EN_NEGTRIG_LSB                                     24
+#define CPU_DPLL2_EN_NEGTRIG_MASK                                    0x01000000
+#define CPU_DPLL2_EN_NEGTRIG_GET(x)                                  (((x) & CPU_DPLL2_EN_NEGTRIG_MASK) >> CPU_DPLL2_EN_NEGTRIG_LSB)
+#define CPU_DPLL2_EN_NEGTRIG_SET(x)                                  (((x) << CPU_DPLL2_EN_NEGTRIG_LSB) & CPU_DPLL2_EN_NEGTRIG_MASK)
+#define CPU_DPLL2_EN_NEGTRIG_RESET                                   0x0 // 0
+#define CPU_DPLL2_SEL_1SDM_MSB                                       23
+#define CPU_DPLL2_SEL_1SDM_LSB                                       23
+#define CPU_DPLL2_SEL_1SDM_MASK                                      0x00800000
+#define CPU_DPLL2_SEL_1SDM_GET(x)                                    (((x) & CPU_DPLL2_SEL_1SDM_MASK) >> CPU_DPLL2_SEL_1SDM_LSB)
+#define CPU_DPLL2_SEL_1SDM_SET(x)                                    (((x) << CPU_DPLL2_SEL_1SDM_LSB) & CPU_DPLL2_SEL_1SDM_MASK)
+#define CPU_DPLL2_SEL_1SDM_RESET                                     0x0 // 0
+#define CPU_DPLL2_PLL_PWD_MSB                                        22
+#define CPU_DPLL2_PLL_PWD_LSB                                        22
+#define CPU_DPLL2_PLL_PWD_MASK                                       0x00400000
+#define CPU_DPLL2_PLL_PWD_GET(x)                                     (((x) & CPU_DPLL2_PLL_PWD_MASK) >> CPU_DPLL2_PLL_PWD_LSB)
+#define CPU_DPLL2_PLL_PWD_SET(x)                                     (((x) << CPU_DPLL2_PLL_PWD_LSB) & CPU_DPLL2_PLL_PWD_MASK)
+#define CPU_DPLL2_PLL_PWD_RESET                                      0x1 // 1
+#define CPU_DPLL2_OUTDIV_MSB                                         21
+#define CPU_DPLL2_OUTDIV_LSB                                         19
+#define CPU_DPLL2_OUTDIV_MASK                                        0x00380000
+#define CPU_DPLL2_OUTDIV_GET(x)                                      (((x) & CPU_DPLL2_OUTDIV_MASK) >> CPU_DPLL2_OUTDIV_LSB)
+#define CPU_DPLL2_OUTDIV_SET(x)                                      (((x) << CPU_DPLL2_OUTDIV_LSB) & CPU_DPLL2_OUTDIV_MASK)
+#define CPU_DPLL2_OUTDIV_RESET                                       0x1 // 1
+#define CPU_DPLL2_PHASE_SHIFT_MSB                                    18
+#define CPU_DPLL2_PHASE_SHIFT_LSB                                    12
+#define CPU_DPLL2_PHASE_SHIFT_MASK                                   0x0007f000
+#define CPU_DPLL2_PHASE_SHIFT_GET(x)                                 (((x) & CPU_DPLL2_PHASE_SHIFT_MASK) >> CPU_DPLL2_PHASE_SHIFT_LSB)
+#define CPU_DPLL2_PHASE_SHIFT_SET(x)                                 (((x) << CPU_DPLL2_PHASE_SHIFT_LSB) & CPU_DPLL2_PHASE_SHIFT_MASK)
+#define CPU_DPLL2_PHASE_SHIFT_RESET                                  0x0 // 0
+#define CPU_DPLL2_TESTIN_MSB                                         11
+#define CPU_DPLL2_TESTIN_LSB                                         2
+#define CPU_DPLL2_TESTIN_MASK                                        0x00000ffc
+#define CPU_DPLL2_TESTIN_GET(x)                                      (((x) & CPU_DPLL2_TESTIN_MASK) >> CPU_DPLL2_TESTIN_LSB)
+#define CPU_DPLL2_TESTIN_SET(x)                                      (((x) << CPU_DPLL2_TESTIN_LSB) & CPU_DPLL2_TESTIN_MASK)
+#define CPU_DPLL2_TESTIN_RESET                                       0x0 // 0
+#define CPU_DPLL2_SEL_COUNT_MSB                                      1
+#define CPU_DPLL2_SEL_COUNT_LSB                                      1
+#define CPU_DPLL2_SEL_COUNT_MASK                                     0x00000002
+#define CPU_DPLL2_SEL_COUNT_GET(x)                                   (((x) & CPU_DPLL2_SEL_COUNT_MASK) >> CPU_DPLL2_SEL_COUNT_LSB)
+#define CPU_DPLL2_SEL_COUNT_SET(x)                                   (((x) << CPU_DPLL2_SEL_COUNT_LSB) & CPU_DPLL2_SEL_COUNT_MASK)
+#define CPU_DPLL2_SEL_COUNT_RESET                                    0x0 // 0
+#define CPU_DPLL2_RESET_TEST_MSB                                     0
+#define CPU_DPLL2_RESET_TEST_LSB                                     0
+#define CPU_DPLL2_RESET_TEST_MASK                                    0x00000001
+#define CPU_DPLL2_RESET_TEST_GET(x)                                  (((x) & CPU_DPLL2_RESET_TEST_MASK) >> CPU_DPLL2_RESET_TEST_LSB)
+#define CPU_DPLL2_RESET_TEST_SET(x)                                  (((x) << CPU_DPLL2_RESET_TEST_LSB) & CPU_DPLL2_RESET_TEST_MASK)
+#define CPU_DPLL2_RESET_TEST_RESET                                   0x0 // 0
+#define CPU_DPLL2_ADDRESS                                            0x181161c4
+
+#define DDR_RD_DATA_THIS_CYCLE_ADDRESS                               0x18000018
+
+#define TAP_CONTROL_0_ADDRESS                                        0x1800001c
+#define TAP_CONTROL_1_ADDRESS                                        0x18000020
+#define TAP_CONTROL_2_ADDRESS                                        0x18000024
+#define TAP_CONTROL_3_ADDRESS                                        0x18000028
+
+#define DDR_BURST_CPU_PRIORITY_MSB                                   31
+#define DDR_BURST_CPU_PRIORITY_LSB                                   31
+#define DDR_BURST_CPU_PRIORITY_MASK                                  0x80000000
+#define DDR_BURST_CPU_PRIORITY_GET(x)                                (((x) & DDR_BURST_CPU_PRIORITY_MASK) >> DDR_BURST_CPU_PRIORITY_LSB)
+#define DDR_BURST_CPU_PRIORITY_SET(x)                                (((x) << DDR_BURST_CPU_PRIORITY_LSB) & DDR_BURST_CPU_PRIORITY_MASK)
+#define DDR_BURST_CPU_PRIORITY_RESET                                 0x0 // 0
+#define DDR_BURST_CPU_PRIORITY_BE_MSB                                30
+#define DDR_BURST_CPU_PRIORITY_BE_LSB                                30
+#define DDR_BURST_CPU_PRIORITY_BE_MASK                               0x40000000
+#define DDR_BURST_CPU_PRIORITY_BE_GET(x)                             (((x) & DDR_BURST_CPU_PRIORITY_BE_MASK) >> DDR_BURST_CPU_PRIORITY_BE_LSB)
+#define DDR_BURST_CPU_PRIORITY_BE_SET(x)                             (((x) << DDR_BURST_CPU_PRIORITY_BE_LSB) & DDR_BURST_CPU_PRIORITY_BE_MASK)
+#define DDR_BURST_CPU_PRIORITY_BE_RESET                              0x1 // 1
+#define DDR_BURST_ENABLE_RWP_MASK_MSB                                29
+#define DDR_BURST_ENABLE_RWP_MASK_LSB                                28
+#define DDR_BURST_ENABLE_RWP_MASK_MASK                               0x30000000
+#define DDR_BURST_ENABLE_RWP_MASK_GET(x)                             (((x) & DDR_BURST_ENABLE_RWP_MASK_MASK) >> DDR_BURST_ENABLE_RWP_MASK_LSB)
+#define DDR_BURST_ENABLE_RWP_MASK_SET(x)                             (((x) << DDR_BURST_ENABLE_RWP_MASK_LSB) & DDR_BURST_ENABLE_RWP_MASK_MASK)
+#define DDR_BURST_ENABLE_RWP_MASK_RESET                              0x3 // 3
+#define DDR_BURST_MAX_WRITE_BURST_MSB                                27
+#define DDR_BURST_MAX_WRITE_BURST_LSB                                24
+#define DDR_BURST_MAX_WRITE_BURST_MASK                               0x0f000000
+#define DDR_BURST_MAX_WRITE_BURST_GET(x)                             (((x) & DDR_BURST_MAX_WRITE_BURST_MASK) >> DDR_BURST_MAX_WRITE_BURST_LSB)
+#define DDR_BURST_MAX_WRITE_BURST_SET(x)                             (((x) << DDR_BURST_MAX_WRITE_BURST_LSB) & DDR_BURST_MAX_WRITE_BURST_MASK)
+#define DDR_BURST_MAX_WRITE_BURST_RESET                              0x4 // 4
+#define DDR_BURST_MAX_READ_BURST_MSB                                 23
+#define DDR_BURST_MAX_READ_BURST_LSB                                 20
+#define DDR_BURST_MAX_READ_BURST_MASK                                0x00f00000
+#define DDR_BURST_MAX_READ_BURST_GET(x)                              (((x) & DDR_BURST_MAX_READ_BURST_MASK) >> DDR_BURST_MAX_READ_BURST_LSB)
+#define DDR_BURST_MAX_READ_BURST_SET(x)                              (((x) << DDR_BURST_MAX_READ_BURST_LSB) & DDR_BURST_MAX_READ_BURST_MASK)
+#define DDR_BURST_MAX_READ_BURST_RESET                               0x4 // 4
+#define DDR_BURST_CPU_MAX_BL_MSB                                     19
+#define DDR_BURST_CPU_MAX_BL_LSB                                     16
+#define DDR_BURST_CPU_MAX_BL_MASK                                    0x000f0000
+#define DDR_BURST_CPU_MAX_BL_GET(x)                                  (((x) & DDR_BURST_CPU_MAX_BL_MASK) >> DDR_BURST_CPU_MAX_BL_LSB)
+#define DDR_BURST_CPU_MAX_BL_SET(x)                                  (((x) << DDR_BURST_CPU_MAX_BL_LSB) & DDR_BURST_CPU_MAX_BL_MASK)
+#define DDR_BURST_CPU_MAX_BL_RESET                                   0x3 // 3
+#define DDR_BURST_USB_MAX_BL_MSB                                     15
+#define DDR_BURST_USB_MAX_BL_LSB                                     12
+#define DDR_BURST_USB_MAX_BL_MASK                                    0x0000f000
+#define DDR_BURST_USB_MAX_BL_GET(x)                                  (((x) & DDR_BURST_USB_MAX_BL_MASK) >> DDR_BURST_USB_MAX_BL_LSB)
+#define DDR_BURST_USB_MAX_BL_SET(x)                                  (((x) << DDR_BURST_USB_MAX_BL_LSB) & DDR_BURST_USB_MAX_BL_MASK)
+#define DDR_BURST_USB_MAX_BL_RESET                                   0x4 // 4
+#define DDR_BURST_PCIE_MAX_BL_MSB                                    11
+#define DDR_BURST_PCIE_MAX_BL_LSB                                    8
+#define DDR_BURST_PCIE_MAX_BL_MASK                                   0x00000f00
+#define DDR_BURST_PCIE_MAX_BL_GET(x)                                 (((x) & DDR_BURST_PCIE_MAX_BL_MASK) >> DDR_BURST_PCIE_MAX_BL_LSB)
+#define DDR_BURST_PCIE_MAX_BL_SET(x)                                 (((x) << DDR_BURST_PCIE_MAX_BL_LSB) & DDR_BURST_PCIE_MAX_BL_MASK)
+#define DDR_BURST_PCIE_MAX_BL_RESET                                  0x3 // 3
+#define DDR_BURST_GE1_MAX_BL_MSB                                     7
+#define DDR_BURST_GE1_MAX_BL_LSB                                     4
+#define DDR_BURST_GE1_MAX_BL_MASK                                    0x000000f0
+#define DDR_BURST_GE1_MAX_BL_GET(x)                                  (((x) & DDR_BURST_GE1_MAX_BL_MASK) >> DDR_BURST_GE1_MAX_BL_LSB)
+#define DDR_BURST_GE1_MAX_BL_SET(x)                                  (((x) << DDR_BURST_GE1_MAX_BL_LSB) & DDR_BURST_GE1_MAX_BL_MASK)
+#define DDR_BURST_GE1_MAX_BL_RESET                                   0x3 // 3
+#define DDR_BURST_GE0_MAX_BL_MSB                                     3
+#define DDR_BURST_GE0_MAX_BL_LSB                                     0
+#define DDR_BURST_GE0_MAX_BL_MASK                                    0x0000000f
+#define DDR_BURST_GE0_MAX_BL_GET(x)                                  (((x) & DDR_BURST_GE0_MAX_BL_MASK) >> DDR_BURST_GE0_MAX_BL_LSB)
+#define DDR_BURST_GE0_MAX_BL_SET(x)                                  (((x) << DDR_BURST_GE0_MAX_BL_LSB) & DDR_BURST_GE0_MAX_BL_MASK)
+#define DDR_BURST_GE0_MAX_BL_RESET                                   0x3 // 3
+#define DDR_BURST_ADDRESS                                            0x180000c4
+
+#define DDR_BURST2_WMAC_MAX_BL_MSB                                   3
+#define DDR_BURST2_WMAC_MAX_BL_LSB                                   0
+#define DDR_BURST2_WMAC_MAX_BL_MASK                                  0x0000000f
+#define DDR_BURST2_WMAC_MAX_BL_GET(x)                                (((x) & DDR_BURST2_WMAC_MAX_BL_MASK) >> DDR_BURST2_WMAC_MAX_BL_LSB)
+#define DDR_BURST2_WMAC_MAX_BL_SET(x)                                (((x) << DDR_BURST2_WMAC_MAX_BL_LSB) & DDR_BURST2_WMAC_MAX_BL_MASK)
+#define DDR_BURST2_WMAC_MAX_BL_RESET                                 0x3 // 3
+#define DDR_BURST2_ADDRESS                                           0x180000c8
+
+#define DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_MSB                         19
+#define DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_LSB                         0
+#define DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_MASK                        0x000fffff
+#define DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_GET(x)                      (((x) & DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_MASK) >> DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_LSB)
+#define DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_SET(x)                      (((x) << DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_LSB) & DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_MASK)
+#define DDR_AHB_MASTER_TIMEOUT_MAX_VALUE_RESET                       0x8000 // 32768
+#define DDR_AHB_MASTER_TIMEOUT_MAX_ADDRESS                           0x180000cc
+
+#define PMU1_ADDRESS                                                 0x18116c40
+
+#define PMU2_SWREGMSB_MSB                                            31
+#define PMU2_SWREGMSB_LSB                                            22
+#define PMU2_SWREGMSB_MASK                                           0xffc00000
+#define PMU2_SWREGMSB_GET(x)                                         (((x) & PMU2_SWREGMSB_MASK) >> PMU2_SWREGMSB_LSB)
+#define PMU2_SWREGMSB_SET(x)                                         (((x) << PMU2_SWREGMSB_LSB) & PMU2_SWREGMSB_MASK)
+#define PMU2_SWREGMSB_RESET                                          0x0 // 0
+#define PMU2_PGM_MSB                                                 21
+#define PMU2_PGM_LSB                                                 21
+#define PMU2_PGM_MASK                                                0x00200000
+#define PMU2_PGM_GET(x)                                              (((x) & PMU2_PGM_MASK) >> PMU2_PGM_LSB)
+#define PMU2_PGM_SET(x)                                              (((x) << PMU2_PGM_LSB) & PMU2_PGM_MASK)
+#define PMU2_PGM_RESET                                               0x0 // 0
+#define PMU2_LDO_TUNE_MSB                                            20
+#define PMU2_LDO_TUNE_LSB                                            19
+#define PMU2_LDO_TUNE_MASK                                           0x00180000
+#define PMU2_LDO_TUNE_GET(x)                                         (((x) & PMU2_LDO_TUNE_MASK) >> PMU2_LDO_TUNE_LSB)
+#define PMU2_LDO_TUNE_SET(x)                                         (((x) << PMU2_LDO_TUNE_LSB) & PMU2_LDO_TUNE_MASK)
+#define PMU2_LDO_TUNE_RESET                                          0x0 // 0
+#define PMU2_PWDLDO_DDR_MSB                                          18
+#define PMU2_PWDLDO_DDR_LSB                                          18
+#define PMU2_PWDLDO_DDR_MASK                                         0x00040000
+#define PMU2_PWDLDO_DDR_GET(x)                                       (((x) & PMU2_PWDLDO_DDR_MASK) >> PMU2_PWDLDO_DDR_LSB)
+#define PMU2_PWDLDO_DDR_SET(x)                                       (((x) << PMU2_PWDLDO_DDR_LSB) & PMU2_PWDLDO_DDR_MASK)
+#define PMU2_PWDLDO_DDR_RESET                                        0x0 // 0
+#define PMU2_LPOPWD_MSB                                              17
+#define PMU2_LPOPWD_LSB                                              17
+#define PMU2_LPOPWD_MASK                                             0x00020000
+#define PMU2_LPOPWD_GET(x)                                           (((x) & PMU2_LPOPWD_MASK) >> PMU2_LPOPWD_LSB)
+#define PMU2_LPOPWD_SET(x)                                           (((x) << PMU2_LPOPWD_LSB) & PMU2_LPOPWD_MASK)
+#define PMU2_LPOPWD_RESET                                            0x0 // 0
+#define PMU2_SPARE_MSB                                               16
+#define PMU2_SPARE_LSB                                               0
+#define PMU2_SPARE_MASK                                              0x0001ffff
+#define PMU2_SPARE_GET(x)                                            (((x) & PMU2_SPARE_MASK) >> PMU2_SPARE_LSB)
+#define PMU2_SPARE_SET(x)                                            (((x) << PMU2_SPARE_LSB) & PMU2_SPARE_MASK)
+#define PMU2_SPARE_RESET                                             0x0 // 0
+#define PMU2_ADDRESS                                                 0x18116c44
+
+#define PHY_CTRL0_LOOPBACK_ERR_CNT_MSB                               31
+#define PHY_CTRL0_LOOPBACK_ERR_CNT_LSB                               24
+#define PHY_CTRL0_LOOPBACK_ERR_CNT_MASK                              0xff000000
+#define PHY_CTRL0_LOOPBACK_ERR_CNT_GET(x)                            (((x) & PHY_CTRL0_LOOPBACK_ERR_CNT_MASK) >> PHY_CTRL0_LOOPBACK_ERR_CNT_LSB)
+#define PHY_CTRL0_LOOPBACK_ERR_CNT_SET(x)                            (((x) << PHY_CTRL0_LOOPBACK_ERR_CNT_LSB) & PHY_CTRL0_LOOPBACK_ERR_CNT_MASK)
+#define PHY_CTRL0_LOOPBACK_ERR_CNT_RESET                             0x0 // 0
+#define PHY_CTRL0_DIG_LOOPBACK_EN_MSB                                23
+#define PHY_CTRL0_DIG_LOOPBACK_EN_LSB                                23
+#define PHY_CTRL0_DIG_LOOPBACK_EN_MASK                               0x00800000
+#define PHY_CTRL0_DIG_LOOPBACK_EN_GET(x)                             (((x) & PHY_CTRL0_DIG_LOOPBACK_EN_MASK) >> PHY_CTRL0_DIG_LOOPBACK_EN_LSB)
+#define PHY_CTRL0_DIG_LOOPBACK_EN_SET(x)                             (((x) << PHY_CTRL0_DIG_LOOPBACK_EN_LSB) & PHY_CTRL0_DIG_LOOPBACK_EN_MASK)
+#define PHY_CTRL0_DIG_LOOPBACK_EN_RESET                              0x0 // 0
+#define PHY_CTRL0_ANA_LOOPBACK_EN_MSB                                22
+#define PHY_CTRL0_ANA_LOOPBACK_EN_LSB                                22
+#define PHY_CTRL0_ANA_LOOPBACK_EN_MASK                               0x00400000
+#define PHY_CTRL0_ANA_LOOPBACK_EN_GET(x)                             (((x) & PHY_CTRL0_ANA_LOOPBACK_EN_MASK) >> PHY_CTRL0_ANA_LOOPBACK_EN_LSB)
+#define PHY_CTRL0_ANA_LOOPBACK_EN_SET(x)                             (((x) << PHY_CTRL0_ANA_LOOPBACK_EN_LSB) & PHY_CTRL0_ANA_LOOPBACK_EN_MASK)
+#define PHY_CTRL0_ANA_LOOPBACK_EN_RESET                              0x0 // 0
+#define PHY_CTRL0_TX_PATTERN_EN_MSB                                  21
+#define PHY_CTRL0_TX_PATTERN_EN_LSB                                  21
+#define PHY_CTRL0_TX_PATTERN_EN_MASK                                 0x00200000
+#define PHY_CTRL0_TX_PATTERN_EN_GET(x)                               (((x) & PHY_CTRL0_TX_PATTERN_EN_MASK) >> PHY_CTRL0_TX_PATTERN_EN_LSB)
+#define PHY_CTRL0_TX_PATTERN_EN_SET(x)                               (((x) << PHY_CTRL0_TX_PATTERN_EN_LSB) & PHY_CTRL0_TX_PATTERN_EN_MASK)
+#define PHY_CTRL0_TX_PATTERN_EN_RESET                                0x0 // 0
+#define PHY_CTRL0_RX_PATTERN_EN_MSB                                  20
+#define PHY_CTRL0_RX_PATTERN_EN_LSB                                  20
+#define PHY_CTRL0_RX_PATTERN_EN_MASK                                 0x00100000
+#define PHY_CTRL0_RX_PATTERN_EN_GET(x)                               (((x) & PHY_CTRL0_RX_PATTERN_EN_MASK) >> PHY_CTRL0_RX_PATTERN_EN_LSB)
+#define PHY_CTRL0_RX_PATTERN_EN_SET(x)                               (((x) << PHY_CTRL0_RX_PATTERN_EN_LSB) & PHY_CTRL0_RX_PATTERN_EN_MASK)
+#define PHY_CTRL0_RX_PATTERN_EN_RESET                                0x0 // 0
+#define PHY_CTRL0_TEST_SPEED_SELECT_MSB                              19
+#define PHY_CTRL0_TEST_SPEED_SELECT_LSB                              19
+#define PHY_CTRL0_TEST_SPEED_SELECT_MASK                             0x00080000
+#define PHY_CTRL0_TEST_SPEED_SELECT_GET(x)                           (((x) & PHY_CTRL0_TEST_SPEED_SELECT_MASK) >> PHY_CTRL0_TEST_SPEED_SELECT_LSB)
+#define PHY_CTRL0_TEST_SPEED_SELECT_SET(x)                           (((x) << PHY_CTRL0_TEST_SPEED_SELECT_LSB) & PHY_CTRL0_TEST_SPEED_SELECT_MASK)
+#define PHY_CTRL0_TEST_SPEED_SELECT_RESET                            0x0 // 0
+#define PHY_CTRL0_PLL_OVERIDE_MSB                                    18
+#define PHY_CTRL0_PLL_OVERIDE_LSB                                    18
+#define PHY_CTRL0_PLL_OVERIDE_MASK                                   0x00040000
+#define PHY_CTRL0_PLL_OVERIDE_GET(x)                                 (((x) & PHY_CTRL0_PLL_OVERIDE_MASK) >> PHY_CTRL0_PLL_OVERIDE_LSB)
+#define PHY_CTRL0_PLL_OVERIDE_SET(x)                                 (((x) << PHY_CTRL0_PLL_OVERIDE_LSB) & PHY_CTRL0_PLL_OVERIDE_MASK)
+#define PHY_CTRL0_PLL_OVERIDE_RESET                                  0x0 // 0
+#define PHY_CTRL0_PLL_MOD_MSB                                        17
+#define PHY_CTRL0_PLL_MOD_LSB                                        15
+#define PHY_CTRL0_PLL_MOD_MASK                                       0x00038000
+#define PHY_CTRL0_PLL_MOD_GET(x)                                     (((x) & PHY_CTRL0_PLL_MOD_MASK) >> PHY_CTRL0_PLL_MOD_LSB)
+#define PHY_CTRL0_PLL_MOD_SET(x)                                     (((x) << PHY_CTRL0_PLL_MOD_LSB) & PHY_CTRL0_PLL_MOD_MASK)
+#define PHY_CTRL0_PLL_MOD_RESET                                      0x0 // 0
+#define PHY_CTRL0_PLL_DIV_MSB                                        14
+#define PHY_CTRL0_PLL_DIV_LSB                                        6
+#define PHY_CTRL0_PLL_DIV_MASK                                       0x00007fc0
+#define PHY_CTRL0_PLL_DIV_GET(x)                                     (((x) & PHY_CTRL0_PLL_DIV_MASK) >> PHY_CTRL0_PLL_DIV_LSB)
+#define PHY_CTRL0_PLL_DIV_SET(x)                                     (((x) << PHY_CTRL0_PLL_DIV_LSB) & PHY_CTRL0_PLL_DIV_MASK)
+#define PHY_CTRL0_PLL_DIV_RESET                                      0x0 // 0
+#define PHY_CTRL0_PLL_RS_MSB                                         5
+#define PHY_CTRL0_PLL_RS_LSB                                         3
+#define PHY_CTRL0_PLL_RS_MASK                                        0x00000038
+#define PHY_CTRL0_PLL_RS_GET(x)                                      (((x) & PHY_CTRL0_PLL_RS_MASK) >> PHY_CTRL0_PLL_RS_LSB)
+#define PHY_CTRL0_PLL_RS_SET(x)                                      (((x) << PHY_CTRL0_PLL_RS_LSB) & PHY_CTRL0_PLL_RS_MASK)
+#define PHY_CTRL0_PLL_RS_RESET                                       0x2 // 2
+#define PHY_CTRL0_PLL_ICP_MSB                                        2
+#define PHY_CTRL0_PLL_ICP_LSB                                        0
+#define PHY_CTRL0_PLL_ICP_MASK                                       0x00000007
+#define PHY_CTRL0_PLL_ICP_GET(x)                                     (((x) & PHY_CTRL0_PLL_ICP_MASK) >> PHY_CTRL0_PLL_ICP_LSB)
+#define PHY_CTRL0_PLL_ICP_SET(x)                                     (((x) << PHY_CTRL0_PLL_ICP_LSB) & PHY_CTRL0_PLL_ICP_MASK)
+#define PHY_CTRL0_PLL_ICP_RESET                                      0x5 // 5
+#define PHY_CTRL0_ADDRESS                                            0x18116c80
+#define PHY_CTRL0_OFFSET                                             0x0000
+// SW modifiable bits
+#define PHY_CTRL0_SW_MASK                                            0xffffffff
+// bits defined at reset
+#define PHY_CTRL0_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL0_RESET                                              0x00000015
+
+#define PHY_CTRL1_PLL_OBS_MODE_N_MSB                                 31
+#define PHY_CTRL1_PLL_OBS_MODE_N_LSB                                 31
+#define PHY_CTRL1_PLL_OBS_MODE_N_MASK                                0x80000000
+#define PHY_CTRL1_PLL_OBS_MODE_N_GET(x)                              (((x) & PHY_CTRL1_PLL_OBS_MODE_N_MASK) >> PHY_CTRL1_PLL_OBS_MODE_N_LSB)
+#define PHY_CTRL1_PLL_OBS_MODE_N_SET(x)                              (((x) << PHY_CTRL1_PLL_OBS_MODE_N_LSB) & PHY_CTRL1_PLL_OBS_MODE_N_MASK)
+#define PHY_CTRL1_PLL_OBS_MODE_N_RESET                               0x1 // 1
+#define PHY_CTRL1_DISABLE_CLK_GATING_MSB                             27
+#define PHY_CTRL1_DISABLE_CLK_GATING_LSB                             27
+#define PHY_CTRL1_DISABLE_CLK_GATING_MASK                            0x08000000
+#define PHY_CTRL1_DISABLE_CLK_GATING_GET(x)                          (((x) & PHY_CTRL1_DISABLE_CLK_GATING_MASK) >> PHY_CTRL1_DISABLE_CLK_GATING_LSB)
+#define PHY_CTRL1_DISABLE_CLK_GATING_SET(x)                          (((x) << PHY_CTRL1_DISABLE_CLK_GATING_LSB) & PHY_CTRL1_DISABLE_CLK_GATING_MASK)
+#define PHY_CTRL1_DISABLE_CLK_GATING_RESET                           0x0 // 0
+#define PHY_CTRL1_ENABLE_REFCLK_GATE_MSB                             26
+#define PHY_CTRL1_ENABLE_REFCLK_GATE_LSB                             26
+#define PHY_CTRL1_ENABLE_REFCLK_GATE_MASK                            0x04000000
+#define PHY_CTRL1_ENABLE_REFCLK_GATE_GET(x)                          (((x) & PHY_CTRL1_ENABLE_REFCLK_GATE_MASK) >> PHY_CTRL1_ENABLE_REFCLK_GATE_LSB)
+#define PHY_CTRL1_ENABLE_REFCLK_GATE_SET(x)                          (((x) << PHY_CTRL1_ENABLE_REFCLK_GATE_LSB) & PHY_CTRL1_ENABLE_REFCLK_GATE_MASK)
+#define PHY_CTRL1_ENABLE_REFCLK_GATE_RESET                           0x1 // 1
+#define PHY_CTRL1_CLKOBS_SEL_MSB                                     25
+#define PHY_CTRL1_CLKOBS_SEL_LSB                                     23
+#define PHY_CTRL1_CLKOBS_SEL_MASK                                    0x03800000
+#define PHY_CTRL1_CLKOBS_SEL_GET(x)                                  (((x) & PHY_CTRL1_CLKOBS_SEL_MASK) >> PHY_CTRL1_CLKOBS_SEL_LSB)
+#define PHY_CTRL1_CLKOBS_SEL_SET(x)                                  (((x) << PHY_CTRL1_CLKOBS_SEL_LSB) & PHY_CTRL1_CLKOBS_SEL_MASK)
+#define PHY_CTRL1_CLKOBS_SEL_RESET                                   0x0 // 0
+#define PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_MSB                           22
+#define PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_LSB                           21
+#define PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_MASK                          0x00600000
+#define PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_GET(x)                        (((x) & PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_MASK) >> PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_LSB)
+#define PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_SET(x)                        (((x) << PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_LSB) & PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_MASK)
+#define PHY_CTRL1_USE_PLL_LOCK_DLY_SEL_RESET                         0x3 // 3
+#define PHY_CTRL1_USE_PLL_LOCKDETECT_MSB                             20
+#define PHY_CTRL1_USE_PLL_LOCKDETECT_LSB                             20
+#define PHY_CTRL1_USE_PLL_LOCKDETECT_MASK                            0x00100000
+#define PHY_CTRL1_USE_PLL_LOCKDETECT_GET(x)                          (((x) & PHY_CTRL1_USE_PLL_LOCKDETECT_MASK) >> PHY_CTRL1_USE_PLL_LOCKDETECT_LSB)
+#define PHY_CTRL1_USE_PLL_LOCKDETECT_SET(x)                          (((x) << PHY_CTRL1_USE_PLL_LOCKDETECT_LSB) & PHY_CTRL1_USE_PLL_LOCKDETECT_MASK)
+#define PHY_CTRL1_USE_PLL_LOCKDETECT_RESET                           0x0 // 0
+#define PHY_CTRL1_TX_PATTERN_SEL_MSB                                 19
+#define PHY_CTRL1_TX_PATTERN_SEL_LSB                                 18
+#define PHY_CTRL1_TX_PATTERN_SEL_MASK                                0x000c0000
+#define PHY_CTRL1_TX_PATTERN_SEL_GET(x)                              (((x) & PHY_CTRL1_TX_PATTERN_SEL_MASK) >> PHY_CTRL1_TX_PATTERN_SEL_LSB)
+#define PHY_CTRL1_TX_PATTERN_SEL_SET(x)                              (((x) << PHY_CTRL1_TX_PATTERN_SEL_LSB) & PHY_CTRL1_TX_PATTERN_SEL_MASK)
+#define PHY_CTRL1_TX_PATTERN_SEL_RESET                               0x0 // 0
+#define PHY_CTRL1_FORCE_SUSPEND_MSB                                  13
+#define PHY_CTRL1_FORCE_SUSPEND_LSB                                  13
+#define PHY_CTRL1_FORCE_SUSPEND_MASK                                 0x00002000
+#define PHY_CTRL1_FORCE_SUSPEND_GET(x)                               (((x) & PHY_CTRL1_FORCE_SUSPEND_MASK) >> PHY_CTRL1_FORCE_SUSPEND_LSB)
+#define PHY_CTRL1_FORCE_SUSPEND_SET(x)                               (((x) << PHY_CTRL1_FORCE_SUSPEND_LSB) & PHY_CTRL1_FORCE_SUSPEND_MASK)
+#define PHY_CTRL1_FORCE_SUSPEND_RESET                                0x0 // 0
+#define PHY_CTRL1_NO_PLL_PWD_MSB                                     12
+#define PHY_CTRL1_NO_PLL_PWD_LSB                                     12
+#define PHY_CTRL1_NO_PLL_PWD_MASK                                    0x00001000
+#define PHY_CTRL1_NO_PLL_PWD_GET(x)                                  (((x) & PHY_CTRL1_NO_PLL_PWD_MASK) >> PHY_CTRL1_NO_PLL_PWD_LSB)
+#define PHY_CTRL1_NO_PLL_PWD_SET(x)                                  (((x) << PHY_CTRL1_NO_PLL_PWD_LSB) & PHY_CTRL1_NO_PLL_PWD_MASK)
+#define PHY_CTRL1_NO_PLL_PWD_RESET                                   0x0 // 0
+#define PHY_CTRL1_RX_RSVD_MSB                                        11
+#define PHY_CTRL1_RX_RSVD_LSB                                        9
+#define PHY_CTRL1_RX_RSVD_MASK                                       0x00000e00
+#define PHY_CTRL1_RX_RSVD_GET(x)                                     (((x) & PHY_CTRL1_RX_RSVD_MASK) >> PHY_CTRL1_RX_RSVD_LSB)
+#define PHY_CTRL1_RX_RSVD_SET(x)                                     (((x) << PHY_CTRL1_RX_RSVD_LSB) & PHY_CTRL1_RX_RSVD_MASK)
+#define PHY_CTRL1_RX_RSVD_RESET                                      0x0 // 0
+#define PHY_CTRL1_RX_SELVREF0P25_MSB                                 8
+#define PHY_CTRL1_RX_SELVREF0P25_LSB                                 8
+#define PHY_CTRL1_RX_SELVREF0P25_MASK                                0x00000100
+#define PHY_CTRL1_RX_SELVREF0P25_GET(x)                              (((x) & PHY_CTRL1_RX_SELVREF0P25_MASK) >> PHY_CTRL1_RX_SELVREF0P25_LSB)
+#define PHY_CTRL1_RX_SELVREF0P25_SET(x)                              (((x) << PHY_CTRL1_RX_SELVREF0P25_LSB) & PHY_CTRL1_RX_SELVREF0P25_MASK)
+#define PHY_CTRL1_RX_SELVREF0P25_RESET                               0x0 // 0
+#define PHY_CTRL1_RX_SELVREF0P6_MSB                                  7
+#define PHY_CTRL1_RX_SELVREF0P6_LSB                                  7
+#define PHY_CTRL1_RX_SELVREF0P6_MASK                                 0x00000080
+#define PHY_CTRL1_RX_SELVREF0P6_GET(x)                               (((x) & PHY_CTRL1_RX_SELVREF0P6_MASK) >> PHY_CTRL1_RX_SELVREF0P6_LSB)
+#define PHY_CTRL1_RX_SELVREF0P6_SET(x)                               (((x) << PHY_CTRL1_RX_SELVREF0P6_LSB) & PHY_CTRL1_RX_SELVREF0P6_MASK)
+#define PHY_CTRL1_RX_SELVREF0P6_RESET                                0x1 // 1
+#define PHY_CTRL1_RX_SELIR_100M_MSB                                  6
+#define PHY_CTRL1_RX_SELIR_100M_LSB                                  5
+#define PHY_CTRL1_RX_SELIR_100M_MASK                                 0x00000060
+#define PHY_CTRL1_RX_SELIR_100M_GET(x)                               (((x) & PHY_CTRL1_RX_SELIR_100M_MASK) >> PHY_CTRL1_RX_SELIR_100M_LSB)
+#define PHY_CTRL1_RX_SELIR_100M_SET(x)                               (((x) << PHY_CTRL1_RX_SELIR_100M_LSB) & PHY_CTRL1_RX_SELIR_100M_MASK)
+#define PHY_CTRL1_RX_SELIR_100M_RESET                                0x0 // 0
+#define PHY_CTRL1_RX_LOWR_PDET_MSB                                   4
+#define PHY_CTRL1_RX_LOWR_PDET_LSB                                   4
+#define PHY_CTRL1_RX_LOWR_PDET_MASK                                  0x00000010
+#define PHY_CTRL1_RX_LOWR_PDET_GET(x)                                (((x) & PHY_CTRL1_RX_LOWR_PDET_MASK) >> PHY_CTRL1_RX_LOWR_PDET_LSB)
+#define PHY_CTRL1_RX_LOWR_PDET_SET(x)                                (((x) << PHY_CTRL1_RX_LOWR_PDET_LSB) & PHY_CTRL1_RX_LOWR_PDET_MASK)
+#define PHY_CTRL1_RX_LOWR_PDET_RESET                                 0x1 // 1
+#define PHY_CTRL1_RX_BYPASSEQ_MSB                                    3
+#define PHY_CTRL1_RX_BYPASSEQ_LSB                                    3
+#define PHY_CTRL1_RX_BYPASSEQ_MASK                                   0x00000008
+#define PHY_CTRL1_RX_BYPASSEQ_GET(x)                                 (((x) & PHY_CTRL1_RX_BYPASSEQ_MASK) >> PHY_CTRL1_RX_BYPASSEQ_LSB)
+#define PHY_CTRL1_RX_BYPASSEQ_SET(x)                                 (((x) << PHY_CTRL1_RX_BYPASSEQ_LSB) & PHY_CTRL1_RX_BYPASSEQ_MASK)
+#define PHY_CTRL1_RX_BYPASSEQ_RESET                                  0x0 // 0
+#define PHY_CTRL1_RX_FORCERXON_MSB                                   2
+#define PHY_CTRL1_RX_FORCERXON_LSB                                   2
+#define PHY_CTRL1_RX_FORCERXON_MASK                                  0x00000004
+#define PHY_CTRL1_RX_FORCERXON_GET(x)                                (((x) & PHY_CTRL1_RX_FORCERXON_MASK) >> PHY_CTRL1_RX_FORCERXON_LSB)
+#define PHY_CTRL1_RX_FORCERXON_SET(x)                                (((x) << PHY_CTRL1_RX_FORCERXON_LSB) & PHY_CTRL1_RX_FORCERXON_MASK)
+#define PHY_CTRL1_RX_FORCERXON_RESET                                 0x1 // 1
+#define PHY_CTRL1_RX_FILBW_SEL_MSB                                   1
+#define PHY_CTRL1_RX_FILBW_SEL_LSB                                   0
+#define PHY_CTRL1_RX_FILBW_SEL_MASK                                  0x00000003
+#define PHY_CTRL1_RX_FILBW_SEL_GET(x)                                (((x) & PHY_CTRL1_RX_FILBW_SEL_MASK) >> PHY_CTRL1_RX_FILBW_SEL_LSB)
+#define PHY_CTRL1_RX_FILBW_SEL_SET(x)                                (((x) << PHY_CTRL1_RX_FILBW_SEL_LSB) & PHY_CTRL1_RX_FILBW_SEL_MASK)
+#define PHY_CTRL1_RX_FILBW_SEL_RESET                                 0x1 // 1
+#define PHY_CTRL1_ADDRESS                                            0x18116c84
+#define PHY_CTRL1_OFFSET                                             0x0004
+// SW modifiable bits
+#define PHY_CTRL1_SW_MASK                                            0x8ffc3fff
+// bits defined at reset
+#define PHY_CTRL1_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL1_RESET                                              0x84600095
+
+#define PHY_CTRL2_PWD_EXTBIAS_MSB                                    31
+#define PHY_CTRL2_PWD_EXTBIAS_LSB                                    31
+#define PHY_CTRL2_PWD_EXTBIAS_MASK                                   0x80000000
+#define PHY_CTRL2_PWD_EXTBIAS_GET(x)                                 (((x) & PHY_CTRL2_PWD_EXTBIAS_MASK) >> PHY_CTRL2_PWD_EXTBIAS_LSB)
+#define PHY_CTRL2_PWD_EXTBIAS_SET(x)                                 (((x) << PHY_CTRL2_PWD_EXTBIAS_LSB) & PHY_CTRL2_PWD_EXTBIAS_MASK)
+#define PHY_CTRL2_PWD_EXTBIAS_RESET                                  0x0 // 0
+#define PHY_CTRL2_TX_RSVD_MSB                                        30
+#define PHY_CTRL2_TX_RSVD_LSB                                        27
+#define PHY_CTRL2_TX_RSVD_MASK                                       0x78000000
+#define PHY_CTRL2_TX_RSVD_GET(x)                                     (((x) & PHY_CTRL2_TX_RSVD_MASK) >> PHY_CTRL2_TX_RSVD_LSB)
+#define PHY_CTRL2_TX_RSVD_SET(x)                                     (((x) << PHY_CTRL2_TX_RSVD_LSB) & PHY_CTRL2_TX_RSVD_MASK)
+#define PHY_CTRL2_TX_RSVD_RESET                                      0x0 // 0
+#define PHY_CTRL2_TX_LCKDET_OVR_MSB                                  26
+#define PHY_CTRL2_TX_LCKDET_OVR_LSB                                  26
+#define PHY_CTRL2_TX_LCKDET_OVR_MASK                                 0x04000000
+#define PHY_CTRL2_TX_LCKDET_OVR_GET(x)                               (((x) & PHY_CTRL2_TX_LCKDET_OVR_MASK) >> PHY_CTRL2_TX_LCKDET_OVR_LSB)
+#define PHY_CTRL2_TX_LCKDET_OVR_SET(x)                               (((x) << PHY_CTRL2_TX_LCKDET_OVR_LSB) & PHY_CTRL2_TX_LCKDET_OVR_MASK)
+#define PHY_CTRL2_TX_LCKDET_OVR_RESET                                0x0 // 0
+#define PHY_CTRL2_TX_MAN_CAL_MSB                                     25
+#define PHY_CTRL2_TX_MAN_CAL_LSB                                     22
+#define PHY_CTRL2_TX_MAN_CAL_MASK                                    0x03c00000
+#define PHY_CTRL2_TX_MAN_CAL_GET(x)                                  (((x) & PHY_CTRL2_TX_MAN_CAL_MASK) >> PHY_CTRL2_TX_MAN_CAL_LSB)
+#define PHY_CTRL2_TX_MAN_CAL_SET(x)                                  (((x) << PHY_CTRL2_TX_MAN_CAL_LSB) & PHY_CTRL2_TX_MAN_CAL_MASK)
+#define PHY_CTRL2_TX_MAN_CAL_RESET                                   0x3 // 3
+#define PHY_CTRL2_TX_CAL_SEL_MSB                                     21
+#define PHY_CTRL2_TX_CAL_SEL_LSB                                     21
+#define PHY_CTRL2_TX_CAL_SEL_MASK                                    0x00200000
+#define PHY_CTRL2_TX_CAL_SEL_GET(x)                                  (((x) & PHY_CTRL2_TX_CAL_SEL_MASK) >> PHY_CTRL2_TX_CAL_SEL_LSB)
+#define PHY_CTRL2_TX_CAL_SEL_SET(x)                                  (((x) << PHY_CTRL2_TX_CAL_SEL_LSB) & PHY_CTRL2_TX_CAL_SEL_MASK)
+#define PHY_CTRL2_TX_CAL_SEL_RESET                                   0x1 // 1
+#define PHY_CTRL2_TX_CAL_EN_MSB                                      20
+#define PHY_CTRL2_TX_CAL_EN_LSB                                      20
+#define PHY_CTRL2_TX_CAL_EN_MASK                                     0x00100000
+#define PHY_CTRL2_TX_CAL_EN_GET(x)                                   (((x) & PHY_CTRL2_TX_CAL_EN_MASK) >> PHY_CTRL2_TX_CAL_EN_LSB)
+#define PHY_CTRL2_TX_CAL_EN_SET(x)                                   (((x) << PHY_CTRL2_TX_CAL_EN_LSB) & PHY_CTRL2_TX_CAL_EN_MASK)
+#define PHY_CTRL2_TX_CAL_EN_RESET                                    0x1 // 1
+#define PHY_CTRL2_PWD_ISP_MSB                                        13
+#define PHY_CTRL2_PWD_ISP_LSB                                        8
+#define PHY_CTRL2_PWD_ISP_MASK                                       0x00003f00
+#define PHY_CTRL2_PWD_ISP_GET(x)                                     (((x) & PHY_CTRL2_PWD_ISP_MASK) >> PHY_CTRL2_PWD_ISP_LSB)
+#define PHY_CTRL2_PWD_ISP_SET(x)                                     (((x) << PHY_CTRL2_PWD_ISP_LSB) & PHY_CTRL2_PWD_ISP_MASK)
+#define PHY_CTRL2_PWD_ISP_RESET                                      0x1b // 27
+#define PHY_CTRL2_PWD_IPLL_MSB                                       7
+#define PHY_CTRL2_PWD_IPLL_LSB                                       2
+#define PHY_CTRL2_PWD_IPLL_MASK                                      0x000000fc
+#define PHY_CTRL2_PWD_IPLL_GET(x)                                    (((x) & PHY_CTRL2_PWD_IPLL_MASK) >> PHY_CTRL2_PWD_IPLL_LSB)
+#define PHY_CTRL2_PWD_IPLL_SET(x)                                    (((x) << PHY_CTRL2_PWD_IPLL_LSB) & PHY_CTRL2_PWD_IPLL_MASK)
+#define PHY_CTRL2_PWD_IPLL_RESET                                     0x1b // 27
+#define PHY_CTRL2_HSRXPHASE_PS_EN_MSB                                1
+#define PHY_CTRL2_HSRXPHASE_PS_EN_LSB                                1
+#define PHY_CTRL2_HSRXPHASE_PS_EN_MASK                               0x00000002
+#define PHY_CTRL2_HSRXPHASE_PS_EN_GET(x)                             (((x) & PHY_CTRL2_HSRXPHASE_PS_EN_MASK) >> PHY_CTRL2_HSRXPHASE_PS_EN_LSB)
+#define PHY_CTRL2_HSRXPHASE_PS_EN_SET(x)                             (((x) << PHY_CTRL2_HSRXPHASE_PS_EN_LSB) & PHY_CTRL2_HSRXPHASE_PS_EN_MASK)
+#define PHY_CTRL2_HSRXPHASE_PS_EN_RESET                              0x0 // 0
+#define PHY_CTRL2_HSTXBIAS_PS_EN_MSB                                 0
+#define PHY_CTRL2_HSTXBIAS_PS_EN_LSB                                 0
+#define PHY_CTRL2_HSTXBIAS_PS_EN_MASK                                0x00000001
+#define PHY_CTRL2_HSTXBIAS_PS_EN_GET(x)                              (((x) & PHY_CTRL2_HSTXBIAS_PS_EN_MASK) >> PHY_CTRL2_HSTXBIAS_PS_EN_LSB)
+#define PHY_CTRL2_HSTXBIAS_PS_EN_SET(x)                              (((x) << PHY_CTRL2_HSTXBIAS_PS_EN_LSB) & PHY_CTRL2_HSTXBIAS_PS_EN_MASK)
+#define PHY_CTRL2_HSTXBIAS_PS_EN_RESET                               0x0 // 0
+#define PHY_CTRL2_ADDRESS                                            0x18116c88
+#define PHY_CTRL2_OFFSET                                             0x0008
+// SW modifiable bits
+#define PHY_CTRL2_SW_MASK                                            0xfff03fff
+// bits defined at reset
+#define PHY_CTRL2_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL2_RESET                                              0x00f01b6c
+
+#define PHY_CTRL3_SPARE_BITS_MSB                                     31
+#define PHY_CTRL3_SPARE_BITS_LSB                                     27
+#define PHY_CTRL3_SPARE_BITS_MASK                                    0xf8000000
+#define PHY_CTRL3_SPARE_BITS_GET(x)                                  (((x) & PHY_CTRL3_SPARE_BITS_MASK) >> PHY_CTRL3_SPARE_BITS_LSB)
+#define PHY_CTRL3_SPARE_BITS_SET(x)                                  (((x) << PHY_CTRL3_SPARE_BITS_LSB) & PHY_CTRL3_SPARE_BITS_MASK)
+#define PHY_CTRL3_SPARE_BITS_RESET                                   0x0 // 0
+#define PHY_CTRL3_SUS_RES_FIX_DIS_MSB                                26
+#define PHY_CTRL3_SUS_RES_FIX_DIS_LSB                                26
+#define PHY_CTRL3_SUS_RES_FIX_DIS_MASK                               0x04000000
+#define PHY_CTRL3_SUS_RES_FIX_DIS_GET(x)                             (((x) & PHY_CTRL3_SUS_RES_FIX_DIS_MASK) >> PHY_CTRL3_SUS_RES_FIX_DIS_LSB)
+#define PHY_CTRL3_SUS_RES_FIX_DIS_SET(x)                             (((x) << PHY_CTRL3_SUS_RES_FIX_DIS_LSB) & PHY_CTRL3_SUS_RES_FIX_DIS_MASK)
+#define PHY_CTRL3_SUS_RES_FIX_DIS_RESET                              0x0 // 0
+#define PHY_CTRL3_TX_STARTCAL_MSB                                    25
+#define PHY_CTRL3_TX_STARTCAL_LSB                                    25
+#define PHY_CTRL3_TX_STARTCAL_MASK                                   0x02000000
+#define PHY_CTRL3_TX_STARTCAL_GET(x)                                 (((x) & PHY_CTRL3_TX_STARTCAL_MASK) >> PHY_CTRL3_TX_STARTCAL_LSB)
+#define PHY_CTRL3_TX_STARTCAL_SET(x)                                 (((x) << PHY_CTRL3_TX_STARTCAL_LSB) & PHY_CTRL3_TX_STARTCAL_MASK)
+#define PHY_CTRL3_TX_STARTCAL_RESET                                  0x0 // 0
+#define PHY_CTRL3_TX_SELTEST_MSB                                     24
+#define PHY_CTRL3_TX_SELTEST_LSB                                     22
+#define PHY_CTRL3_TX_SELTEST_MASK                                    0x01c00000
+#define PHY_CTRL3_TX_SELTEST_GET(x)                                  (((x) & PHY_CTRL3_TX_SELTEST_MASK) >> PHY_CTRL3_TX_SELTEST_LSB)
+#define PHY_CTRL3_TX_SELTEST_SET(x)                                  (((x) << PHY_CTRL3_TX_SELTEST_LSB) & PHY_CTRL3_TX_SELTEST_MASK)
+#define PHY_CTRL3_TX_SELTEST_RESET                                   0x0 // 0
+#define PHY_CTRL3_TX_DISABLE_SHORT_DET_MSB                           21
+#define PHY_CTRL3_TX_DISABLE_SHORT_DET_LSB                           21
+#define PHY_CTRL3_TX_DISABLE_SHORT_DET_MASK                          0x00200000
+#define PHY_CTRL3_TX_DISABLE_SHORT_DET_GET(x)                        (((x) & PHY_CTRL3_TX_DISABLE_SHORT_DET_MASK) >> PHY_CTRL3_TX_DISABLE_SHORT_DET_LSB)
+#define PHY_CTRL3_TX_DISABLE_SHORT_DET_SET(x)                        (((x) << PHY_CTRL3_TX_DISABLE_SHORT_DET_LSB) & PHY_CTRL3_TX_DISABLE_SHORT_DET_MASK)
+#define PHY_CTRL3_TX_DISABLE_SHORT_DET_RESET                         0x0 // 0
+#define PHY_CTRL3_PWD_ITX_MSB                                        18
+#define PHY_CTRL3_PWD_ITX_LSB                                        0
+#define PHY_CTRL3_PWD_ITX_MASK                                       0x0007ffff
+#define PHY_CTRL3_PWD_ITX_GET(x)                                     (((x) & PHY_CTRL3_PWD_ITX_MASK) >> PHY_CTRL3_PWD_ITX_LSB)
+#define PHY_CTRL3_PWD_ITX_SET(x)                                     (((x) << PHY_CTRL3_PWD_ITX_LSB) & PHY_CTRL3_PWD_ITX_MASK)
+#define PHY_CTRL3_PWD_ITX_RESET                                      0x14765 // 83813
+#define PHY_CTRL3_ADDRESS                                            0x18116c8c
+#define PHY_CTRL3_OFFSET                                             0x000c
+// SW modifiable bits
+#define PHY_CTRL3_SW_MASK                                            0xffe7ffff
+// bits defined at reset
+#define PHY_CTRL3_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL3_RESET                                              0x00014765
+
+#define PHY_CTRL4_PPRBS_ERR_CNT_MSB                                  31
+#define PHY_CTRL4_PPRBS_ERR_CNT_LSB                                  24
+#define PHY_CTRL4_PPRBS_ERR_CNT_MASK                                 0xff000000
+#define PHY_CTRL4_PPRBS_ERR_CNT_GET(x)                               (((x) & PHY_CTRL4_PPRBS_ERR_CNT_MASK) >> PHY_CTRL4_PPRBS_ERR_CNT_LSB)
+#define PHY_CTRL4_PPRBS_ERR_CNT_SET(x)                               (((x) << PHY_CTRL4_PPRBS_ERR_CNT_LSB) & PHY_CTRL4_PPRBS_ERR_CNT_MASK)
+#define PHY_CTRL4_PPRBS_ERR_CNT_RESET                                0x0 // 0
+#define PHY_CTRL4_LS_PRBS_EN_MSB                                     21
+#define PHY_CTRL4_LS_PRBS_EN_LSB                                     21
+#define PHY_CTRL4_LS_PRBS_EN_MASK                                    0x00200000
+#define PHY_CTRL4_LS_PRBS_EN_GET(x)                                  (((x) & PHY_CTRL4_LS_PRBS_EN_MASK) >> PHY_CTRL4_LS_PRBS_EN_LSB)
+#define PHY_CTRL4_LS_PRBS_EN_SET(x)                                  (((x) << PHY_CTRL4_LS_PRBS_EN_LSB) & PHY_CTRL4_LS_PRBS_EN_MASK)
+#define PHY_CTRL4_LS_PRBS_EN_RESET                                   0x0 // 0
+#define PHY_CTRL4_PPRBS_TERM_SEL_MSB                                 20
+#define PHY_CTRL4_PPRBS_TERM_SEL_LSB                                 20
+#define PHY_CTRL4_PPRBS_TERM_SEL_MASK                                0x00100000
+#define PHY_CTRL4_PPRBS_TERM_SEL_GET(x)                              (((x) & PHY_CTRL4_PPRBS_TERM_SEL_MASK) >> PHY_CTRL4_PPRBS_TERM_SEL_LSB)
+#define PHY_CTRL4_PPRBS_TERM_SEL_SET(x)                              (((x) << PHY_CTRL4_PPRBS_TERM_SEL_LSB) & PHY_CTRL4_PPRBS_TERM_SEL_MASK)
+#define PHY_CTRL4_PPRBS_TERM_SEL_RESET                               0x0 // 0
+#define PHY_CTRL4_PPRBS_DIG_LPBK_EN_MSB                              19
+#define PHY_CTRL4_PPRBS_DIG_LPBK_EN_LSB                              19
+#define PHY_CTRL4_PPRBS_DIG_LPBK_EN_MASK                             0x00080000
+#define PHY_CTRL4_PPRBS_DIG_LPBK_EN_GET(x)                           (((x) & PHY_CTRL4_PPRBS_DIG_LPBK_EN_MASK) >> PHY_CTRL4_PPRBS_DIG_LPBK_EN_LSB)
+#define PHY_CTRL4_PPRBS_DIG_LPBK_EN_SET(x)                           (((x) << PHY_CTRL4_PPRBS_DIG_LPBK_EN_LSB) & PHY_CTRL4_PPRBS_DIG_LPBK_EN_MASK)
+#define PHY_CTRL4_PPRBS_DIG_LPBK_EN_RESET                            0x0 // 0
+#define PHY_CTRL4_PPRBS_ANA_LPBK_EN_MSB                              18
+#define PHY_CTRL4_PPRBS_ANA_LPBK_EN_LSB                              18
+#define PHY_CTRL4_PPRBS_ANA_LPBK_EN_MASK                             0x00040000
+#define PHY_CTRL4_PPRBS_ANA_LPBK_EN_GET(x)                           (((x) & PHY_CTRL4_PPRBS_ANA_LPBK_EN_MASK) >> PHY_CTRL4_PPRBS_ANA_LPBK_EN_LSB)
+#define PHY_CTRL4_PPRBS_ANA_LPBK_EN_SET(x)                           (((x) << PHY_CTRL4_PPRBS_ANA_LPBK_EN_LSB) & PHY_CTRL4_PPRBS_ANA_LPBK_EN_MASK)
+#define PHY_CTRL4_PPRBS_ANA_LPBK_EN_RESET                            0x0 // 0
+#define PHY_CTRL4_PPRBS_PAT_SEL_MSB                                  17
+#define PHY_CTRL4_PPRBS_PAT_SEL_LSB                                  16
+#define PHY_CTRL4_PPRBS_PAT_SEL_MASK                                 0x00030000
+#define PHY_CTRL4_PPRBS_PAT_SEL_GET(x)                               (((x) & PHY_CTRL4_PPRBS_PAT_SEL_MASK) >> PHY_CTRL4_PPRBS_PAT_SEL_LSB)
+#define PHY_CTRL4_PPRBS_PAT_SEL_SET(x)                               (((x) << PHY_CTRL4_PPRBS_PAT_SEL_LSB) & PHY_CTRL4_PPRBS_PAT_SEL_MASK)
+#define PHY_CTRL4_PPRBS_PAT_SEL_RESET                                0x0 // 0
+#define PHY_CTRL4_PPRBS_TX_EN_MSB                                    15
+#define PHY_CTRL4_PPRBS_TX_EN_LSB                                    15
+#define PHY_CTRL4_PPRBS_TX_EN_MASK                                   0x00008000
+#define PHY_CTRL4_PPRBS_TX_EN_GET(x)                                 (((x) & PHY_CTRL4_PPRBS_TX_EN_MASK) >> PHY_CTRL4_PPRBS_TX_EN_LSB)
+#define PHY_CTRL4_PPRBS_TX_EN_SET(x)                                 (((x) << PHY_CTRL4_PPRBS_TX_EN_LSB) & PHY_CTRL4_PPRBS_TX_EN_MASK)
+#define PHY_CTRL4_PPRBS_TX_EN_RESET                                  0x0 // 0
+#define PHY_CTRL4_PPRBS_RX_EN_MSB                                    14
+#define PHY_CTRL4_PPRBS_RX_EN_LSB                                    14
+#define PHY_CTRL4_PPRBS_RX_EN_MASK                                   0x00004000
+#define PHY_CTRL4_PPRBS_RX_EN_GET(x)                                 (((x) & PHY_CTRL4_PPRBS_RX_EN_MASK) >> PHY_CTRL4_PPRBS_RX_EN_LSB)
+#define PHY_CTRL4_PPRBS_RX_EN_SET(x)                                 (((x) << PHY_CTRL4_PPRBS_RX_EN_LSB) & PHY_CTRL4_PPRBS_RX_EN_MASK)
+#define PHY_CTRL4_PPRBS_RX_EN_RESET                                  0x0 // 0
+#define PHY_CTRL4_PPRBS_SPEED_SEL_MSB                                13
+#define PHY_CTRL4_PPRBS_SPEED_SEL_LSB                                13
+#define PHY_CTRL4_PPRBS_SPEED_SEL_MASK                               0x00002000
+#define PHY_CTRL4_PPRBS_SPEED_SEL_GET(x)                             (((x) & PHY_CTRL4_PPRBS_SPEED_SEL_MASK) >> PHY_CTRL4_PPRBS_SPEED_SEL_LSB)
+#define PHY_CTRL4_PPRBS_SPEED_SEL_SET(x)                             (((x) << PHY_CTRL4_PPRBS_SPEED_SEL_LSB) & PHY_CTRL4_PPRBS_SPEED_SEL_MASK)
+#define PHY_CTRL4_PPRBS_SPEED_SEL_RESET                              0x0 // 0
+#define PHY_CTRL4_PPRBS_RX_INV_MSB                                   12
+#define PHY_CTRL4_PPRBS_RX_INV_LSB                                   12
+#define PHY_CTRL4_PPRBS_RX_INV_MASK                                  0x00001000
+#define PHY_CTRL4_PPRBS_RX_INV_GET(x)                                (((x) & PHY_CTRL4_PPRBS_RX_INV_MASK) >> PHY_CTRL4_PPRBS_RX_INV_LSB)
+#define PHY_CTRL4_PPRBS_RX_INV_SET(x)                                (((x) << PHY_CTRL4_PPRBS_RX_INV_LSB) & PHY_CTRL4_PPRBS_RX_INV_MASK)
+#define PHY_CTRL4_PPRBS_RX_INV_RESET                                 0x0 // 0
+#define PHY_CTRL4_PWD_IRX_MSB                                        11
+#define PHY_CTRL4_PWD_IRX_LSB                                        0
+#define PHY_CTRL4_PWD_IRX_MASK                                       0x00000fff
+#define PHY_CTRL4_PWD_IRX_GET(x)                                     (((x) & PHY_CTRL4_PWD_IRX_MASK) >> PHY_CTRL4_PWD_IRX_LSB)
+#define PHY_CTRL4_PWD_IRX_SET(x)                                     (((x) << PHY_CTRL4_PWD_IRX_LSB) & PHY_CTRL4_PWD_IRX_MASK)
+#define PHY_CTRL4_PWD_IRX_RESET                                      0x6dd // 1757
+#define PHY_CTRL4_ADDRESS                                            0x18116c90
+#define PHY_CTRL4_OFFSET                                             0x0010
+// SW modifiable bits
+#define PHY_CTRL4_SW_MASK                                            0xff3fffff
+// bits defined at reset
+#define PHY_CTRL4_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL4_RESET                                              0x000006dd
+
+#define PHY_CTRL5_SPARE_BITS_MSB                                     31
+#define PHY_CTRL5_SPARE_BITS_LSB                                     30
+#define PHY_CTRL5_SPARE_BITS_MASK                                    0xc0000000
+#define PHY_CTRL5_SPARE_BITS_GET(x)                                  (((x) & PHY_CTRL5_SPARE_BITS_MASK) >> PHY_CTRL5_SPARE_BITS_LSB)
+#define PHY_CTRL5_SPARE_BITS_SET(x)                                  (((x) << PHY_CTRL5_SPARE_BITS_LSB) & PHY_CTRL5_SPARE_BITS_MASK)
+#define PHY_CTRL5_SPARE_BITS_RESET                                   0x0 // 0
+#define PHY_CTRL5_HOST_RES_FIX_EN_MSB                                29
+#define PHY_CTRL5_HOST_RES_FIX_EN_LSB                                29
+#define PHY_CTRL5_HOST_RES_FIX_EN_MASK                               0x20000000
+#define PHY_CTRL5_HOST_RES_FIX_EN_GET(x)                             (((x) & PHY_CTRL5_HOST_RES_FIX_EN_MASK) >> PHY_CTRL5_HOST_RES_FIX_EN_LSB)
+#define PHY_CTRL5_HOST_RES_FIX_EN_SET(x)                             (((x) << PHY_CTRL5_HOST_RES_FIX_EN_LSB) & PHY_CTRL5_HOST_RES_FIX_EN_MASK)
+#define PHY_CTRL5_HOST_RES_FIX_EN_RESET                              0x1 // 1
+#define PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_MSB                       28
+#define PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_LSB                       26
+#define PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_MASK                      0x1c000000
+#define PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_GET(x)                    (((x) & PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_MASK) >> PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_LSB)
+#define PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_SET(x)                    (((x) << PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_LSB) & PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_MASK)
+#define PHY_CTRL5_HOST_DISCON_SAMPLE_WIDTH_RESET                     0x6 // 6
+#define PHY_CTRL5_HOST_DISCON_DETECT_ON_MSB                          25
+#define PHY_CTRL5_HOST_DISCON_DETECT_ON_LSB                          25
+#define PHY_CTRL5_HOST_DISCON_DETECT_ON_MASK                         0x02000000
+#define PHY_CTRL5_HOST_DISCON_DETECT_ON_GET(x)                       (((x) & PHY_CTRL5_HOST_DISCON_DETECT_ON_MASK) >> PHY_CTRL5_HOST_DISCON_DETECT_ON_LSB)
+#define PHY_CTRL5_HOST_DISCON_DETECT_ON_SET(x)                       (((x) << PHY_CTRL5_HOST_DISCON_DETECT_ON_LSB) & PHY_CTRL5_HOST_DISCON_DETECT_ON_MASK)
+#define PHY_CTRL5_HOST_DISCON_DETECT_ON_RESET                        0x1 // 1
+#define PHY_CTRL5_HOST_DISCON_FIX_ON_MSB                             24
+#define PHY_CTRL5_HOST_DISCON_FIX_ON_LSB                             24
+#define PHY_CTRL5_HOST_DISCON_FIX_ON_MASK                            0x01000000
+#define PHY_CTRL5_HOST_DISCON_FIX_ON_GET(x)                          (((x) & PHY_CTRL5_HOST_DISCON_FIX_ON_MASK) >> PHY_CTRL5_HOST_DISCON_FIX_ON_LSB)
+#define PHY_CTRL5_HOST_DISCON_FIX_ON_SET(x)                          (((x) << PHY_CTRL5_HOST_DISCON_FIX_ON_LSB) & PHY_CTRL5_HOST_DISCON_FIX_ON_MASK)
+#define PHY_CTRL5_HOST_DISCON_FIX_ON_RESET                           0x1 // 1
+#define PHY_CTRL5_DM_PULLDOWN_MSB                                    23
+#define PHY_CTRL5_DM_PULLDOWN_LSB                                    23
+#define PHY_CTRL5_DM_PULLDOWN_MASK                                   0x00800000
+#define PHY_CTRL5_DM_PULLDOWN_GET(x)                                 (((x) & PHY_CTRL5_DM_PULLDOWN_MASK) >> PHY_CTRL5_DM_PULLDOWN_LSB)
+#define PHY_CTRL5_DM_PULLDOWN_SET(x)                                 (((x) << PHY_CTRL5_DM_PULLDOWN_LSB) & PHY_CTRL5_DM_PULLDOWN_MASK)
+#define PHY_CTRL5_DM_PULLDOWN_RESET                                  0x0 // 0
+#define PHY_CTRL5_DP_PULLDOWN_MSB                                    22
+#define PHY_CTRL5_DP_PULLDOWN_LSB                                    22
+#define PHY_CTRL5_DP_PULLDOWN_MASK                                   0x00400000
+#define PHY_CTRL5_DP_PULLDOWN_GET(x)                                 (((x) & PHY_CTRL5_DP_PULLDOWN_MASK) >> PHY_CTRL5_DP_PULLDOWN_LSB)
+#define PHY_CTRL5_DP_PULLDOWN_SET(x)                                 (((x) << PHY_CTRL5_DP_PULLDOWN_LSB) & PHY_CTRL5_DP_PULLDOWN_MASK)
+#define PHY_CTRL5_DP_PULLDOWN_RESET                                  0x0 // 0
+#define PHY_CTRL5_SUSPEND_N_MSB                                      21
+#define PHY_CTRL5_SUSPEND_N_LSB                                      21
+#define PHY_CTRL5_SUSPEND_N_MASK                                     0x00200000
+#define PHY_CTRL5_SUSPEND_N_GET(x)                                   (((x) & PHY_CTRL5_SUSPEND_N_MASK) >> PHY_CTRL5_SUSPEND_N_LSB)
+#define PHY_CTRL5_SUSPEND_N_SET(x)                                   (((x) << PHY_CTRL5_SUSPEND_N_LSB) & PHY_CTRL5_SUSPEND_N_MASK)
+#define PHY_CTRL5_SUSPEND_N_RESET                                    0x1 // 1
+#define PHY_CTRL5_TERM_SEL_MSB                                       20
+#define PHY_CTRL5_TERM_SEL_LSB                                       20
+#define PHY_CTRL5_TERM_SEL_MASK                                      0x00100000
+#define PHY_CTRL5_TERM_SEL_GET(x)                                    (((x) & PHY_CTRL5_TERM_SEL_MASK) >> PHY_CTRL5_TERM_SEL_LSB)
+#define PHY_CTRL5_TERM_SEL_SET(x)                                    (((x) << PHY_CTRL5_TERM_SEL_LSB) & PHY_CTRL5_TERM_SEL_MASK)
+#define PHY_CTRL5_TERM_SEL_RESET                                     0x0 // 0
+#define PHY_CTRL5_XCVR_SEL_MSB                                       19
+#define PHY_CTRL5_XCVR_SEL_LSB                                       18
+#define PHY_CTRL5_XCVR_SEL_MASK                                      0x000c0000
+#define PHY_CTRL5_XCVR_SEL_GET(x)                                    (((x) & PHY_CTRL5_XCVR_SEL_MASK) >> PHY_CTRL5_XCVR_SEL_LSB)
+#define PHY_CTRL5_XCVR_SEL_SET(x)                                    (((x) << PHY_CTRL5_XCVR_SEL_LSB) & PHY_CTRL5_XCVR_SEL_MASK)
+#define PHY_CTRL5_XCVR_SEL_RESET                                     0x0 // 0
+#define PHY_CTRL5_TEST_JK_OVERRIDE_MSB                               17
+#define PHY_CTRL5_TEST_JK_OVERRIDE_LSB                               17
+#define PHY_CTRL5_TEST_JK_OVERRIDE_MASK                              0x00020000
+#define PHY_CTRL5_TEST_JK_OVERRIDE_GET(x)                            (((x) & PHY_CTRL5_TEST_JK_OVERRIDE_MASK) >> PHY_CTRL5_TEST_JK_OVERRIDE_LSB)
+#define PHY_CTRL5_TEST_JK_OVERRIDE_SET(x)                            (((x) << PHY_CTRL5_TEST_JK_OVERRIDE_LSB) & PHY_CTRL5_TEST_JK_OVERRIDE_MASK)
+#define PHY_CTRL5_TEST_JK_OVERRIDE_RESET                             0x0 // 0
+#define PHY_CTRL5_FORCE_TEST_SE0_NAK_MSB                             16
+#define PHY_CTRL5_FORCE_TEST_SE0_NAK_LSB                             16
+#define PHY_CTRL5_FORCE_TEST_SE0_NAK_MASK                            0x00010000
+#define PHY_CTRL5_FORCE_TEST_SE0_NAK_GET(x)                          (((x) & PHY_CTRL5_FORCE_TEST_SE0_NAK_MASK) >> PHY_CTRL5_FORCE_TEST_SE0_NAK_LSB)
+#define PHY_CTRL5_FORCE_TEST_SE0_NAK_SET(x)                          (((x) << PHY_CTRL5_FORCE_TEST_SE0_NAK_LSB) & PHY_CTRL5_FORCE_TEST_SE0_NAK_MASK)
+#define PHY_CTRL5_FORCE_TEST_SE0_NAK_RESET                           0x0 // 0
+#define PHY_CTRL5_FORCE_TEST_K_MSB                                   15
+#define PHY_CTRL5_FORCE_TEST_K_LSB                                   15
+#define PHY_CTRL5_FORCE_TEST_K_MASK                                  0x00008000
+#define PHY_CTRL5_FORCE_TEST_K_GET(x)                                (((x) & PHY_CTRL5_FORCE_TEST_K_MASK) >> PHY_CTRL5_FORCE_TEST_K_LSB)
+#define PHY_CTRL5_FORCE_TEST_K_SET(x)                                (((x) << PHY_CTRL5_FORCE_TEST_K_LSB) & PHY_CTRL5_FORCE_TEST_K_MASK)
+#define PHY_CTRL5_FORCE_TEST_K_RESET                                 0x0 // 0
+#define PHY_CTRL5_FORCE_TEST_J_MSB                                   14
+#define PHY_CTRL5_FORCE_TEST_J_LSB                                   14
+#define PHY_CTRL5_FORCE_TEST_J_MASK                                  0x00004000
+#define PHY_CTRL5_FORCE_TEST_J_GET(x)                                (((x) & PHY_CTRL5_FORCE_TEST_J_MASK) >> PHY_CTRL5_FORCE_TEST_J_LSB)
+#define PHY_CTRL5_FORCE_TEST_J_SET(x)                                (((x) << PHY_CTRL5_FORCE_TEST_J_LSB) & PHY_CTRL5_FORCE_TEST_J_MASK)
+#define PHY_CTRL5_FORCE_TEST_J_RESET                                 0x0 // 0
+#define PHY_CTRL5_FORCE_IDDQ_MSB                                     13
+#define PHY_CTRL5_FORCE_IDDQ_LSB                                     13
+#define PHY_CTRL5_FORCE_IDDQ_MASK                                    0x00002000
+#define PHY_CTRL5_FORCE_IDDQ_GET(x)                                  (((x) & PHY_CTRL5_FORCE_IDDQ_MASK) >> PHY_CTRL5_FORCE_IDDQ_LSB)
+#define PHY_CTRL5_FORCE_IDDQ_SET(x)                                  (((x) << PHY_CTRL5_FORCE_IDDQ_LSB) & PHY_CTRL5_FORCE_IDDQ_MASK)
+#define PHY_CTRL5_FORCE_IDDQ_RESET                                   0x0 // 0
+#define PHY_CTRL5_EB_WATERMARK_MSB                                   12
+#define PHY_CTRL5_EB_WATERMARK_LSB                                   7
+#define PHY_CTRL5_EB_WATERMARK_MASK                                  0x00001f80
+#define PHY_CTRL5_EB_WATERMARK_GET(x)                                (((x) & PHY_CTRL5_EB_WATERMARK_MASK) >> PHY_CTRL5_EB_WATERMARK_LSB)
+#define PHY_CTRL5_EB_WATERMARK_SET(x)                                (((x) << PHY_CTRL5_EB_WATERMARK_LSB) & PHY_CTRL5_EB_WATERMARK_MASK)
+#define PHY_CTRL5_EB_WATERMARK_RESET                                 0x14 // 20
+#define PHY_CTRL5_TX_BIAS_DELAY_MSB                                  6
+#define PHY_CTRL5_TX_BIAS_DELAY_LSB                                  0
+#define PHY_CTRL5_TX_BIAS_DELAY_MASK                                 0x0000007f
+#define PHY_CTRL5_TX_BIAS_DELAY_GET(x)                               (((x) & PHY_CTRL5_TX_BIAS_DELAY_MASK) >> PHY_CTRL5_TX_BIAS_DELAY_LSB)
+#define PHY_CTRL5_TX_BIAS_DELAY_SET(x)                               (((x) << PHY_CTRL5_TX_BIAS_DELAY_LSB) & PHY_CTRL5_TX_BIAS_DELAY_MASK)
+#define PHY_CTRL5_TX_BIAS_DELAY_RESET                                0x32 // 50
+#define PHY_CTRL5_ADDRESS                                            0x18116c94
+#define PHY_CTRL5_OFFSET                                             0x0014
+// SW modifiable bits
+#define PHY_CTRL5_SW_MASK                                            0xffffffff
+// bits defined at reset
+#define PHY_CTRL5_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL5_RESET                                              0x3b200a32
+#define PHY_CTRL5_RESET_1					     0x3b202a58
+
+#define PHY_CTRL6_SPARE_BITS_MSB                                     31
+#define PHY_CTRL6_SPARE_BITS_LSB                                     9
+#define PHY_CTRL6_SPARE_BITS_MASK                                    0xfffffe00
+#define PHY_CTRL6_SPARE_BITS_GET(x)                                  (((x) & PHY_CTRL6_SPARE_BITS_MASK) >> PHY_CTRL6_SPARE_BITS_LSB)
+#define PHY_CTRL6_SPARE_BITS_SET(x)                                  (((x) << PHY_CTRL6_SPARE_BITS_LSB) & PHY_CTRL6_SPARE_BITS_MASK)
+#define PHY_CTRL6_SPARE_BITS_RESET                                   0x0 // 0
+#define PHY_CTRL6_DIS_SETUP_RETRY_FIX_MSB                            8
+#define PHY_CTRL6_DIS_SETUP_RETRY_FIX_LSB                            8
+#define PHY_CTRL6_DIS_SETUP_RETRY_FIX_MASK                           0x00000100
+#define PHY_CTRL6_DIS_SETUP_RETRY_FIX_GET(x)                         (((x) & PHY_CTRL6_DIS_SETUP_RETRY_FIX_MASK) >> PHY_CTRL6_DIS_SETUP_RETRY_FIX_LSB)
+#define PHY_CTRL6_DIS_SETUP_RETRY_FIX_SET(x)                         (((x) << PHY_CTRL6_DIS_SETUP_RETRY_FIX_LSB) & PHY_CTRL6_DIS_SETUP_RETRY_FIX_MASK)
+#define PHY_CTRL6_DIS_SETUP_RETRY_FIX_RESET                          0x0 // 0
+#define PHY_CTRL6_XCVR_SEL_MSB                                       7
+#define PHY_CTRL6_XCVR_SEL_LSB                                       6
+#define PHY_CTRL6_XCVR_SEL_MASK                                      0x000000c0
+#define PHY_CTRL6_XCVR_SEL_GET(x)                                    (((x) & PHY_CTRL6_XCVR_SEL_MASK) >> PHY_CTRL6_XCVR_SEL_LSB)
+#define PHY_CTRL6_XCVR_SEL_SET(x)                                    (((x) << PHY_CTRL6_XCVR_SEL_LSB) & PHY_CTRL6_XCVR_SEL_MASK)
+#define PHY_CTRL6_XCVR_SEL_RESET                                     0x0 // 0
+#define PHY_CTRL6_XCVRSEL_OVERRIDE_MSB                               5
+#define PHY_CTRL6_XCVRSEL_OVERRIDE_LSB                               5
+#define PHY_CTRL6_XCVRSEL_OVERRIDE_MASK                              0x00000020
+#define PHY_CTRL6_XCVRSEL_OVERRIDE_GET(x)                            (((x) & PHY_CTRL6_XCVRSEL_OVERRIDE_MASK) >> PHY_CTRL6_XCVRSEL_OVERRIDE_LSB)
+#define PHY_CTRL6_XCVRSEL_OVERRIDE_SET(x)                            (((x) << PHY_CTRL6_XCVRSEL_OVERRIDE_LSB) & PHY_CTRL6_XCVRSEL_OVERRIDE_MASK)
+#define PHY_CTRL6_XCVRSEL_OVERRIDE_RESET                             0x0 // 0
+#define PHY_CTRL6_IDDIG_MSB                                          4
+#define PHY_CTRL6_IDDIG_LSB                                          4
+#define PHY_CTRL6_IDDIG_MASK                                         0x00000010
+#define PHY_CTRL6_IDDIG_GET(x)                                       (((x) & PHY_CTRL6_IDDIG_MASK) >> PHY_CTRL6_IDDIG_LSB)
+#define PHY_CTRL6_IDDIG_SET(x)                                       (((x) << PHY_CTRL6_IDDIG_LSB) & PHY_CTRL6_IDDIG_MASK)
+#define PHY_CTRL6_IDDIG_RESET                                        0x0 // 0
+#define PHY_CTRL6_SESSEND_MSB                                        3
+#define PHY_CTRL6_SESSEND_LSB                                        3
+#define PHY_CTRL6_SESSEND_MASK                                       0x00000008
+#define PHY_CTRL6_SESSEND_GET(x)                                     (((x) & PHY_CTRL6_SESSEND_MASK) >> PHY_CTRL6_SESSEND_LSB)
+#define PHY_CTRL6_SESSEND_SET(x)                                     (((x) << PHY_CTRL6_SESSEND_LSB) & PHY_CTRL6_SESSEND_MASK)
+#define PHY_CTRL6_SESSEND_RESET                                      0x0 // 0
+#define PHY_CTRL6_VBUSVALID_MSB                                      2
+#define PHY_CTRL6_VBUSVALID_LSB                                      2
+#define PHY_CTRL6_VBUSVALID_MASK                                     0x00000004
+#define PHY_CTRL6_VBUSVALID_GET(x)                                   (((x) & PHY_CTRL6_VBUSVALID_MASK) >> PHY_CTRL6_VBUSVALID_LSB)
+#define PHY_CTRL6_VBUSVALID_SET(x)                                   (((x) << PHY_CTRL6_VBUSVALID_LSB) & PHY_CTRL6_VBUSVALID_MASK)
+#define PHY_CTRL6_VBUSVALID_RESET                                    0x1 // 1
+#define PHY_CTRL6_BVALID_MSB                                         1
+#define PHY_CTRL6_BVALID_LSB                                         1
+#define PHY_CTRL6_BVALID_MASK                                        0x00000002
+#define PHY_CTRL6_BVALID_GET(x)                                      (((x) & PHY_CTRL6_BVALID_MASK) >> PHY_CTRL6_BVALID_LSB)
+#define PHY_CTRL6_BVALID_SET(x)                                      (((x) << PHY_CTRL6_BVALID_LSB) & PHY_CTRL6_BVALID_MASK)
+#define PHY_CTRL6_BVALID_RESET                                       0x1 // 1
+#define PHY_CTRL6_AVALID_MSB                                         0
+#define PHY_CTRL6_AVALID_LSB                                         0
+#define PHY_CTRL6_AVALID_MASK                                        0x00000001
+#define PHY_CTRL6_AVALID_GET(x)                                      (((x) & PHY_CTRL6_AVALID_MASK) >> PHY_CTRL6_AVALID_LSB)
+#define PHY_CTRL6_AVALID_SET(x)                                      (((x) << PHY_CTRL6_AVALID_LSB) & PHY_CTRL6_AVALID_MASK)
+#define PHY_CTRL6_AVALID_RESET                                       0x1 // 1
+#define PHY_CTRL6_ADDRESS                                            0x18116c98
+#define PHY_CTRL6_OFFSET                                             0x0018
+// SW modifiable bits
+#define PHY_CTRL6_SW_MASK                                            0xffffffff
+// bits defined at reset
+#define PHY_CTRL6_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL6_RESET                                              0x00000007
+
+#define PHY_STATUS_TX_CAL_MSB                                        3
+#define PHY_STATUS_TX_CAL_LSB                                        0
+#define PHY_STATUS_TX_CAL_MASK                                       0x0000000f
+#define PHY_STATUS_TX_CAL_GET(x)                                     (((x) & PHY_STATUS_TX_CAL_MASK) >> PHY_STATUS_TX_CAL_LSB)
+#define PHY_STATUS_TX_CAL_SET(x)                                     (((x) << PHY_STATUS_TX_CAL_LSB) & PHY_STATUS_TX_CAL_MASK)
+#define PHY_STATUS_TX_CAL_RESET                                      0x0 // 0
+#define PHY_STATUS_ADDRESS                                           0x18116c9c
+#define PHY_STATUS_OFFSET                                            0x001c
+// SW modifiable bits
+#define PHY_STATUS_SW_MASK                                           0x0000000f
+// bits defined at reset
+#define PHY_STATUS_RSTMASK                                           0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_STATUS_RESET                                             0x00000000
+
+#define PHY_CTRL7_PPRBS_ERROR_RATE_MSB                               31
+#define PHY_CTRL7_PPRBS_ERROR_RATE_LSB                               11
+#define PHY_CTRL7_PPRBS_ERROR_RATE_MASK                              0xfffff800
+#define PHY_CTRL7_PPRBS_ERROR_RATE_GET(x)                            (((x) & PHY_CTRL7_PPRBS_ERROR_RATE_MASK) >> PHY_CTRL7_PPRBS_ERROR_RATE_LSB)
+#define PHY_CTRL7_PPRBS_ERROR_RATE_SET(x)                            (((x) << PHY_CTRL7_PPRBS_ERROR_RATE_LSB) & PHY_CTRL7_PPRBS_ERROR_RATE_MASK)
+#define PHY_CTRL7_PPRBS_ERROR_RATE_RESET                             0xa000 // 40960
+#define PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_MSB                          10
+#define PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_LSB                          1
+#define PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_MASK                         0x000007fe
+#define PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_GET(x)                       (((x) & PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_MASK) >> PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_LSB)
+#define PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_SET(x)                       (((x) << PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_LSB) & PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_MASK)
+#define PHY_CTRL7_PPRBS_TOTAL_NUMOF_ERR_RESET                        0x0 // 0
+#define PHY_CTRL7_PPRBS_TRIGGER_ERROR_MSB                            0
+#define PHY_CTRL7_PPRBS_TRIGGER_ERROR_LSB                            0
+#define PHY_CTRL7_PPRBS_TRIGGER_ERROR_MASK                           0x00000001
+#define PHY_CTRL7_PPRBS_TRIGGER_ERROR_GET(x)                         (((x) & PHY_CTRL7_PPRBS_TRIGGER_ERROR_MASK) >> PHY_CTRL7_PPRBS_TRIGGER_ERROR_LSB)
+#define PHY_CTRL7_PPRBS_TRIGGER_ERROR_SET(x)                         (((x) << PHY_CTRL7_PPRBS_TRIGGER_ERROR_LSB) & PHY_CTRL7_PPRBS_TRIGGER_ERROR_MASK)
+#define PHY_CTRL7_PPRBS_TRIGGER_ERROR_RESET                          0x0 // 0
+#define PHY_CTRL7_ADDRESS                                            0x18116ca0
+#define PHY_CTRL7_OFFSET                                             0x0020
+// SW modifiable bits
+#define PHY_CTRL7_SW_MASK                                            0xffffffff
+// bits defined at reset
+#define PHY_CTRL7_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL7_RESET                                              0x05000000
+
+#define PHY_CTRL8_USBPLL_PWD_MSB                                     7
+#define PHY_CTRL8_USBPLL_PWD_LSB                                     7
+#define PHY_CTRL8_USBPLL_PWD_MASK                                    0x00000080
+#define PHY_CTRL8_USBPLL_PWD_GET(x)                                  (((x) & PHY_CTRL8_USBPLL_PWD_MASK) >> PHY_CTRL8_USBPLL_PWD_LSB)
+#define PHY_CTRL8_USBPLL_PWD_SET(x)                                  (((x) << PHY_CTRL8_USBPLL_PWD_LSB) & PHY_CTRL8_USBPLL_PWD_MASK)
+#define PHY_CTRL8_USBPLL_PWD_RESET                                   0x0 // 0
+#define PHY_CTRL8_TX_FASTRISE_MSB                                    6
+#define PHY_CTRL8_TX_FASTRISE_LSB                                    4
+#define PHY_CTRL8_TX_FASTRISE_MASK                                   0x00000070
+#define PHY_CTRL8_TX_FASTRISE_GET(x)                                 (((x) & PHY_CTRL8_TX_FASTRISE_MASK) >> PHY_CTRL8_TX_FASTRISE_LSB)
+#define PHY_CTRL8_TX_FASTRISE_SET(x)                                 (((x) << PHY_CTRL8_TX_FASTRISE_LSB) & PHY_CTRL8_TX_FASTRISE_MASK)
+#define PHY_CTRL8_TX_FASTRISE_RESET                                  0x5 // 5
+#define PHY_CTRL8_TX_ENPRE_MSB                                       3
+#define PHY_CTRL8_TX_ENPRE_LSB                                       2
+#define PHY_CTRL8_TX_ENPRE_MASK                                      0x0000000c
+#define PHY_CTRL8_TX_ENPRE_GET(x)                                    (((x) & PHY_CTRL8_TX_ENPRE_MASK) >> PHY_CTRL8_TX_ENPRE_LSB)
+#define PHY_CTRL8_TX_ENPRE_SET(x)                                    (((x) << PHY_CTRL8_TX_ENPRE_LSB) & PHY_CTRL8_TX_ENPRE_MASK)
+#define PHY_CTRL8_TX_ENPRE_RESET                                     0x0 // 0
+#define PHY_CTRL8_RX_SQ_HYST_EN_MSB                                  1
+#define PHY_CTRL8_RX_SQ_HYST_EN_LSB                                  1
+#define PHY_CTRL8_RX_SQ_HYST_EN_MASK                                 0x00000002
+#define PHY_CTRL8_RX_SQ_HYST_EN_GET(x)                               (((x) & PHY_CTRL8_RX_SQ_HYST_EN_MASK) >> PHY_CTRL8_RX_SQ_HYST_EN_LSB)
+#define PHY_CTRL8_RX_SQ_HYST_EN_SET(x)                               (((x) << PHY_CTRL8_RX_SQ_HYST_EN_LSB) & PHY_CTRL8_RX_SQ_HYST_EN_MASK)
+#define PHY_CTRL8_RX_SQ_HYST_EN_RESET                                0x0 // 0
+#define PHY_CTRL8_RX_SKIP2_MSB                                       0
+#define PHY_CTRL8_RX_SKIP2_LSB                                       0
+#define PHY_CTRL8_RX_SKIP2_MASK                                      0x00000001
+#define PHY_CTRL8_RX_SKIP2_GET(x)                                    (((x) & PHY_CTRL8_RX_SKIP2_MASK) >> PHY_CTRL8_RX_SKIP2_LSB)
+#define PHY_CTRL8_RX_SKIP2_SET(x)                                    (((x) << PHY_CTRL8_RX_SKIP2_LSB) & PHY_CTRL8_RX_SKIP2_MASK)
+#define PHY_CTRL8_RX_SKIP2_RESET                                     0x0 // 0
+#define PHY_CTRL8_ADDRESS                                            0x18116ca4
+#define PHY_CTRL8_OFFSET                                             0x0024
+// SW modifiable bits
+#define PHY_CTRL8_SW_MASK                                            0x000000ff
+// bits defined at reset
+#define PHY_CTRL8_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PHY_CTRL8_RESET                                              0x00000050
+#define CPU_DDR_CLOCK_CONTROL_SPARE_MSB                              31
+#define CPU_DDR_CLOCK_CONTROL_SPARE_LSB                              25
+#define CPU_DDR_CLOCK_CONTROL_SPARE_MASK                             0xfe000000
+#define CPU_DDR_CLOCK_CONTROL_SPARE_GET(x)                           (((x) & CPU_DDR_CLOCK_CONTROL_SPARE_MASK) >> CPU_DDR_CLOCK_CONTROL_SPARE_LSB)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_SET(x)                           (((x) << CPU_DDR_CLOCK_CONTROL_SPARE_LSB) & CPU_DDR_CLOCK_CONTROL_SPARE_MASK)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_RESET                            0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MSB                 24
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB                 24
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK                0x01000000
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_GET(x)              (((x) & CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(x)              (((x) << CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB) & CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_RESET               0x1 // 1
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MSB            23
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB            23
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK           0x00800000
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_GET(x)         (((x) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_SET(x)         (((x) << CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_RESET          0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MSB               22
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB               22
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK              0x00400000
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_GET(x)            (((x) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_SET(x)            (((x) << CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_RESET             0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MSB                 21
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_LSB                 21
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MASK                0x00200000
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_GET(x)              (((x) & CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(x)              (((x) << CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_LSB) & CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_RESET               0x1 // 1
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MSB                 20
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_LSB                 20
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MASK                0x00100000
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_GET(x)              (((x) & CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(x)              (((x) << CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_LSB) & CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_RESET               0x1 // 1
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MSB                       19
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB                       15
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK                      0x000f8000
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_RESET                     0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MSB                       14
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB                       10
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK                      0x00007c00
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_RESET                     0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MSB                       9
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB                       5
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK                      0x000003e0
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_RESET                     0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MSB                     4
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB                     4
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK                    0x00000010
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_RESET                   0x1 // 1
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MSB                     3
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB                     3
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK                    0x00000008
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_RESET                   0x1 // 1
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MSB                     2
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB                     2
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK                    0x00000004
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_RESET                   0x1 // 1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MSB                       1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB                       1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK                      0x00000002
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK) >> CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB)
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB) & CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK)
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_RESET                     0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MSB                       0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB                       0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK                      0x00000001
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK) >> CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB) & CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_RESET                     0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_ADDRESS                                0x18050008
+
+#define PCIE_PLL_CONFIG_UPDATING_MSB                                 31
+#define PCIE_PLL_CONFIG_UPDATING_LSB                                 31
+#define PCIE_PLL_CONFIG_UPDATING_MASK                                0x80000000
+#define PCIE_PLL_CONFIG_UPDATING_GET(x)                              (((x) & PCIE_PLL_CONFIG_UPDATING_MASK) >> PCIE_PLL_CONFIG_UPDATING_LSB)
+#define PCIE_PLL_CONFIG_UPDATING_SET(x)                              (((x) << PCIE_PLL_CONFIG_UPDATING_LSB) & PCIE_PLL_CONFIG_UPDATING_MASK)
+#define PCIE_PLL_CONFIG_UPDATING_RESET                               0x0 // 0
+#define PCIE_PLL_CONFIG_PLLPWD_MSB                                   30
+#define PCIE_PLL_CONFIG_PLLPWD_LSB                                   30
+#define PCIE_PLL_CONFIG_PLLPWD_MASK                                  0x40000000
+#define PCIE_PLL_CONFIG_PLLPWD_GET(x)                                (((x) & PCIE_PLL_CONFIG_PLLPWD_MASK) >> PCIE_PLL_CONFIG_PLLPWD_LSB)
+#define PCIE_PLL_CONFIG_PLLPWD_SET(x)                                (((x) << PCIE_PLL_CONFIG_PLLPWD_LSB) & PCIE_PLL_CONFIG_PLLPWD_MASK)
+#define PCIE_PLL_CONFIG_PLLPWD_RESET                                 0x1 // 1
+#define PCIE_PLL_CONFIG_BYPASS_MSB                                   16
+#define PCIE_PLL_CONFIG_BYPASS_LSB                                   16
+#define PCIE_PLL_CONFIG_BYPASS_MASK                                  0x00010000
+#define PCIE_PLL_CONFIG_BYPASS_GET(x)                                (((x) & PCIE_PLL_CONFIG_BYPASS_MASK) >> PCIE_PLL_CONFIG_BYPASS_LSB)
+#define PCIE_PLL_CONFIG_BYPASS_SET(x)                                (((x) << PCIE_PLL_CONFIG_BYPASS_LSB) & PCIE_PLL_CONFIG_BYPASS_MASK)
+#define PCIE_PLL_CONFIG_BYPASS_RESET                                 0x1 // 1
+#define PCIE_PLL_CONFIG_REFDIV_MSB                                   14
+#define PCIE_PLL_CONFIG_REFDIV_LSB                                   10
+#define PCIE_PLL_CONFIG_REFDIV_MASK                                  0x00007c00
+#define PCIE_PLL_CONFIG_REFDIV_GET(x)                                (((x) & PCIE_PLL_CONFIG_REFDIV_MASK) >> PCIE_PLL_CONFIG_REFDIV_LSB)
+#define PCIE_PLL_CONFIG_REFDIV_SET(x)                                (((x) << PCIE_PLL_CONFIG_REFDIV_LSB) & PCIE_PLL_CONFIG_REFDIV_MASK)
+#define PCIE_PLL_CONFIG_REFDIV_RESET                                 0x1 // 1
+#define PCIE_PLL_CONFIG_ADDRESS                                      0x18050010
+
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MSB                        31
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB                        31
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK                       0x80000000
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_GET(x)                     (((x) & PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK) >> PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_SET(x)                     (((x) << PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB) & PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_RESET                      0x1 // 1
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MSB                          30
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB                          30
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK                         0x40000000
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_GET(x)                       (((x) & PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK) >> PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_SET(x)                       (((x) << PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB) & PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_RESET                        0x1 // 1
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MSB                      20
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB                      15
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK                     0x001f8000
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_GET(x)                   (((x) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK) >> PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_SET(x)                   (((x) << PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_RESET                    0x13 // 19
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MSB                     14
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB                     1
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK                    0x00007ffe
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_GET(x)                  (((x) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK) >> PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_SET(x)                  (((x) << PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_RESET                   0x3fff // 16383
+#define PCIE_PLL_DITHER_DIV_MAX_ADDRESS                              0x18050014
+
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MSB                      20
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB                      15
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK                     0x001f8000
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_GET(x)                   (((x) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK) >> PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_SET(x)                   (((x) << PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_RESET                    0x13 // 19
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MSB                     14
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB                     1
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK                    0x00007ffe
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_GET(x)                  (((x) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK) >> PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_SET(x)                  (((x) << PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_RESET                   0x399d // 14749
+#define PCIE_PLL_DITHER_DIV_MIN_ADDRESS                              0x18050018
+
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_MSB                          31
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB                          28
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK                         0xf0000000
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_GET(x)                       (((x) & PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK) >> PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_SET(x)                       (((x) << PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB) & PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_RESET                        0x0 // 0
+#define PCIE_PLL_DITHER_STEP_STEP_INT_MSB                            24
+#define PCIE_PLL_DITHER_STEP_STEP_INT_LSB                            15
+#define PCIE_PLL_DITHER_STEP_STEP_INT_MASK                           0x01ff8000
+#define PCIE_PLL_DITHER_STEP_STEP_INT_GET(x)                         (((x) & PCIE_PLL_DITHER_STEP_STEP_INT_MASK) >> PCIE_PLL_DITHER_STEP_STEP_INT_LSB)
+#define PCIE_PLL_DITHER_STEP_STEP_INT_SET(x)                         (((x) << PCIE_PLL_DITHER_STEP_STEP_INT_LSB) & PCIE_PLL_DITHER_STEP_STEP_INT_MASK)
+#define PCIE_PLL_DITHER_STEP_STEP_INT_RESET                          0x0 // 0
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_MSB                           14
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB                           1
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK                          0x00007ffe
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_GET(x)                        (((x) & PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK) >> PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB)
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_SET(x)                        (((x) << PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB) & PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK)
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_RESET                         0xa // 10
+#define PCIE_PLL_DITHER_STEP_ADDRESS                                 0x1805001c
+
+
+
+// 32'h180f0008 (PCIE_PWR_MGMT)
+#define PCIE_PWR_MGMT_PME_INT_MSB                                    8
+#define PCIE_PWR_MGMT_PME_INT_LSB                                    8
+#define PCIE_PWR_MGMT_PME_INT_MASK                                   0x00000100
+#define PCIE_PWR_MGMT_PME_INT_GET(x)                                 (((x) & PCIE_PWR_MGMT_PME_INT_MASK) >> PCIE_PWR_MGMT_PME_INT_LSB)
+#define PCIE_PWR_MGMT_PME_INT_SET(x)                                 (((x) << PCIE_PWR_MGMT_PME_INT_LSB) & PCIE_PWR_MGMT_PME_INT_MASK)
+#define PCIE_PWR_MGMT_PME_INT_RESET                                  0x0 // 0
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_MSB                             7
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_LSB                             7
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_MASK                            0x00000080
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_GET(x)                          (((x) & PCIE_PWR_MGMT_ASSERT_CLKREQN_MASK) >> PCIE_PWR_MGMT_ASSERT_CLKREQN_LSB)
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_SET(x)                          (((x) << PCIE_PWR_MGMT_ASSERT_CLKREQN_LSB) & PCIE_PWR_MGMT_ASSERT_CLKREQN_MASK)
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_RESET                           0x0 // 0
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_MSB                             6
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_LSB                             6
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_MASK                            0x00000040
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_GET(x)                          (((x) & PCIE_PWR_MGMT_RADM_PM_TO_ACK_MASK) >> PCIE_PWR_MGMT_RADM_PM_TO_ACK_LSB)
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_SET(x)                          (((x) << PCIE_PWR_MGMT_RADM_PM_TO_ACK_LSB) & PCIE_PWR_MGMT_RADM_PM_TO_ACK_MASK)
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_RESET                           0x0 // 0
+#define PCIE_PWR_MGMT_RADM_PM_PME_MSB                                5
+#define PCIE_PWR_MGMT_RADM_PM_PME_LSB                                5
+#define PCIE_PWR_MGMT_RADM_PM_PME_MASK                               0x00000020
+#define PCIE_PWR_MGMT_RADM_PM_PME_GET(x)                             (((x) & PCIE_PWR_MGMT_RADM_PM_PME_MASK) >> PCIE_PWR_MGMT_RADM_PM_PME_LSB)
+#define PCIE_PWR_MGMT_RADM_PM_PME_SET(x)                             (((x) << PCIE_PWR_MGMT_RADM_PM_PME_LSB) & PCIE_PWR_MGMT_RADM_PM_PME_MASK)
+#define PCIE_PWR_MGMT_RADM_PM_PME_RESET                              0x0 // 0
+#define PCIE_PWR_MGMT_AUX_PM_EN_MSB                                  4
+#define PCIE_PWR_MGMT_AUX_PM_EN_LSB                                  4
+#define PCIE_PWR_MGMT_AUX_PM_EN_MASK                                 0x00000010
+#define PCIE_PWR_MGMT_AUX_PM_EN_GET(x)                               (((x) & PCIE_PWR_MGMT_AUX_PM_EN_MASK) >> PCIE_PWR_MGMT_AUX_PM_EN_LSB)
+#define PCIE_PWR_MGMT_AUX_PM_EN_SET(x)                               (((x) << PCIE_PWR_MGMT_AUX_PM_EN_LSB) & PCIE_PWR_MGMT_AUX_PM_EN_MASK)
+#define PCIE_PWR_MGMT_AUX_PM_EN_RESET                                0x0 // 0
+#define PCIE_PWR_MGMT_READY_ENTR_L23_MSB                             3
+#define PCIE_PWR_MGMT_READY_ENTR_L23_LSB                             3
+#define PCIE_PWR_MGMT_READY_ENTR_L23_MASK                            0x00000008
+#define PCIE_PWR_MGMT_READY_ENTR_L23_GET(x)                          (((x) & PCIE_PWR_MGMT_READY_ENTR_L23_MASK) >> PCIE_PWR_MGMT_READY_ENTR_L23_LSB)
+#define PCIE_PWR_MGMT_READY_ENTR_L23_SET(x)                          (((x) << PCIE_PWR_MGMT_READY_ENTR_L23_LSB) & PCIE_PWR_MGMT_READY_ENTR_L23_MASK)
+#define PCIE_PWR_MGMT_READY_ENTR_L23_RESET                           0x0 // 0
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_MSB                                2
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_LSB                                2
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_MASK                               0x00000004
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_GET(x)                             (((x) & PCIE_PWR_MGMT_REQ_EXIT_L1_MASK) >> PCIE_PWR_MGMT_REQ_EXIT_L1_LSB)
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_SET(x)                             (((x) << PCIE_PWR_MGMT_REQ_EXIT_L1_LSB) & PCIE_PWR_MGMT_REQ_EXIT_L1_MASK)
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_RESET                              0x0 // 0
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_MSB                               1
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_LSB                               1
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_MASK                              0x00000002
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_GET(x)                            (((x) & PCIE_PWR_MGMT_REQ_ENTRY_L1_MASK) >> PCIE_PWR_MGMT_REQ_ENTRY_L1_LSB)
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_SET(x)                            (((x) << PCIE_PWR_MGMT_REQ_ENTRY_L1_LSB) & PCIE_PWR_MGMT_REQ_ENTRY_L1_MASK)
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_RESET                             0x0 // 0
+#define PCIE_PWR_MGMT_AUX_PWR_DET_MSB                                0
+#define PCIE_PWR_MGMT_AUX_PWR_DET_LSB                                0
+#define PCIE_PWR_MGMT_AUX_PWR_DET_MASK                               0x00000001
+#define PCIE_PWR_MGMT_AUX_PWR_DET_GET(x)                             (((x) & PCIE_PWR_MGMT_AUX_PWR_DET_MASK) >> PCIE_PWR_MGMT_AUX_PWR_DET_LSB)
+#define PCIE_PWR_MGMT_AUX_PWR_DET_SET(x)                             (((x) << PCIE_PWR_MGMT_AUX_PWR_DET_LSB) & PCIE_PWR_MGMT_AUX_PWR_DET_MASK)
+#define PCIE_PWR_MGMT_AUX_PWR_DET_RESET                              0x0 // 0
+#define PCIE_PWR_MGMT_ADDRESS                                        0x180f0008
+#define PCIE_PWR_MGMT_OFFSET                                         0x0008
+// SW modifiable bits
+#define PCIE_PWR_MGMT_SW_MASK                                        0x000001ff
+// bits defined at reset
+#define PCIE_PWR_MGMT_RSTMASK                                        0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PWR_MGMT_RESET                                          0x00000000
+
+
+// 32'h180600c0 (RST_CLKGAT_EN)
+#define RST_CLKGAT_EN_SPARE_MSB                                      31
+#define RST_CLKGAT_EN_SPARE_LSB                                      12
+#define RST_CLKGAT_EN_SPARE_MASK                                     0xfffff000
+#define RST_CLKGAT_EN_SPARE_GET(x)                                   (((x) & RST_CLKGAT_EN_SPARE_MASK) >> RST_CLKGAT_EN_SPARE_LSB)
+#define RST_CLKGAT_EN_SPARE_SET(x)                                   (((x) << RST_CLKGAT_EN_SPARE_LSB) & RST_CLKGAT_EN_SPARE_MASK)
+#define RST_CLKGAT_EN_SPARE_RESET                                    0x0 // 0
+#define RST_CLKGAT_EN_WMAC_MSB                                       9
+#define RST_CLKGAT_EN_WMAC_LSB                                       9
+#define RST_CLKGAT_EN_WMAC_MASK                                      0x00000200
+#define RST_CLKGAT_EN_WMAC_GET(x)                                    (((x) & RST_CLKGAT_EN_WMAC_MASK) >> RST_CLKGAT_EN_WMAC_LSB)
+#define RST_CLKGAT_EN_WMAC_SET(x)                                    (((x) << RST_CLKGAT_EN_WMAC_LSB) & RST_CLKGAT_EN_WMAC_MASK)
+#define RST_CLKGAT_EN_WMAC_RESET                                     0x1 // 1
+#define RST_CLKGAT_EN_USB1_MSB                                       7
+#define RST_CLKGAT_EN_USB1_LSB                                       7
+#define RST_CLKGAT_EN_USB1_MASK                                      0x00000080
+#define RST_CLKGAT_EN_USB1_GET(x)                                    (((x) & RST_CLKGAT_EN_USB1_MASK) >> RST_CLKGAT_EN_USB1_LSB)
+#define RST_CLKGAT_EN_USB1_SET(x)                                    (((x) << RST_CLKGAT_EN_USB1_LSB) & RST_CLKGAT_EN_USB1_MASK)
+#define RST_CLKGAT_EN_USB1_RESET                                     0x1 // 1
+#define RST_CLKGAT_EN_GE1_MSB                                        6
+#define RST_CLKGAT_EN_GE1_LSB                                        6
+#define RST_CLKGAT_EN_GE1_MASK                                       0x00000040
+#define RST_CLKGAT_EN_GE1_GET(x)                                     (((x) & RST_CLKGAT_EN_GE1_MASK) >> RST_CLKGAT_EN_GE1_LSB)
+#define RST_CLKGAT_EN_GE1_SET(x)                                     (((x) << RST_CLKGAT_EN_GE1_LSB) & RST_CLKGAT_EN_GE1_MASK)
+#define RST_CLKGAT_EN_GE1_RESET                                      0x1 // 1
+#define RST_CLKGAT_EN_GE0_MSB                                        5
+#define RST_CLKGAT_EN_GE0_LSB                                        5
+#define RST_CLKGAT_EN_GE0_MASK                                       0x00000020
+#define RST_CLKGAT_EN_GE0_GET(x)                                     (((x) & RST_CLKGAT_EN_GE0_MASK) >> RST_CLKGAT_EN_GE0_LSB)
+#define RST_CLKGAT_EN_GE0_SET(x)                                     (((x) << RST_CLKGAT_EN_GE0_LSB) & RST_CLKGAT_EN_GE0_MASK)
+#define RST_CLKGAT_EN_GE0_RESET                                      0x1 // 1
+#define RST_CLKGAT_EN_PCIE_RC_MSB                                    1
+#define RST_CLKGAT_EN_PCIE_RC_LSB                                    1
+#define RST_CLKGAT_EN_PCIE_RC_MASK                                   0x00000002
+#define RST_CLKGAT_EN_PCIE_RC_GET(x)                                 (((x) & RST_CLKGAT_EN_PCIE_RC_MASK) >> RST_CLKGAT_EN_PCIE_RC_LSB)
+#define RST_CLKGAT_EN_PCIE_RC_SET(x)                                 (((x) << RST_CLKGAT_EN_PCIE_RC_LSB) & RST_CLKGAT_EN_PCIE_RC_MASK)
+#define RST_CLKGAT_EN_PCIE_RC_RESET                                  0x1 // 1
+#define RST_CLKGAT_EN_ADDRESS                                        0x180600c0
+#define RST_CLKGAT_EN_OFFSET                                         0x00c0
+// SW modifiable bits
+#define RST_CLKGAT_EN_SW_MASK                                        0xfffff2e2
+// bits defined at reset
+#define RST_CLKGAT_EN_RSTMASK                                        0xffffffff
+// reset value (ignore bits undefined at reset)
+#define RST_CLKGAT_EN_RESET                                          0x000002e2
+
+
+
+#define PCIE_PHY_REG_1_ADDRESS                                       0x18116cc0
+#define PCIE_PHY_REG_3_ADDRESS                                       0x18116cc8
+
+
+
+
+
+#define LDO_POWER_CONTROL_PKG_SEL_MSB                                5
+#define LDO_POWER_CONTROL_PKG_SEL_LSB                                5
+#define LDO_POWER_CONTROL_PKG_SEL_MASK                               0x00000020
+#define LDO_POWER_CONTROL_PKG_SEL_GET(x)                             (((x) & LDO_POWER_CONTROL_PKG_SEL_MASK) >> LDO_POWER_CONTROL_PKG_SEL_LSB)
+#define LDO_POWER_CONTROL_PKG_SEL_SET(x)                             (((x) << LDO_POWER_CONTROL_PKG_SEL_LSB) & LDO_POWER_CONTROL_PKG_SEL_MASK)
+#define LDO_POWER_CONTROL_PKG_SEL_RESET                              0x0 // 0
+#define LDO_POWER_CONTROL_PWDLDO_CPU_MSB                             4
+#define LDO_POWER_CONTROL_PWDLDO_CPU_LSB                             4
+#define LDO_POWER_CONTROL_PWDLDO_CPU_MASK                            0x00000010
+#define LDO_POWER_CONTROL_PWDLDO_CPU_GET(x)                          (((x) & LDO_POWER_CONTROL_PWDLDO_CPU_MASK) >> LDO_POWER_CONTROL_PWDLDO_CPU_LSB)
+#define LDO_POWER_CONTROL_PWDLDO_CPU_SET(x)                          (((x) << LDO_POWER_CONTROL_PWDLDO_CPU_LSB) & LDO_POWER_CONTROL_PWDLDO_CPU_MASK)
+#define LDO_POWER_CONTROL_PWDLDO_CPU_RESET                           0x0 // 0
+#define LDO_POWER_CONTROL_PWDLDO_DDR_MSB                             3
+#define LDO_POWER_CONTROL_PWDLDO_DDR_LSB                             3
+#define LDO_POWER_CONTROL_PWDLDO_DDR_MASK                            0x00000008
+#define LDO_POWER_CONTROL_PWDLDO_DDR_GET(x)                          (((x) & LDO_POWER_CONTROL_PWDLDO_DDR_MASK) >> LDO_POWER_CONTROL_PWDLDO_DDR_LSB)
+#define LDO_POWER_CONTROL_PWDLDO_DDR_SET(x)                          (((x) << LDO_POWER_CONTROL_PWDLDO_DDR_LSB) & LDO_POWER_CONTROL_PWDLDO_DDR_MASK)
+#define LDO_POWER_CONTROL_PWDLDO_DDR_RESET                           0x0 // 0
+#define LDO_POWER_CONTROL_CPU_REFSEL_MSB                             2
+#define LDO_POWER_CONTROL_CPU_REFSEL_LSB                             1
+#define LDO_POWER_CONTROL_CPU_REFSEL_MASK                            0x00000006
+#define LDO_POWER_CONTROL_CPU_REFSEL_GET(x)                          (((x) & LDO_POWER_CONTROL_CPU_REFSEL_MASK) >> LDO_POWER_CONTROL_CPU_REFSEL_LSB)
+#define LDO_POWER_CONTROL_CPU_REFSEL_SET(x)                          (((x) << LDO_POWER_CONTROL_CPU_REFSEL_LSB) & LDO_POWER_CONTROL_CPU_REFSEL_MASK)
+#define LDO_POWER_CONTROL_CPU_REFSEL_RESET                           0x3 // 3
+#define LDO_POWER_CONTROL_SELECT_DDR1_MSB                            0
+#define LDO_POWER_CONTROL_SELECT_DDR1_LSB                            0
+#define LDO_POWER_CONTROL_SELECT_DDR1_MASK                           0x00000001
+#define LDO_POWER_CONTROL_SELECT_DDR1_GET(x)                         (((x) & LDO_POWER_CONTROL_SELECT_DDR1_MASK) >> LDO_POWER_CONTROL_SELECT_DDR1_LSB)
+#define LDO_POWER_CONTROL_SELECT_DDR1_SET(x)                         (((x) << LDO_POWER_CONTROL_SELECT_DDR1_LSB) & LDO_POWER_CONTROL_SELECT_DDR1_MASK)
+#define LDO_POWER_CONTROL_SELECT_DDR1_RESET                          0x0 // 0
+#define LDO_POWER_CONTROL_ADDRESS                                    0x18050020
+
+#define SWITCH_CLOCK_SPARE_SPARE_MSB                                 31
+#define SWITCH_CLOCK_SPARE_SPARE_LSB                                 12
+#define SWITCH_CLOCK_SPARE_SPARE_MASK                                0xfffff000
+#define SWITCH_CLOCK_SPARE_SPARE_GET(x)                              (((x) & SWITCH_CLOCK_SPARE_SPARE_MASK) >> SWITCH_CLOCK_SPARE_SPARE_LSB)
+#define SWITCH_CLOCK_SPARE_SPARE_SET(x)                              (((x) << SWITCH_CLOCK_SPARE_SPARE_LSB) & SWITCH_CLOCK_SPARE_SPARE_MASK)
+#define SWITCH_CLOCK_SPARE_SPARE_RESET                               0x0 // 0
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MSB                   11
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB                   8
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK                  0x00000f00
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_GET(x)                (((x) & SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK) >> SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(x)                (((x) << SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB) & SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_RESET                 0x5 // 5
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MSB                         7
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB                         7
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK                        0x00000080
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_GET(x)                      (((x) & SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_SET(x)                      (((x) << SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_RESET                       0x0 // 0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MSB                          6
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_LSB                          6
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MASK                         0x00000040
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_GET(x)                       (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_SET(x)                       (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_RESET                        0x0 // 0
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MSB                       5
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_LSB                       5
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MASK                      0x00000020
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MASK) >> SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_LSB)
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_LSB) & SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MASK)
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_RESET                     0x1 // 1
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_MSB                            4
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_LSB                            4
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_MASK                           0x00000010
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_GET(x)                         (((x) & SWITCH_CLOCK_SPARE_EN_PLL_TOP_MASK) >> SWITCH_CLOCK_SPARE_EN_PLL_TOP_LSB)
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_SET(x)                         (((x) << SWITCH_CLOCK_SPARE_EN_PLL_TOP_LSB) & SWITCH_CLOCK_SPARE_EN_PLL_TOP_MASK)
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_RESET                          0x1 // 1
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_MSB                            3
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_LSB                            3
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_MASK                           0x00000008
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_GET(x)                         (((x) & SWITCH_CLOCK_SPARE_EEE_ENABLE_MASK) >> SWITCH_CLOCK_SPARE_EEE_ENABLE_LSB)
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_SET(x)                         (((x) << SWITCH_CLOCK_SPARE_EEE_ENABLE_LSB) & SWITCH_CLOCK_SPARE_EEE_ENABLE_MASK)
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_RESET                          0x0 // 0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MSB             2
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_LSB             2
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MASK            0x00000004
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_GET(x)          (((x) & SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MASK) >> SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_LSB)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_SET(x)          (((x) << SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_LSB) & SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MASK)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_RESET           0x0 // 0
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MSB                  1
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_LSB                  1
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MASK                 0x00000002
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_GET(x)               (((x) & SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MASK) >> SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_LSB)
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_SET(x)               (((x) << SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_LSB) & SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MASK)
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_RESET                0x0 // 0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MSB                         0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_LSB                         0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MASK                        0x00000001
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_GET(x)                      (((x) & SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_SET(x)                      (((x) << SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_LSB) & SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_RESET                       0x1 // 1
+#define SWITCH_CLOCK_SPARE_ADDRESS                                   0x18050024
+
+#define CURRENT_PCIE_PLL_DITHER_INT_MSB                              20
+#define CURRENT_PCIE_PLL_DITHER_INT_LSB                              15
+#define CURRENT_PCIE_PLL_DITHER_INT_MASK                             0x001f8000
+#define CURRENT_PCIE_PLL_DITHER_INT_GET(x)                           (((x) & CURRENT_PCIE_PLL_DITHER_INT_MASK) >> CURRENT_PCIE_PLL_DITHER_INT_LSB)
+#define CURRENT_PCIE_PLL_DITHER_INT_SET(x)                           (((x) << CURRENT_PCIE_PLL_DITHER_INT_LSB) & CURRENT_PCIE_PLL_DITHER_INT_MASK)
+#define CURRENT_PCIE_PLL_DITHER_INT_RESET                            0x1 // 1
+#define CURRENT_PCIE_PLL_DITHER_FRAC_MSB                             13
+#define CURRENT_PCIE_PLL_DITHER_FRAC_LSB                             0
+#define CURRENT_PCIE_PLL_DITHER_FRAC_MASK                            0x00003fff
+#define CURRENT_PCIE_PLL_DITHER_FRAC_GET(x)                          (((x) & CURRENT_PCIE_PLL_DITHER_FRAC_MASK) >> CURRENT_PCIE_PLL_DITHER_FRAC_LSB)
+#define CURRENT_PCIE_PLL_DITHER_FRAC_SET(x)                          (((x) << CURRENT_PCIE_PLL_DITHER_FRAC_LSB) & CURRENT_PCIE_PLL_DITHER_FRAC_MASK)
+#define CURRENT_PCIE_PLL_DITHER_FRAC_RESET                           0x0 // 0
+#define CURRENT_PCIE_PLL_DITHER_ADDRESS                              0x18050028
+
+#define ETH_XMII_TX_INVERT_MSB                                       31
+#define ETH_XMII_TX_INVERT_LSB                                       31
+#define ETH_XMII_TX_INVERT_MASK                                      0x80000000
+#define ETH_XMII_TX_INVERT_GET(x)                                    (((x) & ETH_XMII_TX_INVERT_MASK) >> ETH_XMII_TX_INVERT_LSB)
+#define ETH_XMII_TX_INVERT_SET(x)                                    (((x) << ETH_XMII_TX_INVERT_LSB) & ETH_XMII_TX_INVERT_MASK)
+#define ETH_XMII_TX_INVERT_RESET                                     0x0 // 0
+#define ETH_XMII_GIGE_QUAD_MSB                                       30
+#define ETH_XMII_GIGE_QUAD_LSB                                       30
+#define ETH_XMII_GIGE_QUAD_MASK                                      0x40000000
+#define ETH_XMII_GIGE_QUAD_GET(x)                                    (((x) & ETH_XMII_GIGE_QUAD_MASK) >> ETH_XMII_GIGE_QUAD_LSB)
+#define ETH_XMII_GIGE_QUAD_SET(x)                                    (((x) << ETH_XMII_GIGE_QUAD_LSB) & ETH_XMII_GIGE_QUAD_MASK)
+#define ETH_XMII_GIGE_QUAD_RESET                                     0x0 // 0
+#define ETH_XMII_RX_DELAY_MSB                                        29
+#define ETH_XMII_RX_DELAY_LSB                                        28
+#define ETH_XMII_RX_DELAY_MASK                                       0x30000000
+#define ETH_XMII_RX_DELAY_GET(x)                                     (((x) & ETH_XMII_RX_DELAY_MASK) >> ETH_XMII_RX_DELAY_LSB)
+#define ETH_XMII_RX_DELAY_SET(x)                                     (((x) << ETH_XMII_RX_DELAY_LSB) & ETH_XMII_RX_DELAY_MASK)
+#define ETH_XMII_RX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_TX_DELAY_MSB                                        27
+#define ETH_XMII_TX_DELAY_LSB                                        26
+#define ETH_XMII_TX_DELAY_MASK                                       0x0c000000
+#define ETH_XMII_TX_DELAY_GET(x)                                     (((x) & ETH_XMII_TX_DELAY_MASK) >> ETH_XMII_TX_DELAY_LSB)
+#define ETH_XMII_TX_DELAY_SET(x)                                     (((x) << ETH_XMII_TX_DELAY_LSB) & ETH_XMII_TX_DELAY_MASK)
+#define ETH_XMII_TX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_GIGE_MSB                                            25
+#define ETH_XMII_GIGE_LSB                                            25
+#define ETH_XMII_GIGE_MASK                                           0x02000000
+#define ETH_XMII_GIGE_GET(x)                                         (((x) & ETH_XMII_GIGE_MASK) >> ETH_XMII_GIGE_LSB)
+#define ETH_XMII_GIGE_SET(x)                                         (((x) << ETH_XMII_GIGE_LSB) & ETH_XMII_GIGE_MASK)
+#define ETH_XMII_GIGE_RESET                                          0x0 // 0
+#define ETH_XMII_OFFSET_PHASE_MSB                                    24
+#define ETH_XMII_OFFSET_PHASE_LSB                                    24
+#define ETH_XMII_OFFSET_PHASE_MASK                                   0x01000000
+#define ETH_XMII_OFFSET_PHASE_GET(x)                                 (((x) & ETH_XMII_OFFSET_PHASE_MASK) >> ETH_XMII_OFFSET_PHASE_LSB)
+#define ETH_XMII_OFFSET_PHASE_SET(x)                                 (((x) << ETH_XMII_OFFSET_PHASE_LSB) & ETH_XMII_OFFSET_PHASE_MASK)
+#define ETH_XMII_OFFSET_PHASE_RESET                                  0x0 // 0
+#define ETH_XMII_OFFSET_COUNT_MSB                                    23
+#define ETH_XMII_OFFSET_COUNT_LSB                                    16
+#define ETH_XMII_OFFSET_COUNT_MASK                                   0x00ff0000
+#define ETH_XMII_OFFSET_COUNT_GET(x)                                 (((x) & ETH_XMII_OFFSET_COUNT_MASK) >> ETH_XMII_OFFSET_COUNT_LSB)
+#define ETH_XMII_OFFSET_COUNT_SET(x)                                 (((x) << ETH_XMII_OFFSET_COUNT_LSB) & ETH_XMII_OFFSET_COUNT_MASK)
+#define ETH_XMII_OFFSET_COUNT_RESET                                  0x0 // 0
+#define ETH_XMII_PHASE1_COUNT_MSB                                    15
+#define ETH_XMII_PHASE1_COUNT_LSB                                    8
+#define ETH_XMII_PHASE1_COUNT_MASK                                   0x0000ff00
+#define ETH_XMII_PHASE1_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE1_COUNT_MASK) >> ETH_XMII_PHASE1_COUNT_LSB)
+#define ETH_XMII_PHASE1_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE1_COUNT_LSB) & ETH_XMII_PHASE1_COUNT_MASK)
+#define ETH_XMII_PHASE1_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_PHASE0_COUNT_MSB                                    7
+#define ETH_XMII_PHASE0_COUNT_LSB                                    0
+#define ETH_XMII_PHASE0_COUNT_MASK                                   0x000000ff
+#define ETH_XMII_PHASE0_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE0_COUNT_MASK) >> ETH_XMII_PHASE0_COUNT_LSB)
+#define ETH_XMII_PHASE0_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE0_COUNT_LSB) & ETH_XMII_PHASE0_COUNT_MASK)
+#define ETH_XMII_PHASE0_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_ADDRESS                                             0x1805002c
+
+#define BB_PLL_CONFIG_UPDATING_MSB                                   31
+#define BB_PLL_CONFIG_UPDATING_LSB                                   31
+#define BB_PLL_CONFIG_UPDATING_MASK                                  0x80000000
+#define BB_PLL_CONFIG_UPDATING_GET(x)                                (((x) & BB_PLL_CONFIG_UPDATING_MASK) >> BB_PLL_CONFIG_UPDATING_LSB)
+#define BB_PLL_CONFIG_UPDATING_SET(x)                                (((x) << BB_PLL_CONFIG_UPDATING_LSB) & BB_PLL_CONFIG_UPDATING_MASK)
+#define BB_PLL_CONFIG_UPDATING_RESET                                 0x1 // 1
+#define BB_PLL_CONFIG_PLLPWD_MSB                                     30
+#define BB_PLL_CONFIG_PLLPWD_LSB                                     30
+#define BB_PLL_CONFIG_PLLPWD_MASK                                    0x40000000
+#define BB_PLL_CONFIG_PLLPWD_GET(x)                                  (((x) & BB_PLL_CONFIG_PLLPWD_MASK) >> BB_PLL_CONFIG_PLLPWD_LSB)
+#define BB_PLL_CONFIG_PLLPWD_SET(x)                                  (((x) << BB_PLL_CONFIG_PLLPWD_LSB) & BB_PLL_CONFIG_PLLPWD_MASK)
+#define BB_PLL_CONFIG_PLLPWD_RESET                                   0x1 // 1
+#define BB_PLL_CONFIG_SPARE_MSB                                      29
+#define BB_PLL_CONFIG_SPARE_LSB                                      29
+#define BB_PLL_CONFIG_SPARE_MASK                                     0x20000000
+#define BB_PLL_CONFIG_SPARE_GET(x)                                   (((x) & BB_PLL_CONFIG_SPARE_MASK) >> BB_PLL_CONFIG_SPARE_LSB)
+#define BB_PLL_CONFIG_SPARE_SET(x)                                   (((x) << BB_PLL_CONFIG_SPARE_LSB) & BB_PLL_CONFIG_SPARE_MASK)
+#define BB_PLL_CONFIG_SPARE_RESET                                    0x0 // 0
+#define BB_PLL_CONFIG_REFDIV_MSB                                     28
+#define BB_PLL_CONFIG_REFDIV_LSB                                     24
+#define BB_PLL_CONFIG_REFDIV_MASK                                    0x1f000000
+#define BB_PLL_CONFIG_REFDIV_GET(x)                                  (((x) & BB_PLL_CONFIG_REFDIV_MASK) >> BB_PLL_CONFIG_REFDIV_LSB)
+#define BB_PLL_CONFIG_REFDIV_SET(x)                                  (((x) << BB_PLL_CONFIG_REFDIV_LSB) & BB_PLL_CONFIG_REFDIV_MASK)
+#define BB_PLL_CONFIG_REFDIV_RESET                                   0x1 // 1
+#define BB_PLL_CONFIG_NINT_MSB                                       21
+#define BB_PLL_CONFIG_NINT_LSB                                       16
+#define BB_PLL_CONFIG_NINT_MASK                                      0x003f0000
+#define BB_PLL_CONFIG_NINT_GET(x)                                    (((x) & BB_PLL_CONFIG_NINT_MASK) >> BB_PLL_CONFIG_NINT_LSB)
+#define BB_PLL_CONFIG_NINT_SET(x)                                    (((x) << BB_PLL_CONFIG_NINT_LSB) & BB_PLL_CONFIG_NINT_MASK)
+#define BB_PLL_CONFIG_NINT_RESET                                     0x2 // 2
+#define BB_PLL_CONFIG_NFRAC_MSB                                      13
+#define BB_PLL_CONFIG_NFRAC_LSB                                      0
+#define BB_PLL_CONFIG_NFRAC_MASK                                     0x00003fff
+#define BB_PLL_CONFIG_NFRAC_GET(x)                                   (((x) & BB_PLL_CONFIG_NFRAC_MASK) >> BB_PLL_CONFIG_NFRAC_LSB)
+#define BB_PLL_CONFIG_NFRAC_SET(x)                                   (((x) << BB_PLL_CONFIG_NFRAC_LSB) & BB_PLL_CONFIG_NFRAC_MASK)
+#define BB_PLL_CONFIG_NFRAC_RESET                                    0xccc // 3276
+#define BB_PLL_CONFIG_ADDRESS                                        0x18050040
+
+#define DDR_PLL_DITHER_DITHER_EN_MSB                                 31
+#define DDR_PLL_DITHER_DITHER_EN_LSB                                 31
+#define DDR_PLL_DITHER_DITHER_EN_MASK                                0x80000000
+#define DDR_PLL_DITHER_DITHER_EN_GET(x)                              (((x) & DDR_PLL_DITHER_DITHER_EN_MASK) >> DDR_PLL_DITHER_DITHER_EN_LSB)
+#define DDR_PLL_DITHER_DITHER_EN_SET(x)                              (((x) << DDR_PLL_DITHER_DITHER_EN_LSB) & DDR_PLL_DITHER_DITHER_EN_MASK)
+#define DDR_PLL_DITHER_DITHER_EN_RESET                               0x0 // 0
+#define DDR_PLL_DITHER_UPDATE_COUNT_MSB                              30
+#define DDR_PLL_DITHER_UPDATE_COUNT_LSB                              27
+#define DDR_PLL_DITHER_UPDATE_COUNT_MASK                             0x78000000
+#define DDR_PLL_DITHER_UPDATE_COUNT_GET(x)                           (((x) & DDR_PLL_DITHER_UPDATE_COUNT_MASK) >> DDR_PLL_DITHER_UPDATE_COUNT_LSB)
+#define DDR_PLL_DITHER_UPDATE_COUNT_SET(x)                           (((x) << DDR_PLL_DITHER_UPDATE_COUNT_LSB) & DDR_PLL_DITHER_UPDATE_COUNT_MASK)
+#define DDR_PLL_DITHER_UPDATE_COUNT_RESET                            0xf // 15
+#define DDR_PLL_DITHER_NFRAC_STEP_MSB                                26
+#define DDR_PLL_DITHER_NFRAC_STEP_LSB                                20
+#define DDR_PLL_DITHER_NFRAC_STEP_MASK                               0x07f00000
+#define DDR_PLL_DITHER_NFRAC_STEP_GET(x)                             (((x) & DDR_PLL_DITHER_NFRAC_STEP_MASK) >> DDR_PLL_DITHER_NFRAC_STEP_LSB)
+#define DDR_PLL_DITHER_NFRAC_STEP_SET(x)                             (((x) << DDR_PLL_DITHER_NFRAC_STEP_LSB) & DDR_PLL_DITHER_NFRAC_STEP_MASK)
+#define DDR_PLL_DITHER_NFRAC_STEP_RESET                              0x1 // 1
+#define DDR_PLL_DITHER_NFRAC_MIN_MSB                                 19
+#define DDR_PLL_DITHER_NFRAC_MIN_LSB                                 10
+#define DDR_PLL_DITHER_NFRAC_MIN_MASK                                0x000ffc00
+#define DDR_PLL_DITHER_NFRAC_MIN_GET(x)                              (((x) & DDR_PLL_DITHER_NFRAC_MIN_MASK) >> DDR_PLL_DITHER_NFRAC_MIN_LSB)
+#define DDR_PLL_DITHER_NFRAC_MIN_SET(x)                              (((x) << DDR_PLL_DITHER_NFRAC_MIN_LSB) & DDR_PLL_DITHER_NFRAC_MIN_MASK)
+#define DDR_PLL_DITHER_NFRAC_MIN_RESET                               0x19 // 25
+#define DDR_PLL_DITHER_NFRAC_MAX_MSB                                 9
+#define DDR_PLL_DITHER_NFRAC_MAX_LSB                                 0
+#define DDR_PLL_DITHER_NFRAC_MAX_MASK                                0x000003ff
+#define DDR_PLL_DITHER_NFRAC_MAX_GET(x)                              (((x) & DDR_PLL_DITHER_NFRAC_MAX_MASK) >> DDR_PLL_DITHER_NFRAC_MAX_LSB)
+#define DDR_PLL_DITHER_NFRAC_MAX_SET(x)                              (((x) << DDR_PLL_DITHER_NFRAC_MAX_LSB) & DDR_PLL_DITHER_NFRAC_MAX_MASK)
+#define DDR_PLL_DITHER_NFRAC_MAX_RESET                               0x3e8 // 1000
+#define DDR_PLL_DITHER_ADDRESS                                       0x18050044
+
+#define CPU_PLL_DITHER_DITHER_EN_MSB                                 31
+#define CPU_PLL_DITHER_DITHER_EN_LSB                                 31
+#define CPU_PLL_DITHER_DITHER_EN_MASK                                0x80000000
+#define CPU_PLL_DITHER_DITHER_EN_GET(x)                              (((x) & CPU_PLL_DITHER_DITHER_EN_MASK) >> CPU_PLL_DITHER_DITHER_EN_LSB)
+#define CPU_PLL_DITHER_DITHER_EN_SET(x)                              (((x) << CPU_PLL_DITHER_DITHER_EN_LSB) & CPU_PLL_DITHER_DITHER_EN_MASK)
+#define CPU_PLL_DITHER_DITHER_EN_RESET                               0x0 // 0
+#define CPU_PLL_DITHER_UPDATE_COUNT_MSB                              23
+#define CPU_PLL_DITHER_UPDATE_COUNT_LSB                              18
+#define CPU_PLL_DITHER_UPDATE_COUNT_MASK                             0x00fc0000
+#define CPU_PLL_DITHER_UPDATE_COUNT_GET(x)                           (((x) & CPU_PLL_DITHER_UPDATE_COUNT_MASK) >> CPU_PLL_DITHER_UPDATE_COUNT_LSB)
+#define CPU_PLL_DITHER_UPDATE_COUNT_SET(x)                           (((x) << CPU_PLL_DITHER_UPDATE_COUNT_LSB) & CPU_PLL_DITHER_UPDATE_COUNT_MASK)
+#define CPU_PLL_DITHER_UPDATE_COUNT_RESET                            0x14 // 20
+#define CPU_PLL_DITHER_NFRAC_STEP_MSB                                17
+#define CPU_PLL_DITHER_NFRAC_STEP_LSB                                12
+#define CPU_PLL_DITHER_NFRAC_STEP_MASK                               0x0003f000
+#define CPU_PLL_DITHER_NFRAC_STEP_GET(x)                             (((x) & CPU_PLL_DITHER_NFRAC_STEP_MASK) >> CPU_PLL_DITHER_NFRAC_STEP_LSB)
+#define CPU_PLL_DITHER_NFRAC_STEP_SET(x)                             (((x) << CPU_PLL_DITHER_NFRAC_STEP_LSB) & CPU_PLL_DITHER_NFRAC_STEP_MASK)
+#define CPU_PLL_DITHER_NFRAC_STEP_RESET                              0x1 // 1
+#define CPU_PLL_DITHER_NFRAC_MIN_MSB                                 11
+#define CPU_PLL_DITHER_NFRAC_MIN_LSB                                 6
+#define CPU_PLL_DITHER_NFRAC_MIN_MASK                                0x00000fc0
+#define CPU_PLL_DITHER_NFRAC_MIN_GET(x)                              (((x) & CPU_PLL_DITHER_NFRAC_MIN_MASK) >> CPU_PLL_DITHER_NFRAC_MIN_LSB)
+#define CPU_PLL_DITHER_NFRAC_MIN_SET(x)                              (((x) << CPU_PLL_DITHER_NFRAC_MIN_LSB) & CPU_PLL_DITHER_NFRAC_MIN_MASK)
+#define CPU_PLL_DITHER_NFRAC_MIN_RESET                               0x3 // 3
+#define CPU_PLL_DITHER_NFRAC_MAX_MSB                                 5
+#define CPU_PLL_DITHER_NFRAC_MAX_LSB                                 0
+#define CPU_PLL_DITHER_NFRAC_MAX_MASK                                0x0000003f
+#define CPU_PLL_DITHER_NFRAC_MAX_GET(x)                              (((x) & CPU_PLL_DITHER_NFRAC_MAX_MASK) >> CPU_PLL_DITHER_NFRAC_MAX_LSB)
+#define CPU_PLL_DITHER_NFRAC_MAX_SET(x)                              (((x) << CPU_PLL_DITHER_NFRAC_MAX_LSB) & CPU_PLL_DITHER_NFRAC_MAX_MASK)
+#define CPU_PLL_DITHER_NFRAC_MAX_RESET                               0x3c // 60
+#define CPU_PLL_DITHER_ADDRESS                                       0x18050048
+
+#define RST_RESET_USB_EXT_PWR_SEQ_MSB                                29
+#define RST_RESET_USB_EXT_PWR_SEQ_LSB                                29
+#define RST_RESET_USB_EXT_PWR_SEQ_MASK                               0x20000000
+#define RST_RESET_USB_EXT_PWR_SEQ_GET(x)                             (((x) & RST_RESET_USB_EXT_PWR_SEQ_MASK) >> RST_RESET_USB_EXT_PWR_SEQ_LSB)
+#define RST_RESET_USB_EXT_PWR_SEQ_SET(x)                             (((x) << RST_RESET_USB_EXT_PWR_SEQ_LSB) & RST_RESET_USB_EXT_PWR_SEQ_MASK)
+#define RST_RESET_USB_EXT_PWR_SEQ_RESET                              0x1 // 1
+#define RST_RESET_EXTERNAL_RESET_MSB                                 28
+#define RST_RESET_EXTERNAL_RESET_LSB                                 28
+#define RST_RESET_EXTERNAL_RESET_MASK                                0x10000000
+#define RST_RESET_EXTERNAL_RESET_GET(x)                              (((x) & RST_RESET_EXTERNAL_RESET_MASK) >> RST_RESET_EXTERNAL_RESET_LSB)
+#define RST_RESET_EXTERNAL_RESET_SET(x)                              (((x) << RST_RESET_EXTERNAL_RESET_LSB) & RST_RESET_EXTERNAL_RESET_MASK)
+#define RST_RESET_EXTERNAL_RESET_RESET                               0x0 // 0
+#define RST_RESET_RTC_RESET_MSB                                      27
+#define RST_RESET_RTC_RESET_LSB                                      27
+#define RST_RESET_RTC_RESET_MASK                                     0x08000000
+#define RST_RESET_RTC_RESET_GET(x)                                   (((x) & RST_RESET_RTC_RESET_MASK) >> RST_RESET_RTC_RESET_LSB)
+#define RST_RESET_RTC_RESET_SET(x)                                   (((x) << RST_RESET_RTC_RESET_LSB) & RST_RESET_RTC_RESET_MASK)
+#define RST_RESET_RTC_RESET_RESET                                    0x1 // 1
+#define RST_RESET_FULL_CHIP_RESET_MSB                                24
+#define RST_RESET_FULL_CHIP_RESET_LSB                                24
+#define RST_RESET_FULL_CHIP_RESET_MASK                               0x01000000
+#define RST_RESET_FULL_CHIP_RESET_GET(x)                             (((x) & RST_RESET_FULL_CHIP_RESET_MASK) >> RST_RESET_FULL_CHIP_RESET_LSB)
+#define RST_RESET_FULL_CHIP_RESET_SET(x)                             (((x) << RST_RESET_FULL_CHIP_RESET_LSB) & RST_RESET_FULL_CHIP_RESET_MASK)
+#define RST_RESET_FULL_CHIP_RESET_RESET                              0x0 // 0
+#define RST_RESET_GE1_MDIO_RESET_MSB                                 23
+#define RST_RESET_GE1_MDIO_RESET_LSB                                 23
+#define RST_RESET_GE1_MDIO_RESET_MASK                                0x00800000
+#define RST_RESET_GE1_MDIO_RESET_GET(x)                              (((x) & RST_RESET_GE1_MDIO_RESET_MASK) >> RST_RESET_GE1_MDIO_RESET_LSB)
+#define RST_RESET_GE1_MDIO_RESET_SET(x)                              (((x) << RST_RESET_GE1_MDIO_RESET_LSB) & RST_RESET_GE1_MDIO_RESET_MASK)
+#define RST_RESET_GE1_MDIO_RESET_RESET                               0x1 // 1
+#define RST_RESET_GE0_MDIO_RESET_MSB                                 22
+#define RST_RESET_GE0_MDIO_RESET_LSB                                 22
+#define RST_RESET_GE0_MDIO_RESET_MASK                                0x00400000
+#define RST_RESET_GE0_MDIO_RESET_GET(x)                              (((x) & RST_RESET_GE0_MDIO_RESET_MASK) >> RST_RESET_GE0_MDIO_RESET_LSB)
+#define RST_RESET_GE0_MDIO_RESET_SET(x)                              (((x) << RST_RESET_GE0_MDIO_RESET_LSB) & RST_RESET_GE0_MDIO_RESET_MASK)
+#define RST_RESET_GE0_MDIO_RESET_RESET                               0x1 // 1
+#define RST_RESET_CPU_NMI_MSB                                        21
+#define RST_RESET_CPU_NMI_LSB                                        21
+#define RST_RESET_CPU_NMI_MASK                                       0x00200000
+#define RST_RESET_CPU_NMI_GET(x)                                     (((x) & RST_RESET_CPU_NMI_MASK) >> RST_RESET_CPU_NMI_LSB)
+#define RST_RESET_CPU_NMI_SET(x)                                     (((x) << RST_RESET_CPU_NMI_LSB) & RST_RESET_CPU_NMI_MASK)
+#define RST_RESET_CPU_NMI_RESET                                      0x0 // 0
+#define RST_RESET_CPU_COLD_RESET_MSB                                 20
+#define RST_RESET_CPU_COLD_RESET_LSB                                 20
+#define RST_RESET_CPU_COLD_RESET_MASK                                0x00100000
+#define RST_RESET_CPU_COLD_RESET_GET(x)                              (((x) & RST_RESET_CPU_COLD_RESET_MASK) >> RST_RESET_CPU_COLD_RESET_LSB)
+#define RST_RESET_CPU_COLD_RESET_SET(x)                              (((x) << RST_RESET_CPU_COLD_RESET_LSB) & RST_RESET_CPU_COLD_RESET_MASK)
+#define RST_RESET_CPU_COLD_RESET_RESET                               0x0 // 0
+#define RST_RESET_DDR_RESET_MSB                                      16
+#define RST_RESET_DDR_RESET_LSB                                      16
+#define RST_RESET_DDR_RESET_MASK                                     0x00010000
+#define RST_RESET_DDR_RESET_GET(x)                                   (((x) & RST_RESET_DDR_RESET_MASK) >> RST_RESET_DDR_RESET_LSB)
+#define RST_RESET_DDR_RESET_SET(x)                                   (((x) << RST_RESET_DDR_RESET_LSB) & RST_RESET_DDR_RESET_MASK)
+#define RST_RESET_DDR_RESET_RESET                                    0x0 // 0
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_MSB                            15
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_LSB                            15
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_MASK                           0x00008000
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_GET(x)                         (((x) & RST_RESET_USB_PHY_PLL_PWD_EXT_MASK) >> RST_RESET_USB_PHY_PLL_PWD_EXT_LSB)
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_SET(x)                         (((x) << RST_RESET_USB_PHY_PLL_PWD_EXT_LSB) & RST_RESET_USB_PHY_PLL_PWD_EXT_MASK)
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_RESET                          0x0 // 0
+#define RST_RESET_GE1_MAC_RESET_MSB                                  13
+#define RST_RESET_GE1_MAC_RESET_LSB                                  13
+#define RST_RESET_GE1_MAC_RESET_MASK                                 0x00002000
+#define RST_RESET_GE1_MAC_RESET_GET(x)                               (((x) & RST_RESET_GE1_MAC_RESET_MASK) >> RST_RESET_GE1_MAC_RESET_LSB)
+#define RST_RESET_GE1_MAC_RESET_SET(x)                               (((x) << RST_RESET_GE1_MAC_RESET_LSB) & RST_RESET_GE1_MAC_RESET_MASK)
+#define RST_RESET_GE1_MAC_RESET_RESET                                0x1 // 1
+#define RST_RESET_ETH_SWITCH_ARESET_MSB                              12
+#define RST_RESET_ETH_SWITCH_ARESET_LSB                              12
+#define RST_RESET_ETH_SWITCH_ARESET_MASK                             0x00001000
+#define RST_RESET_ETH_SWITCH_ARESET_GET(x)                           (((x) & RST_RESET_ETH_SWITCH_ARESET_MASK) >> RST_RESET_ETH_SWITCH_ARESET_LSB)
+#define RST_RESET_ETH_SWITCH_ARESET_SET(x)                           (((x) << RST_RESET_ETH_SWITCH_ARESET_LSB) & RST_RESET_ETH_SWITCH_ARESET_MASK)
+#define RST_RESET_ETH_SWITCH_ARESET_RESET                            0x1 // 1
+#define RST_RESET_USB_PHY_ARESET_MSB                                 11
+#define RST_RESET_USB_PHY_ARESET_LSB                                 11
+#define RST_RESET_USB_PHY_ARESET_MASK                                0x00000800
+#define RST_RESET_USB_PHY_ARESET_GET(x)                              (((x) & RST_RESET_USB_PHY_ARESET_MASK) >> RST_RESET_USB_PHY_ARESET_LSB)
+#define RST_RESET_USB_PHY_ARESET_SET(x)                              (((x) << RST_RESET_USB_PHY_ARESET_LSB) & RST_RESET_USB_PHY_ARESET_MASK)
+#define RST_RESET_USB_PHY_ARESET_RESET                               0x1 // 1
+#define RST_RESET_GE0_MAC_RESET_MSB                                  9
+#define RST_RESET_GE0_MAC_RESET_LSB                                  9
+#define RST_RESET_GE0_MAC_RESET_MASK                                 0x00000200
+#define RST_RESET_GE0_MAC_RESET_GET(x)                               (((x) & RST_RESET_GE0_MAC_RESET_MASK) >> RST_RESET_GE0_MAC_RESET_LSB)
+#define RST_RESET_GE0_MAC_RESET_SET(x)                               (((x) << RST_RESET_GE0_MAC_RESET_LSB) & RST_RESET_GE0_MAC_RESET_MASK)
+#define RST_RESET_GE0_MAC_RESET_RESET                                0x1 // 1
+#define RST_RESET_ETH_SWITCH_RESET_MSB                               8
+#define RST_RESET_ETH_SWITCH_RESET_LSB                               8
+#define RST_RESET_ETH_SWITCH_RESET_MASK                              0x00000100
+#define RST_RESET_ETH_SWITCH_RESET_GET(x)                            (((x) & RST_RESET_ETH_SWITCH_RESET_MASK) >> RST_RESET_ETH_SWITCH_RESET_LSB)
+#define RST_RESET_ETH_SWITCH_RESET_SET(x)                            (((x) << RST_RESET_ETH_SWITCH_RESET_LSB) & RST_RESET_ETH_SWITCH_RESET_MASK)
+#define RST_RESET_ETH_SWITCH_RESET_RESET                             0x1 // 1
+#define RST_RESET_PCIE_PHY_RESET_MSB                                 7
+#define RST_RESET_PCIE_PHY_RESET_LSB                                 7
+#define RST_RESET_PCIE_PHY_RESET_MASK                                0x00000080
+#define RST_RESET_PCIE_PHY_RESET_GET(x)                              (((x) & RST_RESET_PCIE_PHY_RESET_MASK) >> RST_RESET_PCIE_PHY_RESET_LSB)
+#define RST_RESET_PCIE_PHY_RESET_SET(x)                              (((x) << RST_RESET_PCIE_PHY_RESET_LSB) & RST_RESET_PCIE_PHY_RESET_MASK)
+#define RST_RESET_PCIE_PHY_RESET_RESET                               0x1 // 1
+#define RST_RESET_PCIE_RESET_MSB                                     6
+#define RST_RESET_PCIE_RESET_LSB                                     6
+#define RST_RESET_PCIE_RESET_MASK                                    0x00000040
+#define RST_RESET_PCIE_RESET_GET(x)                                  (((x) & RST_RESET_PCIE_RESET_MASK) >> RST_RESET_PCIE_RESET_LSB)
+#define RST_RESET_PCIE_RESET_SET(x)                                  (((x) << RST_RESET_PCIE_RESET_LSB) & RST_RESET_PCIE_RESET_MASK)
+#define RST_RESET_PCIE_RESET_RESET                                   0x1 // 1
+#define RST_RESET_USB_HOST_RESET_MSB                                 5
+#define RST_RESET_USB_HOST_RESET_LSB                                 5
+#define RST_RESET_USB_HOST_RESET_MASK                                0x00000020
+#define RST_RESET_USB_HOST_RESET_GET(x)                              (((x) & RST_RESET_USB_HOST_RESET_MASK) >> RST_RESET_USB_HOST_RESET_LSB)
+#define RST_RESET_USB_HOST_RESET_SET(x)                              (((x) << RST_RESET_USB_HOST_RESET_LSB) & RST_RESET_USB_HOST_RESET_MASK)
+#define RST_RESET_USB_HOST_RESET_RESET                               0x1 // 1
+#define RST_RESET_USB_PHY_RESET_MSB                                  4
+#define RST_RESET_USB_PHY_RESET_LSB                                  4
+#define RST_RESET_USB_PHY_RESET_MASK                                 0x00000010
+#define RST_RESET_USB_PHY_RESET_GET(x)                               (((x) & RST_RESET_USB_PHY_RESET_MASK) >> RST_RESET_USB_PHY_RESET_LSB)
+#define RST_RESET_USB_PHY_RESET_SET(x)                               (((x) << RST_RESET_USB_PHY_RESET_LSB) & RST_RESET_USB_PHY_RESET_MASK)
+#define RST_RESET_USB_PHY_RESET_RESET                                0x1 // 1
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MSB                       3
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB                       3
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK                      0x00000008
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_GET(x)                    (((x) & RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK) >> RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB)
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(x)                    (((x) << RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB) & RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK)
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_RESET                     0x0 // 0
+#define RST_RESET_ADDRESS                                            0x1806001c
+
+
+#define RST_MISC2_SPARE_MSB                                          31
+#define RST_MISC2_SPARE_LSB                                          26
+#define RST_MISC2_SPARE_MASK                                         0xfc000000
+#define RST_MISC2_SPARE_GET(x)                                       (((x) & RST_MISC2_SPARE_MASK) >> RST_MISC2_SPARE_LSB)
+#define RST_MISC2_SPARE_SET(x)                                       (((x) << RST_MISC2_SPARE_LSB) & RST_MISC2_SPARE_MASK)
+#define RST_MISC2_SPARE_RESET                                        0x0 // 0
+#define RST_MISC2_PCIE_CLKOBS1_SEL_MSB                               19
+#define RST_MISC2_PCIE_CLKOBS1_SEL_LSB                               19
+#define RST_MISC2_PCIE_CLKOBS1_SEL_MASK                              0x00080000
+#define RST_MISC2_PCIE_CLKOBS1_SEL_GET(x)                            (((x) & RST_MISC2_PCIE_CLKOBS1_SEL_MASK) >> RST_MISC2_PCIE_CLKOBS1_SEL_LSB)
+#define RST_MISC2_PCIE_CLKOBS1_SEL_SET(x)                            (((x) << RST_MISC2_PCIE_CLKOBS1_SEL_LSB) & RST_MISC2_PCIE_CLKOBS1_SEL_MASK)
+#define RST_MISC2_PCIE_CLKOBS1_SEL_RESET                             0x0 // 0
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_MSB                           18
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_LSB                           18
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_MASK                          0x00040000
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_GET(x)                        (((x) & RST_MISC2_EXT_HOST_WASP_RST_EN_MASK) >> RST_MISC2_EXT_HOST_WASP_RST_EN_LSB)
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_SET(x)                        (((x) << RST_MISC2_EXT_HOST_WASP_RST_EN_LSB) & RST_MISC2_EXT_HOST_WASP_RST_EN_MASK)
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_RESET                         0x0 // 0
+#define RST_MISC2_PERSTN_RCPHY_MSB                                   13
+#define RST_MISC2_PERSTN_RCPHY_LSB                                   13
+#define RST_MISC2_PERSTN_RCPHY_MASK                                  0x00002000
+#define RST_MISC2_PERSTN_RCPHY_GET(x)                                (((x) & RST_MISC2_PERSTN_RCPHY_MASK) >> RST_MISC2_PERSTN_RCPHY_LSB)
+#define RST_MISC2_PERSTN_RCPHY_SET(x)                                (((x) << RST_MISC2_PERSTN_RCPHY_LSB) & RST_MISC2_PERSTN_RCPHY_MASK)
+#define RST_MISC2_PERSTN_RCPHY_RESET                                 0x1 // 1
+#define RST_MISC2_RESERVED_MSB                                       3
+#define RST_MISC2_RESERVED_LSB                                       1
+#define RST_MISC2_RESERVED_MASK                                      0x0000000e
+#define RST_MISC2_RESERVED_GET(x)                                    (((x) & RST_MISC2_RESERVED_MASK) >> RST_MISC2_RESERVED_LSB)
+#define RST_MISC2_RESERVED_SET(x)                                    (((x) << RST_MISC2_RESERVED_LSB) & RST_MISC2_RESERVED_MASK)
+#define RST_MISC2_RESERVED_RESET                                     0x0 // 0
+#define RST_MISC2_ADDRESS                                            0x180600bc
+
+#define PCIE_APP_CFG_TYPE_MSB                                        21
+#define PCIE_APP_CFG_TYPE_LSB                                        20
+#define PCIE_APP_CFG_TYPE_MASK                                       0x00300000
+#define PCIE_APP_CFG_TYPE_GET(x)                                     (((x) & PCIE_APP_CFG_TYPE_MASK) >> PCIE_APP_CFG_TYPE_LSB)
+#define PCIE_APP_CFG_TYPE_SET(x)                                     (((x) << PCIE_APP_CFG_TYPE_LSB) & PCIE_APP_CFG_TYPE_MASK)
+#define PCIE_APP_CFG_TYPE_RESET                                      0x0 // 0
+#define PCIE_APP_PCIE_BAR_MSN_MSB                                    19
+#define PCIE_APP_PCIE_BAR_MSN_LSB                                    16
+#define PCIE_APP_PCIE_BAR_MSN_MASK                                   0x000f0000
+#define PCIE_APP_PCIE_BAR_MSN_GET(x)                                 (((x) & PCIE_APP_PCIE_BAR_MSN_MASK) >> PCIE_APP_PCIE_BAR_MSN_LSB)
+#define PCIE_APP_PCIE_BAR_MSN_SET(x)                                 (((x) << PCIE_APP_PCIE_BAR_MSN_LSB) & PCIE_APP_PCIE_BAR_MSN_MASK)
+#define PCIE_APP_PCIE_BAR_MSN_RESET                                  0x1 // 1
+#define PCIE_APP_CFG_BE_MSB                                          15
+#define PCIE_APP_CFG_BE_LSB                                          12
+#define PCIE_APP_CFG_BE_MASK                                         0x0000f000
+#define PCIE_APP_CFG_BE_GET(x)                                       (((x) & PCIE_APP_CFG_BE_MASK) >> PCIE_APP_CFG_BE_LSB)
+#define PCIE_APP_CFG_BE_SET(x)                                       (((x) << PCIE_APP_CFG_BE_LSB) & PCIE_APP_CFG_BE_MASK)
+#define PCIE_APP_CFG_BE_RESET                                        0xf // 15
+#define PCIE_APP_SLV_RESP_ERR_MAP_MSB                                11
+#define PCIE_APP_SLV_RESP_ERR_MAP_LSB                                6
+#define PCIE_APP_SLV_RESP_ERR_MAP_MASK                               0x00000fc0
+#define PCIE_APP_SLV_RESP_ERR_MAP_GET(x)                             (((x) & PCIE_APP_SLV_RESP_ERR_MAP_MASK) >> PCIE_APP_SLV_RESP_ERR_MAP_LSB)
+#define PCIE_APP_SLV_RESP_ERR_MAP_SET(x)                             (((x) << PCIE_APP_SLV_RESP_ERR_MAP_LSB) & PCIE_APP_SLV_RESP_ERR_MAP_MASK)
+#define PCIE_APP_SLV_RESP_ERR_MAP_RESET                              0x3f // 63
+#define PCIE_APP_MSTR_RESP_ERR_MAP_MSB                               5
+#define PCIE_APP_MSTR_RESP_ERR_MAP_LSB                               4
+#define PCIE_APP_MSTR_RESP_ERR_MAP_MASK                              0x00000030
+#define PCIE_APP_MSTR_RESP_ERR_MAP_GET(x)                            (((x) & PCIE_APP_MSTR_RESP_ERR_MAP_MASK) >> PCIE_APP_MSTR_RESP_ERR_MAP_LSB)
+#define PCIE_APP_MSTR_RESP_ERR_MAP_SET(x)                            (((x) << PCIE_APP_MSTR_RESP_ERR_MAP_LSB) & PCIE_APP_MSTR_RESP_ERR_MAP_MASK)
+#define PCIE_APP_MSTR_RESP_ERR_MAP_RESET                             0x0 // 0
+#define PCIE_APP_INIT_RST_MSB                                        3
+#define PCIE_APP_INIT_RST_LSB                                        3
+#define PCIE_APP_INIT_RST_MASK                                       0x00000008
+#define PCIE_APP_INIT_RST_GET(x)                                     (((x) & PCIE_APP_INIT_RST_MASK) >> PCIE_APP_INIT_RST_LSB)
+#define PCIE_APP_INIT_RST_SET(x)                                     (((x) << PCIE_APP_INIT_RST_LSB) & PCIE_APP_INIT_RST_MASK)
+#define PCIE_APP_INIT_RST_RESET                                      0x0 // 0
+#define PCIE_APP_PM_XMT_TURNOFF_MSB                                  2
+#define PCIE_APP_PM_XMT_TURNOFF_LSB                                  2
+#define PCIE_APP_PM_XMT_TURNOFF_MASK                                 0x00000004
+#define PCIE_APP_PM_XMT_TURNOFF_GET(x)                               (((x) & PCIE_APP_PM_XMT_TURNOFF_MASK) >> PCIE_APP_PM_XMT_TURNOFF_LSB)
+#define PCIE_APP_PM_XMT_TURNOFF_SET(x)                               (((x) << PCIE_APP_PM_XMT_TURNOFF_LSB) & PCIE_APP_PM_XMT_TURNOFF_MASK)
+#define PCIE_APP_PM_XMT_TURNOFF_RESET                                0x0 // 0
+#define PCIE_APP_UNLOCK_MSG_MSB                                      1
+#define PCIE_APP_UNLOCK_MSG_LSB                                      1
+#define PCIE_APP_UNLOCK_MSG_MASK                                     0x00000002
+#define PCIE_APP_UNLOCK_MSG_GET(x)                                   (((x) & PCIE_APP_UNLOCK_MSG_MASK) >> PCIE_APP_UNLOCK_MSG_LSB)
+#define PCIE_APP_UNLOCK_MSG_SET(x)                                   (((x) << PCIE_APP_UNLOCK_MSG_LSB) & PCIE_APP_UNLOCK_MSG_MASK)
+#define PCIE_APP_UNLOCK_MSG_RESET                                    0x0 // 0
+#define PCIE_APP_LTSSM_ENABLE_MSB                                    0
+#define PCIE_APP_LTSSM_ENABLE_LSB                                    0
+#define PCIE_APP_LTSSM_ENABLE_MASK                                   0x00000001
+#define PCIE_APP_LTSSM_ENABLE_GET(x)                                 (((x) & PCIE_APP_LTSSM_ENABLE_MASK) >> PCIE_APP_LTSSM_ENABLE_LSB)
+#define PCIE_APP_LTSSM_ENABLE_SET(x)                                 (((x) << PCIE_APP_LTSSM_ENABLE_LSB) & PCIE_APP_LTSSM_ENABLE_MASK)
+#define PCIE_APP_LTSSM_ENABLE_RESET                                  0x0 // 0
+#define PCIE_APP_ADDRESS                                             0x180f0000
+
+#define PCIE_PWR_MGMT_PME_INT_MSB                                    8
+#define PCIE_PWR_MGMT_PME_INT_LSB                                    8
+#define PCIE_PWR_MGMT_PME_INT_MASK                                   0x00000100
+#define PCIE_PWR_MGMT_PME_INT_GET(x)                                 (((x) & PCIE_PWR_MGMT_PME_INT_MASK) >> PCIE_PWR_MGMT_PME_INT_LSB)
+#define PCIE_PWR_MGMT_PME_INT_SET(x)                                 (((x) << PCIE_PWR_MGMT_PME_INT_LSB) & PCIE_PWR_MGMT_PME_INT_MASK)
+#define PCIE_PWR_MGMT_PME_INT_RESET                                  0x0 // 0
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_MSB                             7
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_LSB                             7
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_MASK                            0x00000080
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_GET(x)                          (((x) & PCIE_PWR_MGMT_ASSERT_CLKREQN_MASK) >> PCIE_PWR_MGMT_ASSERT_CLKREQN_LSB)
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_SET(x)                          (((x) << PCIE_PWR_MGMT_ASSERT_CLKREQN_LSB) & PCIE_PWR_MGMT_ASSERT_CLKREQN_MASK)
+#define PCIE_PWR_MGMT_ASSERT_CLKREQN_RESET                           0x0 // 0
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_MSB                             6
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_LSB                             6
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_MASK                            0x00000040
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_GET(x)                          (((x) & PCIE_PWR_MGMT_RADM_PM_TO_ACK_MASK) >> PCIE_PWR_MGMT_RADM_PM_TO_ACK_LSB)
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_SET(x)                          (((x) << PCIE_PWR_MGMT_RADM_PM_TO_ACK_LSB) & PCIE_PWR_MGMT_RADM_PM_TO_ACK_MASK)
+#define PCIE_PWR_MGMT_RADM_PM_TO_ACK_RESET                           0x0 // 0
+#define PCIE_PWR_MGMT_RADM_PM_PME_MSB                                5
+#define PCIE_PWR_MGMT_RADM_PM_PME_LSB                                5
+#define PCIE_PWR_MGMT_RADM_PM_PME_MASK                               0x00000020
+#define PCIE_PWR_MGMT_RADM_PM_PME_GET(x)                             (((x) & PCIE_PWR_MGMT_RADM_PM_PME_MASK) >> PCIE_PWR_MGMT_RADM_PM_PME_LSB)
+#define PCIE_PWR_MGMT_RADM_PM_PME_SET(x)                             (((x) << PCIE_PWR_MGMT_RADM_PM_PME_LSB) & PCIE_PWR_MGMT_RADM_PM_PME_MASK)
+#define PCIE_PWR_MGMT_RADM_PM_PME_RESET                              0x0 // 0
+#define PCIE_PWR_MGMT_AUX_PM_EN_MSB                                  4
+#define PCIE_PWR_MGMT_AUX_PM_EN_LSB                                  4
+#define PCIE_PWR_MGMT_AUX_PM_EN_MASK                                 0x00000010
+#define PCIE_PWR_MGMT_AUX_PM_EN_GET(x)                               (((x) & PCIE_PWR_MGMT_AUX_PM_EN_MASK) >> PCIE_PWR_MGMT_AUX_PM_EN_LSB)
+#define PCIE_PWR_MGMT_AUX_PM_EN_SET(x)                               (((x) << PCIE_PWR_MGMT_AUX_PM_EN_LSB) & PCIE_PWR_MGMT_AUX_PM_EN_MASK)
+#define PCIE_PWR_MGMT_AUX_PM_EN_RESET                                0x0 // 0
+#define PCIE_PWR_MGMT_READY_ENTR_L23_MSB                             3
+#define PCIE_PWR_MGMT_READY_ENTR_L23_LSB                             3
+#define PCIE_PWR_MGMT_READY_ENTR_L23_MASK                            0x00000008
+#define PCIE_PWR_MGMT_READY_ENTR_L23_GET(x)                          (((x) & PCIE_PWR_MGMT_READY_ENTR_L23_MASK) >> PCIE_PWR_MGMT_READY_ENTR_L23_LSB)
+#define PCIE_PWR_MGMT_READY_ENTR_L23_SET(x)                          (((x) << PCIE_PWR_MGMT_READY_ENTR_L23_LSB) & PCIE_PWR_MGMT_READY_ENTR_L23_MASK)
+#define PCIE_PWR_MGMT_READY_ENTR_L23_RESET                           0x0 // 0
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_MSB                                2
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_LSB                                2
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_MASK                               0x00000004
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_GET(x)                             (((x) & PCIE_PWR_MGMT_REQ_EXIT_L1_MASK) >> PCIE_PWR_MGMT_REQ_EXIT_L1_LSB)
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_SET(x)                             (((x) << PCIE_PWR_MGMT_REQ_EXIT_L1_LSB) & PCIE_PWR_MGMT_REQ_EXIT_L1_MASK)
+#define PCIE_PWR_MGMT_REQ_EXIT_L1_RESET                              0x0 // 0
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_MSB                               1
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_LSB                               1
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_MASK                              0x00000002
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_GET(x)                            (((x) & PCIE_PWR_MGMT_REQ_ENTRY_L1_MASK) >> PCIE_PWR_MGMT_REQ_ENTRY_L1_LSB)
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_SET(x)                            (((x) << PCIE_PWR_MGMT_REQ_ENTRY_L1_LSB) & PCIE_PWR_MGMT_REQ_ENTRY_L1_MASK)
+#define PCIE_PWR_MGMT_REQ_ENTRY_L1_RESET                             0x0 // 0
+#define PCIE_PWR_MGMT_AUX_PWR_DET_MSB                                0
+#define PCIE_PWR_MGMT_AUX_PWR_DET_LSB                                0
+#define PCIE_PWR_MGMT_AUX_PWR_DET_MASK                               0x00000001
+#define PCIE_PWR_MGMT_AUX_PWR_DET_GET(x)                             (((x) & PCIE_PWR_MGMT_AUX_PWR_DET_MASK) >> PCIE_PWR_MGMT_AUX_PWR_DET_LSB)
+#define PCIE_PWR_MGMT_AUX_PWR_DET_SET(x)                             (((x) << PCIE_PWR_MGMT_AUX_PWR_DET_LSB) & PCIE_PWR_MGMT_AUX_PWR_DET_MASK)
+#define PCIE_PWR_MGMT_AUX_PWR_DET_RESET                              0x0 // 0
+#define PCIE_PWR_MGMT_ADDRESS                                        0x180f0008
+#define PCIE_PWR_MGMT_OFFSET                                         0x0008
+// SW modifiable bits
+#define PCIE_PWR_MGMT_SW_MASK                                        0x000001ff
+// bits defined at reset
+#define PCIE_PWR_MGMT_RSTMASK                                        0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PWR_MGMT_RESET                                          0x00000000
+
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MSB                          31
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_LSB                          31
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MASK                         0x80000000
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_GET(x)                       (((x) & PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MASK) >> PCIE_PHY_REG_1_SERDES_DIS_RXIMP_LSB)
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_SET(x)                       (((x) << PCIE_PHY_REG_1_SERDES_DIS_RXIMP_LSB) & PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MASK)
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MSB                          30
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_LSB                          29
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MASK                         0x60000000
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_GET(x)                       (((x) & PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MASK) >> PCIE_PHY_REG_1_SERDES_TXDR_CTRL_LSB)
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_SET(x)                       (((x) << PCIE_PHY_REG_1_SERDES_TXDR_CTRL_LSB) & PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MASK)
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_PERSTDELAY_MSB                                28
+#define PCIE_PHY_REG_1_PERSTDELAY_LSB                                27
+#define PCIE_PHY_REG_1_PERSTDELAY_MASK                               0x18000000
+#define PCIE_PHY_REG_1_PERSTDELAY_GET(x)                             (((x) & PCIE_PHY_REG_1_PERSTDELAY_MASK) >> PCIE_PHY_REG_1_PERSTDELAY_LSB)
+#define PCIE_PHY_REG_1_PERSTDELAY_SET(x)                             (((x) << PCIE_PHY_REG_1_PERSTDELAY_LSB) & PCIE_PHY_REG_1_PERSTDELAY_MASK)
+#define PCIE_PHY_REG_1_PERSTDELAY_RESET                              0x2 // 2
+#define PCIE_PHY_REG_1_CLKOBSSEL_MSB                                 26
+#define PCIE_PHY_REG_1_CLKOBSSEL_LSB                                 25
+#define PCIE_PHY_REG_1_CLKOBSSEL_MASK                                0x06000000
+#define PCIE_PHY_REG_1_CLKOBSSEL_GET(x)                              (((x) & PCIE_PHY_REG_1_CLKOBSSEL_MASK) >> PCIE_PHY_REG_1_CLKOBSSEL_LSB)
+#define PCIE_PHY_REG_1_CLKOBSSEL_SET(x)                              (((x) << PCIE_PHY_REG_1_CLKOBSSEL_LSB) & PCIE_PHY_REG_1_CLKOBSSEL_MASK)
+#define PCIE_PHY_REG_1_CLKOBSSEL_RESET                               0x0 // 0
+#define PCIE_PHY_REG_1_DATAOBSEN_MSB                                 24
+#define PCIE_PHY_REG_1_DATAOBSEN_LSB                                 24
+#define PCIE_PHY_REG_1_DATAOBSEN_MASK                                0x01000000
+#define PCIE_PHY_REG_1_DATAOBSEN_GET(x)                              (((x) & PCIE_PHY_REG_1_DATAOBSEN_MASK) >> PCIE_PHY_REG_1_DATAOBSEN_LSB)
+#define PCIE_PHY_REG_1_DATAOBSEN_SET(x)                              (((x) << PCIE_PHY_REG_1_DATAOBSEN_LSB) & PCIE_PHY_REG_1_DATAOBSEN_MASK)
+#define PCIE_PHY_REG_1_DATAOBSEN_RESET                               0x0 // 0
+#define PCIE_PHY_REG_1_FUNCTESTEN_MSB                                23
+#define PCIE_PHY_REG_1_FUNCTESTEN_LSB                                23
+#define PCIE_PHY_REG_1_FUNCTESTEN_MASK                               0x00800000
+#define PCIE_PHY_REG_1_FUNCTESTEN_GET(x)                             (((x) & PCIE_PHY_REG_1_FUNCTESTEN_MASK) >> PCIE_PHY_REG_1_FUNCTESTEN_LSB)
+#define PCIE_PHY_REG_1_FUNCTESTEN_SET(x)                             (((x) << PCIE_PHY_REG_1_FUNCTESTEN_LSB) & PCIE_PHY_REG_1_FUNCTESTEN_MASK)
+#define PCIE_PHY_REG_1_FUNCTESTEN_RESET                              0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_DISABLE_MSB                            22
+#define PCIE_PHY_REG_1_SERDES_DISABLE_LSB                            22
+#define PCIE_PHY_REG_1_SERDES_DISABLE_MASK                           0x00400000
+#define PCIE_PHY_REG_1_SERDES_DISABLE_GET(x)                         (((x) & PCIE_PHY_REG_1_SERDES_DISABLE_MASK) >> PCIE_PHY_REG_1_SERDES_DISABLE_LSB)
+#define PCIE_PHY_REG_1_SERDES_DISABLE_SET(x)                         (((x) << PCIE_PHY_REG_1_SERDES_DISABLE_LSB) & PCIE_PHY_REG_1_SERDES_DISABLE_MASK)
+#define PCIE_PHY_REG_1_SERDES_DISABLE_RESET                          0x0 // 0
+#define PCIE_PHY_REG_1_RXCLKINV_MSB                                  21
+#define PCIE_PHY_REG_1_RXCLKINV_LSB                                  21
+#define PCIE_PHY_REG_1_RXCLKINV_MASK                                 0x00200000
+#define PCIE_PHY_REG_1_RXCLKINV_GET(x)                               (((x) & PCIE_PHY_REG_1_RXCLKINV_MASK) >> PCIE_PHY_REG_1_RXCLKINV_LSB)
+#define PCIE_PHY_REG_1_RXCLKINV_SET(x)                               (((x) << PCIE_PHY_REG_1_RXCLKINV_LSB) & PCIE_PHY_REG_1_RXCLKINV_MASK)
+#define PCIE_PHY_REG_1_RXCLKINV_RESET                                0x1 // 1
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MSB                          20
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_LSB                          20
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MASK                         0x00100000
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_GET(x)                       (((x) & PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MASK) >> PCIE_PHY_REG_1_FUNCTESTRXCLKINV_LSB)
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_SET(x)                       (((x) << PCIE_PHY_REG_1_FUNCTESTRXCLKINV_LSB) & PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MASK)
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MSB                          19
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_LSB                          19
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MASK                         0x00080000
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_GET(x)                       (((x) & PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MASK) >> PCIE_PHY_REG_1_FUNCTESTTXCLKINV_LSB)
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_SET(x)                       (((x) << PCIE_PHY_REG_1_FUNCTESTTXCLKINV_LSB) & PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MASK)
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_ENABLECLKREQ_MSB                              18
+#define PCIE_PHY_REG_1_ENABLECLKREQ_LSB                              18
+#define PCIE_PHY_REG_1_ENABLECLKREQ_MASK                             0x00040000
+#define PCIE_PHY_REG_1_ENABLECLKREQ_GET(x)                           (((x) & PCIE_PHY_REG_1_ENABLECLKREQ_MASK) >> PCIE_PHY_REG_1_ENABLECLKREQ_LSB)
+#define PCIE_PHY_REG_1_ENABLECLKREQ_SET(x)                           (((x) << PCIE_PHY_REG_1_ENABLECLKREQ_LSB) & PCIE_PHY_REG_1_ENABLECLKREQ_MASK)
+#define PCIE_PHY_REG_1_ENABLECLKREQ_RESET                            0x0 // 0
+#define PCIE_PHY_REG_1_FORCELOOPBACK_MSB                             17
+#define PCIE_PHY_REG_1_FORCELOOPBACK_LSB                             17
+#define PCIE_PHY_REG_1_FORCELOOPBACK_MASK                            0x00020000
+#define PCIE_PHY_REG_1_FORCELOOPBACK_GET(x)                          (((x) & PCIE_PHY_REG_1_FORCELOOPBACK_MASK) >> PCIE_PHY_REG_1_FORCELOOPBACK_LSB)
+#define PCIE_PHY_REG_1_FORCELOOPBACK_SET(x)                          (((x) << PCIE_PHY_REG_1_FORCELOOPBACK_LSB) & PCIE_PHY_REG_1_FORCELOOPBACK_MASK)
+#define PCIE_PHY_REG_1_FORCELOOPBACK_RESET                           0x0 // 0
+#define PCIE_PHY_REG_1_SEL_CLK_MSB                                   16
+#define PCIE_PHY_REG_1_SEL_CLK_LSB                                   15
+#define PCIE_PHY_REG_1_SEL_CLK_MASK                                  0x00018000
+#define PCIE_PHY_REG_1_SEL_CLK_GET(x)                                (((x) & PCIE_PHY_REG_1_SEL_CLK_MASK) >> PCIE_PHY_REG_1_SEL_CLK_LSB)
+#define PCIE_PHY_REG_1_SEL_CLK_SET(x)                                (((x) << PCIE_PHY_REG_1_SEL_CLK_LSB) & PCIE_PHY_REG_1_SEL_CLK_MASK)
+#define PCIE_PHY_REG_1_SEL_CLK_RESET                                 0x2 // 2
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_MSB                              14
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_LSB                              14
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_MASK                             0x00004000
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_GET(x)                           (((x) & PCIE_PHY_REG_1_SERDES_RX_EQ_MASK) >> PCIE_PHY_REG_1_SERDES_RX_EQ_LSB)
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_SET(x)                           (((x) << PCIE_PHY_REG_1_SERDES_RX_EQ_LSB) & PCIE_PHY_REG_1_SERDES_RX_EQ_MASK)
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_RESET                            0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_MSB                           13
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_LSB                           13
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_MASK                          0x00002000
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_GET(x)                        (((x) & PCIE_PHY_REG_1_SERDES_EN_LCKDT_MASK) >> PCIE_PHY_REG_1_SERDES_EN_LCKDT_LSB)
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_SET(x)                        (((x) << PCIE_PHY_REG_1_SERDES_EN_LCKDT_LSB) & PCIE_PHY_REG_1_SERDES_EN_LCKDT_MASK)
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_RESET                         0x1 // 1
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MSB                     12
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_LSB                     12
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MASK                    0x00001000
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_GET(x)                  (((x) & PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MASK) >> PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_LSB)
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_SET(x)                  (((x) << PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_LSB) & PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MASK)
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_RESET                   0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_MSB                         11
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_LSB                         11
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_MASK                        0x00000800
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_GET(x)                      (((x) & PCIE_PHY_REG_1_SERDES_POWER_SAVE_MASK) >> PCIE_PHY_REG_1_SERDES_POWER_SAVE_LSB)
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_SET(x)                      (((x) << PCIE_PHY_REG_1_SERDES_POWER_SAVE_LSB) & PCIE_PHY_REG_1_SERDES_POWER_SAVE_MASK)
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_RESET                       0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_MSB                             10
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_LSB                             9
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_MASK                            0x00000600
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_GET(x)                          (((x) & PCIE_PHY_REG_1_SERDES_CDR_BW_MASK) >> PCIE_PHY_REG_1_SERDES_CDR_BW_LSB)
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_SET(x)                          (((x) << PCIE_PHY_REG_1_SERDES_CDR_BW_LSB) & PCIE_PHY_REG_1_SERDES_CDR_BW_MASK)
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_RESET                           0x3 // 3
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_MSB                             8
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_LSB                             7
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_MASK                            0x00000180
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_GET(x)                          (((x) & PCIE_PHY_REG_1_SERDES_TH_LOS_MASK) >> PCIE_PHY_REG_1_SERDES_TH_LOS_LSB)
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_SET(x)                          (((x) << PCIE_PHY_REG_1_SERDES_TH_LOS_LSB) & PCIE_PHY_REG_1_SERDES_TH_LOS_MASK)
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_RESET                           0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_MSB                           6
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_LSB                           6
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_MASK                          0x00000040
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_GET(x)                        (((x) & PCIE_PHY_REG_1_SERDES_EN_DEEMP_MASK) >> PCIE_PHY_REG_1_SERDES_EN_DEEMP_LSB)
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_SET(x)                        (((x) << PCIE_PHY_REG_1_SERDES_EN_DEEMP_LSB) & PCIE_PHY_REG_1_SERDES_EN_DEEMP_MASK)
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_RESET                         0x1 // 1
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_MSB                           5
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_LSB                           5
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_MASK                          0x00000020
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_GET(x)                        (((x) & PCIE_PHY_REG_1_SERDES_HALFTXDR_MASK) >> PCIE_PHY_REG_1_SERDES_HALFTXDR_LSB)
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_SET(x)                        (((x) << PCIE_PHY_REG_1_SERDES_HALFTXDR_LSB) & PCIE_PHY_REG_1_SERDES_HALFTXDR_MASK)
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_RESET                         0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_MSB                            4
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_LSB                            4
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_MASK                           0x00000010
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_GET(x)                         (((x) & PCIE_PHY_REG_1_SERDES_SEL_HSP_MASK) >> PCIE_PHY_REG_1_SERDES_SEL_HSP_LSB)
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_SET(x)                         (((x) << PCIE_PHY_REG_1_SERDES_SEL_HSP_LSB) & PCIE_PHY_REG_1_SERDES_SEL_HSP_MASK)
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_RESET                          0x1 // 1
+#define PCIE_PHY_REG_1_S_MSB                                         3
+#define PCIE_PHY_REG_1_S_LSB                                         0
+#define PCIE_PHY_REG_1_S_MASK                                        0x0000000f
+#define PCIE_PHY_REG_1_S_GET(x)                                      (((x) & PCIE_PHY_REG_1_S_MASK) >> PCIE_PHY_REG_1_S_LSB)
+#define PCIE_PHY_REG_1_S_SET(x)                                      (((x) << PCIE_PHY_REG_1_S_LSB) & PCIE_PHY_REG_1_S_MASK)
+#define PCIE_PHY_REG_1_S_RESET                                       0xe // 14
+#define PCIE_PHY_REG_1_ADDRESS                                       0x18116cc0
+#define PCIE_PHY_REG_1_OFFSET                                        0x0000
+// SW modifiable bits
+#define PCIE_PHY_REG_1_SW_MASK                                       0xffffffff
+// bits defined at reset
+#define PCIE_PHY_REG_1_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PHY_REG_1_RESET                                         0x1021265e
+#define PCIE_PHY_REG_1_RESET_1                                       0x0061060e  
+
+// 32'h18116cc4 (PCIE_PHY_REG_2)
+#define PCIE_PHY_REG_2_PRBS_ERROR_COUNT_MSB                          31
+#define PCIE_PHY_REG_2_PRBS_ERROR_COUNT_LSB                          24
+#define PCIE_PHY_REG_2_PRBS_ERROR_COUNT_MASK                         0xff000000
+#define PCIE_PHY_REG_2_PRBS_ERROR_COUNT_GET(x)                       (((x) & PCIE_PHY_REG_2_PRBS_ERROR_COUNT_MASK) >> PCIE_PHY_REG_2_PRBS_ERROR_COUNT_LSB)
+#define PCIE_PHY_REG_2_PRBS_ERROR_COUNT_SET(x)                       (((x) << PCIE_PHY_REG_2_PRBS_ERROR_COUNT_LSB) & PCIE_PHY_REG_2_PRBS_ERROR_COUNT_MASK)
+#define PCIE_PHY_REG_2_PRBS_ERROR_COUNT_RESET                        0x0 // 0
+#define PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_MSB                        23
+#define PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_LSB                        23
+#define PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_MASK                       0x00800000
+#define PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_GET(x)                     (((x) & PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_MASK) >> PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_LSB)
+#define PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_SET(x)                     (((x) << PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_LSB) & PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_MASK)
+#define PCIE_PHY_REG_2_SDS_SDM_RXELECIDLE_RESET                      0x0 // 0
+#define PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_MSB                        22
+#define PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_LSB                        22
+#define PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_MASK                       0x00400000
+#define PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_GET(x)                     (((x) & PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_MASK) >> PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_LSB)
+#define PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_SET(x)                     (((x) << PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_LSB) & PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_MASK)
+#define PCIE_PHY_REG_2_SDS_SDM_RXDETECTED_RESET                      0x0 // 0
+#define PCIE_PHY_REG_2_PRBS_SCRAMBLE_MSB                             21
+#define PCIE_PHY_REG_2_PRBS_SCRAMBLE_LSB                             21
+#define PCIE_PHY_REG_2_PRBS_SCRAMBLE_MASK                            0x00200000
+#define PCIE_PHY_REG_2_PRBS_SCRAMBLE_GET(x)                          (((x) & PCIE_PHY_REG_2_PRBS_SCRAMBLE_MASK) >> PCIE_PHY_REG_2_PRBS_SCRAMBLE_LSB)
+#define PCIE_PHY_REG_2_PRBS_SCRAMBLE_SET(x)                          (((x) << PCIE_PHY_REG_2_PRBS_SCRAMBLE_LSB) & PCIE_PHY_REG_2_PRBS_SCRAMBLE_MASK)
+#define PCIE_PHY_REG_2_PRBS_SCRAMBLE_RESET                           0x0 // 0
+#define PCIE_PHY_REG_2_PRBS_START_MSB                                20
+#define PCIE_PHY_REG_2_PRBS_START_LSB                                20
+#define PCIE_PHY_REG_2_PRBS_START_MASK                               0x00100000
+#define PCIE_PHY_REG_2_PRBS_START_GET(x)                             (((x) & PCIE_PHY_REG_2_PRBS_START_MASK) >> PCIE_PHY_REG_2_PRBS_START_LSB)
+#define PCIE_PHY_REG_2_PRBS_START_SET(x)                             (((x) << PCIE_PHY_REG_2_PRBS_START_LSB) & PCIE_PHY_REG_2_PRBS_START_MASK)
+#define PCIE_PHY_REG_2_PRBS_START_RESET                              0x0 // 0
+#define PCIE_PHY_REG_2_PRBS_TS_NUM_MSB                               19
+#define PCIE_PHY_REG_2_PRBS_TS_NUM_LSB                               13
+#define PCIE_PHY_REG_2_PRBS_TS_NUM_MASK                              0x000fe000
+#define PCIE_PHY_REG_2_PRBS_TS_NUM_GET(x)                            (((x) & PCIE_PHY_REG_2_PRBS_TS_NUM_MASK) >> PCIE_PHY_REG_2_PRBS_TS_NUM_LSB)
+#define PCIE_PHY_REG_2_PRBS_TS_NUM_SET(x)                            (((x) << PCIE_PHY_REG_2_PRBS_TS_NUM_LSB) & PCIE_PHY_REG_2_PRBS_TS_NUM_MASK)
+#define PCIE_PHY_REG_2_PRBS_TS_NUM_RESET                             0x40 // 64
+#define PCIE_PHY_REG_2_TXDETRXOVRVALUE_MSB                           12
+#define PCIE_PHY_REG_2_TXDETRXOVRVALUE_LSB                           12
+#define PCIE_PHY_REG_2_TXDETRXOVRVALUE_MASK                          0x00001000
+#define PCIE_PHY_REG_2_TXDETRXOVRVALUE_GET(x)                        (((x) & PCIE_PHY_REG_2_TXDETRXOVRVALUE_MASK) >> PCIE_PHY_REG_2_TXDETRXOVRVALUE_LSB)
+#define PCIE_PHY_REG_2_TXDETRXOVRVALUE_SET(x)                        (((x) << PCIE_PHY_REG_2_TXDETRXOVRVALUE_LSB) & PCIE_PHY_REG_2_TXDETRXOVRVALUE_MASK)
+#define PCIE_PHY_REG_2_TXDETRXOVRVALUE_RESET                         0x0 // 0
+#define PCIE_PHY_REG_2_TXDETRXOVREN_MSB                              11
+#define PCIE_PHY_REG_2_TXDETRXOVREN_LSB                              11
+#define PCIE_PHY_REG_2_TXDETRXOVREN_MASK                             0x00000800
+#define PCIE_PHY_REG_2_TXDETRXOVREN_GET(x)                           (((x) & PCIE_PHY_REG_2_TXDETRXOVREN_MASK) >> PCIE_PHY_REG_2_TXDETRXOVREN_LSB)
+#define PCIE_PHY_REG_2_TXDETRXOVREN_SET(x)                           (((x) << PCIE_PHY_REG_2_TXDETRXOVREN_LSB) & PCIE_PHY_REG_2_TXDETRXOVREN_MASK)
+#define PCIE_PHY_REG_2_TXDETRXOVREN_RESET                            0x0 // 0
+#define PCIE_PHY_REG_2_DATAOBSPRBSERR_MSB                            10
+#define PCIE_PHY_REG_2_DATAOBSPRBSERR_LSB                            10
+#define PCIE_PHY_REG_2_DATAOBSPRBSERR_MASK                           0x00000400
+#define PCIE_PHY_REG_2_DATAOBSPRBSERR_GET(x)                         (((x) & PCIE_PHY_REG_2_DATAOBSPRBSERR_MASK) >> PCIE_PHY_REG_2_DATAOBSPRBSERR_LSB)
+#define PCIE_PHY_REG_2_DATAOBSPRBSERR_SET(x)                         (((x) << PCIE_PHY_REG_2_DATAOBSPRBSERR_LSB) & PCIE_PHY_REG_2_DATAOBSPRBSERR_MASK)
+#define PCIE_PHY_REG_2_DATAOBSPRBSERR_RESET                          0x0 // 0
+#define PCIE_PHY_REG_2_CDRREADYTIMER_MSB                             9
+#define PCIE_PHY_REG_2_CDRREADYTIMER_LSB                             6
+#define PCIE_PHY_REG_2_CDRREADYTIMER_MASK                            0x000003c0
+#define PCIE_PHY_REG_2_CDRREADYTIMER_GET(x)                          (((x) & PCIE_PHY_REG_2_CDRREADYTIMER_MASK) >> PCIE_PHY_REG_2_CDRREADYTIMER_LSB)
+#define PCIE_PHY_REG_2_CDRREADYTIMER_SET(x)                          (((x) << PCIE_PHY_REG_2_CDRREADYTIMER_LSB) & PCIE_PHY_REG_2_CDRREADYTIMER_MASK)
+#define PCIE_PHY_REG_2_CDRREADYTIMER_RESET                           0x7 // 7
+#define PCIE_PHY_REG_2_TXDETRXTARGETDELAY_MSB                        5
+#define PCIE_PHY_REG_2_TXDETRXTARGETDELAY_LSB                        1
+#define PCIE_PHY_REG_2_TXDETRXTARGETDELAY_MASK                       0x0000003e
+#define PCIE_PHY_REG_2_TXDETRXTARGETDELAY_GET(x)                     (((x) & PCIE_PHY_REG_2_TXDETRXTARGETDELAY_MASK) >> PCIE_PHY_REG_2_TXDETRXTARGETDELAY_LSB)
+#define PCIE_PHY_REG_2_TXDETRXTARGETDELAY_SET(x)                     (((x) << PCIE_PHY_REG_2_TXDETRXTARGETDELAY_LSB) & PCIE_PHY_REG_2_TXDETRXTARGETDELAY_MASK)
+#define PCIE_PHY_REG_2_TXDETRXTARGETDELAY_RESET                      0xc // 12
+#define PCIE_PHY_REG_2_FORCEDETECT_MSB                               0
+#define PCIE_PHY_REG_2_FORCEDETECT_LSB                               0
+#define PCIE_PHY_REG_2_FORCEDETECT_MASK                              0x00000001
+#define PCIE_PHY_REG_2_FORCEDETECT_GET(x)                            (((x) & PCIE_PHY_REG_2_FORCEDETECT_MASK) >> PCIE_PHY_REG_2_FORCEDETECT_LSB)
+#define PCIE_PHY_REG_2_FORCEDETECT_SET(x)                            (((x) << PCIE_PHY_REG_2_FORCEDETECT_LSB) & PCIE_PHY_REG_2_FORCEDETECT_MASK)
+#define PCIE_PHY_REG_2_FORCEDETECT_RESET                             0x0 // 0
+#define PCIE_PHY_REG_2_ADDRESS                                       0x18116cc4
+#define PCIE_PHY_REG_2_OFFSET                                        0x0004
+// SW modifiable bits
+#define PCIE_PHY_REG_2_SW_MASK                                       0xffffffff
+// bits defined at reset
+#define PCIE_PHY_REG_2_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PHY_REG_2_RESET                                         0x000801d8
+
+#define PCIE_PHY_REG_3_PRBS_COMMA_STATUS_MSB                         31
+#define PCIE_PHY_REG_3_PRBS_COMMA_STATUS_LSB                         28
+#define PCIE_PHY_REG_3_PRBS_COMMA_STATUS_MASK                        0xf0000000
+#define PCIE_PHY_REG_3_PRBS_COMMA_STATUS_GET(x)                      (((x) & PCIE_PHY_REG_3_PRBS_COMMA_STATUS_MASK) >> PCIE_PHY_REG_3_PRBS_COMMA_STATUS_LSB)
+#define PCIE_PHY_REG_3_PRBS_COMMA_STATUS_SET(x)                      (((x) << PCIE_PHY_REG_3_PRBS_COMMA_STATUS_LSB) & PCIE_PHY_REG_3_PRBS_COMMA_STATUS_MASK)
+#define PCIE_PHY_REG_3_PRBS_COMMA_STATUS_RESET                       0x0 // 0
+#define PCIE_PHY_REG_3_SPARE_MSB                                     27
+#define PCIE_PHY_REG_3_SPARE_LSB                                     11
+#define PCIE_PHY_REG_3_SPARE_MASK                                    0x0ffff800
+#define PCIE_PHY_REG_3_SPARE_GET(x)                                  (((x) & PCIE_PHY_REG_3_SPARE_MASK) >> PCIE_PHY_REG_3_SPARE_LSB)
+#define PCIE_PHY_REG_3_SPARE_SET(x)                                  (((x) << PCIE_PHY_REG_3_SPARE_LSB) & PCIE_PHY_REG_3_SPARE_MASK)
+#define PCIE_PHY_REG_3_SPARE_RESET                                   0xa0b // 2571
+#define PCIE_PHY_REG_3_SEL_CLK100_MSB                                10
+#define PCIE_PHY_REG_3_SEL_CLK100_LSB                                10
+#define PCIE_PHY_REG_3_SEL_CLK100_MASK                               0x00000400
+#define PCIE_PHY_REG_3_SEL_CLK100_GET(x)                             (((x) & PCIE_PHY_REG_3_SEL_CLK100_MASK) >> PCIE_PHY_REG_3_SEL_CLK100_LSB)
+#define PCIE_PHY_REG_3_SEL_CLK100_SET(x)                             (((x) << PCIE_PHY_REG_3_SEL_CLK100_LSB) & PCIE_PHY_REG_3_SEL_CLK100_MASK)
+#define PCIE_PHY_REG_3_SEL_CLK100_RESET                              0x0 // 0
+#define PCIE_PHY_REG_3_EN_BEACONGEN_MSB                              9
+#define PCIE_PHY_REG_3_EN_BEACONGEN_LSB                              9
+#define PCIE_PHY_REG_3_EN_BEACONGEN_MASK                             0x00000200
+#define PCIE_PHY_REG_3_EN_BEACONGEN_GET(x)                           (((x) & PCIE_PHY_REG_3_EN_BEACONGEN_MASK) >> PCIE_PHY_REG_3_EN_BEACONGEN_LSB)
+#define PCIE_PHY_REG_3_EN_BEACONGEN_SET(x)                           (((x) << PCIE_PHY_REG_3_EN_BEACONGEN_LSB) & PCIE_PHY_REG_3_EN_BEACONGEN_MASK)
+#define PCIE_PHY_REG_3_EN_BEACONGEN_RESET                            0x0 // 0
+#define PCIE_PHY_REG_3_TXELECIDLE_MSB                                8
+#define PCIE_PHY_REG_3_TXELECIDLE_LSB                                8
+#define PCIE_PHY_REG_3_TXELECIDLE_MASK                               0x00000100
+#define PCIE_PHY_REG_3_TXELECIDLE_GET(x)                             (((x) & PCIE_PHY_REG_3_TXELECIDLE_MASK) >> PCIE_PHY_REG_3_TXELECIDLE_LSB)
+#define PCIE_PHY_REG_3_TXELECIDLE_SET(x)                             (((x) << PCIE_PHY_REG_3_TXELECIDLE_LSB) & PCIE_PHY_REG_3_TXELECIDLE_MASK)
+#define PCIE_PHY_REG_3_TXELECIDLE_RESET                              0x0 // 0
+#define PCIE_PHY_REG_3_SEL_CLK_MSB                                   7
+#define PCIE_PHY_REG_3_SEL_CLK_LSB                                   6
+#define PCIE_PHY_REG_3_SEL_CLK_MASK                                  0x000000c0
+#define PCIE_PHY_REG_3_SEL_CLK_GET(x)                                (((x) & PCIE_PHY_REG_3_SEL_CLK_MASK) >> PCIE_PHY_REG_3_SEL_CLK_LSB)
+#define PCIE_PHY_REG_3_SEL_CLK_SET(x)                                (((x) << PCIE_PHY_REG_3_SEL_CLK_LSB) & PCIE_PHY_REG_3_SEL_CLK_MASK)
+#define PCIE_PHY_REG_3_SEL_CLK_RESET                                 0x0 // 0
+#define PCIE_PHY_REG_3_RX_DET_REQ_MSB                                5
+#define PCIE_PHY_REG_3_RX_DET_REQ_LSB                                5
+#define PCIE_PHY_REG_3_RX_DET_REQ_MASK                               0x00000020
+#define PCIE_PHY_REG_3_RX_DET_REQ_GET(x)                             (((x) & PCIE_PHY_REG_3_RX_DET_REQ_MASK) >> PCIE_PHY_REG_3_RX_DET_REQ_LSB)
+#define PCIE_PHY_REG_3_RX_DET_REQ_SET(x)                             (((x) << PCIE_PHY_REG_3_RX_DET_REQ_LSB) & PCIE_PHY_REG_3_RX_DET_REQ_MASK)
+#define PCIE_PHY_REG_3_RX_DET_REQ_RESET                              0x0 // 0
+#define PCIE_PHY_REG_3_MODE_OCLK_IN_MSB                              4
+#define PCIE_PHY_REG_3_MODE_OCLK_IN_LSB                              4
+#define PCIE_PHY_REG_3_MODE_OCLK_IN_MASK                             0x00000010
+#define PCIE_PHY_REG_3_MODE_OCLK_IN_GET(x)                           (((x) & PCIE_PHY_REG_3_MODE_OCLK_IN_MASK) >> PCIE_PHY_REG_3_MODE_OCLK_IN_LSB)
+#define PCIE_PHY_REG_3_MODE_OCLK_IN_SET(x)                           (((x) << PCIE_PHY_REG_3_MODE_OCLK_IN_LSB) & PCIE_PHY_REG_3_MODE_OCLK_IN_MASK)
+#define PCIE_PHY_REG_3_MODE_OCLK_IN_RESET                            0x0 // 0
+#define PCIE_PHY_REG_3_EN_PLL_MSB                                    3
+#define PCIE_PHY_REG_3_EN_PLL_LSB                                    3
+#define PCIE_PHY_REG_3_EN_PLL_MASK                                   0x00000008
+#define PCIE_PHY_REG_3_EN_PLL_GET(x)                                 (((x) & PCIE_PHY_REG_3_EN_PLL_MASK) >> PCIE_PHY_REG_3_EN_PLL_LSB)
+#define PCIE_PHY_REG_3_EN_PLL_SET(x)                                 (((x) << PCIE_PHY_REG_3_EN_PLL_LSB) & PCIE_PHY_REG_3_EN_PLL_MASK)
+#define PCIE_PHY_REG_3_EN_PLL_RESET                                  0x1 // 1
+#define PCIE_PHY_REG_3_EN_LCKDT_MSB                                  2
+#define PCIE_PHY_REG_3_EN_LCKDT_LSB                                  2
+#define PCIE_PHY_REG_3_EN_LCKDT_MASK                                 0x00000004
+#define PCIE_PHY_REG_3_EN_LCKDT_GET(x)                               (((x) & PCIE_PHY_REG_3_EN_LCKDT_MASK) >> PCIE_PHY_REG_3_EN_LCKDT_LSB)
+#define PCIE_PHY_REG_3_EN_LCKDT_SET(x)                               (((x) << PCIE_PHY_REG_3_EN_LCKDT_LSB) & PCIE_PHY_REG_3_EN_LCKDT_MASK)
+#define PCIE_PHY_REG_3_EN_LCKDT_RESET                                0x1 // 1
+#define PCIE_PHY_REG_3_EN_BUFS_RX_MSB                                1
+#define PCIE_PHY_REG_3_EN_BUFS_RX_LSB                                1
+#define PCIE_PHY_REG_3_EN_BUFS_RX_MASK                               0x00000002
+#define PCIE_PHY_REG_3_EN_BUFS_RX_GET(x)                             (((x) & PCIE_PHY_REG_3_EN_BUFS_RX_MASK) >> PCIE_PHY_REG_3_EN_BUFS_RX_LSB)
+#define PCIE_PHY_REG_3_EN_BUFS_RX_SET(x)                             (((x) << PCIE_PHY_REG_3_EN_BUFS_RX_LSB) & PCIE_PHY_REG_3_EN_BUFS_RX_MASK)
+#define PCIE_PHY_REG_3_EN_BUFS_RX_RESET                              0x0 // 0
+#define PCIE_PHY_REG_3_EN_MSB                                        0
+#define PCIE_PHY_REG_3_EN_LSB                                        0
+#define PCIE_PHY_REG_3_EN_MASK                                       0x00000001
+#define PCIE_PHY_REG_3_EN_GET(x)                                     (((x) & PCIE_PHY_REG_3_EN_MASK) >> PCIE_PHY_REG_3_EN_LSB)
+#define PCIE_PHY_REG_3_EN_SET(x)                                     (((x) << PCIE_PHY_REG_3_EN_LSB) & PCIE_PHY_REG_3_EN_MASK)
+#define PCIE_PHY_REG_3_EN_RESET                                      0x0 // 0
+#define PCIE_PHY_REG_3_ADDRESS                                       0x18116cc8
+#define PCIE_PHY_REG_3_OFFSET                                        0x0008
+// SW modifiable bits
+#define PCIE_PHY_REG_3_SW_MASK                                       0xffffffff
+// bits defined at reset
+#define PCIE_PHY_REG_3_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PHY_REG_3_RESET                                         0x0050580c
+#define PCIE_PHY_REG_3_RESET_1 		               		     0x00505900
+
+#define PCIE_PHY_REG_4_PRBS_ERROR_RATE_MSB                           31
+#define PCIE_PHY_REG_4_PRBS_ERROR_RATE_LSB                           11
+#define PCIE_PHY_REG_4_PRBS_ERROR_RATE_MASK                          0xfffff800
+#define PCIE_PHY_REG_4_PRBS_ERROR_RATE_GET(x)                        (((x) & PCIE_PHY_REG_4_PRBS_ERROR_RATE_MASK) >> PCIE_PHY_REG_4_PRBS_ERROR_RATE_LSB)
+#define PCIE_PHY_REG_4_PRBS_ERROR_RATE_SET(x)                        (((x) << PCIE_PHY_REG_4_PRBS_ERROR_RATE_LSB) & PCIE_PHY_REG_4_PRBS_ERROR_RATE_MASK)
+#define PCIE_PHY_REG_4_PRBS_ERROR_RATE_RESET                         0xa000 // 40960
+#define PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_MSB                      10
+#define PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_LSB                      1
+#define PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_MASK                     0x000007fe
+#define PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_GET(x)                   (((x) & PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_MASK) >> PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_LSB)
+#define PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_SET(x)                   (((x) << PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_LSB) & PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_MASK)
+#define PCIE_PHY_REG_4_PRBS_TOTAL_NUMOF_ERR_RESET                    0x0 // 0
+#define PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_MSB                        0
+#define PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_LSB                        0
+#define PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_MASK                       0x00000001
+#define PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_GET(x)                     (((x) & PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_MASK) >> PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_LSB)
+#define PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_SET(x)                     (((x) << PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_LSB) & PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_MASK)
+#define PCIE_PHY_REG_4_PRBS_TRIGGER_ERROR_RESET                      0x0 // 0
+#define PCIE_PHY_REG_4_ADDRESS                                       0x18116ccc
+#define PCIE_PHY_REG_4_OFFSET                                        0x000c
+// SW modifiable bits
+#define PCIE_PHY_REG_4_SW_MASK                                       0xffffffff
+// bits defined at reset
+#define PCIE_PHY_REG_4_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PHY_REG_4_RESET                                         0x05000000
+
+#define XTAL_TCXODET_MSB                                             31
+#define XTAL_TCXODET_LSB                                             31
+#define XTAL_TCXODET_MASK                                            0x80000000
+#define XTAL_TCXODET_GET(x)                                          (((x) & XTAL_TCXODET_MASK) >> XTAL_TCXODET_LSB)
+#define XTAL_TCXODET_SET(x)                                          (((x) << XTAL_TCXODET_LSB) & XTAL_TCXODET_MASK)
+#define XTAL_TCXODET_RESET                                           0x0 // 0
+#define XTAL_XTAL_CAPINDAC_MSB                                       30
+#define XTAL_XTAL_CAPINDAC_LSB                                       24
+#define XTAL_XTAL_CAPINDAC_MASK                                      0x7f000000
+#define XTAL_XTAL_CAPINDAC_GET(x)                                    (((x) & XTAL_XTAL_CAPINDAC_MASK) >> XTAL_XTAL_CAPINDAC_LSB)
+#define XTAL_XTAL_CAPINDAC_SET(x)                                    (((x) << XTAL_XTAL_CAPINDAC_LSB) & XTAL_XTAL_CAPINDAC_MASK)
+#define XTAL_XTAL_CAPINDAC_RESET                                     0x4b // 75
+#define XTAL_XTAL_CAPOUTDAC_MSB                                      23
+#define XTAL_XTAL_CAPOUTDAC_LSB                                      17
+#define XTAL_XTAL_CAPOUTDAC_MASK                                     0x00fe0000
+#define XTAL_XTAL_CAPOUTDAC_GET(x)                                   (((x) & XTAL_XTAL_CAPOUTDAC_MASK) >> XTAL_XTAL_CAPOUTDAC_LSB)
+#define XTAL_XTAL_CAPOUTDAC_SET(x)                                   (((x) << XTAL_XTAL_CAPOUTDAC_LSB) & XTAL_XTAL_CAPOUTDAC_MASK)
+#define XTAL_XTAL_CAPOUTDAC_RESET                                    0x4b // 75
+#define XTAL_XTAL_DRVSTR_MSB                                         16
+#define XTAL_XTAL_DRVSTR_LSB                                         15
+#define XTAL_XTAL_DRVSTR_MASK                                        0x00018000
+#define XTAL_XTAL_DRVSTR_GET(x)                                      (((x) & XTAL_XTAL_DRVSTR_MASK) >> XTAL_XTAL_DRVSTR_LSB)
+#define XTAL_XTAL_DRVSTR_SET(x)                                      (((x) << XTAL_XTAL_DRVSTR_LSB) & XTAL_XTAL_DRVSTR_MASK)
+#define XTAL_XTAL_DRVSTR_RESET                                       0x0 // 0
+#define XTAL_XTAL_SHORTXIN_MSB                                       14
+#define XTAL_XTAL_SHORTXIN_LSB                                       14
+#define XTAL_XTAL_SHORTXIN_MASK                                      0x00004000
+#define XTAL_XTAL_SHORTXIN_GET(x)                                    (((x) & XTAL_XTAL_SHORTXIN_MASK) >> XTAL_XTAL_SHORTXIN_LSB)
+#define XTAL_XTAL_SHORTXIN_SET(x)                                    (((x) << XTAL_XTAL_SHORTXIN_LSB) & XTAL_XTAL_SHORTXIN_MASK)
+#define XTAL_XTAL_SHORTXIN_RESET                                     0x0 // 0
+#define XTAL_XTAL_LOCALBIAS_MSB                                      13
+#define XTAL_XTAL_LOCALBIAS_LSB                                      13
+#define XTAL_XTAL_LOCALBIAS_MASK                                     0x00002000
+#define XTAL_XTAL_LOCALBIAS_GET(x)                                   (((x) & XTAL_XTAL_LOCALBIAS_MASK) >> XTAL_XTAL_LOCALBIAS_LSB)
+#define XTAL_XTAL_LOCALBIAS_SET(x)                                   (((x) << XTAL_XTAL_LOCALBIAS_LSB) & XTAL_XTAL_LOCALBIAS_MASK)
+#define XTAL_XTAL_LOCALBIAS_RESET                                    0x1 // 1
+#define XTAL_XTAL_PWDCLKD_MSB                                        12
+#define XTAL_XTAL_PWDCLKD_LSB                                        12
+#define XTAL_XTAL_PWDCLKD_MASK                                       0x00001000
+#define XTAL_XTAL_PWDCLKD_GET(x)                                     (((x) & XTAL_XTAL_PWDCLKD_MASK) >> XTAL_XTAL_PWDCLKD_LSB)
+#define XTAL_XTAL_PWDCLKD_SET(x)                                     (((x) << XTAL_XTAL_PWDCLKD_LSB) & XTAL_XTAL_PWDCLKD_MASK)
+#define XTAL_XTAL_PWDCLKD_RESET                                      0x0 // 0
+#define XTAL_XTAL_BIAS2X_MSB                                         11
+#define XTAL_XTAL_BIAS2X_LSB                                         11
+#define XTAL_XTAL_BIAS2X_MASK                                        0x00000800
+#define XTAL_XTAL_BIAS2X_GET(x)                                      (((x) & XTAL_XTAL_BIAS2X_MASK) >> XTAL_XTAL_BIAS2X_LSB)
+#define XTAL_XTAL_BIAS2X_SET(x)                                      (((x) << XTAL_XTAL_BIAS2X_LSB) & XTAL_XTAL_BIAS2X_MASK)
+#define XTAL_XTAL_BIAS2X_RESET                                       0x0 // 0
+#define XTAL_XTAL_LBIAS2X_MSB                                        10
+#define XTAL_XTAL_LBIAS2X_LSB                                        10
+#define XTAL_XTAL_LBIAS2X_MASK                                       0x00000400
+#define XTAL_XTAL_LBIAS2X_GET(x)                                     (((x) & XTAL_XTAL_LBIAS2X_MASK) >> XTAL_XTAL_LBIAS2X_LSB)
+#define XTAL_XTAL_LBIAS2X_SET(x)                                     (((x) << XTAL_XTAL_LBIAS2X_LSB) & XTAL_XTAL_LBIAS2X_MASK)
+#define XTAL_XTAL_LBIAS2X_RESET                                      0x0 // 0
+#define XTAL_XTAL_SELVREG_MSB                                        9
+#define XTAL_XTAL_SELVREG_LSB                                        9
+#define XTAL_XTAL_SELVREG_MASK                                       0x00000200
+#define XTAL_XTAL_SELVREG_GET(x)                                     (((x) & XTAL_XTAL_SELVREG_MASK) >> XTAL_XTAL_SELVREG_LSB)
+#define XTAL_XTAL_SELVREG_SET(x)                                     (((x) << XTAL_XTAL_SELVREG_LSB) & XTAL_XTAL_SELVREG_MASK)
+#define XTAL_XTAL_SELVREG_RESET                                      0x0 // 0
+#define XTAL_XTAL_OSCON_MSB                                          8
+#define XTAL_XTAL_OSCON_LSB                                          8
+#define XTAL_XTAL_OSCON_MASK                                         0x00000100
+#define XTAL_XTAL_OSCON_GET(x)                                       (((x) & XTAL_XTAL_OSCON_MASK) >> XTAL_XTAL_OSCON_LSB)
+#define XTAL_XTAL_OSCON_SET(x)                                       (((x) << XTAL_XTAL_OSCON_LSB) & XTAL_XTAL_OSCON_MASK)
+#define XTAL_XTAL_OSCON_RESET                                        0x1 // 1
+#define XTAL_XTAL_PWDCLKIN_MSB                                       7
+#define XTAL_XTAL_PWDCLKIN_LSB                                       7
+#define XTAL_XTAL_PWDCLKIN_MASK                                      0x00000080
+#define XTAL_XTAL_PWDCLKIN_GET(x)                                    (((x) & XTAL_XTAL_PWDCLKIN_MASK) >> XTAL_XTAL_PWDCLKIN_LSB)
+#define XTAL_XTAL_PWDCLKIN_SET(x)                                    (((x) << XTAL_XTAL_PWDCLKIN_LSB) & XTAL_XTAL_PWDCLKIN_MASK)
+#define XTAL_XTAL_PWDCLKIN_RESET                                     0x0 // 0
+#define XTAL_LOCAL_XTAL_MSB                                          6
+#define XTAL_LOCAL_XTAL_LSB                                          6
+#define XTAL_LOCAL_XTAL_MASK                                         0x00000040
+#define XTAL_LOCAL_XTAL_GET(x)                                       (((x) & XTAL_LOCAL_XTAL_MASK) >> XTAL_LOCAL_XTAL_LSB)
+#define XTAL_LOCAL_XTAL_SET(x)                                       (((x) << XTAL_LOCAL_XTAL_LSB) & XTAL_LOCAL_XTAL_MASK)
+#define XTAL_LOCAL_XTAL_RESET                                        0x0 // 0
+#define XTAL_PWD_SWREGCLK_MSB                                        5
+#define XTAL_PWD_SWREGCLK_LSB                                        5
+#define XTAL_PWD_SWREGCLK_MASK                                       0x00000020
+#define XTAL_PWD_SWREGCLK_GET(x)                                     (((x) & XTAL_PWD_SWREGCLK_MASK) >> XTAL_PWD_SWREGCLK_LSB)
+#define XTAL_PWD_SWREGCLK_SET(x)                                     (((x) << XTAL_PWD_SWREGCLK_LSB) & XTAL_PWD_SWREGCLK_MASK)
+#define XTAL_PWD_SWREGCLK_RESET                                      0x0 // 0
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_MSB                                4
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_LSB                                4
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_MASK                               0x00000010
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_GET(x)                             (((x) & XTAL_LOCAL_EXT_CLK_OUT_EN_MASK) >> XTAL_LOCAL_EXT_CLK_OUT_EN_LSB)
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_SET(x)                             (((x) << XTAL_LOCAL_EXT_CLK_OUT_EN_LSB) & XTAL_LOCAL_EXT_CLK_OUT_EN_MASK)
+#define XTAL_LOCAL_EXT_CLK_OUT_EN_RESET                              0x0 // 0
+#define XTAL_EXT_CLK_OUT_EN_MSB                                      3
+#define XTAL_EXT_CLK_OUT_EN_LSB                                      3
+#define XTAL_EXT_CLK_OUT_EN_MASK                                     0x00000008
+#define XTAL_EXT_CLK_OUT_EN_GET(x)                                   (((x) & XTAL_EXT_CLK_OUT_EN_MASK) >> XTAL_EXT_CLK_OUT_EN_LSB)
+#define XTAL_EXT_CLK_OUT_EN_SET(x)                                   (((x) << XTAL_EXT_CLK_OUT_EN_LSB) & XTAL_EXT_CLK_OUT_EN_MASK)
+#define XTAL_EXT_CLK_OUT_EN_RESET                                    0x0 // 0
+#define XTAL_XTAL_SVREG_MSB                                          2
+#define XTAL_XTAL_SVREG_LSB                                          2
+#define XTAL_XTAL_SVREG_MASK                                         0x00000004
+#define XTAL_XTAL_SVREG_GET(x)                                       (((x) & XTAL_XTAL_SVREG_MASK) >> XTAL_XTAL_SVREG_LSB)
+#define XTAL_XTAL_SVREG_SET(x)                                       (((x) << XTAL_XTAL_SVREG_LSB) & XTAL_XTAL_SVREG_MASK)
+#define XTAL_XTAL_SVREG_RESET                                        0x0 // 0
+#define XTAL_RBK_UDSEL_MSB                                           1
+#define XTAL_RBK_UDSEL_LSB                                           1
+#define XTAL_RBK_UDSEL_MASK                                          0x00000002
+#define XTAL_RBK_UDSEL_GET(x)                                        (((x) & XTAL_RBK_UDSEL_MASK) >> XTAL_RBK_UDSEL_LSB)
+#define XTAL_RBK_UDSEL_SET(x)                                        (((x) << XTAL_RBK_UDSEL_LSB) & XTAL_RBK_UDSEL_MASK)
+#define XTAL_RBK_UDSEL_RESET                                         0x0 // 0
+#define XTAL_SPARE_MSB                                               0
+#define XTAL_SPARE_LSB                                               0
+#define XTAL_SPARE_MASK                                              0x00000001
+#define XTAL_SPARE_GET(x)                                            (((x) & XTAL_SPARE_MASK) >> XTAL_SPARE_LSB)
+#define XTAL_SPARE_SET(x)                                            (((x) << XTAL_SPARE_LSB) & XTAL_SPARE_MASK)
+#define XTAL_SPARE_RESET                                             0x0 // 0
+#define XTAL_ADDRESS                                                 0x181162c0
+
+#define XTAL2_TDC_COUNT_MSB                                          31
+#define XTAL2_TDC_COUNT_LSB                                          26
+#define XTAL2_TDC_COUNT_MASK                                         0xfc000000
+#define XTAL2_TDC_COUNT_GET(x)                                       (((x) & XTAL2_TDC_COUNT_MASK) >> XTAL2_TDC_COUNT_LSB)
+#define XTAL2_TDC_COUNT_SET(x)                                       (((x) << XTAL2_TDC_COUNT_LSB) & XTAL2_TDC_COUNT_MASK)
+#define XTAL2_TDC_COUNT_RESET                                        0x0 // 0
+#define XTAL2_TDC_PH_COUNT_MSB                                       25
+#define XTAL2_TDC_PH_COUNT_LSB                                       21
+#define XTAL2_TDC_PH_COUNT_MASK                                      0x03e00000
+#define XTAL2_TDC_PH_COUNT_GET(x)                                    (((x) & XTAL2_TDC_PH_COUNT_MASK) >> XTAL2_TDC_PH_COUNT_LSB)
+#define XTAL2_TDC_PH_COUNT_SET(x)                                    (((x) << XTAL2_TDC_PH_COUNT_LSB) & XTAL2_TDC_PH_COUNT_MASK)
+#define XTAL2_TDC_PH_COUNT_RESET                                     0x0 // 0
+#define XTAL2_DUTY_UP_MSB                                            20
+#define XTAL2_DUTY_UP_LSB                                            16
+#define XTAL2_DUTY_UP_MASK                                           0x001f0000
+#define XTAL2_DUTY_UP_GET(x)                                         (((x) & XTAL2_DUTY_UP_MASK) >> XTAL2_DUTY_UP_LSB)
+#define XTAL2_DUTY_UP_SET(x)                                         (((x) << XTAL2_DUTY_UP_LSB) & XTAL2_DUTY_UP_MASK)
+#define XTAL2_DUTY_UP_RESET                                          0x0 // 0
+#define XTAL2_DUTY_DN_MSB                                            15
+#define XTAL2_DUTY_DN_LSB                                            11
+#define XTAL2_DUTY_DN_MASK                                           0x0000f800
+#define XTAL2_DUTY_DN_GET(x)                                         (((x) & XTAL2_DUTY_DN_MASK) >> XTAL2_DUTY_DN_LSB)
+#define XTAL2_DUTY_DN_SET(x)                                         (((x) << XTAL2_DUTY_DN_LSB) & XTAL2_DUTY_DN_MASK)
+#define XTAL2_DUTY_DN_RESET                                          0x0 // 0
+#define XTAL2_DCA_BYPASS_MSB                                         10
+#define XTAL2_DCA_BYPASS_LSB                                         10
+#define XTAL2_DCA_BYPASS_MASK                                        0x00000400
+#define XTAL2_DCA_BYPASS_GET(x)                                      (((x) & XTAL2_DCA_BYPASS_MASK) >> XTAL2_DCA_BYPASS_LSB)
+#define XTAL2_DCA_BYPASS_SET(x)                                      (((x) << XTAL2_DCA_BYPASS_LSB) & XTAL2_DCA_BYPASS_MASK)
+#define XTAL2_DCA_BYPASS_RESET                                       0x1 // 1
+#define XTAL2_DCA_SWCAL_MSB                                          9
+#define XTAL2_DCA_SWCAL_LSB                                          9
+#define XTAL2_DCA_SWCAL_MASK                                         0x00000200
+#define XTAL2_DCA_SWCAL_GET(x)                                       (((x) & XTAL2_DCA_SWCAL_MASK) >> XTAL2_DCA_SWCAL_LSB)
+#define XTAL2_DCA_SWCAL_SET(x)                                       (((x) << XTAL2_DCA_SWCAL_LSB) & XTAL2_DCA_SWCAL_MASK)
+#define XTAL2_DCA_SWCAL_RESET                                        0x0 // 0
+#define XTAL2_FSM_UD_HOLD_MSB                                        8
+#define XTAL2_FSM_UD_HOLD_LSB                                        8
+#define XTAL2_FSM_UD_HOLD_MASK                                       0x00000100
+#define XTAL2_FSM_UD_HOLD_GET(x)                                     (((x) & XTAL2_FSM_UD_HOLD_MASK) >> XTAL2_FSM_UD_HOLD_LSB)
+#define XTAL2_FSM_UD_HOLD_SET(x)                                     (((x) << XTAL2_FSM_UD_HOLD_LSB) & XTAL2_FSM_UD_HOLD_MASK)
+#define XTAL2_FSM_UD_HOLD_RESET                                      0x0 // 0
+#define XTAL2_FSM_START_L_MSB                                        7
+#define XTAL2_FSM_START_L_LSB                                        7
+#define XTAL2_FSM_START_L_MASK                                       0x00000080
+#define XTAL2_FSM_START_L_GET(x)                                     (((x) & XTAL2_FSM_START_L_MASK) >> XTAL2_FSM_START_L_LSB)
+#define XTAL2_FSM_START_L_SET(x)                                     (((x) << XTAL2_FSM_START_L_LSB) & XTAL2_FSM_START_L_MASK)
+#define XTAL2_FSM_START_L_RESET                                      0x1 // 1
+#define XTAL2_FSM_DN_READBACK_MSB                                    6
+#define XTAL2_FSM_DN_READBACK_LSB                                    2
+#define XTAL2_FSM_DN_READBACK_MASK                                   0x0000007c
+#define XTAL2_FSM_DN_READBACK_GET(x)                                 (((x) & XTAL2_FSM_DN_READBACK_MASK) >> XTAL2_FSM_DN_READBACK_LSB)
+#define XTAL2_FSM_DN_READBACK_SET(x)                                 (((x) << XTAL2_FSM_DN_READBACK_LSB) & XTAL2_FSM_DN_READBACK_MASK)
+#define XTAL2_FSM_DN_READBACK_RESET                                  0x0 // 0
+#define XTAL2_TDC_SAT_FLAG_MSB                                       1
+#define XTAL2_TDC_SAT_FLAG_LSB                                       1
+#define XTAL2_TDC_SAT_FLAG_MASK                                      0x00000002
+#define XTAL2_TDC_SAT_FLAG_GET(x)                                    (((x) & XTAL2_TDC_SAT_FLAG_MASK) >> XTAL2_TDC_SAT_FLAG_LSB)
+#define XTAL2_TDC_SAT_FLAG_SET(x)                                    (((x) << XTAL2_TDC_SAT_FLAG_LSB) & XTAL2_TDC_SAT_FLAG_MASK)
+#define XTAL2_TDC_SAT_FLAG_RESET                                     0x0 // 0
+#define XTAL2_FSM_READY_MSB                                          0
+#define XTAL2_FSM_READY_LSB                                          0
+#define XTAL2_FSM_READY_MASK                                         0x00000001
+#define XTAL2_FSM_READY_GET(x)                                       (((x) & XTAL2_FSM_READY_MASK) >> XTAL2_FSM_READY_LSB)
+#define XTAL2_FSM_READY_SET(x)                                       (((x) << XTAL2_FSM_READY_LSB) & XTAL2_FSM_READY_MASK)
+#define XTAL2_FSM_READY_RESET                                        0x0 // 0
+#define XTAL2_ADDRESS                                                0x181162c4
+
+#define XTAL3_FSM_UP_READBACK_MSB                                    31
+#define XTAL3_FSM_UP_READBACK_LSB                                    27
+#define XTAL3_FSM_UP_READBACK_MASK                                   0xf8000000
+#define XTAL3_FSM_UP_READBACK_GET(x)                                 (((x) & XTAL3_FSM_UP_READBACK_MASK) >> XTAL3_FSM_UP_READBACK_LSB)
+#define XTAL3_FSM_UP_READBACK_SET(x)                                 (((x) << XTAL3_FSM_UP_READBACK_LSB) & XTAL3_FSM_UP_READBACK_MASK)
+#define XTAL3_FSM_UP_READBACK_RESET                                  0x0 // 0
+#define XTAL3_EVAL_LENGTH_MSB                                        26
+#define XTAL3_EVAL_LENGTH_LSB                                        16
+#define XTAL3_EVAL_LENGTH_MASK                                       0x07ff0000
+#define XTAL3_EVAL_LENGTH_GET(x)                                     (((x) & XTAL3_EVAL_LENGTH_MASK) >> XTAL3_EVAL_LENGTH_LSB)
+#define XTAL3_EVAL_LENGTH_SET(x)                                     (((x) << XTAL3_EVAL_LENGTH_LSB) & XTAL3_EVAL_LENGTH_MASK)
+#define XTAL3_EVAL_LENGTH_RESET                                      0x400 // 1024
+#define XTAL3_TDC_ERROR_FLAG_MSB                                     15
+#define XTAL3_TDC_ERROR_FLAG_LSB                                     15
+#define XTAL3_TDC_ERROR_FLAG_MASK                                    0x00008000
+#define XTAL3_TDC_ERROR_FLAG_GET(x)                                  (((x) & XTAL3_TDC_ERROR_FLAG_MASK) >> XTAL3_TDC_ERROR_FLAG_LSB)
+#define XTAL3_TDC_ERROR_FLAG_SET(x)                                  (((x) << XTAL3_TDC_ERROR_FLAG_LSB) & XTAL3_TDC_ERROR_FLAG_MASK)
+#define XTAL3_TDC_ERROR_FLAG_RESET                                   0x0 // 0
+#define XTAL3_HARMONIC_NUMBER_MSB                                    14
+#define XTAL3_HARMONIC_NUMBER_LSB                                    2
+#define XTAL3_HARMONIC_NUMBER_MASK                                   0x00007ffc
+#define XTAL3_HARMONIC_NUMBER_GET(x)                                 (((x) & XTAL3_HARMONIC_NUMBER_MASK) >> XTAL3_HARMONIC_NUMBER_LSB)
+#define XTAL3_HARMONIC_NUMBER_SET(x)                                 (((x) << XTAL3_HARMONIC_NUMBER_LSB) & XTAL3_HARMONIC_NUMBER_MASK)
+#define XTAL3_HARMONIC_NUMBER_RESET                                  0x51 // 81
+#define XTAL3_SPARE_MSB                                              1
+#define XTAL3_SPARE_LSB                                              0
+#define XTAL3_SPARE_MASK                                             0x00000003
+#define XTAL3_SPARE_GET(x)                                           (((x) & XTAL3_SPARE_MASK) >> XTAL3_SPARE_LSB)
+#define XTAL3_SPARE_SET(x)                                           (((x) << XTAL3_SPARE_LSB) & XTAL3_SPARE_MASK)
+#define XTAL3_SPARE_RESET                                            0x0 // 0
+#define XTAL3_ADDRESS                                                0x181162c8
+
+#define RST_REVISION_ID_ADDRESS                                      0x18060090
+#define is_drqfn()	(!(ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0x1000))
+
+#define RST_BOOTSTRAP_RES4_MSB                                       15
+#define RST_BOOTSTRAP_RES4_LSB                                       13
+#define RST_BOOTSTRAP_RES4_MASK                                      0x0000e000
+#define RST_BOOTSTRAP_RES4_GET(x)                                    (((x) & RST_BOOTSTRAP_RES4_MASK) >> RST_BOOTSTRAP_RES4_LSB)
+#define RST_BOOTSTRAP_RES4_SET(x)                                    (((x) << RST_BOOTSTRAP_RES4_LSB) & RST_BOOTSTRAP_RES4_MASK)
+#define RST_BOOTSTRAP_RES4_RESET                                     0x0 // 0
+#define RST_BOOTSTRAP_SW_OPTION2_MSB                                 12
+#define RST_BOOTSTRAP_SW_OPTION2_LSB                                 12
+#define RST_BOOTSTRAP_SW_OPTION2_MASK                                0x00001000
+#define RST_BOOTSTRAP_SW_OPTION2_GET(x)                              (((x) & RST_BOOTSTRAP_SW_OPTION2_MASK) >> RST_BOOTSTRAP_SW_OPTION2_LSB)
+#define RST_BOOTSTRAP_SW_OPTION2_SET(x)                              (((x) << RST_BOOTSTRAP_SW_OPTION2_LSB) & RST_BOOTSTRAP_SW_OPTION2_MASK)
+#define RST_BOOTSTRAP_SW_OPTION2_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_SW_OPTION1_MSB                                 11
+#define RST_BOOTSTRAP_SW_OPTION1_LSB                                 11
+#define RST_BOOTSTRAP_SW_OPTION1_MASK                                0x00000800
+#define RST_BOOTSTRAP_SW_OPTION1_GET(x)                              (((x) & RST_BOOTSTRAP_SW_OPTION1_MASK) >> RST_BOOTSTRAP_SW_OPTION1_LSB)
+#define RST_BOOTSTRAP_SW_OPTION1_SET(x)                              (((x) << RST_BOOTSTRAP_SW_OPTION1_LSB) & RST_BOOTSTRAP_SW_OPTION1_MASK)
+#define RST_BOOTSTRAP_SW_OPTION1_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_TESTROM_ENABLE_MSB                             10
+#define RST_BOOTSTRAP_TESTROM_ENABLE_LSB                             10
+#define RST_BOOTSTRAP_TESTROM_ENABLE_MASK                            0x00000400
+#define RST_BOOTSTRAP_TESTROM_ENABLE_GET(x)                          (((x) & RST_BOOTSTRAP_TESTROM_ENABLE_MASK) >> RST_BOOTSTRAP_TESTROM_ENABLE_LSB)
+#define RST_BOOTSTRAP_TESTROM_ENABLE_SET(x)                          (((x) << RST_BOOTSTRAP_TESTROM_ENABLE_LSB) & RST_BOOTSTRAP_TESTROM_ENABLE_MASK)
+#define RST_BOOTSTRAP_TESTROM_ENABLE_RESET                           0x0 // 0
+#define RST_BOOTSTRAP_RES3_MSB                                       9
+#define RST_BOOTSTRAP_RES3_LSB                                       9
+#define RST_BOOTSTRAP_RES3_MASK                                      0x00000200
+#define RST_BOOTSTRAP_RES3_GET(x)                                    (((x) & RST_BOOTSTRAP_RES3_MASK) >> RST_BOOTSTRAP_RES3_LSB)
+#define RST_BOOTSTRAP_RES3_SET(x)                                    (((x) << RST_BOOTSTRAP_RES3_LSB) & RST_BOOTSTRAP_RES3_MASK)
+#define RST_BOOTSTRAP_RES3_RESET                                     0x0 // 0
+#define RST_BOOTSTRAP_SRIF_ENABLE_MSB                                8
+#define RST_BOOTSTRAP_SRIF_ENABLE_LSB                                8
+#define RST_BOOTSTRAP_SRIF_ENABLE_MASK                               0x00000100
+#define RST_BOOTSTRAP_SRIF_ENABLE_GET(x)                             (((x) & RST_BOOTSTRAP_SRIF_ENABLE_MASK) >> RST_BOOTSTRAP_SRIF_ENABLE_LSB)
+#define RST_BOOTSTRAP_SRIF_ENABLE_SET(x)                             (((x) << RST_BOOTSTRAP_SRIF_ENABLE_LSB) & RST_BOOTSTRAP_SRIF_ENABLE_MASK)
+#define RST_BOOTSTRAP_SRIF_ENABLE_RESET                              0x0 // 0
+#define RST_BOOTSTRAP_USB_MODE_MSB                                   7
+#define RST_BOOTSTRAP_USB_MODE_LSB                                   7
+#define RST_BOOTSTRAP_USB_MODE_MASK                                  0x00000080
+#define RST_BOOTSTRAP_USB_MODE_GET(x)                                (((x) & RST_BOOTSTRAP_USB_MODE_MASK) >> RST_BOOTSTRAP_USB_MODE_LSB)
+#define RST_BOOTSTRAP_USB_MODE_SET(x)                                (((x) << RST_BOOTSTRAP_USB_MODE_LSB) & RST_BOOTSTRAP_USB_MODE_MASK)
+#define RST_BOOTSTRAP_USB_MODE_RESET                                 0x0 // 0
+#define RST_BOOTSTRAP_RES2_MSB                                       6
+#define RST_BOOTSTRAP_RES2_LSB                                       6
+#define RST_BOOTSTRAP_RES2_MASK                                      0x00000040
+#define RST_BOOTSTRAP_RES2_GET(x)                                    (((x) & RST_BOOTSTRAP_RES2_MASK) >> RST_BOOTSTRAP_RES2_LSB)
+#define RST_BOOTSTRAP_RES2_SET(x)                                    (((x) << RST_BOOTSTRAP_RES2_LSB) & RST_BOOTSTRAP_RES2_MASK)
+#define RST_BOOTSTRAP_RES2_RESET                                     0x0 // 0
+#define RST_BOOTSTRAP_EJTAG_MODE_MSB                                 5
+#define RST_BOOTSTRAP_EJTAG_MODE_LSB                                 5
+#define RST_BOOTSTRAP_EJTAG_MODE_MASK                                0x00000020
+#define RST_BOOTSTRAP_EJTAG_MODE_GET(x)                              (((x) & RST_BOOTSTRAP_EJTAG_MODE_MASK) >> RST_BOOTSTRAP_EJTAG_MODE_LSB)
+#define RST_BOOTSTRAP_EJTAG_MODE_SET(x)                              (((x) << RST_BOOTSTRAP_EJTAG_MODE_LSB) & RST_BOOTSTRAP_EJTAG_MODE_MASK)
+#define RST_BOOTSTRAP_EJTAG_MODE_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_REF_CLK_MSB                                    4
+#define RST_BOOTSTRAP_REF_CLK_LSB                                    4
+#define RST_BOOTSTRAP_REF_CLK_MASK                                   0x00000010
+#define RST_BOOTSTRAP_REF_CLK_GET(x)                                 (((x) & RST_BOOTSTRAP_REF_CLK_MASK) >> RST_BOOTSTRAP_REF_CLK_LSB)
+#define RST_BOOTSTRAP_REF_CLK_SET(x)                                 (((x) << RST_BOOTSTRAP_REF_CLK_LSB) & RST_BOOTSTRAP_REF_CLK_MASK)
+#define RST_BOOTSTRAP_REF_CLK_RESET                                  0x0 // 0
+#define RST_BOOTSTRAP_RES1_MSB                                       3
+#define RST_BOOTSTRAP_RES1_LSB                                       3
+#define RST_BOOTSTRAP_RES1_MASK                                      0x00000008
+#define RST_BOOTSTRAP_RES1_GET(x)                                    (((x) & RST_BOOTSTRAP_RES1_MASK) >> RST_BOOTSTRAP_RES1_LSB)
+#define RST_BOOTSTRAP_RES1_SET(x)                                    (((x) << RST_BOOTSTRAP_RES1_LSB) & RST_BOOTSTRAP_RES1_MASK)
+#define RST_BOOTSTRAP_RES1_RESET                                     0x0 // 0
+#define RST_BOOTSTRAP_RES0_MSB                                       2
+#define RST_BOOTSTRAP_RES0_LSB                                       2
+#define RST_BOOTSTRAP_RES0_MASK                                      0x00000004
+#define RST_BOOTSTRAP_RES0_GET(x)                                    (((x) & RST_BOOTSTRAP_RES0_MASK) >> RST_BOOTSTRAP_RES0_LSB)
+#define RST_BOOTSTRAP_RES0_SET(x)                                    (((x) << RST_BOOTSTRAP_RES0_LSB) & RST_BOOTSTRAP_RES0_MASK)
+#define RST_BOOTSTRAP_RES0_RESET                                     0x0 // 0
+#define RST_BOOTSTRAP_SDRAM_SELECT_MSB                               1
+#define RST_BOOTSTRAP_SDRAM_SELECT_LSB                               1
+#define RST_BOOTSTRAP_SDRAM_SELECT_MASK                              0x00000002
+#define RST_BOOTSTRAP_SDRAM_SELECT_GET(x)                            (((x) & RST_BOOTSTRAP_SDRAM_SELECT_MASK) >> RST_BOOTSTRAP_SDRAM_SELECT_LSB)
+#define RST_BOOTSTRAP_SDRAM_SELECT_SET(x)                            (((x) << RST_BOOTSTRAP_SDRAM_SELECT_LSB) & RST_BOOTSTRAP_SDRAM_SELECT_MASK)
+#define RST_BOOTSTRAP_SDRAM_SELECT_RESET                             0x0 // 0
+#define RST_BOOTSTRAP_DDR_SELECT_MSB                                 0
+#define RST_BOOTSTRAP_DDR_SELECT_LSB                                 0
+#define RST_BOOTSTRAP_DDR_SELECT_MASK                                0x00000001
+#define RST_BOOTSTRAP_DDR_SELECT_GET(x)                              (((x) & RST_BOOTSTRAP_DDR_SELECT_MASK) >> RST_BOOTSTRAP_DDR_SELECT_LSB)
+#define RST_BOOTSTRAP_DDR_SELECT_SET(x)                              (((x) << RST_BOOTSTRAP_DDR_SELECT_LSB) & RST_BOOTSTRAP_DDR_SELECT_MASK)
+#define RST_BOOTSTRAP_DDR_SELECT_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_ADDRESS                                        0x180600b0
+
+#define RST_CLKGAT_EN_SPARE_MSB                                      31
+#define RST_CLKGAT_EN_SPARE_LSB                                      12
+#define RST_CLKGAT_EN_SPARE_MASK                                     0xfffff000
+#define RST_CLKGAT_EN_SPARE_GET(x)                                   (((x) & RST_CLKGAT_EN_SPARE_MASK) >> RST_CLKGAT_EN_SPARE_LSB)
+#define RST_CLKGAT_EN_SPARE_SET(x)                                   (((x) << RST_CLKGAT_EN_SPARE_LSB) & RST_CLKGAT_EN_SPARE_MASK)
+#define RST_CLKGAT_EN_SPARE_RESET                                    0x0 // 0
+#define RST_CLKGAT_EN_WMAC_MSB                                       9
+#define RST_CLKGAT_EN_WMAC_LSB                                       9
+#define RST_CLKGAT_EN_WMAC_MASK                                      0x00000200
+#define RST_CLKGAT_EN_WMAC_GET(x)                                    (((x) & RST_CLKGAT_EN_WMAC_MASK) >> RST_CLKGAT_EN_WMAC_LSB)
+#define RST_CLKGAT_EN_WMAC_SET(x)                                    (((x) << RST_CLKGAT_EN_WMAC_LSB) & RST_CLKGAT_EN_WMAC_MASK)
+#define RST_CLKGAT_EN_WMAC_RESET                                     0x1 // 1
+#define RST_CLKGAT_EN_USB1_MSB                                       7
+#define RST_CLKGAT_EN_USB1_LSB                                       7
+#define RST_CLKGAT_EN_USB1_MASK                                      0x00000080
+#define RST_CLKGAT_EN_USB1_GET(x)                                    (((x) & RST_CLKGAT_EN_USB1_MASK) >> RST_CLKGAT_EN_USB1_LSB)
+#define RST_CLKGAT_EN_USB1_SET(x)                                    (((x) << RST_CLKGAT_EN_USB1_LSB) & RST_CLKGAT_EN_USB1_MASK)
+#define RST_CLKGAT_EN_USB1_RESET                                     0x1 // 1
+#define RST_CLKGAT_EN_GE1_MSB                                        6
+#define RST_CLKGAT_EN_GE1_LSB                                        6
+#define RST_CLKGAT_EN_GE1_MASK                                       0x00000040
+#define RST_CLKGAT_EN_GE1_GET(x)                                     (((x) & RST_CLKGAT_EN_GE1_MASK) >> RST_CLKGAT_EN_GE1_LSB)
+#define RST_CLKGAT_EN_GE1_SET(x)                                     (((x) << RST_CLKGAT_EN_GE1_LSB) & RST_CLKGAT_EN_GE1_MASK)
+#define RST_CLKGAT_EN_GE1_RESET                                      0x1 // 1
+#define RST_CLKGAT_EN_GE0_MSB                                        5
+#define RST_CLKGAT_EN_GE0_LSB                                        5
+#define RST_CLKGAT_EN_GE0_MASK                                       0x00000020
+#define RST_CLKGAT_EN_GE0_GET(x)                                     (((x) & RST_CLKGAT_EN_GE0_MASK) >> RST_CLKGAT_EN_GE0_LSB)
+#define RST_CLKGAT_EN_GE0_SET(x)                                     (((x) << RST_CLKGAT_EN_GE0_LSB) & RST_CLKGAT_EN_GE0_MASK)
+#define RST_CLKGAT_EN_GE0_RESET                                      0x1 // 1
+#define RST_CLKGAT_EN_PCIE_RC_MSB                                    1
+#define RST_CLKGAT_EN_PCIE_RC_LSB                                    1
+#define RST_CLKGAT_EN_PCIE_RC_MASK                                   0x00000002
+#define RST_CLKGAT_EN_PCIE_RC_GET(x)                                 (((x) & RST_CLKGAT_EN_PCIE_RC_MASK) >> RST_CLKGAT_EN_PCIE_RC_LSB)
+#define RST_CLKGAT_EN_PCIE_RC_SET(x)                                 (((x) << RST_CLKGAT_EN_PCIE_RC_LSB) & RST_CLKGAT_EN_PCIE_RC_MASK)
+#define RST_CLKGAT_EN_PCIE_RC_RESET                                  0x1 // 1
+#define RST_CLKGAT_EN_ADDRESS                                        0x180600c0
+#define RST_CLKGAT_EN_OFFSET                                         0x00c0
+// SW modifiable bits
+#define RST_CLKGAT_EN_SW_MASK                                        0xfffff2e2
+// bits defined at reset
+#define RST_CLKGAT_EN_RSTMASK                                        0xffffffff
+// reset value (ignore bits undefined at reset)
+#define RST_CLKGAT_EN_RESET                                          0x000002e2
+
+#define GPIO_OE_ADDRESS                                              0x18040000
+#define GPIO_IN_ADDRESS												 0x18040004/*  by huangwenzhong, 03Sep13 */
+#define GPIO_OUT_ADDRESS                                             0x18040008
+#define GPIO_SPARE_ADDRESS                                           0x18040070
+
+
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_MSB                         31
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_LSB                         24
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_MASK                        0xff000000
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_GET(x)                      (((x) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_MASK) >> GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_LSB)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_SET(x)                      (((x) << GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_LSB) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_MASK)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_3_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_MSB                         23
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_LSB                         16
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_MASK                        0x00ff0000
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_GET(x)                      (((x) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_MASK) >> GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_LSB)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_SET(x)                      (((x) << GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_LSB) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_MASK)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_2_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_MSB                         15
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_LSB                         8
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_MASK                        0x0000ff00
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_GET(x)                      (((x) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_MASK) >> GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_LSB)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_SET(x)                      (((x) << GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_LSB) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_MASK)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_1_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_MSB                         7
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_LSB                         0
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_MASK                        0x000000ff
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_GET(x)                      (((x) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_MASK) >> GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_LSB)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_SET(x)                      (((x) << GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_LSB) & GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_MASK)
+#define GPIO_OUT_FUNCTION0_ENABLE_GPIO_0_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION0_ADDRESS                                   0x1804002c
+
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MSB                         31
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB                         24
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK                        0xff000000
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_RESET                       0xc // 12
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MSB                         23
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB                         16
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK                        0x00ff0000
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_RESET                       0x8 // 8
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MSB                         15
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB                         8
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK                        0x0000ff00
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_RESET                       0x9 // 9
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MSB                         7
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB                         0
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK                        0x000000ff
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_RESET                       0x5d // 93
+#define GPIO_OUT_FUNCTION1_ADDRESS                                   0x18040030
+
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MSB                        31
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_LSB                        24
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MASK                       0xff000000
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_GET(x)                     (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_SET(x)                     (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MSB                        23
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_LSB                        16
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MASK                       0x00ff0000
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_GET(x)                     (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_SET(x)                     (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MSB                         15
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_LSB                         8
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MASK                        0x0000ff00
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_GET(x)                      (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_SET(x)                      (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MSB                         7
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_LSB                         0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MASK                        0x000000ff
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_GET(x)                      (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_SET(x)                      (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION2_ADDRESS                                   0x18040034
+
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MSB                        31
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_LSB                        24
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK                       0xff000000
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MSB                        23
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_LSB                        16
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK                       0x00ff0000
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MSB                        15
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_LSB                        8
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK                       0x0000ff00
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MSB                        7
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_LSB                        0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK                       0x000000ff
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ADDRESS                                   0x18040038
+
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MSB                        15
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB                        8
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK                       0x0000ff00
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_RESET                      0x1 // 1
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MSB                        7
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB                        0
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK                       0x000000ff
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION4_ADDRESS                                   0x1804003c
+
+#define GPIO_IN_ENABLE0_UART_SIN_MSB                                 15
+#define GPIO_IN_ENABLE0_UART_SIN_LSB                                 8
+#define GPIO_IN_ENABLE0_UART_SIN_MASK                                0x0000ff00
+#define GPIO_IN_ENABLE0_UART_SIN_GET(x)                              (((x) & GPIO_IN_ENABLE0_UART_SIN_MASK) >> GPIO_IN_ENABLE0_UART_SIN_LSB)
+#define GPIO_IN_ENABLE0_UART_SIN_SET(x)                              (((x) << GPIO_IN_ENABLE0_UART_SIN_LSB) & GPIO_IN_ENABLE0_UART_SIN_MASK)
+#define GPIO_IN_ENABLE0_UART_SIN_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_MSB                              7
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_LSB                              0
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_MASK                             0x000000ff
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_GET(x)                           (((x) & GPIO_IN_ENABLE0_SPI_DATA_IN_MASK) >> GPIO_IN_ENABLE0_SPI_DATA_IN_LSB)
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_SET(x)                           (((x) << GPIO_IN_ENABLE0_SPI_DATA_IN_LSB) & GPIO_IN_ENABLE0_SPI_DATA_IN_MASK)
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_RESET                            0x8 // 8
+#define GPIO_IN_ENABLE0_ADDRESS                                      0x18040044
+
+#define GPIO_IN_ENABLE1_RES_MSB                                      31
+#define GPIO_IN_ENABLE1_RES_LSB                                      0
+#define GPIO_IN_ENABLE1_RES_MASK                                     0xffffffff
+#define GPIO_IN_ENABLE1_RES_GET(x)                                   (((x) & GPIO_IN_ENABLE1_RES_MASK) >> GPIO_IN_ENABLE1_RES_LSB)
+#define GPIO_IN_ENABLE1_RES_SET(x)                                   (((x) << GPIO_IN_ENABLE1_RES_LSB) & GPIO_IN_ENABLE1_RES_MASK)
+#define GPIO_IN_ENABLE1_RES_RESET                                    0x0 // 0
+#define GPIO_IN_ENABLE1_ADDRESS                                      0x18040048
+
+#define GPIO_IN_ENABLE2_RES_MSB                                      31
+#define GPIO_IN_ENABLE2_RES_LSB                                      0
+#define GPIO_IN_ENABLE2_RES_MASK                                     0xffffffff
+#define GPIO_IN_ENABLE2_RES_GET(x)                                   (((x) & GPIO_IN_ENABLE2_RES_MASK) >> GPIO_IN_ENABLE2_RES_LSB)
+#define GPIO_IN_ENABLE2_RES_SET(x)                                   (((x) << GPIO_IN_ENABLE2_RES_LSB) & GPIO_IN_ENABLE2_RES_MASK)
+#define GPIO_IN_ENABLE2_RES_RESET                                    0x0 // 0
+#define GPIO_IN_ENABLE2_ADDRESS                                      0x1804004c
+
+#define GPIO_IN_ENABLE3_RES_MSB                                      31
+#define GPIO_IN_ENABLE3_RES_LSB                                      0
+#define GPIO_IN_ENABLE3_RES_MASK                                     0xffffffff
+#define GPIO_IN_ENABLE3_RES_GET(x)                                   (((x) & GPIO_IN_ENABLE3_RES_MASK) >> GPIO_IN_ENABLE3_RES_LSB)
+#define GPIO_IN_ENABLE3_RES_SET(x)                                   (((x) << GPIO_IN_ENABLE3_RES_LSB) & GPIO_IN_ENABLE3_RES_MASK)
+#define GPIO_IN_ENABLE3_RES_RESET                                    0x0 // 0
+#define GPIO_IN_ENABLE3_ADDRESS                                      0x18040050
+
+#define GPIO_IN_ENABLE4_RES_MSB                                      31
+#define GPIO_IN_ENABLE4_RES_LSB                                      0
+#define GPIO_IN_ENABLE4_RES_MASK                                     0xffffffff
+#define GPIO_IN_ENABLE4_RES_GET(x)                                   (((x) & GPIO_IN_ENABLE4_RES_MASK) >> GPIO_IN_ENABLE4_RES_LSB)
+#define GPIO_IN_ENABLE4_RES_SET(x)                                   (((x) << GPIO_IN_ENABLE4_RES_LSB) & GPIO_IN_ENABLE4_RES_MASK)
+#define GPIO_IN_ENABLE4_RES_RESET                                    0x0 // 0
+#define GPIO_IN_ENABLE4_ADDRESS                                      0x18040054
+
+#define GPIO_IN_ENABLE5_WMAC_IN3_MSB                                 31
+#define GPIO_IN_ENABLE5_WMAC_IN3_LSB                                 24
+#define GPIO_IN_ENABLE5_WMAC_IN3_MASK                                0xff000000
+#define GPIO_IN_ENABLE5_WMAC_IN3_GET(x)                              (((x) & GPIO_IN_ENABLE5_WMAC_IN3_MASK) >> GPIO_IN_ENABLE5_WMAC_IN3_LSB)
+#define GPIO_IN_ENABLE5_WMAC_IN3_SET(x)                              (((x) << GPIO_IN_ENABLE5_WMAC_IN3_LSB) & GPIO_IN_ENABLE5_WMAC_IN3_MASK)
+#define GPIO_IN_ENABLE5_WMAC_IN3_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE5_WMAC_IN2_MSB                                 23
+#define GPIO_IN_ENABLE5_WMAC_IN2_LSB                                 16
+#define GPIO_IN_ENABLE5_WMAC_IN2_MASK                                0x00ff0000
+#define GPIO_IN_ENABLE5_WMAC_IN2_GET(x)                              (((x) & GPIO_IN_ENABLE5_WMAC_IN2_MASK) >> GPIO_IN_ENABLE5_WMAC_IN2_LSB)
+#define GPIO_IN_ENABLE5_WMAC_IN2_SET(x)                              (((x) << GPIO_IN_ENABLE5_WMAC_IN2_LSB) & GPIO_IN_ENABLE5_WMAC_IN2_MASK)
+#define GPIO_IN_ENABLE5_WMAC_IN2_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE5_WMAC_IN1_MSB                                 15
+#define GPIO_IN_ENABLE5_WMAC_IN1_LSB                                 8
+#define GPIO_IN_ENABLE5_WMAC_IN1_MASK                                0x0000ff00
+#define GPIO_IN_ENABLE5_WMAC_IN1_GET(x)                              (((x) & GPIO_IN_ENABLE5_WMAC_IN1_MASK) >> GPIO_IN_ENABLE5_WMAC_IN1_LSB)
+#define GPIO_IN_ENABLE5_WMAC_IN1_SET(x)                              (((x) << GPIO_IN_ENABLE5_WMAC_IN1_LSB) & GPIO_IN_ENABLE5_WMAC_IN1_MASK)
+#define GPIO_IN_ENABLE5_WMAC_IN1_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE5_WMAC_IN0_MSB                                 7
+#define GPIO_IN_ENABLE5_WMAC_IN0_LSB                                 0
+#define GPIO_IN_ENABLE5_WMAC_IN0_MASK                                0x000000ff
+#define GPIO_IN_ENABLE5_WMAC_IN0_GET(x)                              (((x) & GPIO_IN_ENABLE5_WMAC_IN0_MASK) >> GPIO_IN_ENABLE5_WMAC_IN0_LSB)
+#define GPIO_IN_ENABLE5_WMAC_IN0_SET(x)                              (((x) << GPIO_IN_ENABLE5_WMAC_IN0_LSB) & GPIO_IN_ENABLE5_WMAC_IN0_MASK)
+#define GPIO_IN_ENABLE5_WMAC_IN0_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE5_ADDRESS                                      0x18040058
+
+#define GPIO_IN_ENABLE6_WMAC_IN7_MSB                                 31
+#define GPIO_IN_ENABLE6_WMAC_IN7_LSB                                 24
+#define GPIO_IN_ENABLE6_WMAC_IN7_MASK                                0xff000000
+#define GPIO_IN_ENABLE6_WMAC_IN7_GET(x)                              (((x) & GPIO_IN_ENABLE6_WMAC_IN7_MASK) >> GPIO_IN_ENABLE6_WMAC_IN7_LSB)
+#define GPIO_IN_ENABLE6_WMAC_IN7_SET(x)                              (((x) << GPIO_IN_ENABLE6_WMAC_IN7_LSB) & GPIO_IN_ENABLE6_WMAC_IN7_MASK)
+#define GPIO_IN_ENABLE6_WMAC_IN7_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE6_WMAC_IN6_MSB                                 23
+#define GPIO_IN_ENABLE6_WMAC_IN6_LSB                                 16
+#define GPIO_IN_ENABLE6_WMAC_IN6_MASK                                0x00ff0000
+#define GPIO_IN_ENABLE6_WMAC_IN6_GET(x)                              (((x) & GPIO_IN_ENABLE6_WMAC_IN6_MASK) >> GPIO_IN_ENABLE6_WMAC_IN6_LSB)
+#define GPIO_IN_ENABLE6_WMAC_IN6_SET(x)                              (((x) << GPIO_IN_ENABLE6_WMAC_IN6_LSB) & GPIO_IN_ENABLE6_WMAC_IN6_MASK)
+#define GPIO_IN_ENABLE6_WMAC_IN6_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE6_WMAC_IN5_MSB                                 15
+#define GPIO_IN_ENABLE6_WMAC_IN5_LSB                                 8
+#define GPIO_IN_ENABLE6_WMAC_IN5_MASK                                0x0000ff00
+#define GPIO_IN_ENABLE6_WMAC_IN5_GET(x)                              (((x) & GPIO_IN_ENABLE6_WMAC_IN5_MASK) >> GPIO_IN_ENABLE6_WMAC_IN5_LSB)
+#define GPIO_IN_ENABLE6_WMAC_IN5_SET(x)                              (((x) << GPIO_IN_ENABLE6_WMAC_IN5_LSB) & GPIO_IN_ENABLE6_WMAC_IN5_MASK)
+#define GPIO_IN_ENABLE6_WMAC_IN5_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE6_WMAC_IN4_MSB                                 7
+#define GPIO_IN_ENABLE6_WMAC_IN4_LSB                                 0
+#define GPIO_IN_ENABLE6_WMAC_IN4_MASK                                0x000000ff
+#define GPIO_IN_ENABLE6_WMAC_IN4_GET(x)                              (((x) & GPIO_IN_ENABLE6_WMAC_IN4_MASK) >> GPIO_IN_ENABLE6_WMAC_IN4_LSB)
+#define GPIO_IN_ENABLE6_WMAC_IN4_SET(x)                              (((x) << GPIO_IN_ENABLE6_WMAC_IN4_LSB) & GPIO_IN_ENABLE6_WMAC_IN4_MASK)
+#define GPIO_IN_ENABLE6_WMAC_IN4_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE6_ADDRESS                                      0x1804005c
+
+#define GPIO_IN_ENABLE7_WMAC_IN11_MSB                                31
+#define GPIO_IN_ENABLE7_WMAC_IN11_LSB                                24
+#define GPIO_IN_ENABLE7_WMAC_IN11_MASK                               0xff000000
+#define GPIO_IN_ENABLE7_WMAC_IN11_GET(x)                             (((x) & GPIO_IN_ENABLE7_WMAC_IN11_MASK) >> GPIO_IN_ENABLE7_WMAC_IN11_LSB)
+#define GPIO_IN_ENABLE7_WMAC_IN11_SET(x)                             (((x) << GPIO_IN_ENABLE7_WMAC_IN11_LSB) & GPIO_IN_ENABLE7_WMAC_IN11_MASK)
+#define GPIO_IN_ENABLE7_WMAC_IN11_RESET                              0x80 // 128
+#define GPIO_IN_ENABLE7_WMAC_IN10_MSB                                23
+#define GPIO_IN_ENABLE7_WMAC_IN10_LSB                                16
+#define GPIO_IN_ENABLE7_WMAC_IN10_MASK                               0x00ff0000
+#define GPIO_IN_ENABLE7_WMAC_IN10_GET(x)                             (((x) & GPIO_IN_ENABLE7_WMAC_IN10_MASK) >> GPIO_IN_ENABLE7_WMAC_IN10_LSB)
+#define GPIO_IN_ENABLE7_WMAC_IN10_SET(x)                             (((x) << GPIO_IN_ENABLE7_WMAC_IN10_LSB) & GPIO_IN_ENABLE7_WMAC_IN10_MASK)
+#define GPIO_IN_ENABLE7_WMAC_IN10_RESET                              0x80 // 128
+#define GPIO_IN_ENABLE7_WMAC_IN9_MSB                                 15
+#define GPIO_IN_ENABLE7_WMAC_IN9_LSB                                 8
+#define GPIO_IN_ENABLE7_WMAC_IN9_MASK                                0x0000ff00
+#define GPIO_IN_ENABLE7_WMAC_IN9_GET(x)                              (((x) & GPIO_IN_ENABLE7_WMAC_IN9_MASK) >> GPIO_IN_ENABLE7_WMAC_IN9_LSB)
+#define GPIO_IN_ENABLE7_WMAC_IN9_SET(x)                              (((x) << GPIO_IN_ENABLE7_WMAC_IN9_LSB) & GPIO_IN_ENABLE7_WMAC_IN9_MASK)
+#define GPIO_IN_ENABLE7_WMAC_IN9_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE7_WMAC_IN8_MSB                                 7
+#define GPIO_IN_ENABLE7_WMAC_IN8_LSB                                 0
+#define GPIO_IN_ENABLE7_WMAC_IN8_MASK                                0x000000ff
+#define GPIO_IN_ENABLE7_WMAC_IN8_GET(x)                              (((x) & GPIO_IN_ENABLE7_WMAC_IN8_MASK) >> GPIO_IN_ENABLE7_WMAC_IN8_LSB)
+#define GPIO_IN_ENABLE7_WMAC_IN8_SET(x)                              (((x) << GPIO_IN_ENABLE7_WMAC_IN8_LSB) & GPIO_IN_ENABLE7_WMAC_IN8_MASK)
+#define GPIO_IN_ENABLE7_WMAC_IN8_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE7_ADDRESS                                      0x18040060
+
+#define GPIO_IN_ENABLE8_SRIF_SRESET_MSB                              31
+#define GPIO_IN_ENABLE8_SRIF_SRESET_LSB                              24
+#define GPIO_IN_ENABLE8_SRIF_SRESET_MASK                             0xff000000
+#define GPIO_IN_ENABLE8_SRIF_SRESET_GET(x)                           (((x) & GPIO_IN_ENABLE8_SRIF_SRESET_MASK) >> GPIO_IN_ENABLE8_SRIF_SRESET_LSB)
+#define GPIO_IN_ENABLE8_SRIF_SRESET_SET(x)                           (((x) << GPIO_IN_ENABLE8_SRIF_SRESET_LSB) & GPIO_IN_ENABLE8_SRIF_SRESET_MASK)
+#define GPIO_IN_ENABLE8_SRIF_SRESET_RESET                            0x80 // 128
+#define GPIO_IN_ENABLE8_SRIF_SIN_MSB                                 23
+#define GPIO_IN_ENABLE8_SRIF_SIN_LSB                                 16
+#define GPIO_IN_ENABLE8_SRIF_SIN_MASK                                0x00ff0000
+#define GPIO_IN_ENABLE8_SRIF_SIN_GET(x)                              (((x) & GPIO_IN_ENABLE8_SRIF_SIN_MASK) >> GPIO_IN_ENABLE8_SRIF_SIN_LSB)
+#define GPIO_IN_ENABLE8_SRIF_SIN_SET(x)                              (((x) << GPIO_IN_ENABLE8_SRIF_SIN_LSB) & GPIO_IN_ENABLE8_SRIF_SIN_MASK)
+#define GPIO_IN_ENABLE8_SRIF_SIN_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE8_SRIF_SOT_MSB                                 15
+#define GPIO_IN_ENABLE8_SRIF_SOT_LSB                                 8
+#define GPIO_IN_ENABLE8_SRIF_SOT_MASK                                0x0000ff00
+#define GPIO_IN_ENABLE8_SRIF_SOT_GET(x)                              (((x) & GPIO_IN_ENABLE8_SRIF_SOT_MASK) >> GPIO_IN_ENABLE8_SRIF_SOT_LSB)
+#define GPIO_IN_ENABLE8_SRIF_SOT_SET(x)                              (((x) << GPIO_IN_ENABLE8_SRIF_SOT_LSB) & GPIO_IN_ENABLE8_SRIF_SOT_MASK)
+#define GPIO_IN_ENABLE8_SRIF_SOT_RESET                               0x80 // 128
+#define GPIO_IN_ENABLE8_SRIF_SCLK_MSB                                7
+#define GPIO_IN_ENABLE8_SRIF_SCLK_LSB                                0
+#define GPIO_IN_ENABLE8_SRIF_SCLK_MASK                               0x000000ff
+#define GPIO_IN_ENABLE8_SRIF_SCLK_GET(x)                             (((x) & GPIO_IN_ENABLE8_SRIF_SCLK_MASK) >> GPIO_IN_ENABLE8_SRIF_SCLK_LSB)
+#define GPIO_IN_ENABLE8_SRIF_SCLK_SET(x)                             (((x) << GPIO_IN_ENABLE8_SRIF_SCLK_LSB) & GPIO_IN_ENABLE8_SRIF_SCLK_MASK)
+#define GPIO_IN_ENABLE8_SRIF_SCLK_RESET                              0x80 // 128
+#define GPIO_IN_ENABLE8_ADDRESS                                      0x18040064
+
+#define GPIO_IN_ENABLE9_RES_MSB                                      31
+#define GPIO_IN_ENABLE9_RES_LSB                                      0
+#define GPIO_IN_ENABLE9_RES_MASK                                     0xffffffff
+#define GPIO_IN_ENABLE9_RES_GET(x)                                   (((x) & GPIO_IN_ENABLE9_RES_MASK) >> GPIO_IN_ENABLE9_RES_LSB)
+#define GPIO_IN_ENABLE9_RES_SET(x)                                   (((x) << GPIO_IN_ENABLE9_RES_LSB) & GPIO_IN_ENABLE9_RES_MASK)
+#define GPIO_IN_ENABLE9_RES_RESET                                    0x0 // 0
+#define GPIO_IN_ENABLE9_ADDRESS                                      0x18040068
+
+#define GPIO_FUNCTION_EXT_MDIO_SEL_MSB                               11
+#define GPIO_FUNCTION_EXT_MDIO_SEL_LSB                               11
+#define GPIO_FUNCTION_EXT_MDIO_SEL_MASK                              0x00000800
+#define GPIO_FUNCTION_EXT_MDIO_SEL_GET(x)                            (((x) & GPIO_FUNCTION_EXT_MDIO_SEL_MASK) >> GPIO_FUNCTION_EXT_MDIO_SEL_LSB)
+#define GPIO_FUNCTION_EXT_MDIO_SEL_SET(x)                            (((x) << GPIO_FUNCTION_EXT_MDIO_SEL_LSB) & GPIO_FUNCTION_EXT_MDIO_SEL_MASK)
+#define GPIO_FUNCTION_EXT_MDIO_SEL_RESET                             0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_MSB                            8
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_LSB                            8
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_MASK                           0x00000100
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS6_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS6_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS6_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS6_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_MSB                            7
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_LSB                            7
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_MASK                           0x00000080
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS5_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS5_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS5_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS5_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_MSB                            6
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_LSB                            6
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_MASK                           0x00000040
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS4_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS4_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS4_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS4_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_MSB                            5
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_LSB                            5
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_MASK                           0x00000020
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS3_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS3_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS3_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS3_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_RESET                          0x1 // 1
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_MSB                            4
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_LSB                            4
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_MASK                           0x00000010
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS2_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS2_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS2_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS2_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_MSB                            3
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_LSB                            3
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_MASK                           0x00000008
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS1_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS1_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS1_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS1_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_MSB                            2
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_LSB                            2
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_MASK                           0x00000004
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS0_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS0_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS0_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS0_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_DISABLE_JTAG_MSB                               1
+#define GPIO_FUNCTION_DISABLE_JTAG_LSB                               1
+#define GPIO_FUNCTION_DISABLE_JTAG_MASK                              0x00000002
+#define GPIO_FUNCTION_DISABLE_JTAG_GET(x)                            (((x) & GPIO_FUNCTION_DISABLE_JTAG_MASK) >> GPIO_FUNCTION_DISABLE_JTAG_LSB)
+#define GPIO_FUNCTION_DISABLE_JTAG_SET(x)                            (((x) << GPIO_FUNCTION_DISABLE_JTAG_LSB) & GPIO_FUNCTION_DISABLE_JTAG_MASK)
+#define GPIO_FUNCTION_DISABLE_JTAG_RESET                             0x0 // 0
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_MSB                           0
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_LSB                           0
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_MASK                          0x00000001
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_GET(x)                        (((x) & GPIO_FUNCTION_ENABLE_GPIO_SRIF_MASK) >> GPIO_FUNCTION_ENABLE_GPIO_SRIF_LSB)
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_SET(x)                        (((x) << GPIO_FUNCTION_ENABLE_GPIO_SRIF_LSB) & GPIO_FUNCTION_ENABLE_GPIO_SRIF_MASK)
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_RESET                         0x0 // 0
+#define GPIO_FUNCTION_ADDRESS                                        0x1804006c
+
+#define PCIE_RESET_EP_RESET_L_MSB                                    2
+#define PCIE_RESET_EP_RESET_L_LSB                                    2
+#define PCIE_RESET_EP_RESET_L_MASK                                   0x00000004
+#define PCIE_RESET_EP_RESET_L_GET(x)                                 (((x) & PCIE_RESET_EP_RESET_L_MASK) >> PCIE_RESET_EP_RESET_L_LSB)
+#define PCIE_RESET_EP_RESET_L_SET(x)                                 (((x) << PCIE_RESET_EP_RESET_L_LSB) & PCIE_RESET_EP_RESET_L_MASK)
+#define PCIE_RESET_EP_RESET_L_RESET                                  0x0 // 0
+#define PCIE_RESET_LINK_REQ_RESET_MSB                                1
+#define PCIE_RESET_LINK_REQ_RESET_LSB                                1
+#define PCIE_RESET_LINK_REQ_RESET_MASK                               0x00000002
+#define PCIE_RESET_LINK_REQ_RESET_GET(x)                             (((x) & PCIE_RESET_LINK_REQ_RESET_MASK) >> PCIE_RESET_LINK_REQ_RESET_LSB)
+#define PCIE_RESET_LINK_REQ_RESET_SET(x)                             (((x) << PCIE_RESET_LINK_REQ_RESET_LSB) & PCIE_RESET_LINK_REQ_RESET_MASK)
+#define PCIE_RESET_LINK_REQ_RESET_RESET                              0x0 // 0
+#define PCIE_RESET_LINK_UP_MSB                                       0
+#define PCIE_RESET_LINK_UP_LSB                                       0
+#define PCIE_RESET_LINK_UP_MASK                                      0x00000001
+#define PCIE_RESET_LINK_UP_GET(x)                                    (((x) & PCIE_RESET_LINK_UP_MASK) >> PCIE_RESET_LINK_UP_LSB)
+#define PCIE_RESET_LINK_UP_SET(x)                                    (((x) << PCIE_RESET_LINK_UP_LSB) & PCIE_RESET_LINK_UP_MASK)
+#define PCIE_RESET_LINK_UP_RESET                                     0x0 // 0
+#define PCIE_RESET_ADDRESS                                           0x180f0018
+
+#define ETH_CFG_ETH_SPARE_MSB                                        31
+#define ETH_CFG_ETH_SPARE_LSB                                        22
+#define ETH_CFG_ETH_SPARE_MASK                                       0xffc00000
+#define ETH_CFG_ETH_SPARE_GET(x)                                     (((x) & ETH_CFG_ETH_SPARE_MASK) >> ETH_CFG_ETH_SPARE_LSB)
+#define ETH_CFG_ETH_SPARE_SET(x)                                     (((x) << ETH_CFG_ETH_SPARE_LSB) & ETH_CFG_ETH_SPARE_MASK)
+#define ETH_CFG_ETH_SPARE_RESET                                      0x0 // 0
+#define ETH_CFG_SW_ACC_MSB_FIRST_MSB                                 13
+#define ETH_CFG_SW_ACC_MSB_FIRST_LSB                                 13
+#define ETH_CFG_SW_ACC_MSB_FIRST_MASK                                0x00002000
+#define ETH_CFG_SW_ACC_MSB_FIRST_GET(x)                              (((x) & ETH_CFG_SW_ACC_MSB_FIRST_MASK) >> ETH_CFG_SW_ACC_MSB_FIRST_LSB)
+#define ETH_CFG_SW_ACC_MSB_FIRST_SET(x)                              (((x) << ETH_CFG_SW_ACC_MSB_FIRST_LSB) & ETH_CFG_SW_ACC_MSB_FIRST_MASK)
+#define ETH_CFG_SW_ACC_MSB_FIRST_RESET                               0x1 // 1
+#define ETH_CFG_SW_APB_ACCESS_MSB                                    9
+#define ETH_CFG_SW_APB_ACCESS_LSB                                    9
+#define ETH_CFG_SW_APB_ACCESS_MASK                                   0x00000200
+#define ETH_CFG_SW_APB_ACCESS_GET(x)                                 (((x) & ETH_CFG_SW_APB_ACCESS_MASK) >> ETH_CFG_SW_APB_ACCESS_LSB)
+#define ETH_CFG_SW_APB_ACCESS_SET(x)                                 (((x) << ETH_CFG_SW_APB_ACCESS_LSB) & ETH_CFG_SW_APB_ACCESS_MASK)
+#define ETH_CFG_SW_APB_ACCESS_RESET                                  0x0 // 0
+#define ETH_CFG_SW_PHY_ADDR_SWAP_MSB                                 8
+#define ETH_CFG_SW_PHY_ADDR_SWAP_LSB                                 8
+#define ETH_CFG_SW_PHY_ADDR_SWAP_MASK                                0x00000100
+#define ETH_CFG_SW_PHY_ADDR_SWAP_GET(x)                              (((x) & ETH_CFG_SW_PHY_ADDR_SWAP_MASK) >> ETH_CFG_SW_PHY_ADDR_SWAP_LSB)
+#define ETH_CFG_SW_PHY_ADDR_SWAP_SET(x)                              (((x) << ETH_CFG_SW_PHY_ADDR_SWAP_LSB) & ETH_CFG_SW_PHY_ADDR_SWAP_MASK)
+#define ETH_CFG_SW_PHY_ADDR_SWAP_RESET                               0x0 // 0
+#define ETH_CFG_SW_PHY_SWAP_MSB                                      7
+#define ETH_CFG_SW_PHY_SWAP_LSB                                      7
+#define ETH_CFG_SW_PHY_SWAP_MASK                                     0x00000080
+#define ETH_CFG_SW_PHY_SWAP_GET(x)                                   (((x) & ETH_CFG_SW_PHY_SWAP_MASK) >> ETH_CFG_SW_PHY_SWAP_LSB)
+#define ETH_CFG_SW_PHY_SWAP_SET(x)                                   (((x) << ETH_CFG_SW_PHY_SWAP_LSB) & ETH_CFG_SW_PHY_SWAP_MASK)
+#define ETH_CFG_SW_PHY_SWAP_RESET                                    0x0 // 0
+#define ETH_CFG_SW_ONLY_MODE_MSB                                     6
+#define ETH_CFG_SW_ONLY_MODE_LSB                                     6
+#define ETH_CFG_SW_ONLY_MODE_MASK                                    0x00000040
+#define ETH_CFG_SW_ONLY_MODE_GET(x)                                  (((x) & ETH_CFG_SW_ONLY_MODE_MASK) >> ETH_CFG_SW_ONLY_MODE_LSB)
+#define ETH_CFG_SW_ONLY_MODE_SET(x)                                  (((x) << ETH_CFG_SW_ONLY_MODE_LSB) & ETH_CFG_SW_ONLY_MODE_MASK)
+#define ETH_CFG_SW_ONLY_MODE_RESET                                   0x0 // 0
+#define ETH_CFG_ADDRESS                                              0x18070000
+
+#define CONFIG_MIPS32		1	/* MIPS32 CPU core	*/
+
+#define CONFIG_BOOTDELAY	1	// lsz 081222/* autoboot after 4 seconds	*/
+
+/* lsz add CONFIG_AUTOBOOT_STOP_STR 090223 */
+#define CONFIG_AUTOBOOT_KEYED
+#define CONFIG_AUTOBOOT_PROMPT   	"Autobooting in %d seconds\n"
+#define CONFIG_AUTOBOOT_STOP_STR 	"tpl"
+#undef  CONFIG_AUTOBOOT_DELAY_STR
+#define DEBUG_BOOTKEYS       		0
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{115200}
+
+#define	CONFIG_TIMESTAMP		/* Print image info with timestamp */
+
+#define CONFIG_ROOTFS_RD
+
+#define	CONFIG_BOOTARGS_RD     "console=ttyS0,115200 root=01:00 rd_start=0x802d0000 rd_size=5242880 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),4096k(rootfs),2048k(uImage)"
+
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS_FL     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),2048k(uImage)"
+
+#ifdef CONFIG_ROOTFS_FLASH
+#define CONFIG_BOOTARGS CONFIG_BOOTARGS_FL
+#else
+#define CONFIG_BOOTARGS ""
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"hb> "		/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		512		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE		(CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		(128*1024)
+
+#define CFG_BOOTPARAMS_LEN	(128*1024)
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+//#define CFG_SDRAM_BASE	0xa0000000     /* Cached addr */
+
+#define	CFG_LOAD_ADDR		0x81000000     /* default load address	*/
+//#define CFG_LOAD_ADDR		0xa1000000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#undef CFG_MEMTEST_START
+#define CFG_MEMTEST_START       0x80200000
+#define CFG_MEMTEST_END		0x83800000
+
+/*------------------------------------------------------------------------
+ * *  * JFFS2
+ */
+#define CFG_JFFS_CUSTOM_PART            /* board defined part   */
+#define CONFIG_JFFS2_CMDLINE
+#define MTDIDS_DEFAULT		"nor0=ath-nor0"
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#define CFG_RX_ETH_BUFFER	16
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		32768
+#define CFG_ICACHE_SIZE		65536
+#define CFG_CACHELINE_SIZE	32
+
+/*
+ * Address map
+ */
+#define ATH_PCI_MEM_BASE		0x10000000	/* 128M */
+#define ATH_APB_BASE			0x18000000	/* 384M */
+#define ATH_GE0_BASE			0x19000000	/* 16M */
+#define ATH_GE1_BASE			0x1a000000	/* 16M */
+#define ATH_USB_OHCI_BASE		0x1b000000
+#define ATH_USB_EHCI_BASE		0x1b000000
+#define ATH_USB_EHCI_BASE_1		0x1b000000
+#define ATH_USB_EHCI_BASE_2		0x1b400000
+#define ATH_SPI_BASE			0x1f000000
+
+/*
+ * Added the PCI LCL RESET register from u-boot
+ * ath_soc.h so that we can query the PCI LCL RESET
+ * register for the presence of WLAN H/W.
+ */
+#define ATH_PCI_LCL_BASE		(ATH_APB_BASE+0x000f0000)
+#define ATH_PCI_LCL_APP			(ATH_PCI_LCL_BASE+0x00)
+#define ATH_PCI_LCL_RESET		(ATH_PCI_LCL_BASE+0x18)
+
+/*
+ * APB block
+ */
+#define ATH_DDR_CTL_BASE		ATH_APB_BASE+0x00000000
+#define ATH_CPU_BASE			ATH_APB_BASE+0x00010000
+#define ATH_UART_BASE			ATH_APB_BASE+0x00020000
+#define ATH_USB_CONFIG_BASE		ATH_APB_BASE+0x00030000
+#define ATH_GPIO_BASE			ATH_APB_BASE+0x00040000
+#define ATH_PLL_BASE			ATH_APB_BASE+0x00050000
+#define ATH_RESET_BASE			ATH_APB_BASE+0x00060000
+#define ATH_DMA_BASE			ATH_APB_BASE+0x000A0000
+#define ATH_SLIC_BASE			ATH_APB_BASE+0x000A9000
+#define ATH_STEREO_BASE			ATH_APB_BASE+0x000B0000
+#define ATH_PCI_CTLR_BASE		ATH_APB_BASE+0x000F0000
+#define ATH_OTP_BASE			ATH_APB_BASE+0x00130000
+#define ATH_NAND_FLASH_BASE		0x1b800000u
+
+
+/*
+ * DDR Config values
+ */
+#define ATH_DDR_CONFIG_16BIT		(1 << 31)
+#define ATH_DDR_CONFIG_PAGE_OPEN	(1 << 30)
+#define ATH_DDR_CONFIG_CAS_LAT_SHIFT	27
+#define ATH_DDR_CONFIG_TMRD_SHIFT	23
+#define ATH_DDR_CONFIG_TRFC_SHIFT	17
+#define ATH_DDR_CONFIG_TRRD_SHIFT	13
+#define ATH_DDR_CONFIG_TRP_SHIFT	9
+#define ATH_DDR_CONFIG_TRCD_SHIFT	5
+#define ATH_DDR_CONFIG_TRAS_SHIFT	0
+
+#define ATH_DDR_CONFIG2_BL2		(2 << 0)
+#define ATH_DDR_CONFIG2_BL4		(4 << 0)
+#define ATH_DDR_CONFIG2_BL8		(8 << 0)
+
+#define ATH_DDR_CONFIG2_BT_IL		(1 << 4)
+#define ATH_DDR_CONFIG2_CNTL_OE_EN	(1 << 5)
+#define ATH_DDR_CONFIG2_PHASE_SEL	(1 << 6)
+#define ATH_DDR_CONFIG2_DRAM_CKE	(1 << 7)
+#define ATH_DDR_CONFIG2_TWR_SHIFT	8
+#define ATH_DDR_CONFIG2_TRTW_SHIFT	12
+#define ATH_DDR_CONFIG2_TRTP_SHIFT	17
+#define ATH_DDR_CONFIG2_TWTR_SHIFT	21
+#define ATH_DDR_CONFIG2_HALF_WIDTH_L	(1 << 31)
+
+#define ATH_DDR_TAP_DEFAULT		0x18
+
+/*
+ * DDR block, gmac flushing
+ */
+#define ATH_DDR_GE0_FLUSH		ATH_DDR_CTL_BASE+0x9c
+#define ATH_DDR_GE1_FLUSH		ATH_DDR_CTL_BASE+0xa0
+#define ATH_DDR_USB_FLUSH		ATH_DDR_CTL_BASE+0xa4
+#define ATH_DDR_PCIE_FLUSH		ATH_DDR_CTL_BASE+0x88
+
+#define ATH_EEPROM_GE0_MAC_ADDR		0xbfff1000
+#define ATH_EEPROM_GE1_MAC_ADDR		0xbfff1006
+
+/*
+ * PLL block/CPU
+ */
+
+#define ATH_PLL_CONFIG			ATH_PLL_BASE+0x0
+#define ATH_DDR_CLK_CTRL		ATH_PLL_BASE+0x8
+
+
+#define PLL_DIV_SHIFT			0
+#define PLL_DIV_MASK			0x3ff
+#define REF_DIV_SHIFT			10
+#define REF_DIV_MASK			0xf
+#define AHB_DIV_SHIFT			19
+#define AHB_DIV_MASK			0x1
+#define DDR_DIV_SHIFT			22
+#define DDR_DIV_MASK			0x1
+#define ATH_DDR_PLL_CONFIG		ATH_PLL_BASE+0x4
+#define ATH_ETH_XMII_CONFIG		ATH_PLL_BASE+0x2c
+#define ATH_AUDIO_PLL_CONFIG		ATH_PLL_BASE+0x30
+
+#define ATH_ETH_INT0_CLK		ATH_PLL_BASE+0x14
+#define ATH_ETH_INT1_CLK		ATH_PLL_BASE+0x18
+
+
+/*
+ * USB block
+ */
+#define ATH_USB_FLADJ_VAL		ATH_USB_CONFIG_BASE
+#define ATH_USB_CONFIG			ATH_USB_CONFIG_BASE+0x4
+#define ATH_USB_WINDOW			0x10000
+#define ATH_USB_MODE			ATH_USB_EHCI_BASE+0x1a8
+
+/*
+ * PCI block
+ */
+#define ATH_PCI_WINDOW			0x8000000 /* 128MB */
+#define ATH_PCI_WINDOW0_OFFSET		ATH_DDR_CTL_BASE+0x7c
+#define ATH_PCI_WINDOW1_OFFSET		ATH_DDR_CTL_BASE+0x80
+#define ATH_PCI_WINDOW2_OFFSET		ATH_DDR_CTL_BASE+0x84
+#define ATH_PCI_WINDOW3_OFFSET		ATH_DDR_CTL_BASE+0x88
+#define ATH_PCI_WINDOW4_OFFSET		ATH_DDR_CTL_BASE+0x8c
+#define ATH_PCI_WINDOW5_OFFSET		ATH_DDR_CTL_BASE+0x90
+#define ATH_PCI_WINDOW6_OFFSET		ATH_DDR_CTL_BASE+0x94
+#define ATH_PCI_WINDOW7_OFFSET		ATH_DDR_CTL_BASE+0x98
+
+#define ATH_PCI_WINDOW0_VAL		0x10000000
+#define ATH_PCI_WINDOW1_VAL		0x11000000
+#define ATH_PCI_WINDOW2_VAL		0x12000000
+#define ATH_PCI_WINDOW3_VAL		0x13000000
+#define ATH_PCI_WINDOW4_VAL		0x14000000
+#define ATH_PCI_WINDOW5_VAL		0x15000000
+#define ATH_PCI_WINDOW6_VAL		0x16000000
+#define ATH_PCI_WINDOW7_VAL		0x07000000
+
+#define ath_write_pci_window(_no)	\
+	ath_reg_wr(ATH_PCI_WINDOW##_no##_OFFSET, ATH_PCI_WINDOW##_no##_VAL);
+
+/*
+ * CRP. To access the host controller config and status registers
+ */
+#define ATH_PCI_CRP			0x180c0000
+#define ATH_PCI_DEV_CFGBASE		0x14000000
+#define ATH_PCI_CRP_AD_CBE		ATH_PCI_CRP
+#define ATH_PCI_CRP_WRDATA		ATH_PCI_CRP+0x4
+#define ATH_PCI_CRP_RDDATA		ATH_PCI_CRP+0x8
+#define ATH_PCI_ERROR			ATH_PCI_CRP+0x1c
+#define ATH_PCI_ERROR_ADDRESS		ATH_PCI_CRP+0x20
+#define ATH_PCI_AHB_ERROR		ATH_PCI_CRP+0x24
+#define ATH_PCI_AHB_ERROR_ADDRESS	ATH_PCI_CRP+0x28
+
+#define ATH_CRP_CMD_WRITE		0x00010000
+#define ATH_CRP_CMD_READ		0x00000000
+
+/*
+ * PCI CFG. To generate config cycles
+ */
+#define ATH_PCI_CFG_AD			ATH_PCI_CRP+0xc
+#define ATH_PCI_CFG_CBE			ATH_PCI_CRP+0x10
+#define ATH_PCI_CFG_WRDATA		ATH_PCI_CRP+0x14
+#define ATH_PCI_CFG_RDDATA		ATH_PCI_CRP+0x18
+#define ATH_CFG_CMD_READ		0x0000000a
+#define ATH_CFG_CMD_WRITE		0x0000000b
+
+#define ATH_PCI_IDSEL_ADLINE_START	17
+
+#define ATH_SPI_FS		(ATH_SPI_BASE+0x00)
+#define ATH_SPI_READ		(ATH_SPI_BASE+0x00)
+#define ATH_SPI_CLOCK		(ATH_SPI_BASE+0x04)
+#define ATH_SPI_WRITE		(ATH_SPI_BASE+0x08)
+#define ATH_SPI_RD_STATUS	(ATH_SPI_BASE+0x0c)
+#define ATH_SPI_SHIFT_DO	(ATH_SPI_BASE+0x10)
+#define ATH_SPI_SHIFT_CNT	(ATH_SPI_BASE+0x14)
+#define ATH_SPI_SHIFT_DI	(ATH_SPI_BASE+0x18)
+#define ATH_SPI_D0_HIGH		(1<<0)	/* Pin spi_do */
+#define ATH_SPI_CLK_HIGH	(1<<8)	/* Pin spi_clk */
+
+#define ATH_SPI_CS_ENABLE_0	(6<<16)	/* Pin gpio/cs0 (active low) */
+#define ATH_SPI_CS_ENABLE_1	(5<<16)	/* Pin gpio/cs1 (active low) */
+#define ATH_SPI_CS_ENABLE_2	(3<<16)	/* Pin gpio/cs2 (active low) */
+#define ATH_SPI_CS_DIS		0x70000
+#define ATH_SPI_CE_LOW		0x60000
+#define ATH_SPI_CE_HIGH		0x60100
+
+#define ATH_SPI_SECTOR_SIZE	(1024*64)
+#define ATH_SPI_PAGE_SIZE	256
+
+#define ATH_RESET_GE0_MAC	RST_RESET_GE0_MAC_RESET_SET(1)
+#define ATH_RESET_GE0_PHY	RST_RESET_ETH_SWITCH_RESET_SET(1)
+#define ATH_RESET_GE1_MAC	RST_RESET_GE1_MAC_RESET_SET(1)
+#define ATH_RESET_GE1_PHY	RST_RESET_ETH_SWITCH_ARESET_SET(1)
+#define ATH_RESET_GE0_MDIO	RST_RESET_GE0_MDIO_RESET_SET(1)
+#define ATH_RESET_GE1_MDIO	RST_RESET_GE1_MDIO_RESET_SET(1)
+
+/*
+ * SOC
+ */
+#define ATH_SPI_CMD_WRITE_SR		0x01
+#define ATH_SPI_CMD_WREN		0x06
+#define ATH_SPI_CMD_RD_STATUS		0x05
+#define ATH_SPI_CMD_FAST_READ		0x0b
+#define ATH_SPI_CMD_PAGE_PROG		0x02
+#define ATH_SPI_CMD_SECTOR_ERASE	0xd8
+#define ATH_SPI_CMD_CHIP_ERASE		0xc7
+#define ATH_SPI_CMD_RDID		0x9f
+
+#if defined(CFG_ATH_EMULATION)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(2)	// 80 MHz
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(1)	// 40 MHz
+
+#elif (CFG_PLL_FREQ == CFG_PLL_550_400_200)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+/*  by huangwenzhong, 02July13 */
+/* modify the value advised from atheros, enable dither */
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(1) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0x266) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(7) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_600_200)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_600_300)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(16)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(16)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_680_240)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(17)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_600_240)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_560_450_220)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(11)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0x100) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_680_680_226)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(1)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(17)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(17)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_550_600_200)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(24)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_600_200)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(1)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+ 						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+ 						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+ 						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+ 
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(24)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+ 						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+ 						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+ 						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#else
+#	error "CFG_PLL_FREQ not set"
+#endif	// CFG_PLL_FREQ
+
+#define CPU_CLK_FROM_DDR_PLL	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(0)
+#define CPU_CLK_FROM_CPU_PLL	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+
+#define DDR_CLK_FROM_DDR_PLL	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define DDR_CLK_FROM_CPU_PLL	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(0)
+
+#if CPU_DDR_SYNC_MODE
+
+#	define both_from_cpu		0
+#	define both_from_ddr		1
+
+#	if both_from_ddr
+#		define CLK_SRC_CONTROL		(CPU_CLK_FROM_DDR_PLL | DDR_CLK_FROM_DDR_PLL)
+#		define AHB_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#	elif both_from_cpu
+#		define CLK_SRC_CONTROL		(CPU_CLK_FROM_CPU_PLL | DDR_CLK_FROM_CPU_PLL)
+#		define AHB_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#	else
+#		error "Invalid sync mode settings"
+#	endif
+#else
+#	define CLK_SRC_CONTROL		(CPU_CLK_FROM_CPU_PLL | DDR_CLK_FROM_DDR_PLL)
+#endif
+
+
+
+#define __nint_to_mhz(n, ref)	((n) * (ref) * 1000000)
+#define __cpu_hz_40(pll)	(__nint_to_mhz(CPU_PLL_CONFIG_NINT_GET(pll), 40))
+#define __cpu_hz_25(pll)	(__nint_to_mhz(CPU_PLL_CONFIG_NINT_GET(pll), 25))
+
+/* Since the count is incremented every other tick, divide by 2 */
+#define CFG_HZ			(__cpu_hz_40(CPU_PLL_CONFIG_NINT_VAL) / 2)
+
+/* SGMII DEFINES */
+
+// 32'h18070034 (SGMII_CONFIG)
+#define SGMII_CONFIG_BERT_ENABLE_MSB                                 14
+#define SGMII_CONFIG_BERT_ENABLE_LSB                                 14
+#define SGMII_CONFIG_BERT_ENABLE_MASK                                0x00004000
+#define SGMII_CONFIG_BERT_ENABLE_GET(x)                              (((x) & SGMII_CONFIG_BERT_ENABLE_MASK) >> SGMII_CONFIG_BERT_ENABLE_LSB)
+#define SGMII_CONFIG_BERT_ENABLE_SET(x)                              (((x) << SGMII_CONFIG_BERT_ENABLE_LSB) & SGMII_CONFIG_BERT_ENABLE_MASK)
+#define SGMII_CONFIG_BERT_ENABLE_RESET                               0x0 // 0
+#define SGMII_CONFIG_PRBS_ENABLE_MSB                                 13
+#define SGMII_CONFIG_PRBS_ENABLE_LSB                                 13
+#define SGMII_CONFIG_PRBS_ENABLE_MASK                                0x00002000
+#define SGMII_CONFIG_PRBS_ENABLE_GET(x)                              (((x) & SGMII_CONFIG_PRBS_ENABLE_MASK) >> SGMII_CONFIG_PRBS_ENABLE_LSB)
+#define SGMII_CONFIG_PRBS_ENABLE_SET(x)                              (((x) << SGMII_CONFIG_PRBS_ENABLE_LSB) & SGMII_CONFIG_PRBS_ENABLE_MASK)
+#define SGMII_CONFIG_PRBS_ENABLE_RESET                               0x0 // 0
+#define SGMII_CONFIG_MDIO_COMPLETE_MSB                               12
+#define SGMII_CONFIG_MDIO_COMPLETE_LSB                               12
+#define SGMII_CONFIG_MDIO_COMPLETE_MASK                              0x00001000
+#define SGMII_CONFIG_MDIO_COMPLETE_GET(x)                            (((x) & SGMII_CONFIG_MDIO_COMPLETE_MASK) >> SGMII_CONFIG_MDIO_COMPLETE_LSB)
+#define SGMII_CONFIG_MDIO_COMPLETE_SET(x)                            (((x) << SGMII_CONFIG_MDIO_COMPLETE_LSB) & SGMII_CONFIG_MDIO_COMPLETE_MASK)
+#define SGMII_CONFIG_MDIO_COMPLETE_RESET                             0x0 // 0
+#define SGMII_CONFIG_MDIO_PULSE_MSB                                  11
+#define SGMII_CONFIG_MDIO_PULSE_LSB                                  11
+#define SGMII_CONFIG_MDIO_PULSE_MASK                                 0x00000800
+#define SGMII_CONFIG_MDIO_PULSE_GET(x)                               (((x) & SGMII_CONFIG_MDIO_PULSE_MASK) >> SGMII_CONFIG_MDIO_PULSE_LSB)
+#define SGMII_CONFIG_MDIO_PULSE_SET(x)                               (((x) << SGMII_CONFIG_MDIO_PULSE_LSB) & SGMII_CONFIG_MDIO_PULSE_MASK)
+#define SGMII_CONFIG_MDIO_PULSE_RESET                                0x0 // 0
+#define SGMII_CONFIG_MDIO_ENABLE_MSB                                 10
+#define SGMII_CONFIG_MDIO_ENABLE_LSB                                 10
+#define SGMII_CONFIG_MDIO_ENABLE_MASK                                0x00000400
+#define SGMII_CONFIG_MDIO_ENABLE_GET(x)                              (((x) & SGMII_CONFIG_MDIO_ENABLE_MASK) >> SGMII_CONFIG_MDIO_ENABLE_LSB)
+#define SGMII_CONFIG_MDIO_ENABLE_SET(x)                              (((x) << SGMII_CONFIG_MDIO_ENABLE_LSB) & SGMII_CONFIG_MDIO_ENABLE_MASK)
+#define SGMII_CONFIG_MDIO_ENABLE_RESET                               0x0 // 0
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_MSB                            9
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_LSB                            9
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_MASK                           0x00000200
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_GET(x)                         (((x) & SGMII_CONFIG_NEXT_PAGE_LOADED_MASK) >> SGMII_CONFIG_NEXT_PAGE_LOADED_LSB)
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_SET(x)                         (((x) << SGMII_CONFIG_NEXT_PAGE_LOADED_LSB) & SGMII_CONFIG_NEXT_PAGE_LOADED_MASK)
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_RESET                          0x0 // 0
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MSB                         8
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_LSB                         8
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MASK                        0x00000100
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_GET(x)                      (((x) & SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MASK) >> SGMII_CONFIG_REMOTE_PHY_LOOPBACK_LSB)
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_SET(x)                      (((x) << SGMII_CONFIG_REMOTE_PHY_LOOPBACK_LSB) & SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MASK)
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_RESET                       0x0 // 0
+#define SGMII_CONFIG_SPEED_MSB                                       7
+#define SGMII_CONFIG_SPEED_LSB                                       6
+#define SGMII_CONFIG_SPEED_MASK                                      0x000000c0
+#define SGMII_CONFIG_SPEED_GET(x)                                    (((x) & SGMII_CONFIG_SPEED_MASK) >> SGMII_CONFIG_SPEED_LSB)
+#define SGMII_CONFIG_SPEED_SET(x)                                    (((x) << SGMII_CONFIG_SPEED_LSB) & SGMII_CONFIG_SPEED_MASK)
+#define SGMII_CONFIG_SPEED_RESET                                     0x0 // 0
+#define SGMII_CONFIG_FORCE_SPEED_MSB                                 5
+#define SGMII_CONFIG_FORCE_SPEED_LSB                                 5
+#define SGMII_CONFIG_FORCE_SPEED_MASK                                0x00000020
+#define SGMII_CONFIG_FORCE_SPEED_GET(x)                              (((x) & SGMII_CONFIG_FORCE_SPEED_MASK) >> SGMII_CONFIG_FORCE_SPEED_LSB)
+#define SGMII_CONFIG_FORCE_SPEED_SET(x)                              (((x) << SGMII_CONFIG_FORCE_SPEED_LSB) & SGMII_CONFIG_FORCE_SPEED_MASK)
+#define SGMII_CONFIG_FORCE_SPEED_RESET                               0x0 // 0
+#define SGMII_CONFIG_MR_REG4_CHANGED_MSB                             4
+#define SGMII_CONFIG_MR_REG4_CHANGED_LSB                             4
+#define SGMII_CONFIG_MR_REG4_CHANGED_MASK                            0x00000010
+#define SGMII_CONFIG_MR_REG4_CHANGED_GET(x)                          (((x) & SGMII_CONFIG_MR_REG4_CHANGED_MASK) >> SGMII_CONFIG_MR_REG4_CHANGED_LSB)
+#define SGMII_CONFIG_MR_REG4_CHANGED_SET(x)                          (((x) << SGMII_CONFIG_MR_REG4_CHANGED_LSB) & SGMII_CONFIG_MR_REG4_CHANGED_MASK)
+#define SGMII_CONFIG_MR_REG4_CHANGED_RESET                           0x0 // 0
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MSB                       3
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_LSB                       3
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MASK                      0x00000008
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_GET(x)                    (((x) & SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MASK) >> SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_LSB)
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_SET(x)                    (((x) << SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_LSB) & SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MASK)
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_RESET                     0x0 // 0
+#define SGMII_CONFIG_MODE_CTRL_MSB                                   2
+#define SGMII_CONFIG_MODE_CTRL_LSB                                   0
+#define SGMII_CONFIG_MODE_CTRL_MASK                                  0x00000007
+#define SGMII_CONFIG_MODE_CTRL_GET(x)                                (((x) & SGMII_CONFIG_MODE_CTRL_MASK) >> SGMII_CONFIG_MODE_CTRL_LSB)
+#define SGMII_CONFIG_MODE_CTRL_SET(x)                                (((x) << SGMII_CONFIG_MODE_CTRL_LSB) & SGMII_CONFIG_MODE_CTRL_MASK)
+#define SGMII_CONFIG_MODE_CTRL_RESET                                 0x0 // 0
+#define SGMII_CONFIG_ADDRESS                                         0x18070034
+
+
+
+// 32'h1807001c (MR_AN_CONTROL)
+#define MR_AN_CONTROL_PHY_RESET_MSB                                  15
+#define MR_AN_CONTROL_PHY_RESET_LSB                                  15
+#define MR_AN_CONTROL_PHY_RESET_MASK                                 0x00008000
+#define MR_AN_CONTROL_PHY_RESET_GET(x)                               (((x) & MR_AN_CONTROL_PHY_RESET_MASK) >> MR_AN_CONTROL_PHY_RESET_LSB)
+#define MR_AN_CONTROL_PHY_RESET_SET(x)                               (((x) << MR_AN_CONTROL_PHY_RESET_LSB) & MR_AN_CONTROL_PHY_RESET_MASK)
+#define MR_AN_CONTROL_PHY_RESET_RESET                                0x0 // 0
+#define MR_AN_CONTROL_LOOPBACK_MSB                                   14
+#define MR_AN_CONTROL_LOOPBACK_LSB                                   14
+#define MR_AN_CONTROL_LOOPBACK_MASK                                  0x00004000
+#define MR_AN_CONTROL_LOOPBACK_GET(x)                                (((x) & MR_AN_CONTROL_LOOPBACK_MASK) >> MR_AN_CONTROL_LOOPBACK_LSB)
+#define MR_AN_CONTROL_LOOPBACK_SET(x)                                (((x) << MR_AN_CONTROL_LOOPBACK_LSB) & MR_AN_CONTROL_LOOPBACK_MASK)
+#define MR_AN_CONTROL_LOOPBACK_RESET                                 0x0 // 0
+#define MR_AN_CONTROL_SPEED_SEL0_MSB                                 13
+#define MR_AN_CONTROL_SPEED_SEL0_LSB                                 13
+#define MR_AN_CONTROL_SPEED_SEL0_MASK                                0x00002000
+#define MR_AN_CONTROL_SPEED_SEL0_GET(x)                              (((x) & MR_AN_CONTROL_SPEED_SEL0_MASK) >> MR_AN_CONTROL_SPEED_SEL0_LSB)
+#define MR_AN_CONTROL_SPEED_SEL0_SET(x)                              (((x) << MR_AN_CONTROL_SPEED_SEL0_LSB) & MR_AN_CONTROL_SPEED_SEL0_MASK)
+#define MR_AN_CONTROL_SPEED_SEL0_RESET                               0x0 // 0
+#define MR_AN_CONTROL_AN_ENABLE_MSB                                  12
+#define MR_AN_CONTROL_AN_ENABLE_LSB                                  12
+#define MR_AN_CONTROL_AN_ENABLE_MASK                                 0x00001000
+#define MR_AN_CONTROL_AN_ENABLE_GET(x)                               (((x) & MR_AN_CONTROL_AN_ENABLE_MASK) >> MR_AN_CONTROL_AN_ENABLE_LSB)
+#define MR_AN_CONTROL_AN_ENABLE_SET(x)                               (((x) << MR_AN_CONTROL_AN_ENABLE_LSB) & MR_AN_CONTROL_AN_ENABLE_MASK)
+#define MR_AN_CONTROL_AN_ENABLE_RESET                                0x1 // 1
+#define MR_AN_CONTROL_POWER_DOWN_MSB                                 11
+#define MR_AN_CONTROL_POWER_DOWN_LSB                                 11
+#define MR_AN_CONTROL_POWER_DOWN_MASK                                0x00000800
+#define MR_AN_CONTROL_POWER_DOWN_GET(x)                              (((x) & MR_AN_CONTROL_POWER_DOWN_MASK) >> MR_AN_CONTROL_POWER_DOWN_LSB)
+#define MR_AN_CONTROL_POWER_DOWN_SET(x)                              (((x) << MR_AN_CONTROL_POWER_DOWN_LSB) & MR_AN_CONTROL_POWER_DOWN_MASK)
+#define MR_AN_CONTROL_POWER_DOWN_RESET                               0x0 // 0
+#define MR_AN_CONTROL_RESTART_AN_MSB                                 9
+#define MR_AN_CONTROL_RESTART_AN_LSB                                 9
+#define MR_AN_CONTROL_RESTART_AN_MASK                                0x00000200
+#define MR_AN_CONTROL_RESTART_AN_GET(x)                              (((x) & MR_AN_CONTROL_RESTART_AN_MASK) >> MR_AN_CONTROL_RESTART_AN_LSB)
+#define MR_AN_CONTROL_RESTART_AN_SET(x)                              (((x) << MR_AN_CONTROL_RESTART_AN_LSB) & MR_AN_CONTROL_RESTART_AN_MASK)
+#define MR_AN_CONTROL_RESTART_AN_RESET                               0x0 // 0
+#define MR_AN_CONTROL_DUPLEX_MODE_MSB                                8
+#define MR_AN_CONTROL_DUPLEX_MODE_LSB                                8
+#define MR_AN_CONTROL_DUPLEX_MODE_MASK                               0x00000100
+#define MR_AN_CONTROL_DUPLEX_MODE_GET(x)                             (((x) & MR_AN_CONTROL_DUPLEX_MODE_MASK) >> MR_AN_CONTROL_DUPLEX_MODE_LSB)
+#define MR_AN_CONTROL_DUPLEX_MODE_SET(x)                             (((x) << MR_AN_CONTROL_DUPLEX_MODE_LSB) & MR_AN_CONTROL_DUPLEX_MODE_MASK)
+#define MR_AN_CONTROL_DUPLEX_MODE_RESET                              0x1 // 1
+#define MR_AN_CONTROL_SPEED_SEL1_MSB                                 6
+#define MR_AN_CONTROL_SPEED_SEL1_LSB                                 6
+#define MR_AN_CONTROL_SPEED_SEL1_MASK                                0x00000040
+#define MR_AN_CONTROL_SPEED_SEL1_GET(x)                              (((x) & MR_AN_CONTROL_SPEED_SEL1_MASK) >> MR_AN_CONTROL_SPEED_SEL1_LSB)
+#define MR_AN_CONTROL_SPEED_SEL1_SET(x)                              (((x) << MR_AN_CONTROL_SPEED_SEL1_LSB) & MR_AN_CONTROL_SPEED_SEL1_MASK)
+#define MR_AN_CONTROL_SPEED_SEL1_RESET                               0x1 // 1
+#define MR_AN_CONTROL_ADDRESS                                        0x1807001c
+
+
+
+
+
+// 32'h18070014 (SGMII_RESET)
+#define SGMII_RESET_HW_RX_125M_N_MSB                                 4
+#define SGMII_RESET_HW_RX_125M_N_LSB                                 4
+#define SGMII_RESET_HW_RX_125M_N_MASK                                0x00000010
+#define SGMII_RESET_HW_RX_125M_N_GET(x)                              (((x) & SGMII_RESET_HW_RX_125M_N_MASK) >> SGMII_RESET_HW_RX_125M_N_LSB)
+#define SGMII_RESET_HW_RX_125M_N_SET(x)                              (((x) << SGMII_RESET_HW_RX_125M_N_LSB) & SGMII_RESET_HW_RX_125M_N_MASK)
+#define SGMII_RESET_HW_RX_125M_N_RESET                               0x0 // 0
+#define SGMII_RESET_TX_125M_N_MSB                                    3
+#define SGMII_RESET_TX_125M_N_LSB                                    3
+#define SGMII_RESET_TX_125M_N_MASK                                   0x00000008
+#define SGMII_RESET_TX_125M_N_GET(x)                                 (((x) & SGMII_RESET_TX_125M_N_MASK) >> SGMII_RESET_TX_125M_N_LSB)
+#define SGMII_RESET_TX_125M_N_SET(x)                                 (((x) << SGMII_RESET_TX_125M_N_LSB) & SGMII_RESET_TX_125M_N_MASK)
+#define SGMII_RESET_TX_125M_N_RESET                                  0x0 // 0
+#define SGMII_RESET_RX_125M_N_MSB                                    2
+#define SGMII_RESET_RX_125M_N_LSB                                    2
+#define SGMII_RESET_RX_125M_N_MASK                                   0x00000004
+#define SGMII_RESET_RX_125M_N_GET(x)                                 (((x) & SGMII_RESET_RX_125M_N_MASK) >> SGMII_RESET_RX_125M_N_LSB)
+#define SGMII_RESET_RX_125M_N_SET(x)                                 (((x) << SGMII_RESET_RX_125M_N_LSB) & SGMII_RESET_RX_125M_N_MASK)
+#define SGMII_RESET_RX_125M_N_RESET                                  0x0 // 0
+#define SGMII_RESET_TX_CLK_N_MSB                                     1
+#define SGMII_RESET_TX_CLK_N_LSB                                     1
+#define SGMII_RESET_TX_CLK_N_MASK                                    0x00000002
+#define SGMII_RESET_TX_CLK_N_GET(x)                                  (((x) & SGMII_RESET_TX_CLK_N_MASK) >> SGMII_RESET_TX_CLK_N_LSB)
+#define SGMII_RESET_TX_CLK_N_SET(x)                                  (((x) << SGMII_RESET_TX_CLK_N_LSB) & SGMII_RESET_TX_CLK_N_MASK)
+#define SGMII_RESET_TX_CLK_N_RESET                                   0x0 // 0
+#define SGMII_RESET_RX_CLK_N_MSB                                     0
+#define SGMII_RESET_RX_CLK_N_LSB                                     0
+#define SGMII_RESET_RX_CLK_N_MASK                                    0x00000001
+#define SGMII_RESET_RX_CLK_N_GET(x)                                  (((x) & SGMII_RESET_RX_CLK_N_MASK) >> SGMII_RESET_RX_CLK_N_LSB)
+#define SGMII_RESET_RX_CLK_N_SET(x)                                  (((x) << SGMII_RESET_RX_CLK_N_LSB) & SGMII_RESET_RX_CLK_N_MASK)
+#define SGMII_RESET_RX_CLK_N_RESET                                   0x0 // 0
+#define SGMII_RESET_ADDRESS                                          0x18070014
+
+
+
+// 32'h18070038 (SGMII_MAC_RX_CONFIG)
+#define SGMII_MAC_RX_CONFIG_LINK_MSB                                 15
+#define SGMII_MAC_RX_CONFIG_LINK_LSB                                 15
+#define SGMII_MAC_RX_CONFIG_LINK_MASK                                0x00008000
+#define SGMII_MAC_RX_CONFIG_LINK_GET(x)                              (((x) & SGMII_MAC_RX_CONFIG_LINK_MASK) >> SGMII_MAC_RX_CONFIG_LINK_LSB)
+#define SGMII_MAC_RX_CONFIG_LINK_SET(x)                              (((x) << SGMII_MAC_RX_CONFIG_LINK_LSB) & SGMII_MAC_RX_CONFIG_LINK_MASK)
+#define SGMII_MAC_RX_CONFIG_LINK_RESET                               0x0 // 0
+#define SGMII_MAC_RX_CONFIG_ACK_MSB                                  14
+#define SGMII_MAC_RX_CONFIG_ACK_LSB                                  14
+#define SGMII_MAC_RX_CONFIG_ACK_MASK                                 0x00004000
+#define SGMII_MAC_RX_CONFIG_ACK_GET(x)                               (((x) & SGMII_MAC_RX_CONFIG_ACK_MASK) >> SGMII_MAC_RX_CONFIG_ACK_LSB)
+#define SGMII_MAC_RX_CONFIG_ACK_SET(x)                               (((x) << SGMII_MAC_RX_CONFIG_ACK_LSB) & SGMII_MAC_RX_CONFIG_ACK_MASK)
+#define SGMII_MAC_RX_CONFIG_ACK_RESET                                0x0 // 0
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MSB                          12
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_LSB                          12
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MASK                         0x00001000
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_GET(x)                       (((x) & SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MASK) >> SGMII_MAC_RX_CONFIG_DUPLEX_MODE_LSB)
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_SET(x)                       (((x) << SGMII_MAC_RX_CONFIG_DUPLEX_MODE_LSB) & SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MASK)
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_RESET                        0x0 // 0
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_MSB                           11
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_LSB                           10
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_MASK                          0x00000c00
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_GET(x)                        (((x) & SGMII_MAC_RX_CONFIG_SPEED_MODE_MASK) >> SGMII_MAC_RX_CONFIG_SPEED_MODE_LSB)
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_SET(x)                        (((x) << SGMII_MAC_RX_CONFIG_SPEED_MODE_LSB) & SGMII_MAC_RX_CONFIG_SPEED_MODE_MASK)
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_RESET                         0x0 // 0
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_MSB                            8
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_LSB                            8
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_MASK                           0x00000100
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_GET(x)                         (((x) & SGMII_MAC_RX_CONFIG_ASM_PAUSE_MASK) >> SGMII_MAC_RX_CONFIG_ASM_PAUSE_LSB)
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_SET(x)                         (((x) << SGMII_MAC_RX_CONFIG_ASM_PAUSE_LSB) & SGMII_MAC_RX_CONFIG_ASM_PAUSE_MASK)
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_RESET                          0x0 // 0
+#define SGMII_MAC_RX_CONFIG_PAUSE_MSB                                7
+#define SGMII_MAC_RX_CONFIG_PAUSE_LSB                                7
+#define SGMII_MAC_RX_CONFIG_PAUSE_MASK                               0x00000080
+#define SGMII_MAC_RX_CONFIG_PAUSE_GET(x)                             (((x) & SGMII_MAC_RX_CONFIG_PAUSE_MASK) >> SGMII_MAC_RX_CONFIG_PAUSE_LSB)
+#define SGMII_MAC_RX_CONFIG_PAUSE_SET(x)                             (((x) << SGMII_MAC_RX_CONFIG_PAUSE_LSB) & SGMII_MAC_RX_CONFIG_PAUSE_MASK)
+#define SGMII_MAC_RX_CONFIG_PAUSE_RESET                              0x0 // 0
+#define SGMII_MAC_RX_CONFIG_RES0_MSB                                 0
+#define SGMII_MAC_RX_CONFIG_RES0_LSB                                 0
+#define SGMII_MAC_RX_CONFIG_RES0_MASK                                0x00000001
+#define SGMII_MAC_RX_CONFIG_RES0_GET(x)                              (((x) & SGMII_MAC_RX_CONFIG_RES0_MASK) >> SGMII_MAC_RX_CONFIG_RES0_LSB)
+#define SGMII_MAC_RX_CONFIG_RES0_SET(x)                              (((x) << SGMII_MAC_RX_CONFIG_RES0_LSB) & SGMII_MAC_RX_CONFIG_RES0_MASK)
+#define SGMII_MAC_RX_CONFIG_RES0_RESET                               0x1 // 1
+#define SGMII_MAC_RX_CONFIG_ADDRESS                                  0x18070038
+
+// 32'h18070058 (SGMII_DEBUG)
+#define SGMII_DEBUG_ARB_STATE_MSB                                    27
+#define SGMII_DEBUG_ARB_STATE_LSB                                    24
+#define SGMII_DEBUG_ARB_STATE_MASK                                   0x0f000000
+#define SGMII_DEBUG_ARB_STATE_GET(x)                                 (((x) & SGMII_DEBUG_ARB_STATE_MASK) >> SGMII_DEBUG_ARB_STATE_LSB)
+#define SGMII_DEBUG_ARB_STATE_SET(x)                                 (((x) << SGMII_DEBUG_ARB_STATE_LSB) & SGMII_DEBUG_ARB_STATE_MASK)
+#define SGMII_DEBUG_ARB_STATE_RESET                                  0x0 // 0
+#define SGMII_DEBUG_RX_SYNC_STATE_MSB                                23
+#define SGMII_DEBUG_RX_SYNC_STATE_LSB                                16
+#define SGMII_DEBUG_RX_SYNC_STATE_MASK                               0x00ff0000
+#define SGMII_DEBUG_RX_SYNC_STATE_GET(x)                             (((x) & SGMII_DEBUG_RX_SYNC_STATE_MASK) >> SGMII_DEBUG_RX_SYNC_STATE_LSB)
+#define SGMII_DEBUG_RX_SYNC_STATE_SET(x)                             (((x) << SGMII_DEBUG_RX_SYNC_STATE_LSB) & SGMII_DEBUG_RX_SYNC_STATE_MASK)
+#define SGMII_DEBUG_RX_SYNC_STATE_RESET                              0x0 // 0
+#define SGMII_DEBUG_RX_STATE_MSB                                     15
+#define SGMII_DEBUG_RX_STATE_LSB                                     8
+#define SGMII_DEBUG_RX_STATE_MASK                                    0x0000ff00
+#define SGMII_DEBUG_RX_STATE_GET(x)                                  (((x) & SGMII_DEBUG_RX_STATE_MASK) >> SGMII_DEBUG_RX_STATE_LSB)
+#define SGMII_DEBUG_RX_STATE_SET(x)                                  (((x) << SGMII_DEBUG_RX_STATE_LSB) & SGMII_DEBUG_RX_STATE_MASK)
+#define SGMII_DEBUG_RX_STATE_RESET                                   0x0 // 0
+#define SGMII_DEBUG_TX_STATE_MSB                                     7
+#define SGMII_DEBUG_TX_STATE_LSB                                     0
+#define SGMII_DEBUG_TX_STATE_MASK                                    0x000000ff
+#define SGMII_DEBUG_TX_STATE_GET(x)                                  (((x) & SGMII_DEBUG_TX_STATE_MASK) >> SGMII_DEBUG_TX_STATE_LSB)
+#define SGMII_DEBUG_TX_STATE_SET(x)                                  (((x) << SGMII_DEBUG_TX_STATE_LSB) & SGMII_DEBUG_TX_STATE_MASK)
+#define SGMII_DEBUG_TX_STATE_RESET                                   0x0 // 0
+#define SGMII_DEBUG_ADDRESS                                          0x18070058
+#define SGMII_DEBUG_OFFSET                                           0x0058
+
+
+
+// 32'h18070060 (SGMII_INTERRUPT_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_MSB                                7
+#define SGMII_INTERRUPT_MASK_MASK_LSB                                0
+#define SGMII_INTERRUPT_MASK_MASK_MASK                               0x000000ff
+#define SGMII_INTERRUPT_MASK_MASK_GET(x)                             (((x) & SGMII_INTERRUPT_MASK_MASK_MASK) >> SGMII_INTERRUPT_MASK_MASK_LSB)
+#define SGMII_INTERRUPT_MASK_MASK_SET(x)                             (((x) << SGMII_INTERRUPT_MASK_MASK_LSB) & SGMII_INTERRUPT_MASK_MASK_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_RESET                              0x0 // 0
+#define SGMII_INTERRUPT_MASK_ADDRESS                                 0x18070060
+
+
+
+
+// 32'h1807005c (SGMII_INTERRUPT)
+#define SGMII_INTERRUPT_INTR_MSB                                     7
+#define SGMII_INTERRUPT_INTR_LSB                                     0
+#define SGMII_INTERRUPT_INTR_MASK                                    0x000000ff
+#define SGMII_INTERRUPT_INTR_GET(x)                                  (((x) & SGMII_INTERRUPT_INTR_MASK) >> SGMII_INTERRUPT_INTR_LSB)
+#define SGMII_INTERRUPT_INTR_SET(x)                                  (((x) << SGMII_INTERRUPT_INTR_LSB) & SGMII_INTERRUPT_INTR_MASK)
+#define SGMII_INTERRUPT_INTR_RESET                                   0x0 // 0
+#define SGMII_INTERRUPT_ADDRESS                                      0x1807005c
+#define SGMII_INTERRUPT_OFFSET                                       0x005c
+// SW modifiable bits
+#define SGMII_INTERRUPT_SW_MASK                                      0x000000ff
+// bits defined at reset
+#define SGMII_INTERRUPT_RSTMASK                                      0xffffffff
+// reset value (ignore bits undefined at reset)
+#define SGMII_INTERRUPT_RESET                                        0x00000000
+
+// 32'h18070060 (SGMII_INTERRUPT_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_MSB                                7
+#define SGMII_INTERRUPT_MASK_MASK_LSB                                0
+#define SGMII_INTERRUPT_MASK_MASK_MASK                               0x000000ff
+#define SGMII_INTERRUPT_MASK_MASK_GET(x)                             (((x) & SGMII_INTERRUPT_MASK_MASK_MASK) >> SGMII_INTERRUPT_MASK_MASK_LSB)
+#define SGMII_INTERRUPT_MASK_MASK_SET(x)                             (((x) << SGMII_INTERRUPT_MASK_MASK_LSB) & SGMII_INTERRUPT_MASK_MASK_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_RESET                              0x0 // 0
+#define SGMII_INTERRUPT_MASK_ADDRESS                                 0x18070060
+
+
+#define SGMII_LINK_FAIL				(1 << 0)
+#define SGMII_DUPLEX_ERR			(1 << 1)
+#define SGMII_MR_AN_COMPLETE			(1 << 2)
+#define SGMII_LINK_MAC_CHANGE			(1 << 3)
+#define SGMII_DUPLEX_MODE_CHANGE		(1 << 4)
+#define SGMII_SPEED_MODE_MAC_CHANGE		(1 << 5)
+#define SGMII_RX_QUIET_CHANGE			(1 << 6)
+#define SGMII_RX_MDIO_COMP_CHANGE		(1 << 7)
+
+#define SGMII_INTR				SGMII_LINK_FAIL | \
+						SGMII_LINK_MAC_CHANGE | \
+						SGMII_DUPLEX_MODE_CHANGE | \
+						SGMII_SPEED_MODE_MAC_CHANGE
+
+
+// 32'h18050048 (ETH_SGMII)
+#define ETH_SGMII_TX_INVERT_MSB                                      31
+#define ETH_SGMII_TX_INVERT_LSB                                      31
+#define ETH_SGMII_TX_INVERT_MASK                                     0x80000000
+#define ETH_SGMII_TX_INVERT_GET(x)                                   (((x) & ETH_SGMII_TX_INVERT_MASK) >> ETH_SGMII_TX_INVERT_LSB)
+#define ETH_SGMII_TX_INVERT_SET(x)                                   (((x) << ETH_SGMII_TX_INVERT_LSB) & ETH_SGMII_TX_INVERT_MASK)
+#define ETH_SGMII_TX_INVERT_RESET                                    0x0 // 0
+#define ETH_SGMII_GIGE_QUAD_MSB                                      30
+#define ETH_SGMII_GIGE_QUAD_LSB                                      30
+#define ETH_SGMII_GIGE_QUAD_MASK                                     0x40000000
+#define ETH_SGMII_GIGE_QUAD_GET(x)                                   (((x) & ETH_SGMII_GIGE_QUAD_MASK) >> ETH_SGMII_GIGE_QUAD_LSB)
+#define ETH_SGMII_GIGE_QUAD_SET(x)                                   (((x) << ETH_SGMII_GIGE_QUAD_LSB) & ETH_SGMII_GIGE_QUAD_MASK)
+#define ETH_SGMII_GIGE_QUAD_RESET                                    0x0 // 0
+#define ETH_SGMII_RX_DELAY_MSB                                       29
+#define ETH_SGMII_RX_DELAY_LSB                                       28
+#define ETH_SGMII_RX_DELAY_MASK                                      0x30000000
+#define ETH_SGMII_RX_DELAY_GET(x)                                    (((x) & ETH_SGMII_RX_DELAY_MASK) >> ETH_SGMII_RX_DELAY_LSB)
+#define ETH_SGMII_RX_DELAY_SET(x)                                    (((x) << ETH_SGMII_RX_DELAY_LSB) & ETH_SGMII_RX_DELAY_MASK)
+#define ETH_SGMII_RX_DELAY_RESET                                     0x0 // 0
+#define ETH_SGMII_TX_DELAY_MSB                                       27
+#define ETH_SGMII_TX_DELAY_LSB                                       26
+#define ETH_SGMII_TX_DELAY_MASK                                      0x0c000000
+#define ETH_SGMII_TX_DELAY_GET(x)                                    (((x) & ETH_SGMII_TX_DELAY_MASK) >> ETH_SGMII_TX_DELAY_LSB)
+#define ETH_SGMII_TX_DELAY_SET(x)                                    (((x) << ETH_SGMII_TX_DELAY_LSB) & ETH_SGMII_TX_DELAY_MASK)
+#define ETH_SGMII_TX_DELAY_RESET                                     0x0 // 0
+#define ETH_SGMII_CLK_SEL_MSB                                        25
+#define ETH_SGMII_CLK_SEL_LSB                                        25
+#define ETH_SGMII_CLK_SEL_MASK                                       0x02000000
+#define ETH_SGMII_CLK_SEL_GET(x)                                     (((x) & ETH_SGMII_CLK_SEL_MASK) >> ETH_SGMII_CLK_SEL_LSB)
+#define ETH_SGMII_CLK_SEL_SET(x)                                     (((x) << ETH_SGMII_CLK_SEL_LSB) & ETH_SGMII_CLK_SEL_MASK)
+#define ETH_SGMII_CLK_SEL_RESET                                      0x1 // 1
+#define ETH_SGMII_GIGE_MSB                                           24
+#define ETH_SGMII_GIGE_LSB                                           24
+#define ETH_SGMII_GIGE_MASK                                          0x01000000
+#define ETH_SGMII_GIGE_GET(x)                                        (((x) & ETH_SGMII_GIGE_MASK) >> ETH_SGMII_GIGE_LSB)
+#define ETH_SGMII_GIGE_SET(x)                                        (((x) << ETH_SGMII_GIGE_LSB) & ETH_SGMII_GIGE_MASK)
+#define ETH_SGMII_GIGE_RESET                                         0x1 // 1
+#define ETH_SGMII_PHASE1_COUNT_MSB                                   15
+#define ETH_SGMII_PHASE1_COUNT_LSB                                   8
+#define ETH_SGMII_PHASE1_COUNT_MASK                                  0x0000ff00
+#define ETH_SGMII_PHASE1_COUNT_GET(x)                                (((x) & ETH_SGMII_PHASE1_COUNT_MASK) >> ETH_SGMII_PHASE1_COUNT_LSB)
+#define ETH_SGMII_PHASE1_COUNT_SET(x)                                (((x) << ETH_SGMII_PHASE1_COUNT_LSB) & ETH_SGMII_PHASE1_COUNT_MASK)
+#define ETH_SGMII_PHASE1_COUNT_RESET                                 0x1 // 1
+#define ETH_SGMII_PHASE0_COUNT_MSB                                   7
+#define ETH_SGMII_PHASE0_COUNT_LSB                                   0
+#define ETH_SGMII_PHASE0_COUNT_MASK                                  0x000000ff
+#define ETH_SGMII_PHASE0_COUNT_GET(x)                                (((x) & ETH_SGMII_PHASE0_COUNT_MASK) >> ETH_SGMII_PHASE0_COUNT_LSB)
+#define ETH_SGMII_PHASE0_COUNT_SET(x)                                (((x) << ETH_SGMII_PHASE0_COUNT_LSB) & ETH_SGMII_PHASE0_COUNT_MASK)
+#define ETH_SGMII_PHASE0_COUNT_RESET                                 0x1 // 1
+#define ETH_SGMII_ADDRESS                                            0x18050048
+
+#endif /* _QCA953X_H */
diff --git a/include/955x.h b/include/955x.h
new file mode 100644
index 0000000000..9602dee1a8
--- /dev/null
+++ b/include/955x.h
@@ -0,0 +1,3484 @@
+/*
+ * QCA 955x series processor SOC registers
+ *
+ * (C) Copyright 2008 Atheros Communications, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _QCA955X_H
+#define _QCA955X_H
+
+#ifndef __ASSEMBLY__
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <linux/types.h>
+#endif /* __ASSEMBLY__ */
+
+#undef is_qca955x
+#undef is_sco
+
+#define is_qca955x()	(1)
+#define is_sco()	(1)
+
+
+#define CPU_PLL_CONFIG_UPDATING_MSB                                  31
+#define CPU_PLL_CONFIG_UPDATING_LSB                                  31
+#define CPU_PLL_CONFIG_UPDATING_MASK                                 0x80000000
+#define CPU_PLL_CONFIG_UPDATING_GET(x)                               (((x) & CPU_PLL_CONFIG_UPDATING_MASK) >> CPU_PLL_CONFIG_UPDATING_LSB)
+#define CPU_PLL_CONFIG_UPDATING_SET(x)                               (((x) << CPU_PLL_CONFIG_UPDATING_LSB) & CPU_PLL_CONFIG_UPDATING_MASK)
+#define CPU_PLL_CONFIG_UPDATING_RESET                                0x1 // 1
+#define CPU_PLL_CONFIG_PLLPWD_MSB                                    30
+#define CPU_PLL_CONFIG_PLLPWD_LSB                                    30
+#define CPU_PLL_CONFIG_PLLPWD_MASK                                   0x40000000
+#define CPU_PLL_CONFIG_PLLPWD_GET(x)                                 (((x) & CPU_PLL_CONFIG_PLLPWD_MASK) >> CPU_PLL_CONFIG_PLLPWD_LSB)
+#define CPU_PLL_CONFIG_PLLPWD_SET(x)                                 (((x) << CPU_PLL_CONFIG_PLLPWD_LSB) & CPU_PLL_CONFIG_PLLPWD_MASK)
+#define CPU_PLL_CONFIG_PLLPWD_RESET                                  0x1 // 1
+#define CPU_PLL_CONFIG_SPARE_MSB                                     29
+#define CPU_PLL_CONFIG_SPARE_LSB                                     22
+#define CPU_PLL_CONFIG_SPARE_MASK                                    0x3fc00000
+#define CPU_PLL_CONFIG_SPARE_GET(x)                                  (((x) & CPU_PLL_CONFIG_SPARE_MASK) >> CPU_PLL_CONFIG_SPARE_LSB)
+#define CPU_PLL_CONFIG_SPARE_SET(x)                                  (((x) << CPU_PLL_CONFIG_SPARE_LSB) & CPU_PLL_CONFIG_SPARE_MASK)
+#define CPU_PLL_CONFIG_SPARE_RESET                                   0x0 // 0
+#define CPU_PLL_CONFIG_OUTDIV_MSB                                    21
+#define CPU_PLL_CONFIG_OUTDIV_LSB                                    19
+#define CPU_PLL_CONFIG_OUTDIV_MASK                                   0x00380000
+#define CPU_PLL_CONFIG_OUTDIV_GET(x)                                 (((x) & CPU_PLL_CONFIG_OUTDIV_MASK) >> CPU_PLL_CONFIG_OUTDIV_LSB)
+#define CPU_PLL_CONFIG_OUTDIV_SET(x)                                 (((x) << CPU_PLL_CONFIG_OUTDIV_LSB) & CPU_PLL_CONFIG_OUTDIV_MASK)
+#define CPU_PLL_CONFIG_OUTDIV_RESET                                  0x0 // 0
+#define CPU_PLL_CONFIG_RANGE_MSB                                     18
+#define CPU_PLL_CONFIG_RANGE_LSB                                     17
+#define CPU_PLL_CONFIG_RANGE_MASK                                    0x00060000
+#define CPU_PLL_CONFIG_RANGE_GET(x)                                  (((x) & CPU_PLL_CONFIG_RANGE_MASK) >> CPU_PLL_CONFIG_RANGE_LSB)
+#define CPU_PLL_CONFIG_RANGE_SET(x)                                  (((x) << CPU_PLL_CONFIG_RANGE_LSB) & CPU_PLL_CONFIG_RANGE_MASK)
+#define CPU_PLL_CONFIG_RANGE_RESET                                   0x3 // 3
+#define CPU_PLL_CONFIG_REFDIV_MSB                                    16
+#define CPU_PLL_CONFIG_REFDIV_LSB                                    12
+#define CPU_PLL_CONFIG_REFDIV_MASK                                   0x0001f000
+#define CPU_PLL_CONFIG_REFDIV_GET(x)                                 (((x) & CPU_PLL_CONFIG_REFDIV_MASK) >> CPU_PLL_CONFIG_REFDIV_LSB)
+#define CPU_PLL_CONFIG_REFDIV_SET(x)                                 (((x) << CPU_PLL_CONFIG_REFDIV_LSB) & CPU_PLL_CONFIG_REFDIV_MASK)
+#define CPU_PLL_CONFIG_REFDIV_RESET                                  0x2 // 2
+#define CPU_PLL_CONFIG_NINT_MSB                                      11
+#define CPU_PLL_CONFIG_NINT_LSB                                      6
+#define CPU_PLL_CONFIG_NINT_MASK                                     0x00000fc0
+#define CPU_PLL_CONFIG_NINT_GET(x)                                   (((x) & CPU_PLL_CONFIG_NINT_MASK) >> CPU_PLL_CONFIG_NINT_LSB)
+#define CPU_PLL_CONFIG_NINT_SET(x)                                   (((x) << CPU_PLL_CONFIG_NINT_LSB) & CPU_PLL_CONFIG_NINT_MASK)
+#define CPU_PLL_CONFIG_NINT_RESET                                    0x14 // 20
+#define CPU_PLL_CONFIG_NFRAC_MSB                                     5
+#define CPU_PLL_CONFIG_NFRAC_LSB                                     0
+#define CPU_PLL_CONFIG_NFRAC_MASK                                    0x0000003f
+#define CPU_PLL_CONFIG_NFRAC_GET(x)                                  (((x) & CPU_PLL_CONFIG_NFRAC_MASK) >> CPU_PLL_CONFIG_NFRAC_LSB)
+#define CPU_PLL_CONFIG_NFRAC_SET(x)                                  (((x) << CPU_PLL_CONFIG_NFRAC_LSB) & CPU_PLL_CONFIG_NFRAC_MASK)
+#define CPU_PLL_CONFIG_NFRAC_RESET                                   0x10 // 16
+#define CPU_PLL_CONFIG_ADDRESS                                       0x18050000
+
+#define DDR_PLL_CONFIG_UPDATING_MSB                                  31
+#define DDR_PLL_CONFIG_UPDATING_LSB                                  31
+#define DDR_PLL_CONFIG_UPDATING_MASK                                 0x80000000
+#define DDR_PLL_CONFIG_UPDATING_GET(x)                               (((x) & DDR_PLL_CONFIG_UPDATING_MASK) >> DDR_PLL_CONFIG_UPDATING_LSB)
+#define DDR_PLL_CONFIG_UPDATING_SET(x)                               (((x) << DDR_PLL_CONFIG_UPDATING_LSB) & DDR_PLL_CONFIG_UPDATING_MASK)
+#define DDR_PLL_CONFIG_UPDATING_RESET                                0x1 // 1
+#define DDR_PLL_CONFIG_PLLPWD_MSB                                    30
+#define DDR_PLL_CONFIG_PLLPWD_LSB                                    30
+#define DDR_PLL_CONFIG_PLLPWD_MASK                                   0x40000000
+#define DDR_PLL_CONFIG_PLLPWD_GET(x)                                 (((x) & DDR_PLL_CONFIG_PLLPWD_MASK) >> DDR_PLL_CONFIG_PLLPWD_LSB)
+#define DDR_PLL_CONFIG_PLLPWD_SET(x)                                 (((x) << DDR_PLL_CONFIG_PLLPWD_LSB) & DDR_PLL_CONFIG_PLLPWD_MASK)
+#define DDR_PLL_CONFIG_PLLPWD_RESET                                  0x1 // 1
+#define DDR_PLL_CONFIG_SPARE_MSB                                     29
+#define DDR_PLL_CONFIG_SPARE_LSB                                     26
+#define DDR_PLL_CONFIG_SPARE_MASK                                    0x3c000000
+#define DDR_PLL_CONFIG_SPARE_GET(x)                                  (((x) & DDR_PLL_CONFIG_SPARE_MASK) >> DDR_PLL_CONFIG_SPARE_LSB)
+#define DDR_PLL_CONFIG_SPARE_SET(x)                                  (((x) << DDR_PLL_CONFIG_SPARE_LSB) & DDR_PLL_CONFIG_SPARE_MASK)
+#define DDR_PLL_CONFIG_SPARE_RESET                                   0x0 // 0
+#define DDR_PLL_CONFIG_OUTDIV_MSB                                    25
+#define DDR_PLL_CONFIG_OUTDIV_LSB                                    23
+#define DDR_PLL_CONFIG_OUTDIV_MASK                                   0x03800000
+#define DDR_PLL_CONFIG_OUTDIV_GET(x)                                 (((x) & DDR_PLL_CONFIG_OUTDIV_MASK) >> DDR_PLL_CONFIG_OUTDIV_LSB)
+#define DDR_PLL_CONFIG_OUTDIV_SET(x)                                 (((x) << DDR_PLL_CONFIG_OUTDIV_LSB) & DDR_PLL_CONFIG_OUTDIV_MASK)
+#define DDR_PLL_CONFIG_OUTDIV_RESET                                  0x0 // 0
+#define DDR_PLL_CONFIG_RANGE_MSB                                     22
+#define DDR_PLL_CONFIG_RANGE_LSB                                     21
+#define DDR_PLL_CONFIG_RANGE_MASK                                    0x00600000
+#define DDR_PLL_CONFIG_RANGE_GET(x)                                  (((x) & DDR_PLL_CONFIG_RANGE_MASK) >> DDR_PLL_CONFIG_RANGE_LSB)
+#define DDR_PLL_CONFIG_RANGE_SET(x)                                  (((x) << DDR_PLL_CONFIG_RANGE_LSB) & DDR_PLL_CONFIG_RANGE_MASK)
+#define DDR_PLL_CONFIG_RANGE_RESET                                   0x3 // 3
+#define DDR_PLL_CONFIG_REFDIV_MSB                                    20
+#define DDR_PLL_CONFIG_REFDIV_LSB                                    16
+#define DDR_PLL_CONFIG_REFDIV_MASK                                   0x001f0000
+#define DDR_PLL_CONFIG_REFDIV_GET(x)                                 (((x) & DDR_PLL_CONFIG_REFDIV_MASK) >> DDR_PLL_CONFIG_REFDIV_LSB)
+#define DDR_PLL_CONFIG_REFDIV_SET(x)                                 (((x) << DDR_PLL_CONFIG_REFDIV_LSB) & DDR_PLL_CONFIG_REFDIV_MASK)
+#define DDR_PLL_CONFIG_REFDIV_RESET                                  0x2 // 2
+#define DDR_PLL_CONFIG_NINT_MSB                                      15
+#define DDR_PLL_CONFIG_NINT_LSB                                      10
+#define DDR_PLL_CONFIG_NINT_MASK                                     0x0000fc00
+#define DDR_PLL_CONFIG_NINT_GET(x)                                   (((x) & DDR_PLL_CONFIG_NINT_MASK) >> DDR_PLL_CONFIG_NINT_LSB)
+#define DDR_PLL_CONFIG_NINT_SET(x)                                   (((x) << DDR_PLL_CONFIG_NINT_LSB) & DDR_PLL_CONFIG_NINT_MASK)
+#define DDR_PLL_CONFIG_NINT_RESET                                    0x14 // 20
+#define DDR_PLL_CONFIG_NFRAC_MSB                                     9
+#define DDR_PLL_CONFIG_NFRAC_LSB                                     0
+#define DDR_PLL_CONFIG_NFRAC_MASK                                    0x000003ff
+#define DDR_PLL_CONFIG_NFRAC_GET(x)                                  (((x) & DDR_PLL_CONFIG_NFRAC_MASK) >> DDR_PLL_CONFIG_NFRAC_LSB)
+#define DDR_PLL_CONFIG_NFRAC_SET(x)                                  (((x) << DDR_PLL_CONFIG_NFRAC_LSB) & DDR_PLL_CONFIG_NFRAC_MASK)
+#define DDR_PLL_CONFIG_NFRAC_RESET                                   0x200 // 512
+#define DDR_PLL_CONFIG_ADDRESS                                       0x18050004
+
+#define DDR_CTL_CONFIG_SRAM_TSEL_MSB                                 31
+#define DDR_CTL_CONFIG_SRAM_TSEL_LSB                                 30
+#define DDR_CTL_CONFIG_SRAM_TSEL_MASK                                0xc0000000
+#define DDR_CTL_CONFIG_SRAM_TSEL_GET(x)                              (((x) & DDR_CTL_CONFIG_SRAM_TSEL_MASK) >> DDR_CTL_CONFIG_SRAM_TSEL_LSB)
+#define DDR_CTL_CONFIG_SRAM_TSEL_SET(x)                              (((x) << DDR_CTL_CONFIG_SRAM_TSEL_LSB) & DDR_CTL_CONFIG_SRAM_TSEL_MASK)
+#define DDR_CTL_CONFIG_SRAM_TSEL_RESET                               0x1 // 1
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MSB                           29
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB                           21
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK                          0x3fe00000
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_GET(x)                        (((x) & DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK) >> DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB)
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_SET(x)                        (((x) << DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB) & DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK)
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_RESET                         0x0 // 0
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_MSB                             20
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_LSB                             20
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_MASK                            0x00100000
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_GET(x)                          (((x) & DDR_CTL_CONFIG_GE0_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_GE0_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_SET(x)                          (((x) << DDR_CTL_CONFIG_GE0_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_GE0_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_GE0_SRAM_SYNC_RESET                           0x1 // 1
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_MSB                             19
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_LSB                             19
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_MASK                            0x00080000
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_GET(x)                          (((x) & DDR_CTL_CONFIG_GE1_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_GE1_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_SET(x)                          (((x) << DDR_CTL_CONFIG_GE1_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_GE1_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_GE1_SRAM_SYNC_RESET                           0x1 // 1
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_MSB                             18
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_LSB                             18
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_MASK                            0x00040000
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_GET(x)                          (((x) & DDR_CTL_CONFIG_USB_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_USB_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_SET(x)                          (((x) << DDR_CTL_CONFIG_USB_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_USB_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_USB_SRAM_SYNC_RESET                           0x1 // 1
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MSB                            17
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_LSB                            17
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MASK                           0x00020000
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_GET(x)                         (((x) & DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_PCIE_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_SET(x)                         (((x) << DDR_CTL_CONFIG_PCIE_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_PCIE_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_PCIE_SRAM_SYNC_RESET                          0x1 // 1
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MSB                            16
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_LSB                            16
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MASK                           0x00010000
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_GET(x)                         (((x) & DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_WMAC_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_SET(x)                         (((x) << DDR_CTL_CONFIG_WMAC_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_WMAC_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_WMAC_SRAM_SYNC_RESET                          0x1 // 1
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_MSB                       15
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_LSB                       15
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_MASK                      0x00008000
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_GET(x)                    (((x) & DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_SET(x)                    (((x) << DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_RESET                     0x1 // 1
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_MSB                       14
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_LSB                       14
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_MASK                      0x00004000
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_GET(x)                    (((x) & DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_MASK) >> DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_LSB)
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_SET(x)                    (((x) << DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_LSB) & DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_MASK)
+#define DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_RESET                     0x1 // 1
+#define DDR_CTL_CONFIG_SPARE_MSB                                     13
+#define DDR_CTL_CONFIG_SPARE_LSB                                     7
+#define DDR_CTL_CONFIG_SPARE_MASK                                    0x00003f80
+#define DDR_CTL_CONFIG_SPARE_GET(x)                                  (((x) & DDR_CTL_CONFIG_SPARE_MASK) >> DDR_CTL_CONFIG_SPARE_LSB)
+#define DDR_CTL_CONFIG_SPARE_SET(x)                                  (((x) << DDR_CTL_CONFIG_SPARE_LSB) & DDR_CTL_CONFIG_SPARE_MASK)
+#define DDR_CTL_CONFIG_SPARE_RESET                                   0x0 // 0
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_MSB                              6
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_LSB                              6
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_MASK                             0x00000040
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_GET(x)                           (((x) & DDR_CTL_CONFIG_PAD_DDR2_SEL_MASK) >> DDR_CTL_CONFIG_PAD_DDR2_SEL_LSB)
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_SET(x)                           (((x) << DDR_CTL_CONFIG_PAD_DDR2_SEL_LSB) & DDR_CTL_CONFIG_PAD_DDR2_SEL_MASK)
+#define DDR_CTL_CONFIG_PAD_DDR2_SEL_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_MSB                             4
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_LSB                             4
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_MASK                            0x00000010
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_GET(x)                          (((x) & DDR_CTL_CONFIG_GATE_SRAM_CLK_MASK) >> DDR_CTL_CONFIG_GATE_SRAM_CLK_LSB)
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_SET(x)                          (((x) << DDR_CTL_CONFIG_GATE_SRAM_CLK_LSB) & DDR_CTL_CONFIG_GATE_SRAM_CLK_MASK)
+#define DDR_CTL_CONFIG_GATE_SRAM_CLK_RESET                           0x0 // 0
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_MSB                              3
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_LSB                              3
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_MASK                             0x00000008
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_GET(x)                           (((x) & DDR_CTL_CONFIG_SRAM_REQ_ACK_MASK) >> DDR_CTL_CONFIG_SRAM_REQ_ACK_LSB)
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_SET(x)                           (((x) << DDR_CTL_CONFIG_SRAM_REQ_ACK_LSB) & DDR_CTL_CONFIG_SRAM_REQ_ACK_MASK)
+#define DDR_CTL_CONFIG_SRAM_REQ_ACK_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_MSB                              2
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_LSB                              2
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_MASK                             0x00000004
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_GET(x)                           (((x) & DDR_CTL_CONFIG_CPU_DDR_SYNC_MASK) >> DDR_CTL_CONFIG_CPU_DDR_SYNC_LSB)
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(x)                           (((x) << DDR_CTL_CONFIG_CPU_DDR_SYNC_LSB) & DDR_CTL_CONFIG_CPU_DDR_SYNC_MASK)
+#define DDR_CTL_CONFIG_CPU_DDR_SYNC_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_HALF_WIDTH_MSB                                1
+#define DDR_CTL_CONFIG_HALF_WIDTH_LSB                                1
+#define DDR_CTL_CONFIG_HALF_WIDTH_MASK                               0x00000002
+#define DDR_CTL_CONFIG_HALF_WIDTH_GET(x)                             (((x) & DDR_CTL_CONFIG_HALF_WIDTH_MASK) >> DDR_CTL_CONFIG_HALF_WIDTH_LSB)
+#define DDR_CTL_CONFIG_HALF_WIDTH_SET(x)                             (((x) << DDR_CTL_CONFIG_HALF_WIDTH_LSB) & DDR_CTL_CONFIG_HALF_WIDTH_MASK)
+#define DDR_CTL_CONFIG_HALF_WIDTH_RESET                              0x1 // 1
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_MSB                             0
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_LSB                             0
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_MASK                            0x00000001
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_GET(x)                          (((x) & DDR_CTL_CONFIG_SDRAM_MODE_EN_MASK) >> DDR_CTL_CONFIG_SDRAM_MODE_EN_LSB)
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_SET(x)                          (((x) << DDR_CTL_CONFIG_SDRAM_MODE_EN_LSB) & DDR_CTL_CONFIG_SDRAM_MODE_EN_MASK)
+#define DDR_CTL_CONFIG_SDRAM_MODE_EN_RESET                           0x0 // 0
+#define DDR_CTL_CONFIG_ADDRESS                                       0x18000108
+
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MSB                            31
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_LSB                            31
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MASK                           0x80000000
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_GET(x)                         (((x) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MASK) >> DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_LSB)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_SET(x)                         (((x) << DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_LSB) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_MASK)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQ_RESET                          0x0 // 0
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MSB                           30
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_LSB                           30
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MASK                          0x40000000
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_GET(x)                        (((x) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MASK) >> DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_LSB)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_SET(x)                        (((x) << DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_LSB) & DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_MASK)
+#define DDR_DEBUG_RD_CNTL_FORCE_WR_DQS_RESET                         0x0 // 0
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_MSB                             29
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_LSB                             29
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_MASK                            0x20000000
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_GET(x)                          (((x) & DDR_DEBUG_RD_CNTL_USE_LB_CLK_MASK) >> DDR_DEBUG_RD_CNTL_USE_LB_CLK_LSB)
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_SET(x)                          (((x) << DDR_DEBUG_RD_CNTL_USE_LB_CLK_LSB) & DDR_DEBUG_RD_CNTL_USE_LB_CLK_MASK)
+#define DDR_DEBUG_RD_CNTL_USE_LB_CLK_RESET                           0x0 // 0
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MSB                            28
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_LSB                            28
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MASK                           0x10000000
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_GET(x)                         (((x) & DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MASK) >> DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_LSB)
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_SET(x)                         (((x) << DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_LSB) & DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_MASK)
+#define DDR_DEBUG_RD_CNTL_LB_SRC_CK_P_RESET                          0x1 // 1
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MSB                            27
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_LSB                            27
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MASK                           0x08000000
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_GET(x)                         (((x) & DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MASK) >> DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_LSB)
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_SET(x)                         (((x) << DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_LSB) & DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_MASK)
+#define DDR_DEBUG_RD_CNTL_EN_RD_ON_WR_RESET                          0x0 // 0
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MSB                          14
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_LSB                          13
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MASK                         0x00006000
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_GET(x)                       (((x) & DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MASK) >> DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_LSB)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_SET(x)                       (((x) << DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_LSB) & DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_MASK)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_PDLY_RESET                        0x0 // 0
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_MSB                               12
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_LSB                               8
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_MASK                              0x00001f00
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_GET(x)                            (((x) & DDR_DEBUG_RD_CNTL_GATE_TAP_MASK) >> DDR_DEBUG_RD_CNTL_GATE_TAP_LSB)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_SET(x)                            (((x) << DDR_DEBUG_RD_CNTL_GATE_TAP_LSB) & DDR_DEBUG_RD_CNTL_GATE_TAP_MASK)
+#define DDR_DEBUG_RD_CNTL_GATE_TAP_RESET                             0x1 // 1
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MSB                          6
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_LSB                          5
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MASK                         0x00000060
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_GET(x)                       (((x) & DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MASK) >> DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_LSB)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_SET(x)                       (((x) << DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_LSB) & DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_MASK)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_PDLY_RESET                        0x0 // 0
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_MSB                               4
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_LSB                               0
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_MASK                              0x0000001f
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_GET(x)                            (((x) & DDR_DEBUG_RD_CNTL_CK_P_TAP_MASK) >> DDR_DEBUG_RD_CNTL_CK_P_TAP_LSB)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_SET(x)                            (((x) << DDR_DEBUG_RD_CNTL_CK_P_TAP_LSB) & DDR_DEBUG_RD_CNTL_CK_P_TAP_MASK)
+#define DDR_DEBUG_RD_CNTL_CK_P_TAP_RESET                             0x1 // 1
+#define DDR_DEBUG_RD_CNTL_ADDRESS                                    0x18000118
+
+#define DDR2_CONFIG_DDR2_TWL_MSB                                     13
+#define DDR2_CONFIG_DDR2_TWL_LSB                                     10
+#define DDR2_CONFIG_DDR2_TWL_MASK                                    0x00003c00
+#define DDR2_CONFIG_DDR2_TWL_GET(x)                                  (((x) & DDR2_CONFIG_DDR2_TWL_MASK) >> DDR2_CONFIG_DDR2_TWL_LSB)
+#define DDR2_CONFIG_DDR2_TWL_SET(x)                                  (((x) << DDR2_CONFIG_DDR2_TWL_LSB) & DDR2_CONFIG_DDR2_TWL_MASK)
+#define DDR2_CONFIG_DDR2_TWL_RESET                                   0x1 // 1
+#define DDR2_CONFIG_DDR2_ODT_MSB                                     9
+#define DDR2_CONFIG_DDR2_ODT_LSB                                     9
+#define DDR2_CONFIG_DDR2_ODT_MASK                                    0x00000200
+#define DDR2_CONFIG_DDR2_ODT_GET(x)                                  (((x) & DDR2_CONFIG_DDR2_ODT_MASK) >> DDR2_CONFIG_DDR2_ODT_LSB)
+#define DDR2_CONFIG_DDR2_ODT_SET(x)                                  (((x) << DDR2_CONFIG_DDR2_ODT_LSB) & DDR2_CONFIG_DDR2_ODT_MASK)
+#define DDR2_CONFIG_DDR2_ODT_RESET                                   0x1 // 1
+#define DDR2_CONFIG_TFAW_MSB                                         7
+#define DDR2_CONFIG_TFAW_LSB                                         2
+#define DDR2_CONFIG_TFAW_MASK                                        0x000000fc
+#define DDR2_CONFIG_TFAW_GET(x)                                      (((x) & DDR2_CONFIG_TFAW_MASK) >> DDR2_CONFIG_TFAW_LSB)
+#define DDR2_CONFIG_TFAW_SET(x)                                      (((x) << DDR2_CONFIG_TFAW_LSB) & DDR2_CONFIG_TFAW_MASK)
+#define DDR2_CONFIG_TFAW_RESET                                       0x16 // 22
+#define DDR2_CONFIG_ENABLE_DDR2_MSB                                  0
+#define DDR2_CONFIG_ENABLE_DDR2_LSB                                  0
+#define DDR2_CONFIG_ENABLE_DDR2_MASK                                 0x00000001
+#define DDR2_CONFIG_ENABLE_DDR2_GET(x)                               (((x) & DDR2_CONFIG_ENABLE_DDR2_MASK) >> DDR2_CONFIG_ENABLE_DDR2_LSB)
+#define DDR2_CONFIG_ENABLE_DDR2_SET(x)                               (((x) << DDR2_CONFIG_ENABLE_DDR2_LSB) & DDR2_CONFIG_ENABLE_DDR2_MASK)
+#define DDR2_CONFIG_ENABLE_DDR2_RESET                                0x0 // 0
+#define DDR2_CONFIG_ADDRESS                                          0x180000b8
+
+#define DDR_CONTROL_EMR3S_MSB                                        5
+#define DDR_CONTROL_EMR3S_LSB                                        5
+#define DDR_CONTROL_EMR3S_MASK                                       0x00000020
+#define DDR_CONTROL_EMR3S_GET(x)                                     (((x) & DDR_CONTROL_EMR3S_MASK) >> DDR_CONTROL_EMR3S_LSB)
+#define DDR_CONTROL_EMR3S_SET(x)                                     (((x) << DDR_CONTROL_EMR3S_LSB) & DDR_CONTROL_EMR3S_MASK)
+#define DDR_CONTROL_EMR3S_RESET                                      0x0 // 0
+#define DDR_CONTROL_EMR2S_MSB                                        4
+#define DDR_CONTROL_EMR2S_LSB                                        4
+#define DDR_CONTROL_EMR2S_MASK                                       0x00000010
+#define DDR_CONTROL_EMR2S_GET(x)                                     (((x) & DDR_CONTROL_EMR2S_MASK) >> DDR_CONTROL_EMR2S_LSB)
+#define DDR_CONTROL_EMR2S_SET(x)                                     (((x) << DDR_CONTROL_EMR2S_LSB) & DDR_CONTROL_EMR2S_MASK)
+#define DDR_CONTROL_EMR2S_RESET                                      0x0 // 0
+#define DDR_CONTROL_PREA_MSB                                         3
+#define DDR_CONTROL_PREA_LSB                                         3
+#define DDR_CONTROL_PREA_MASK                                        0x00000008
+#define DDR_CONTROL_PREA_GET(x)                                      (((x) & DDR_CONTROL_PREA_MASK) >> DDR_CONTROL_PREA_LSB)
+#define DDR_CONTROL_PREA_SET(x)                                      (((x) << DDR_CONTROL_PREA_LSB) & DDR_CONTROL_PREA_MASK)
+#define DDR_CONTROL_PREA_RESET                                       0x0 // 0
+#define DDR_CONTROL_REF_MSB                                          2
+#define DDR_CONTROL_REF_LSB                                          2
+#define DDR_CONTROL_REF_MASK                                         0x00000004
+#define DDR_CONTROL_REF_GET(x)                                       (((x) & DDR_CONTROL_REF_MASK) >> DDR_CONTROL_REF_LSB)
+#define DDR_CONTROL_REF_SET(x)                                       (((x) << DDR_CONTROL_REF_LSB) & DDR_CONTROL_REF_MASK)
+#define DDR_CONTROL_REF_RESET                                        0x0 // 0
+#define DDR_CONTROL_EMRS_MSB                                         1
+#define DDR_CONTROL_EMRS_LSB                                         1
+#define DDR_CONTROL_EMRS_MASK                                        0x00000002
+#define DDR_CONTROL_EMRS_GET(x)                                      (((x) & DDR_CONTROL_EMRS_MASK) >> DDR_CONTROL_EMRS_LSB)
+#define DDR_CONTROL_EMRS_SET(x)                                      (((x) << DDR_CONTROL_EMRS_LSB) & DDR_CONTROL_EMRS_MASK)
+#define DDR_CONTROL_EMRS_RESET                                       0x0 // 0
+#define DDR_CONTROL_MRS_MSB                                          0
+#define DDR_CONTROL_MRS_LSB                                          0
+#define DDR_CONTROL_MRS_MASK                                         0x00000001
+#define DDR_CONTROL_MRS_GET(x)                                       (((x) & DDR_CONTROL_MRS_MASK) >> DDR_CONTROL_MRS_LSB)
+#define DDR_CONTROL_MRS_SET(x)                                       (((x) << DDR_CONTROL_MRS_LSB) & DDR_CONTROL_MRS_MASK)
+#define DDR_CONTROL_MRS_RESET                                        0x0 // 0
+#define DDR_CONTROL_ADDRESS                                          0x18000010
+
+#define DDR_CONFIG_CAS_LATENCY_MSB_MSB                               31
+#define DDR_CONFIG_CAS_LATENCY_MSB_LSB                               31
+#define DDR_CONFIG_CAS_LATENCY_MSB_MASK                              0x80000000
+#define DDR_CONFIG_CAS_LATENCY_MSB_GET(x)                            (((x) & DDR_CONFIG_CAS_LATENCY_MSB_MASK) >> DDR_CONFIG_CAS_LATENCY_MSB_LSB)
+#define DDR_CONFIG_CAS_LATENCY_MSB_SET(x)                            (((x) << DDR_CONFIG_CAS_LATENCY_MSB_LSB) & DDR_CONFIG_CAS_LATENCY_MSB_MASK)
+#define DDR_CONFIG_CAS_LATENCY_MSB_RESET                             0x0 // 0
+#define DDR_CONFIG_OPEN_PAGE_MSB                                     30
+#define DDR_CONFIG_OPEN_PAGE_LSB                                     30
+#define DDR_CONFIG_OPEN_PAGE_MASK                                    0x40000000
+#define DDR_CONFIG_OPEN_PAGE_GET(x)                                  (((x) & DDR_CONFIG_OPEN_PAGE_MASK) >> DDR_CONFIG_OPEN_PAGE_LSB)
+#define DDR_CONFIG_OPEN_PAGE_SET(x)                                  (((x) << DDR_CONFIG_OPEN_PAGE_LSB) & DDR_CONFIG_OPEN_PAGE_MASK)
+#define DDR_CONFIG_OPEN_PAGE_RESET                                   0x1 // 1
+#define DDR_CONFIG_CAS_LATENCY_MSB                                   29
+#define DDR_CONFIG_CAS_LATENCY_LSB                                   27
+#define DDR_CONFIG_CAS_LATENCY_MASK                                  0x38000000
+#define DDR_CONFIG_CAS_LATENCY_GET(x)                                (((x) & DDR_CONFIG_CAS_LATENCY_MASK) >> DDR_CONFIG_CAS_LATENCY_LSB)
+#define DDR_CONFIG_CAS_LATENCY_SET(x)                                (((x) << DDR_CONFIG_CAS_LATENCY_LSB) & DDR_CONFIG_CAS_LATENCY_MASK)
+#define DDR_CONFIG_CAS_LATENCY_RESET                                 0x6 // 6
+#define DDR_CONFIG_TMRD_MSB                                          26
+#define DDR_CONFIG_TMRD_LSB                                          23
+#define DDR_CONFIG_TMRD_MASK                                         0x07800000
+#define DDR_CONFIG_TMRD_GET(x)                                       (((x) & DDR_CONFIG_TMRD_MASK) >> DDR_CONFIG_TMRD_LSB)
+#define DDR_CONFIG_TMRD_SET(x)                                       (((x) << DDR_CONFIG_TMRD_LSB) & DDR_CONFIG_TMRD_MASK)
+#define DDR_CONFIG_TMRD_RESET                                        0xf // 15
+#define DDR_CONFIG_TRFC_MSB                                          22
+#define DDR_CONFIG_TRFC_LSB                                          17
+#define DDR_CONFIG_TRFC_MASK                                         0x007e0000
+#define DDR_CONFIG_TRFC_GET(x)                                       (((x) & DDR_CONFIG_TRFC_MASK) >> DDR_CONFIG_TRFC_LSB)
+#define DDR_CONFIG_TRFC_SET(x)                                       (((x) << DDR_CONFIG_TRFC_LSB) & DDR_CONFIG_TRFC_MASK)
+#define DDR_CONFIG_TRFC_RESET                                        0x24 // 36
+#define DDR_CONFIG_TRRD_MSB                                          16
+#define DDR_CONFIG_TRRD_LSB                                          13
+#define DDR_CONFIG_TRRD_MASK                                         0x0001e000
+#define DDR_CONFIG_TRRD_GET(x)                                       (((x) & DDR_CONFIG_TRRD_MASK) >> DDR_CONFIG_TRRD_LSB)
+#define DDR_CONFIG_TRRD_SET(x)                                       (((x) << DDR_CONFIG_TRRD_LSB) & DDR_CONFIG_TRRD_MASK)
+#define DDR_CONFIG_TRRD_RESET                                        0x4 // 4
+#define DDR_CONFIG_TRP_MSB                                           12
+#define DDR_CONFIG_TRP_LSB                                           9
+#define DDR_CONFIG_TRP_MASK                                          0x00001e00
+#define DDR_CONFIG_TRP_GET(x)                                        (((x) & DDR_CONFIG_TRP_MASK) >> DDR_CONFIG_TRP_LSB)
+#define DDR_CONFIG_TRP_SET(x)                                        (((x) << DDR_CONFIG_TRP_LSB) & DDR_CONFIG_TRP_MASK)
+#define DDR_CONFIG_TRP_RESET                                         0x6 // 6
+#define DDR_CONFIG_TRCD_MSB                                          8
+#define DDR_CONFIG_TRCD_LSB                                          5
+#define DDR_CONFIG_TRCD_MASK                                         0x000001e0
+#define DDR_CONFIG_TRCD_GET(x)                                       (((x) & DDR_CONFIG_TRCD_MASK) >> DDR_CONFIG_TRCD_LSB)
+#define DDR_CONFIG_TRCD_SET(x)                                       (((x) << DDR_CONFIG_TRCD_LSB) & DDR_CONFIG_TRCD_MASK)
+#define DDR_CONFIG_TRCD_RESET                                        0x6 // 6
+#define DDR_CONFIG_TRAS_MSB                                          4
+#define DDR_CONFIG_TRAS_LSB                                          0
+#define DDR_CONFIG_TRAS_MASK                                         0x0000001f
+#define DDR_CONFIG_TRAS_GET(x)                                       (((x) & DDR_CONFIG_TRAS_MASK) >> DDR_CONFIG_TRAS_LSB)
+#define DDR_CONFIG_TRAS_SET(x)                                       (((x) << DDR_CONFIG_TRAS_LSB) & DDR_CONFIG_TRAS_MASK)
+#define DDR_CONFIG_TRAS_RESET                                        0x10 // 16
+#define DDR_CONFIG_ADDRESS                                           0x18000000
+
+#define DDR_CONFIG2_HALF_WIDTH_LOW_MSB                               31
+#define DDR_CONFIG2_HALF_WIDTH_LOW_LSB                               31
+#define DDR_CONFIG2_HALF_WIDTH_LOW_MASK                              0x80000000
+#define DDR_CONFIG2_HALF_WIDTH_LOW_GET(x)                            (((x) & DDR_CONFIG2_HALF_WIDTH_LOW_MASK) >> DDR_CONFIG2_HALF_WIDTH_LOW_LSB)
+#define DDR_CONFIG2_HALF_WIDTH_LOW_SET(x)                            (((x) << DDR_CONFIG2_HALF_WIDTH_LOW_LSB) & DDR_CONFIG2_HALF_WIDTH_LOW_MASK)
+#define DDR_CONFIG2_HALF_WIDTH_LOW_RESET                             0x1 // 1
+#define DDR_CONFIG2_SWAP_A26_A27_MSB                                 30
+#define DDR_CONFIG2_SWAP_A26_A27_LSB                                 30
+#define DDR_CONFIG2_SWAP_A26_A27_MASK                                0x40000000
+#define DDR_CONFIG2_SWAP_A26_A27_GET(x)                              (((x) & DDR_CONFIG2_SWAP_A26_A27_MASK) >> DDR_CONFIG2_SWAP_A26_A27_LSB)
+#define DDR_CONFIG2_SWAP_A26_A27_SET(x)                              (((x) << DDR_CONFIG2_SWAP_A26_A27_LSB) & DDR_CONFIG2_SWAP_A26_A27_MASK)
+#define DDR_CONFIG2_SWAP_A26_A27_RESET                               0x0 // 0
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_MSB                            29
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_LSB                            26
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_MASK                           0x3c000000
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_GET(x)                         (((x) & DDR_CONFIG2_GATE_OPEN_LATENCY_MASK) >> DDR_CONFIG2_GATE_OPEN_LATENCY_LSB)
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_SET(x)                         (((x) << DDR_CONFIG2_GATE_OPEN_LATENCY_LSB) & DDR_CONFIG2_GATE_OPEN_LATENCY_MASK)
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_RESET                          0x6 // 6
+#define DDR_CONFIG2_TWTR_MSB                                         25
+#define DDR_CONFIG2_TWTR_LSB                                         21
+#define DDR_CONFIG2_TWTR_MASK                                        0x03e00000
+#define DDR_CONFIG2_TWTR_GET(x)                                      (((x) & DDR_CONFIG2_TWTR_MASK) >> DDR_CONFIG2_TWTR_LSB)
+#define DDR_CONFIG2_TWTR_SET(x)                                      (((x) << DDR_CONFIG2_TWTR_LSB) & DDR_CONFIG2_TWTR_MASK)
+#define DDR_CONFIG2_TWTR_RESET                                       0xe // 14
+#define DDR_CONFIG2_TRTP_MSB                                         20
+#define DDR_CONFIG2_TRTP_LSB                                         17
+#define DDR_CONFIG2_TRTP_MASK                                        0x001e0000
+#define DDR_CONFIG2_TRTP_GET(x)                                      (((x) & DDR_CONFIG2_TRTP_MASK) >> DDR_CONFIG2_TRTP_LSB)
+#define DDR_CONFIG2_TRTP_SET(x)                                      (((x) << DDR_CONFIG2_TRTP_LSB) & DDR_CONFIG2_TRTP_MASK)
+#define DDR_CONFIG2_TRTP_RESET                                       0x8 // 8
+#define DDR_CONFIG2_TRTW_MSB                                         16
+#define DDR_CONFIG2_TRTW_LSB                                         12
+#define DDR_CONFIG2_TRTW_MASK                                        0x0001f000
+#define DDR_CONFIG2_TRTW_GET(x)                                      (((x) & DDR_CONFIG2_TRTW_MASK) >> DDR_CONFIG2_TRTW_LSB)
+#define DDR_CONFIG2_TRTW_SET(x)                                      (((x) << DDR_CONFIG2_TRTW_LSB) & DDR_CONFIG2_TRTW_MASK)
+#define DDR_CONFIG2_TRTW_RESET                                       0x10 // 16
+#define DDR_CONFIG2_TWR_MSB                                          11
+#define DDR_CONFIG2_TWR_LSB                                          8
+#define DDR_CONFIG2_TWR_MASK                                         0x00000f00
+#define DDR_CONFIG2_TWR_GET(x)                                       (((x) & DDR_CONFIG2_TWR_MASK) >> DDR_CONFIG2_TWR_LSB)
+#define DDR_CONFIG2_TWR_SET(x)                                       (((x) << DDR_CONFIG2_TWR_LSB) & DDR_CONFIG2_TWR_MASK)
+#define DDR_CONFIG2_TWR_RESET                                        0x6 // 6
+#define DDR_CONFIG2_CKE_MSB                                          7
+#define DDR_CONFIG2_CKE_LSB                                          7
+#define DDR_CONFIG2_CKE_MASK                                         0x00000080
+#define DDR_CONFIG2_CKE_GET(x)                                       (((x) & DDR_CONFIG2_CKE_MASK) >> DDR_CONFIG2_CKE_LSB)
+#define DDR_CONFIG2_CKE_SET(x)                                       (((x) << DDR_CONFIG2_CKE_LSB) & DDR_CONFIG2_CKE_MASK)
+#define DDR_CONFIG2_CKE_RESET                                        0x0 // 0
+#define DDR_CONFIG2_PHASE_SELECT_MSB                                 6
+#define DDR_CONFIG2_PHASE_SELECT_LSB                                 6
+#define DDR_CONFIG2_PHASE_SELECT_MASK                                0x00000040
+#define DDR_CONFIG2_PHASE_SELECT_GET(x)                              (((x) & DDR_CONFIG2_PHASE_SELECT_MASK) >> DDR_CONFIG2_PHASE_SELECT_LSB)
+#define DDR_CONFIG2_PHASE_SELECT_SET(x)                              (((x) << DDR_CONFIG2_PHASE_SELECT_LSB) & DDR_CONFIG2_PHASE_SELECT_MASK)
+#define DDR_CONFIG2_PHASE_SELECT_RESET                               0x0 // 0
+#define DDR_CONFIG2_CNTL_OE_EN_MSB                                   5
+#define DDR_CONFIG2_CNTL_OE_EN_LSB                                   5
+#define DDR_CONFIG2_CNTL_OE_EN_MASK                                  0x00000020
+#define DDR_CONFIG2_CNTL_OE_EN_GET(x)                                (((x) & DDR_CONFIG2_CNTL_OE_EN_MASK) >> DDR_CONFIG2_CNTL_OE_EN_LSB)
+#define DDR_CONFIG2_CNTL_OE_EN_SET(x)                                (((x) << DDR_CONFIG2_CNTL_OE_EN_LSB) & DDR_CONFIG2_CNTL_OE_EN_MASK)
+#define DDR_CONFIG2_CNTL_OE_EN_RESET                                 0x1 // 1
+#define DDR_CONFIG2_BURST_TYPE_MSB                                   4
+#define DDR_CONFIG2_BURST_TYPE_LSB                                   4
+#define DDR_CONFIG2_BURST_TYPE_MASK                                  0x00000010
+#define DDR_CONFIG2_BURST_TYPE_GET(x)                                (((x) & DDR_CONFIG2_BURST_TYPE_MASK) >> DDR_CONFIG2_BURST_TYPE_LSB)
+#define DDR_CONFIG2_BURST_TYPE_SET(x)                                (((x) << DDR_CONFIG2_BURST_TYPE_LSB) & DDR_CONFIG2_BURST_TYPE_MASK)
+#define DDR_CONFIG2_BURST_TYPE_RESET                                 0x0 // 0
+#define DDR_CONFIG2_BURST_LENGTH_MSB                                 3
+#define DDR_CONFIG2_BURST_LENGTH_LSB                                 0
+#define DDR_CONFIG2_BURST_LENGTH_MASK                                0x0000000f
+#define DDR_CONFIG2_BURST_LENGTH_GET(x)                              (((x) & DDR_CONFIG2_BURST_LENGTH_MASK) >> DDR_CONFIG2_BURST_LENGTH_LSB)
+#define DDR_CONFIG2_BURST_LENGTH_SET(x)                              (((x) << DDR_CONFIG2_BURST_LENGTH_LSB) & DDR_CONFIG2_BURST_LENGTH_MASK)
+#define DDR_CONFIG2_BURST_LENGTH_RESET                               0x8 // 8
+#define DDR_CONFIG2_ADDRESS                                          0x18000004
+
+#define DDR_CONFIG_3_SPARE_MSB                                       31
+#define DDR_CONFIG_3_SPARE_LSB                                       4
+#define DDR_CONFIG_3_SPARE_MASK                                      0xfffffff0
+#define DDR_CONFIG_3_SPARE_GET(x)                                    (((x) & DDR_CONFIG_3_SPARE_MASK) >> DDR_CONFIG_3_SPARE_LSB)
+#define DDR_CONFIG_3_SPARE_SET(x)                                    (((x) << DDR_CONFIG_3_SPARE_LSB) & DDR_CONFIG_3_SPARE_MASK)
+#define DDR_CONFIG_3_SPARE_RESET                                     0x0 // 0
+#define DDR_CONFIG_3_TWR_MSB_MSB                                     3
+#define DDR_CONFIG_3_TWR_MSB_LSB                                     3
+#define DDR_CONFIG_3_TWR_MSB_MASK                                    0x00000008
+#define DDR_CONFIG_3_TWR_MSB_GET(x)                                  (((x) & DDR_CONFIG_3_TWR_MSB_MASK) >> DDR_CONFIG_3_TWR_MSB_LSB)
+#define DDR_CONFIG_3_TWR_MSB_SET(x)                                  (((x) << DDR_CONFIG_3_TWR_MSB_LSB) & DDR_CONFIG_3_TWR_MSB_MASK)
+#define DDR_CONFIG_3_TWR_MSB_RESET                                   0x0 // 0
+#define DDR_CONFIG_3_TRAS_MSB_MSB                                    2
+#define DDR_CONFIG_3_TRAS_MSB_LSB                                    2
+#define DDR_CONFIG_3_TRAS_MSB_MASK                                   0x00000004
+#define DDR_CONFIG_3_TRAS_MSB_GET(x)                                 (((x) & DDR_CONFIG_3_TRAS_MSB_MASK) >> DDR_CONFIG_3_TRAS_MSB_LSB)
+#define DDR_CONFIG_3_TRAS_MSB_SET(x)                                 (((x) << DDR_CONFIG_3_TRAS_MSB_LSB) & DDR_CONFIG_3_TRAS_MSB_MASK)
+#define DDR_CONFIG_3_TRAS_MSB_RESET                                  0x0 // 0
+#define DDR_CONFIG_3_TRFC_LSB_MSB                                    1
+#define DDR_CONFIG_3_TRFC_LSB_LSB                                    0
+#define DDR_CONFIG_3_TRFC_LSB_MASK                                   0x00000003
+#define DDR_CONFIG_3_TRFC_LSB_GET(x)                                 (((x) & DDR_CONFIG_3_TRFC_LSB_MASK) >> DDR_CONFIG_3_TRFC_LSB_LSB)
+#define DDR_CONFIG_3_TRFC_LSB_SET(x)                                 (((x) << DDR_CONFIG_3_TRFC_LSB_LSB) & DDR_CONFIG_3_TRFC_LSB_MASK)
+#define DDR_CONFIG_3_TRFC_LSB_RESET                                  0x0 // 0
+#define DDR_CONFIG_3_ADDRESS                                         0x1800015c
+
+#define DDR_MODE_REGISTER_VALUE_MSB                                  13
+#define DDR_MODE_REGISTER_VALUE_LSB                                  0
+#define DDR_MODE_REGISTER_VALUE_MASK                                 0x00003fff
+#define DDR_MODE_REGISTER_VALUE_GET(x)                               (((x) & DDR_MODE_REGISTER_VALUE_MASK) >> DDR_MODE_REGISTER_VALUE_LSB)
+#define DDR_MODE_REGISTER_VALUE_SET(x)                               (((x) << DDR_MODE_REGISTER_VALUE_LSB) & DDR_MODE_REGISTER_VALUE_MASK)
+#define DDR_MODE_REGISTER_VALUE_RESET                                0x133 // 307
+#define DDR_MODE_REGISTER_ADDRESS                                    0x18000008
+
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_MSB                         13
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_LSB                         0
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_MASK                        0x00003fff
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_GET(x)                      (((x) & DDR_EXTENDED_MODE_REGISTER_VALUE_MASK) >> DDR_EXTENDED_MODE_REGISTER_VALUE_LSB)
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_SET(x)                      (((x) << DDR_EXTENDED_MODE_REGISTER_VALUE_LSB) & DDR_EXTENDED_MODE_REGISTER_VALUE_MASK)
+#define DDR_EXTENDED_MODE_REGISTER_VALUE_RESET                       0x2 // 2
+#define DDR_EXTENDED_MODE_REGISTER_ADDRESS                           0x1800000c
+
+#define DDR_REFRESH_ENABLE_MSB                                       14
+#define DDR_REFRESH_ENABLE_LSB                                       14
+#define DDR_REFRESH_ENABLE_MASK                                      0x00004000
+#define DDR_REFRESH_ENABLE_GET(x)                                    (((x) & DDR_REFRESH_ENABLE_MASK) >> DDR_REFRESH_ENABLE_LSB)
+#define DDR_REFRESH_ENABLE_SET(x)                                    (((x) << DDR_REFRESH_ENABLE_LSB) & DDR_REFRESH_ENABLE_MASK)
+#define DDR_REFRESH_ENABLE_RESET                                     0x0 // 0
+#define DDR_REFRESH_PERIOD_MSB                                       13
+#define DDR_REFRESH_PERIOD_LSB                                       0
+#define DDR_REFRESH_PERIOD_MASK                                      0x00003fff
+#define DDR_REFRESH_PERIOD_GET(x)                                    (((x) & DDR_REFRESH_PERIOD_MASK) >> DDR_REFRESH_PERIOD_LSB)
+#define DDR_REFRESH_PERIOD_SET(x)                                    (((x) << DDR_REFRESH_PERIOD_LSB) & DDR_REFRESH_PERIOD_MASK)
+#define DDR_REFRESH_PERIOD_RESET                                     0x12c // 300
+#define DDR_REFRESH_ADDRESS                                          0x18000014
+
+#define BB_DPLL2_RANGE_MSB                                           31
+#define BB_DPLL2_RANGE_LSB                                           31
+#define BB_DPLL2_RANGE_MASK                                          0x80000000
+#define BB_DPLL2_RANGE_GET(x)                                        (((x) & BB_DPLL2_RANGE_MASK) >> BB_DPLL2_RANGE_LSB)
+#define BB_DPLL2_RANGE_SET(x)                                        (((x) << BB_DPLL2_RANGE_LSB) & BB_DPLL2_RANGE_MASK)
+#define BB_DPLL2_RANGE_RESET                                         0x0 // 0
+#define BB_DPLL2_LOCAL_PLL_MSB                                       30
+#define BB_DPLL2_LOCAL_PLL_LSB                                       30
+#define BB_DPLL2_LOCAL_PLL_MASK                                      0x40000000
+#define BB_DPLL2_LOCAL_PLL_GET(x)                                    (((x) & BB_DPLL2_LOCAL_PLL_MASK) >> BB_DPLL2_LOCAL_PLL_LSB)
+#define BB_DPLL2_LOCAL_PLL_SET(x)                                    (((x) << BB_DPLL2_LOCAL_PLL_LSB) & BB_DPLL2_LOCAL_PLL_MASK)
+#define BB_DPLL2_LOCAL_PLL_RESET                                     0x0 // 0
+#define BB_DPLL2_KI_MSB                                              29
+#define BB_DPLL2_KI_LSB                                              26
+#define BB_DPLL2_KI_MASK                                             0x3c000000
+#define BB_DPLL2_KI_GET(x)                                           (((x) & BB_DPLL2_KI_MASK) >> BB_DPLL2_KI_LSB)
+#define BB_DPLL2_KI_SET(x)                                           (((x) << BB_DPLL2_KI_LSB) & BB_DPLL2_KI_MASK)
+#define BB_DPLL2_KI_RESET                                            0x6 // 6
+#define BB_DPLL2_KD_MSB                                              25
+#define BB_DPLL2_KD_LSB                                              19
+#define BB_DPLL2_KD_MASK                                             0x03f80000
+#define BB_DPLL2_KD_GET(x)                                           (((x) & BB_DPLL2_KD_MASK) >> BB_DPLL2_KD_LSB)
+#define BB_DPLL2_KD_SET(x)                                           (((x) << BB_DPLL2_KD_LSB) & BB_DPLL2_KD_MASK)
+#define BB_DPLL2_KD_RESET                                            0x7f // 127
+#define BB_DPLL2_EN_NEGTRIG_MSB                                      18
+#define BB_DPLL2_EN_NEGTRIG_LSB                                      18
+#define BB_DPLL2_EN_NEGTRIG_MASK                                     0x00040000
+#define BB_DPLL2_EN_NEGTRIG_GET(x)                                   (((x) & BB_DPLL2_EN_NEGTRIG_MASK) >> BB_DPLL2_EN_NEGTRIG_LSB)
+#define BB_DPLL2_EN_NEGTRIG_SET(x)                                   (((x) << BB_DPLL2_EN_NEGTRIG_LSB) & BB_DPLL2_EN_NEGTRIG_MASK)
+#define BB_DPLL2_EN_NEGTRIG_RESET                                    0x0 // 0
+#define BB_DPLL2_SEL_1SDM_MSB                                        17
+#define BB_DPLL2_SEL_1SDM_LSB                                        17
+#define BB_DPLL2_SEL_1SDM_MASK                                       0x00020000
+#define BB_DPLL2_SEL_1SDM_GET(x)                                     (((x) & BB_DPLL2_SEL_1SDM_MASK) >> BB_DPLL2_SEL_1SDM_LSB)
+#define BB_DPLL2_SEL_1SDM_SET(x)                                     (((x) << BB_DPLL2_SEL_1SDM_LSB) & BB_DPLL2_SEL_1SDM_MASK)
+#define BB_DPLL2_SEL_1SDM_RESET                                      0x0 // 0
+#define BB_DPLL2_PLL_PWD_MSB                                         16
+#define BB_DPLL2_PLL_PWD_LSB                                         16
+#define BB_DPLL2_PLL_PWD_MASK                                        0x00010000
+#define BB_DPLL2_PLL_PWD_GET(x)                                      (((x) & BB_DPLL2_PLL_PWD_MASK) >> BB_DPLL2_PLL_PWD_LSB)
+#define BB_DPLL2_PLL_PWD_SET(x)                                      (((x) << BB_DPLL2_PLL_PWD_LSB) & BB_DPLL2_PLL_PWD_MASK)
+#define BB_DPLL2_PLL_PWD_RESET                                       0x1 // 1
+#define BB_DPLL2_OUTDIV_MSB                                          15
+#define BB_DPLL2_OUTDIV_LSB                                          13
+#define BB_DPLL2_OUTDIV_MASK                                         0x0000e000
+#define BB_DPLL2_OUTDIV_GET(x)                                       (((x) & BB_DPLL2_OUTDIV_MASK) >> BB_DPLL2_OUTDIV_LSB)
+#define BB_DPLL2_OUTDIV_SET(x)                                       (((x) << BB_DPLL2_OUTDIV_LSB) & BB_DPLL2_OUTDIV_MASK)
+#define BB_DPLL2_OUTDIV_RESET                                        0x0 // 0
+#define BB_DPLL2_DELTA_MSB                                           12
+#define BB_DPLL2_DELTA_LSB                                           7
+#define BB_DPLL2_DELTA_MASK                                          0x00001f80
+#define BB_DPLL2_DELTA_GET(x)                                        (((x) & BB_DPLL2_DELTA_MASK) >> BB_DPLL2_DELTA_LSB)
+#define BB_DPLL2_DELTA_SET(x)                                        (((x) << BB_DPLL2_DELTA_LSB) & BB_DPLL2_DELTA_MASK)
+#define BB_DPLL2_DELTA_RESET                                         0x1e // 30
+#define BB_DPLL2_TESTINMSB_MSB                                       6
+#define BB_DPLL2_TESTINMSB_LSB                                       0
+#define BB_DPLL2_TESTINMSB_MASK                                      0x0000007f
+#define BB_DPLL2_TESTINMSB_GET(x)                                    (((x) & BB_DPLL2_TESTINMSB_MASK) >> BB_DPLL2_TESTINMSB_LSB)
+#define BB_DPLL2_TESTINMSB_SET(x)                                    (((x) << BB_DPLL2_TESTINMSB_LSB) & BB_DPLL2_TESTINMSB_MASK)
+#define BB_DPLL2_TESTINMSB_RESET                                     0x0 // 0
+#define BB_DPLL2_ADDRESS                                             0x18116184
+
+#define PCIe_DPLL2_RANGE_MSB                                         31
+#define PCIe_DPLL2_RANGE_LSB                                         31
+#define PCIe_DPLL2_RANGE_MASK                                        0x80000000
+#define PCIe_DPLL2_RANGE_GET(x)                                      (((x) & PCIe_DPLL2_RANGE_MASK) >> PCIe_DPLL2_RANGE_LSB)
+#define PCIe_DPLL2_RANGE_SET(x)                                      (((x) << PCIe_DPLL2_RANGE_LSB) & PCIe_DPLL2_RANGE_MASK)
+#define PCIe_DPLL2_RANGE_RESET                                       0x0 // 0
+#define PCIe_DPLL2_LOCAL_PLL_MSB                                     30
+#define PCIe_DPLL2_LOCAL_PLL_LSB                                     30
+#define PCIe_DPLL2_LOCAL_PLL_MASK                                    0x40000000
+#define PCIe_DPLL2_LOCAL_PLL_GET(x)                                  (((x) & PCIe_DPLL2_LOCAL_PLL_MASK) >> PCIe_DPLL2_LOCAL_PLL_LSB)
+#define PCIe_DPLL2_LOCAL_PLL_SET(x)                                  (((x) << PCIe_DPLL2_LOCAL_PLL_LSB) & PCIe_DPLL2_LOCAL_PLL_MASK)
+#define PCIe_DPLL2_LOCAL_PLL_RESET                                   0x0 // 0
+#define PCIe_DPLL2_KI_MSB                                            29
+#define PCIe_DPLL2_KI_LSB                                            26
+#define PCIe_DPLL2_KI_MASK                                           0x3c000000
+#define PCIe_DPLL2_KI_GET(x)                                         (((x) & PCIe_DPLL2_KI_MASK) >> PCIe_DPLL2_KI_LSB)
+#define PCIe_DPLL2_KI_SET(x)                                         (((x) << PCIe_DPLL2_KI_LSB) & PCIe_DPLL2_KI_MASK)
+#define PCIe_DPLL2_KI_RESET                                          0x6 // 6
+#define PCIe_DPLL2_KD_MSB                                            25
+#define PCIe_DPLL2_KD_LSB                                            19
+#define PCIe_DPLL2_KD_MASK                                           0x03f80000
+#define PCIe_DPLL2_KD_GET(x)                                         (((x) & PCIe_DPLL2_KD_MASK) >> PCIe_DPLL2_KD_LSB)
+#define PCIe_DPLL2_KD_SET(x)                                         (((x) << PCIe_DPLL2_KD_LSB) & PCIe_DPLL2_KD_MASK)
+#define PCIe_DPLL2_KD_RESET                                          0x7f // 127
+#define PCIe_DPLL2_EN_NEGTRIG_MSB                                    18
+#define PCIe_DPLL2_EN_NEGTRIG_LSB                                    18
+#define PCIe_DPLL2_EN_NEGTRIG_MASK                                   0x00040000
+#define PCIe_DPLL2_EN_NEGTRIG_GET(x)                                 (((x) & PCIe_DPLL2_EN_NEGTRIG_MASK) >> PCIe_DPLL2_EN_NEGTRIG_LSB)
+#define PCIe_DPLL2_EN_NEGTRIG_SET(x)                                 (((x) << PCIe_DPLL2_EN_NEGTRIG_LSB) & PCIe_DPLL2_EN_NEGTRIG_MASK)
+#define PCIe_DPLL2_EN_NEGTRIG_RESET                                  0x0 // 0
+#define PCIe_DPLL2_SEL_1SDM_MSB                                      17
+#define PCIe_DPLL2_SEL_1SDM_LSB                                      17
+#define PCIe_DPLL2_SEL_1SDM_MASK                                     0x00020000
+#define PCIe_DPLL2_SEL_1SDM_GET(x)                                   (((x) & PCIe_DPLL2_SEL_1SDM_MASK) >> PCIe_DPLL2_SEL_1SDM_LSB)
+#define PCIe_DPLL2_SEL_1SDM_SET(x)                                   (((x) << PCIe_DPLL2_SEL_1SDM_LSB) & PCIe_DPLL2_SEL_1SDM_MASK)
+#define PCIe_DPLL2_SEL_1SDM_RESET                                    0x0 // 0
+#define PCIe_DPLL2_PLL_PWD_MSB                                       16
+#define PCIe_DPLL2_PLL_PWD_LSB                                       16
+#define PCIe_DPLL2_PLL_PWD_MASK                                      0x00010000
+#define PCIe_DPLL2_PLL_PWD_GET(x)                                    (((x) & PCIe_DPLL2_PLL_PWD_MASK) >> PCIe_DPLL2_PLL_PWD_LSB)
+#define PCIe_DPLL2_PLL_PWD_SET(x)                                    (((x) << PCIe_DPLL2_PLL_PWD_LSB) & PCIe_DPLL2_PLL_PWD_MASK)
+#define PCIe_DPLL2_PLL_PWD_RESET                                     0x1 // 1
+#define PCIe_DPLL2_OUTDIV_MSB                                        15
+#define PCIe_DPLL2_OUTDIV_LSB                                        13
+#define PCIe_DPLL2_OUTDIV_MASK                                       0x0000e000
+#define PCIe_DPLL2_OUTDIV_GET(x)                                     (((x) & PCIe_DPLL2_OUTDIV_MASK) >> PCIe_DPLL2_OUTDIV_LSB)
+#define PCIe_DPLL2_OUTDIV_SET(x)                                     (((x) << PCIe_DPLL2_OUTDIV_LSB) & PCIe_DPLL2_OUTDIV_MASK)
+#define PCIe_DPLL2_OUTDIV_RESET                                      0x0 // 0
+#define PCIe_DPLL2_DELTA_MSB                                         12
+#define PCIe_DPLL2_DELTA_LSB                                         7
+#define PCIe_DPLL2_DELTA_MASK                                        0x00001f80
+#define PCIe_DPLL2_DELTA_GET(x)                                      (((x) & PCIe_DPLL2_DELTA_MASK) >> PCIe_DPLL2_DELTA_LSB)
+#define PCIe_DPLL2_DELTA_SET(x)                                      (((x) << PCIe_DPLL2_DELTA_LSB) & PCIe_DPLL2_DELTA_MASK)
+#define PCIe_DPLL2_DELTA_RESET                                       0x1e // 30
+#define PCIe_DPLL2_TESTINMSB_MSB                                     6
+#define PCIe_DPLL2_TESTINMSB_LSB                                     0
+#define PCIe_DPLL2_TESTINMSB_MASK                                    0x0000007f
+#define PCIe_DPLL2_TESTINMSB_GET(x)                                  (((x) & PCIe_DPLL2_TESTINMSB_MASK) >> PCIe_DPLL2_TESTINMSB_LSB)
+#define PCIe_DPLL2_TESTINMSB_SET(x)                                  (((x) << PCIe_DPLL2_TESTINMSB_LSB) & PCIe_DPLL2_TESTINMSB_MASK)
+#define PCIe_DPLL2_TESTINMSB_RESET                                   0x0 // 0
+#define PCIe_DPLL2_ADDRESS                                           0x18116c84
+
+#define DDR_DPLL2_RANGE_MSB                                          31
+#define DDR_DPLL2_RANGE_LSB                                          31
+#define DDR_DPLL2_RANGE_MASK                                         0x80000000
+#define DDR_DPLL2_RANGE_GET(x)                                       (((x) & DDR_DPLL2_RANGE_MASK) >> DDR_DPLL2_RANGE_LSB)
+#define DDR_DPLL2_RANGE_SET(x)                                       (((x) << DDR_DPLL2_RANGE_LSB) & DDR_DPLL2_RANGE_MASK)
+#define DDR_DPLL2_RANGE_RESET                                        0x0 // 0
+#define DDR_DPLL2_LOCAL_PLL_MSB                                      30
+#define DDR_DPLL2_LOCAL_PLL_LSB                                      30
+#define DDR_DPLL2_LOCAL_PLL_MASK                                     0x40000000
+#define DDR_DPLL2_LOCAL_PLL_GET(x)                                   (((x) & DDR_DPLL2_LOCAL_PLL_MASK) >> DDR_DPLL2_LOCAL_PLL_LSB)
+#define DDR_DPLL2_LOCAL_PLL_SET(x)                                   (((x) << DDR_DPLL2_LOCAL_PLL_LSB) & DDR_DPLL2_LOCAL_PLL_MASK)
+#define DDR_DPLL2_LOCAL_PLL_RESET                                    0x0 // 0
+#define DDR_DPLL2_KI_MSB                                             29
+#define DDR_DPLL2_KI_LSB                                             26
+#define DDR_DPLL2_KI_MASK                                            0x3c000000
+#define DDR_DPLL2_KI_GET(x)                                          (((x) & DDR_DPLL2_KI_MASK) >> DDR_DPLL2_KI_LSB)
+#define DDR_DPLL2_KI_SET(x)                                          (((x) << DDR_DPLL2_KI_LSB) & DDR_DPLL2_KI_MASK)
+#define DDR_DPLL2_KI_RESET                                           0x6 // 6
+#define DDR_DPLL2_KD_MSB                                             25
+#define DDR_DPLL2_KD_LSB                                             19
+#define DDR_DPLL2_KD_MASK                                            0x03f80000
+#define DDR_DPLL2_KD_GET(x)                                          (((x) & DDR_DPLL2_KD_MASK) >> DDR_DPLL2_KD_LSB)
+#define DDR_DPLL2_KD_SET(x)                                          (((x) << DDR_DPLL2_KD_LSB) & DDR_DPLL2_KD_MASK)
+#define DDR_DPLL2_KD_RESET                                           0x7f // 127
+#define DDR_DPLL2_EN_NEGTRIG_MSB                                     18
+#define DDR_DPLL2_EN_NEGTRIG_LSB                                     18
+#define DDR_DPLL2_EN_NEGTRIG_MASK                                    0x00040000
+#define DDR_DPLL2_EN_NEGTRIG_GET(x)                                  (((x) & DDR_DPLL2_EN_NEGTRIG_MASK) >> DDR_DPLL2_EN_NEGTRIG_LSB)
+#define DDR_DPLL2_EN_NEGTRIG_SET(x)                                  (((x) << DDR_DPLL2_EN_NEGTRIG_LSB) & DDR_DPLL2_EN_NEGTRIG_MASK)
+#define DDR_DPLL2_EN_NEGTRIG_RESET                                   0x0 // 0
+#define DDR_DPLL2_SEL_1SDM_MSB                                       17
+#define DDR_DPLL2_SEL_1SDM_LSB                                       17
+#define DDR_DPLL2_SEL_1SDM_MASK                                      0x00020000
+#define DDR_DPLL2_SEL_1SDM_GET(x)                                    (((x) & DDR_DPLL2_SEL_1SDM_MASK) >> DDR_DPLL2_SEL_1SDM_LSB)
+#define DDR_DPLL2_SEL_1SDM_SET(x)                                    (((x) << DDR_DPLL2_SEL_1SDM_LSB) & DDR_DPLL2_SEL_1SDM_MASK)
+#define DDR_DPLL2_SEL_1SDM_RESET                                     0x0 // 0
+#define DDR_DPLL2_PLL_PWD_MSB                                        16
+#define DDR_DPLL2_PLL_PWD_LSB                                        16
+#define DDR_DPLL2_PLL_PWD_MASK                                       0x00010000
+#define DDR_DPLL2_PLL_PWD_GET(x)                                     (((x) & DDR_DPLL2_PLL_PWD_MASK) >> DDR_DPLL2_PLL_PWD_LSB)
+#define DDR_DPLL2_PLL_PWD_SET(x)                                     (((x) << DDR_DPLL2_PLL_PWD_LSB) & DDR_DPLL2_PLL_PWD_MASK)
+#define DDR_DPLL2_PLL_PWD_RESET                                      0x1 // 1
+#define DDR_DPLL2_OUTDIV_MSB                                         15
+#define DDR_DPLL2_OUTDIV_LSB                                         13
+#define DDR_DPLL2_OUTDIV_MASK                                        0x0000e000
+#define DDR_DPLL2_OUTDIV_GET(x)                                      (((x) & DDR_DPLL2_OUTDIV_MASK) >> DDR_DPLL2_OUTDIV_LSB)
+#define DDR_DPLL2_OUTDIV_SET(x)                                      (((x) << DDR_DPLL2_OUTDIV_LSB) & DDR_DPLL2_OUTDIV_MASK)
+#define DDR_DPLL2_OUTDIV_RESET                                       0x0 // 0
+#define DDR_DPLL2_DELTA_MSB                                          12
+#define DDR_DPLL2_DELTA_LSB                                          7
+#define DDR_DPLL2_DELTA_MASK                                         0x00001f80
+#define DDR_DPLL2_DELTA_GET(x)                                       (((x) & DDR_DPLL2_DELTA_MASK) >> DDR_DPLL2_DELTA_LSB)
+#define DDR_DPLL2_DELTA_SET(x)                                       (((x) << DDR_DPLL2_DELTA_LSB) & DDR_DPLL2_DELTA_MASK)
+#define DDR_DPLL2_DELTA_RESET                                        0x1e // 30
+#define DDR_DPLL2_TESTINMSB_MSB                                      6
+#define DDR_DPLL2_TESTINMSB_LSB                                      0
+#define DDR_DPLL2_TESTINMSB_MASK                                     0x0000007f
+#define DDR_DPLL2_TESTINMSB_GET(x)                                   (((x) & DDR_DPLL2_TESTINMSB_MASK) >> DDR_DPLL2_TESTINMSB_LSB)
+#define DDR_DPLL2_TESTINMSB_SET(x)                                   (((x) << DDR_DPLL2_TESTINMSB_LSB) & DDR_DPLL2_TESTINMSB_MASK)
+#define DDR_DPLL2_TESTINMSB_RESET                                    0x0 // 0
+#define DDR_DPLL2_ADDRESS                                            0x18116ec4
+
+#define CPU_DPLL2_RANGE_MSB                                          31
+#define CPU_DPLL2_RANGE_LSB                                          31
+#define CPU_DPLL2_RANGE_MASK                                         0x80000000
+#define CPU_DPLL2_RANGE_GET(x)                                       (((x) & CPU_DPLL2_RANGE_MASK) >> CPU_DPLL2_RANGE_LSB)
+#define CPU_DPLL2_RANGE_SET(x)                                       (((x) << CPU_DPLL2_RANGE_LSB) & CPU_DPLL2_RANGE_MASK)
+#define CPU_DPLL2_RANGE_RESET                                        0x0 // 0
+#define CPU_DPLL2_LOCAL_PLL_MSB                                      30
+#define CPU_DPLL2_LOCAL_PLL_LSB                                      30
+#define CPU_DPLL2_LOCAL_PLL_MASK                                     0x40000000
+#define CPU_DPLL2_LOCAL_PLL_GET(x)                                   (((x) & CPU_DPLL2_LOCAL_PLL_MASK) >> CPU_DPLL2_LOCAL_PLL_LSB)
+#define CPU_DPLL2_LOCAL_PLL_SET(x)                                   (((x) << CPU_DPLL2_LOCAL_PLL_LSB) & CPU_DPLL2_LOCAL_PLL_MASK)
+#define CPU_DPLL2_LOCAL_PLL_RESET                                    0x0 // 0
+#define CPU_DPLL2_KI_MSB                                             29
+#define CPU_DPLL2_KI_LSB                                             26
+#define CPU_DPLL2_KI_MASK                                            0x3c000000
+#define CPU_DPLL2_KI_GET(x)                                          (((x) & CPU_DPLL2_KI_MASK) >> CPU_DPLL2_KI_LSB)
+#define CPU_DPLL2_KI_SET(x)                                          (((x) << CPU_DPLL2_KI_LSB) & CPU_DPLL2_KI_MASK)
+#define CPU_DPLL2_KI_RESET                                           0x6 // 6
+#define CPU_DPLL2_KD_MSB                                             25
+#define CPU_DPLL2_KD_LSB                                             19
+#define CPU_DPLL2_KD_MASK                                            0x03f80000
+#define CPU_DPLL2_KD_GET(x)                                          (((x) & CPU_DPLL2_KD_MASK) >> CPU_DPLL2_KD_LSB)
+#define CPU_DPLL2_KD_SET(x)                                          (((x) << CPU_DPLL2_KD_LSB) & CPU_DPLL2_KD_MASK)
+#define CPU_DPLL2_KD_RESET                                           0x7f // 127
+#define CPU_DPLL2_EN_NEGTRIG_MSB                                     18
+#define CPU_DPLL2_EN_NEGTRIG_LSB                                     18
+#define CPU_DPLL2_EN_NEGTRIG_MASK                                    0x00040000
+#define CPU_DPLL2_EN_NEGTRIG_GET(x)                                  (((x) & CPU_DPLL2_EN_NEGTRIG_MASK) >> CPU_DPLL2_EN_NEGTRIG_LSB)
+#define CPU_DPLL2_EN_NEGTRIG_SET(x)                                  (((x) << CPU_DPLL2_EN_NEGTRIG_LSB) & CPU_DPLL2_EN_NEGTRIG_MASK)
+#define CPU_DPLL2_EN_NEGTRIG_RESET                                   0x0 // 0
+#define CPU_DPLL2_SEL_1SDM_MSB                                       17
+#define CPU_DPLL2_SEL_1SDM_LSB                                       17
+#define CPU_DPLL2_SEL_1SDM_MASK                                      0x00020000
+#define CPU_DPLL2_SEL_1SDM_GET(x)                                    (((x) & CPU_DPLL2_SEL_1SDM_MASK) >> CPU_DPLL2_SEL_1SDM_LSB)
+#define CPU_DPLL2_SEL_1SDM_SET(x)                                    (((x) << CPU_DPLL2_SEL_1SDM_LSB) & CPU_DPLL2_SEL_1SDM_MASK)
+#define CPU_DPLL2_SEL_1SDM_RESET                                     0x0 // 0
+#define CPU_DPLL2_PLL_PWD_MSB                                        16
+#define CPU_DPLL2_PLL_PWD_LSB                                        16
+#define CPU_DPLL2_PLL_PWD_MASK                                       0x00010000
+#define CPU_DPLL2_PLL_PWD_GET(x)                                     (((x) & CPU_DPLL2_PLL_PWD_MASK) >> CPU_DPLL2_PLL_PWD_LSB)
+#define CPU_DPLL2_PLL_PWD_SET(x)                                     (((x) << CPU_DPLL2_PLL_PWD_LSB) & CPU_DPLL2_PLL_PWD_MASK)
+#define CPU_DPLL2_PLL_PWD_RESET                                      0x1 // 1
+#define CPU_DPLL2_OUTDIV_MSB                                         15
+#define CPU_DPLL2_OUTDIV_LSB                                         13
+#define CPU_DPLL2_OUTDIV_MASK                                        0x0000e000
+#define CPU_DPLL2_OUTDIV_GET(x)                                      (((x) & CPU_DPLL2_OUTDIV_MASK) >> CPU_DPLL2_OUTDIV_LSB)
+#define CPU_DPLL2_OUTDIV_SET(x)                                      (((x) << CPU_DPLL2_OUTDIV_LSB) & CPU_DPLL2_OUTDIV_MASK)
+#define CPU_DPLL2_OUTDIV_RESET                                       0x0 // 0
+#define CPU_DPLL2_DELTA_MSB                                          12
+#define CPU_DPLL2_DELTA_LSB                                          7
+#define CPU_DPLL2_DELTA_MASK                                         0x00001f80
+#define CPU_DPLL2_DELTA_GET(x)                                       (((x) & CPU_DPLL2_DELTA_MASK) >> CPU_DPLL2_DELTA_LSB)
+#define CPU_DPLL2_DELTA_SET(x)                                       (((x) << CPU_DPLL2_DELTA_LSB) & CPU_DPLL2_DELTA_MASK)
+#define CPU_DPLL2_DELTA_RESET                                        0x1e // 30
+#define CPU_DPLL2_TESTINMSB_MSB                                      6
+#define CPU_DPLL2_TESTINMSB_LSB                                      0
+#define CPU_DPLL2_TESTINMSB_MASK                                     0x0000007f
+#define CPU_DPLL2_TESTINMSB_GET(x)                                   (((x) & CPU_DPLL2_TESTINMSB_MASK) >> CPU_DPLL2_TESTINMSB_LSB)
+#define CPU_DPLL2_TESTINMSB_SET(x)                                   (((x) << CPU_DPLL2_TESTINMSB_LSB) & CPU_DPLL2_TESTINMSB_MASK)
+#define CPU_DPLL2_TESTINMSB_RESET                                    0x0 // 0
+#define CPU_DPLL2_ADDRESS                                            0x18116f04
+
+#define DDR_RD_DATA_THIS_CYCLE_ADDRESS                               0x18000018
+
+#define TAP_CONTROL_0_ADDRESS                                        0x1800001c
+#define TAP_CONTROL_1_ADDRESS                                        0x18000020
+#define TAP_CONTROL_2_ADDRESS                                        0x18000024
+#define TAP_CONTROL_3_ADDRESS                                        0x18000028
+
+#define DDR_BURST_ADDRESS                                            0x180000c4
+#define DDR_BURST2_ADDRESS                                           0x180000c8
+#define DDR_AHB_MASTER_TIMEOUT_MAX_ADDRESS                           0x180000cc
+
+#define PMU1_ADDRESS                                                 0x18116cc0
+
+#define PMU2_SWREGMSB_MSB                                            31
+#define PMU2_SWREGMSB_LSB                                            22
+#define PMU2_SWREGMSB_MASK                                           0xffc00000
+#define PMU2_SWREGMSB_GET(x)                                         (((x) & PMU2_SWREGMSB_MASK) >> PMU2_SWREGMSB_LSB)
+#define PMU2_SWREGMSB_SET(x)                                         (((x) << PMU2_SWREGMSB_LSB) & PMU2_SWREGMSB_MASK)
+#define PMU2_SWREGMSB_RESET                                          0x0 // 0
+#define PMU2_PGM_MSB                                                 21
+#define PMU2_PGM_LSB                                                 21
+#define PMU2_PGM_MASK                                                0x00200000
+#define PMU2_PGM_GET(x)                                              (((x) & PMU2_PGM_MASK) >> PMU2_PGM_LSB)
+#define PMU2_PGM_SET(x)                                              (((x) << PMU2_PGM_LSB) & PMU2_PGM_MASK)
+#define PMU2_PGM_RESET                                               0x0 // 0
+#define PMU2_LDO_TUNE_MSB                                            20
+#define PMU2_LDO_TUNE_LSB                                            19
+#define PMU2_LDO_TUNE_MASK                                           0x00180000
+#define PMU2_LDO_TUNE_GET(x)                                         (((x) & PMU2_LDO_TUNE_MASK) >> PMU2_LDO_TUNE_LSB)
+#define PMU2_LDO_TUNE_SET(x)                                         (((x) << PMU2_LDO_TUNE_LSB) & PMU2_LDO_TUNE_MASK)
+#define PMU2_LDO_TUNE_RESET                                          0x0 // 0
+#define PMU2_PWDLDO_DDR_MSB                                          18
+#define PMU2_PWDLDO_DDR_LSB                                          18
+#define PMU2_PWDLDO_DDR_MASK                                         0x00040000
+#define PMU2_PWDLDO_DDR_GET(x)                                       (((x) & PMU2_PWDLDO_DDR_MASK) >> PMU2_PWDLDO_DDR_LSB)
+#define PMU2_PWDLDO_DDR_SET(x)                                       (((x) << PMU2_PWDLDO_DDR_LSB) & PMU2_PWDLDO_DDR_MASK)
+#define PMU2_PWDLDO_DDR_RESET                                        0x0 // 0
+#define PMU2_LPOPWD_MSB                                              17
+#define PMU2_LPOPWD_LSB                                              17
+#define PMU2_LPOPWD_MASK                                             0x00020000
+#define PMU2_LPOPWD_GET(x)                                           (((x) & PMU2_LPOPWD_MASK) >> PMU2_LPOPWD_LSB)
+#define PMU2_LPOPWD_SET(x)                                           (((x) << PMU2_LPOPWD_LSB) & PMU2_LPOPWD_MASK)
+#define PMU2_LPOPWD_RESET                                            0x0 // 0
+#define PMU2_SPARE_MSB                                               16
+#define PMU2_SPARE_LSB                                               0
+#define PMU2_SPARE_MASK                                              0x0001ffff
+#define PMU2_SPARE_GET(x)                                            (((x) & PMU2_SPARE_MASK) >> PMU2_SPARE_LSB)
+#define PMU2_SPARE_SET(x)                                            (((x) << PMU2_SPARE_LSB) & PMU2_SPARE_MASK)
+#define PMU2_SPARE_RESET                                             0x0 // 0
+#define PMU2_ADDRESS                                                 0x18116cc4
+
+
+
+
+
+
+#define CPU_DDR_CLOCK_CONTROL_SPARE_MSB                              31
+#define CPU_DDR_CLOCK_CONTROL_SPARE_LSB                              25
+#define CPU_DDR_CLOCK_CONTROL_SPARE_MASK                             0xfe000000
+#define CPU_DDR_CLOCK_CONTROL_SPARE_GET(x)                           (((x) & CPU_DDR_CLOCK_CONTROL_SPARE_MASK) >> CPU_DDR_CLOCK_CONTROL_SPARE_LSB)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_SET(x)                           (((x) << CPU_DDR_CLOCK_CONTROL_SPARE_LSB) & CPU_DDR_CLOCK_CONTROL_SPARE_MASK)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_RESET                            0
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MSB                 24
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB                 24
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK                0x01000000
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_GET(x)              (((x) & CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(x)              (((x) << CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB) & CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_RESET               1
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MSB            23
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB            23
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK           0x00800000
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_GET(x)         (((x) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_SET(x)         (((x) << CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_RESET          0
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MSB               22
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB               22
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK              0x00400000
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_GET(x)            (((x) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_SET(x)            (((x) << CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_RESET             0x0
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_MSB            21
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_LSB            21
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_MASK           0x00200000
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_GET(x)         (((x) & CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(x)         (((x) << CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_RESET          0x0
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_MSB            20
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_LSB            20
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_MASK           0x00100000
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_GET(x)         (((x) & CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(x)         (((x) << CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_RESET          0x0 // 0
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MSB                       19
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB                       15
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK                      0x000f8000
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MSB                       14
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB                       10
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK                      0x00007c00
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MSB                       9
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB                       5
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK                      0x000003e0
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MSB                     4
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB                     4
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK                    0x00000010
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_RESET                   1
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MSB                     3
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB                     3
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK                    0x00000008
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_RESET                   1
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MSB                     2
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB                     2
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK                    0x00000004
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_RESET                   1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MSB                       1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB                       1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK                      0x00000002
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK) >> CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB)
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB) & CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK)
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MSB                       0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB                       0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK                      0x00000001
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK) >> CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB) & CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_ADDRESS                                0x18050008
+
+#define PCIE_PLL_CONFIG_UPDATING_MSB                                 31
+#define PCIE_PLL_CONFIG_UPDATING_LSB                                 31
+#define PCIE_PLL_CONFIG_UPDATING_MASK                                0x80000000
+#define PCIE_PLL_CONFIG_UPDATING_GET(x)                              (((x) & PCIE_PLL_CONFIG_UPDATING_MASK) >> PCIE_PLL_CONFIG_UPDATING_LSB)
+#define PCIE_PLL_CONFIG_UPDATING_SET(x)                              (((x) << PCIE_PLL_CONFIG_UPDATING_LSB) & PCIE_PLL_CONFIG_UPDATING_MASK)
+#define PCIE_PLL_CONFIG_UPDATING_RESET                               0x0 // 0
+#define PCIE_PLL_CONFIG_PLLPWD_MSB                                   30
+#define PCIE_PLL_CONFIG_PLLPWD_LSB                                   30
+#define PCIE_PLL_CONFIG_PLLPWD_MASK                                  0x40000000
+#define PCIE_PLL_CONFIG_PLLPWD_GET(x)                                (((x) & PCIE_PLL_CONFIG_PLLPWD_MASK) >> PCIE_PLL_CONFIG_PLLPWD_LSB)
+#define PCIE_PLL_CONFIG_PLLPWD_SET(x)                                (((x) << PCIE_PLL_CONFIG_PLLPWD_LSB) & PCIE_PLL_CONFIG_PLLPWD_MASK)
+#define PCIE_PLL_CONFIG_PLLPWD_RESET                                 0x1 // 1
+#define PCIE_PLL_CONFIG_BYPASS_MSB                                   16
+#define PCIE_PLL_CONFIG_BYPASS_LSB                                   16
+#define PCIE_PLL_CONFIG_BYPASS_MASK                                  0x00010000
+#define PCIE_PLL_CONFIG_BYPASS_GET(x)                                (((x) & PCIE_PLL_CONFIG_BYPASS_MASK) >> PCIE_PLL_CONFIG_BYPASS_LSB)
+#define PCIE_PLL_CONFIG_BYPASS_SET(x)                                (((x) << PCIE_PLL_CONFIG_BYPASS_LSB) & PCIE_PLL_CONFIG_BYPASS_MASK)
+#define PCIE_PLL_CONFIG_BYPASS_RESET                                 0x1 // 1
+#define PCIE_PLL_CONFIG_REFDIV_MSB                                   14
+#define PCIE_PLL_CONFIG_REFDIV_LSB                                   10
+#define PCIE_PLL_CONFIG_REFDIV_MASK                                  0x00007c00
+#define PCIE_PLL_CONFIG_REFDIV_GET(x)                                (((x) & PCIE_PLL_CONFIG_REFDIV_MASK) >> PCIE_PLL_CONFIG_REFDIV_LSB)
+#define PCIE_PLL_CONFIG_REFDIV_SET(x)                                (((x) << PCIE_PLL_CONFIG_REFDIV_LSB) & PCIE_PLL_CONFIG_REFDIV_MASK)
+#define PCIE_PLL_CONFIG_REFDIV_RESET                                 0x1 // 1
+#define PCIE_PLL_CONFIG_ADDRESS                                      0x1805000c
+
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MSB                        31
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB                        31
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK                       0x80000000
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_GET(x)                     (((x) & PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK) >> PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_SET(x)                     (((x) << PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB) & PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_RESET                      0x1 // 1
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MSB                          30
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB                          30
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK                         0x40000000
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_GET(x)                       (((x) & PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK) >> PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_SET(x)                       (((x) << PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB) & PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_RESET                        0x1 // 1
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MSB                      20
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB                      15
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK                     0x001f8000
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_GET(x)                   (((x) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK) >> PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_SET(x)                   (((x) << PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_RESET                    0x13 // 19
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MSB                     14
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB                     1
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK                    0x00007ffe
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_GET(x)                  (((x) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK) >> PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_SET(x)                  (((x) << PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_RESET                   0x3fff // 16383
+#define PCIE_PLL_DITHER_DIV_MAX_ADDRESS                              0x18050010
+
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MSB                      20
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB                      15
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK                     0x001f8000
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_GET(x)                   (((x) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK) >> PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_SET(x)                   (((x) << PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_RESET                    0x13 // 19
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MSB                     14
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB                     1
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK                    0x00007ffe
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_GET(x)                  (((x) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK) >> PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_SET(x)                  (((x) << PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_RESET                   0x399d // 14749
+#define PCIE_PLL_DITHER_DIV_MIN_ADDRESS                              0x18050014
+
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_MSB                          31
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB                          28
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK                         0xf0000000
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_GET(x)                       (((x) & PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK) >> PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_SET(x)                       (((x) << PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB) & PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_RESET                        0x0 // 0
+#define PCIE_PLL_DITHER_STEP_STEP_INT_MSB                            24
+#define PCIE_PLL_DITHER_STEP_STEP_INT_LSB                            15
+#define PCIE_PLL_DITHER_STEP_STEP_INT_MASK                           0x01ff8000
+#define PCIE_PLL_DITHER_STEP_STEP_INT_GET(x)                         (((x) & PCIE_PLL_DITHER_STEP_STEP_INT_MASK) >> PCIE_PLL_DITHER_STEP_STEP_INT_LSB)
+#define PCIE_PLL_DITHER_STEP_STEP_INT_SET(x)                         (((x) << PCIE_PLL_DITHER_STEP_STEP_INT_LSB) & PCIE_PLL_DITHER_STEP_STEP_INT_MASK)
+#define PCIE_PLL_DITHER_STEP_STEP_INT_RESET                          0x0 // 0
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_MSB                           14
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB                           1
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK                          0x00007ffe
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_GET(x)                        (((x) & PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK) >> PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB)
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_SET(x)                        (((x) << PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB) & PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK)
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_RESET                         0xa // 10
+#define PCIE_PLL_DITHER_STEP_ADDRESS                                 0x18050018
+
+#define LDO_POWER_CONTROL_PKG_SEL_MSB                                5
+#define LDO_POWER_CONTROL_PKG_SEL_LSB                                5
+#define LDO_POWER_CONTROL_PKG_SEL_MASK                               0x00000020
+#define LDO_POWER_CONTROL_PKG_SEL_GET(x)                             (((x) & LDO_POWER_CONTROL_PKG_SEL_MASK) >> LDO_POWER_CONTROL_PKG_SEL_LSB)
+#define LDO_POWER_CONTROL_PKG_SEL_SET(x)                             (((x) << LDO_POWER_CONTROL_PKG_SEL_LSB) & LDO_POWER_CONTROL_PKG_SEL_MASK)
+#define LDO_POWER_CONTROL_PKG_SEL_RESET                              0x0 // 0
+#define LDO_POWER_CONTROL_PWDLDO_CPU_MSB                             4
+#define LDO_POWER_CONTROL_PWDLDO_CPU_LSB                             4
+#define LDO_POWER_CONTROL_PWDLDO_CPU_MASK                            0x00000010
+#define LDO_POWER_CONTROL_PWDLDO_CPU_GET(x)                          (((x) & LDO_POWER_CONTROL_PWDLDO_CPU_MASK) >> LDO_POWER_CONTROL_PWDLDO_CPU_LSB)
+#define LDO_POWER_CONTROL_PWDLDO_CPU_SET(x)                          (((x) << LDO_POWER_CONTROL_PWDLDO_CPU_LSB) & LDO_POWER_CONTROL_PWDLDO_CPU_MASK)
+#define LDO_POWER_CONTROL_PWDLDO_CPU_RESET                           0x0 // 0
+#define LDO_POWER_CONTROL_PWDLDO_DDR_MSB                             3
+#define LDO_POWER_CONTROL_PWDLDO_DDR_LSB                             3
+#define LDO_POWER_CONTROL_PWDLDO_DDR_MASK                            0x00000008
+#define LDO_POWER_CONTROL_PWDLDO_DDR_GET(x)                          (((x) & LDO_POWER_CONTROL_PWDLDO_DDR_MASK) >> LDO_POWER_CONTROL_PWDLDO_DDR_LSB)
+#define LDO_POWER_CONTROL_PWDLDO_DDR_SET(x)                          (((x) << LDO_POWER_CONTROL_PWDLDO_DDR_LSB) & LDO_POWER_CONTROL_PWDLDO_DDR_MASK)
+#define LDO_POWER_CONTROL_PWDLDO_DDR_RESET                           0x0 // 0
+#define LDO_POWER_CONTROL_CPU_REFSEL_MSB                             2
+#define LDO_POWER_CONTROL_CPU_REFSEL_LSB                             1
+#define LDO_POWER_CONTROL_CPU_REFSEL_MASK                            0x00000006
+#define LDO_POWER_CONTROL_CPU_REFSEL_GET(x)                          (((x) & LDO_POWER_CONTROL_CPU_REFSEL_MASK) >> LDO_POWER_CONTROL_CPU_REFSEL_LSB)
+#define LDO_POWER_CONTROL_CPU_REFSEL_SET(x)                          (((x) << LDO_POWER_CONTROL_CPU_REFSEL_LSB) & LDO_POWER_CONTROL_CPU_REFSEL_MASK)
+#define LDO_POWER_CONTROL_CPU_REFSEL_RESET                           0x3 // 3
+#define LDO_POWER_CONTROL_SELECT_DDR1_MSB                            0
+#define LDO_POWER_CONTROL_SELECT_DDR1_LSB                            0
+#define LDO_POWER_CONTROL_SELECT_DDR1_MASK                           0x00000001
+#define LDO_POWER_CONTROL_SELECT_DDR1_GET(x)                         (((x) & LDO_POWER_CONTROL_SELECT_DDR1_MASK) >> LDO_POWER_CONTROL_SELECT_DDR1_LSB)
+#define LDO_POWER_CONTROL_SELECT_DDR1_SET(x)                         (((x) << LDO_POWER_CONTROL_SELECT_DDR1_LSB) & LDO_POWER_CONTROL_SELECT_DDR1_MASK)
+#define LDO_POWER_CONTROL_SELECT_DDR1_RESET                          0x0 // 0
+#define LDO_POWER_CONTROL_ADDRESS                                    0x1805001c
+
+#define SWITCH_CLOCK_SPARE_SPARE_MSB                                 31
+#define SWITCH_CLOCK_SPARE_SPARE_LSB                                 16
+#define SWITCH_CLOCK_SPARE_SPARE_MASK                                0xffff0000
+#define SWITCH_CLOCK_SPARE_SPARE_GET(x)                              (((x) & SWITCH_CLOCK_SPARE_SPARE_MASK) >> SWITCH_CLOCK_SPARE_SPARE_LSB)
+#define SWITCH_CLOCK_SPARE_SPARE_SET(x)                              (((x) << SWITCH_CLOCK_SPARE_SPARE_LSB) & SWITCH_CLOCK_SPARE_SPARE_MASK)
+#define SWITCH_CLOCK_SPARE_SPARE_RESET                               0x0 // 0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_MSB                       15
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_LSB                       15
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_MASK                      0x00008000
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_2_RESET                     0x0 // 0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_MSB                       14
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_LSB                       14
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_MASK                      0x00004000
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL1_1_RESET                     0x0 // 0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_MSB                       13
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_LSB                       13
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_MASK                      0x00002000
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_2_RESET                     0x0 // 0
+#define SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_MSB                         12
+#define SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_LSB                         12
+#define SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_MASK                        0x00001000
+#define SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_GET(x)                      (((x) & SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_SET(x)                      (((x) << SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_NANDF_CLK_SEL_RESET                       0x0 // 0
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MSB                   11
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB                   8
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK                  0x00000f00
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_GET(x)                (((x) & SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK) >> SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(x)                (((x) << SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB) & SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_RESET                 0x5 // 5
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MSB                         7
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB                         7
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK                        0x00000080
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_GET(x)                      (((x) & SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_SET(x)                      (((x) << SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_RESET                       0x0 // 0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_MSB                       6
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_LSB                       6
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_MASK                      0x00000040
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL0_1_RESET                     0x0 // 0
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_MSB                           5
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_LSB                           5
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_MASK                          0x00000020
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_GET(x)                        (((x) & SWITCH_CLOCK_SPARE_I2C_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_I2C_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_SET(x)                        (((x) << SWITCH_CLOCK_SPARE_I2C_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_I2C_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_I2C_CLK_SEL_RESET                         0x0 // 0
+#define SWITCH_CLOCK_SPARE_SPARE_0_MSB                               4
+#define SWITCH_CLOCK_SPARE_SPARE_0_LSB                               0
+#define SWITCH_CLOCK_SPARE_SPARE_0_MASK                              0x0000001f
+#define SWITCH_CLOCK_SPARE_SPARE_0_GET(x)                            (((x) & SWITCH_CLOCK_SPARE_SPARE_0_MASK) >> SWITCH_CLOCK_SPARE_SPARE_0_LSB)
+#define SWITCH_CLOCK_SPARE_SPARE_0_SET(x)                            (((x) << SWITCH_CLOCK_SPARE_SPARE_0_LSB) & SWITCH_CLOCK_SPARE_SPARE_0_MASK)
+#define SWITCH_CLOCK_SPARE_SPARE_0_RESET                             0x0 // 0
+#define SWITCH_CLOCK_SPARE_ADDRESS                                   0x18050020
+
+#define CURRENT_PCIE_PLL_DITHER_INT_MSB                              20
+#define CURRENT_PCIE_PLL_DITHER_INT_LSB                              15
+#define CURRENT_PCIE_PLL_DITHER_INT_MASK                             0x001f8000
+#define CURRENT_PCIE_PLL_DITHER_INT_GET(x)                           (((x) & CURRENT_PCIE_PLL_DITHER_INT_MASK) >> CURRENT_PCIE_PLL_DITHER_INT_LSB)
+#define CURRENT_PCIE_PLL_DITHER_INT_SET(x)                           (((x) << CURRENT_PCIE_PLL_DITHER_INT_LSB) & CURRENT_PCIE_PLL_DITHER_INT_MASK)
+#define CURRENT_PCIE_PLL_DITHER_INT_RESET                            0x1 // 1
+#define CURRENT_PCIE_PLL_DITHER_FRAC_MSB                             13
+#define CURRENT_PCIE_PLL_DITHER_FRAC_LSB                             0
+#define CURRENT_PCIE_PLL_DITHER_FRAC_MASK                            0x00003fff
+#define CURRENT_PCIE_PLL_DITHER_FRAC_GET(x)                          (((x) & CURRENT_PCIE_PLL_DITHER_FRAC_MASK) >> CURRENT_PCIE_PLL_DITHER_FRAC_LSB)
+#define CURRENT_PCIE_PLL_DITHER_FRAC_SET(x)                          (((x) << CURRENT_PCIE_PLL_DITHER_FRAC_LSB) & CURRENT_PCIE_PLL_DITHER_FRAC_MASK)
+#define CURRENT_PCIE_PLL_DITHER_FRAC_RESET                           0x0 // 0
+#define CURRENT_PCIE_PLL_DITHER_ADDRESS                              0x18050024
+
+#define ETH_XMII_TX_INVERT_MSB                                       31
+#define ETH_XMII_TX_INVERT_LSB                                       31
+#define ETH_XMII_TX_INVERT_MASK                                      0x80000000
+#define ETH_XMII_TX_INVERT_GET(x)                                    (((x) & ETH_XMII_TX_INVERT_MASK) >> ETH_XMII_TX_INVERT_LSB)
+#define ETH_XMII_TX_INVERT_SET(x)                                    (((x) << ETH_XMII_TX_INVERT_LSB) & ETH_XMII_TX_INVERT_MASK)
+#define ETH_XMII_TX_INVERT_RESET                                     0x0 // 0
+#define ETH_XMII_GIGE_QUAD_MSB                                       30
+#define ETH_XMII_GIGE_QUAD_LSB                                       30
+#define ETH_XMII_GIGE_QUAD_MASK                                      0x40000000
+#define ETH_XMII_GIGE_QUAD_GET(x)                                    (((x) & ETH_XMII_GIGE_QUAD_MASK) >> ETH_XMII_GIGE_QUAD_LSB)
+#define ETH_XMII_GIGE_QUAD_SET(x)                                    (((x) << ETH_XMII_GIGE_QUAD_LSB) & ETH_XMII_GIGE_QUAD_MASK)
+#define ETH_XMII_GIGE_QUAD_RESET                                     0x0 // 0
+#define ETH_XMII_RX_DELAY_MSB                                        29
+#define ETH_XMII_RX_DELAY_LSB                                        28
+#define ETH_XMII_RX_DELAY_MASK                                       0x30000000
+#define ETH_XMII_RX_DELAY_GET(x)                                     (((x) & ETH_XMII_RX_DELAY_MASK) >> ETH_XMII_RX_DELAY_LSB)
+#define ETH_XMII_RX_DELAY_SET(x)                                     (((x) << ETH_XMII_RX_DELAY_LSB) & ETH_XMII_RX_DELAY_MASK)
+#define ETH_XMII_RX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_TX_DELAY_MSB                                        27
+#define ETH_XMII_TX_DELAY_LSB                                        26
+#define ETH_XMII_TX_DELAY_MASK                                       0x0c000000
+#define ETH_XMII_TX_DELAY_GET(x)                                     (((x) & ETH_XMII_TX_DELAY_MASK) >> ETH_XMII_TX_DELAY_LSB)
+#define ETH_XMII_TX_DELAY_SET(x)                                     (((x) << ETH_XMII_TX_DELAY_LSB) & ETH_XMII_TX_DELAY_MASK)
+#define ETH_XMII_TX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_GIGE_MSB                                            25
+#define ETH_XMII_GIGE_LSB                                            25
+#define ETH_XMII_GIGE_MASK                                           0x02000000
+#define ETH_XMII_GIGE_GET(x)                                         (((x) & ETH_XMII_GIGE_MASK) >> ETH_XMII_GIGE_LSB)
+#define ETH_XMII_GIGE_SET(x)                                         (((x) << ETH_XMII_GIGE_LSB) & ETH_XMII_GIGE_MASK)
+#define ETH_XMII_GIGE_RESET                                          0x0 // 0
+#define ETH_XMII_OFFSET_PHASE_MSB                                    24
+#define ETH_XMII_OFFSET_PHASE_LSB                                    24
+#define ETH_XMII_OFFSET_PHASE_MASK                                   0x01000000
+#define ETH_XMII_OFFSET_PHASE_GET(x)                                 (((x) & ETH_XMII_OFFSET_PHASE_MASK) >> ETH_XMII_OFFSET_PHASE_LSB)
+#define ETH_XMII_OFFSET_PHASE_SET(x)                                 (((x) << ETH_XMII_OFFSET_PHASE_LSB) & ETH_XMII_OFFSET_PHASE_MASK)
+#define ETH_XMII_OFFSET_PHASE_RESET                                  0x0 // 0
+#define ETH_XMII_OFFSET_COUNT_MSB                                    23
+#define ETH_XMII_OFFSET_COUNT_LSB                                    16
+#define ETH_XMII_OFFSET_COUNT_MASK                                   0x00ff0000
+#define ETH_XMII_OFFSET_COUNT_GET(x)                                 (((x) & ETH_XMII_OFFSET_COUNT_MASK) >> ETH_XMII_OFFSET_COUNT_LSB)
+#define ETH_XMII_OFFSET_COUNT_SET(x)                                 (((x) << ETH_XMII_OFFSET_COUNT_LSB) & ETH_XMII_OFFSET_COUNT_MASK)
+#define ETH_XMII_OFFSET_COUNT_RESET                                  0x0 // 0
+#define ETH_XMII_PHASE1_COUNT_MSB                                    15
+#define ETH_XMII_PHASE1_COUNT_LSB                                    8
+#define ETH_XMII_PHASE1_COUNT_MASK                                   0x0000ff00
+#define ETH_XMII_PHASE1_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE1_COUNT_MASK) >> ETH_XMII_PHASE1_COUNT_LSB)
+#define ETH_XMII_PHASE1_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE1_COUNT_LSB) & ETH_XMII_PHASE1_COUNT_MASK)
+#define ETH_XMII_PHASE1_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_PHASE0_COUNT_MSB                                    7
+#define ETH_XMII_PHASE0_COUNT_LSB                                    0
+#define ETH_XMII_PHASE0_COUNT_MASK                                   0x000000ff
+#define ETH_XMII_PHASE0_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE0_COUNT_MASK) >> ETH_XMII_PHASE0_COUNT_LSB)
+#define ETH_XMII_PHASE0_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE0_COUNT_LSB) & ETH_XMII_PHASE0_COUNT_MASK)
+#define ETH_XMII_PHASE0_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_ADDRESS                                             0x18050028
+
+#define AUDIO_PLL_CONFIG_UPDATING_MSB                                31
+#define AUDIO_PLL_CONFIG_UPDATING_LSB                                31
+#define AUDIO_PLL_CONFIG_UPDATING_MASK                               0x80000000
+#define AUDIO_PLL_CONFIG_UPDATING_GET(x)                             (((x) & AUDIO_PLL_CONFIG_UPDATING_MASK) >> AUDIO_PLL_CONFIG_UPDATING_LSB)
+#define AUDIO_PLL_CONFIG_UPDATING_SET(x)                             (((x) << AUDIO_PLL_CONFIG_UPDATING_LSB) & AUDIO_PLL_CONFIG_UPDATING_MASK)
+#define AUDIO_PLL_CONFIG_UPDATING_RESET                              0x1 // 1
+#define AUDIO_PLL_CONFIG_EXT_DIV_MSB                                 14
+#define AUDIO_PLL_CONFIG_EXT_DIV_LSB                                 12
+#define AUDIO_PLL_CONFIG_EXT_DIV_MASK                                0x00007000
+#define AUDIO_PLL_CONFIG_EXT_DIV_GET(x)                              (((x) & AUDIO_PLL_CONFIG_EXT_DIV_MASK) >> AUDIO_PLL_CONFIG_EXT_DIV_LSB)
+#define AUDIO_PLL_CONFIG_EXT_DIV_SET(x)                              (((x) << AUDIO_PLL_CONFIG_EXT_DIV_LSB) & AUDIO_PLL_CONFIG_EXT_DIV_MASK)
+#define AUDIO_PLL_CONFIG_EXT_DIV_RESET                               0x1 // 1
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_MSB                              9
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_LSB                              7
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_MASK                             0x00000380
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_GET(x)                           (((x) & AUDIO_PLL_CONFIG_POSTPLLDIV_MASK) >> AUDIO_PLL_CONFIG_POSTPLLDIV_LSB)
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_SET(x)                           (((x) << AUDIO_PLL_CONFIG_POSTPLLDIV_LSB) & AUDIO_PLL_CONFIG_POSTPLLDIV_MASK)
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_RESET                            0x1 // 1
+#define AUDIO_PLL_CONFIG_PLLPWD_MSB                                  5
+#define AUDIO_PLL_CONFIG_PLLPWD_LSB                                  5
+#define AUDIO_PLL_CONFIG_PLLPWD_MASK                                 0x00000020
+#define AUDIO_PLL_CONFIG_PLLPWD_GET(x)                               (((x) & AUDIO_PLL_CONFIG_PLLPWD_MASK) >> AUDIO_PLL_CONFIG_PLLPWD_LSB)
+#define AUDIO_PLL_CONFIG_PLLPWD_SET(x)                               (((x) << AUDIO_PLL_CONFIG_PLLPWD_LSB) & AUDIO_PLL_CONFIG_PLLPWD_MASK)
+#define AUDIO_PLL_CONFIG_PLLPWD_RESET                                0x1 // 1
+#define AUDIO_PLL_CONFIG_BYPASS_MSB                                  4
+#define AUDIO_PLL_CONFIG_BYPASS_LSB                                  4
+#define AUDIO_PLL_CONFIG_BYPASS_MASK                                 0x00000010
+#define AUDIO_PLL_CONFIG_BYPASS_GET(x)                               (((x) & AUDIO_PLL_CONFIG_BYPASS_MASK) >> AUDIO_PLL_CONFIG_BYPASS_LSB)
+#define AUDIO_PLL_CONFIG_BYPASS_SET(x)                               (((x) << AUDIO_PLL_CONFIG_BYPASS_LSB) & AUDIO_PLL_CONFIG_BYPASS_MASK)
+#define AUDIO_PLL_CONFIG_BYPASS_RESET                                0x1 // 1
+#define AUDIO_PLL_CONFIG_REFDIV_MSB                                  3
+#define AUDIO_PLL_CONFIG_REFDIV_LSB                                  0
+#define AUDIO_PLL_CONFIG_REFDIV_MASK                                 0x0000000f
+#define AUDIO_PLL_CONFIG_REFDIV_GET(x)                               (((x) & AUDIO_PLL_CONFIG_REFDIV_MASK) >> AUDIO_PLL_CONFIG_REFDIV_LSB)
+#define AUDIO_PLL_CONFIG_REFDIV_SET(x)                               (((x) << AUDIO_PLL_CONFIG_REFDIV_LSB) & AUDIO_PLL_CONFIG_REFDIV_MASK)
+#define AUDIO_PLL_CONFIG_REFDIV_RESET                                0x3 // 3
+#define AUDIO_PLL_CONFIG_ADDRESS                                     0x1805002c
+
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MSB                        28
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_LSB                        11
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MASK                       0x1ffff800
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_GET(x)                     (((x) & AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MASK) >> AUDIO_PLL_MODULATION_TGT_DIV_FRAC_LSB)
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_SET(x)                     (((x) << AUDIO_PLL_MODULATION_TGT_DIV_FRAC_LSB) & AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MASK)
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_RESET                      0x148fe // 84222
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_MSB                         6
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_LSB                         1
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_MASK                        0x0000007e
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_GET(x)                      (((x) & AUDIO_PLL_MODULATION_TGT_DIV_INT_MASK) >> AUDIO_PLL_MODULATION_TGT_DIV_INT_LSB)
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_SET(x)                      (((x) << AUDIO_PLL_MODULATION_TGT_DIV_INT_LSB) & AUDIO_PLL_MODULATION_TGT_DIV_INT_MASK)
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_RESET                       0x14 // 20
+#define AUDIO_PLL_MODULATION_START_MSB                               0
+#define AUDIO_PLL_MODULATION_START_LSB                               0
+#define AUDIO_PLL_MODULATION_START_MASK                              0x00000001
+#define AUDIO_PLL_MODULATION_START_GET(x)                            (((x) & AUDIO_PLL_MODULATION_START_MASK) >> AUDIO_PLL_MODULATION_START_LSB)
+#define AUDIO_PLL_MODULATION_START_SET(x)                            (((x) << AUDIO_PLL_MODULATION_START_LSB) & AUDIO_PLL_MODULATION_START_MASK)
+#define AUDIO_PLL_MODULATION_START_RESET                             0x0 // 0
+#define AUDIO_PLL_MODULATION_ADDRESS                                 0x18050030
+
+#define AUDIO_PLL_MOD_STEP_FRAC_MSB                                  31
+#define AUDIO_PLL_MOD_STEP_FRAC_LSB                                  14
+#define AUDIO_PLL_MOD_STEP_FRAC_MASK                                 0xffffc000
+#define AUDIO_PLL_MOD_STEP_FRAC_GET(x)                               (((x) & AUDIO_PLL_MOD_STEP_FRAC_MASK) >> AUDIO_PLL_MOD_STEP_FRAC_LSB)
+#define AUDIO_PLL_MOD_STEP_FRAC_SET(x)                               (((x) << AUDIO_PLL_MOD_STEP_FRAC_LSB) & AUDIO_PLL_MOD_STEP_FRAC_MASK)
+#define AUDIO_PLL_MOD_STEP_FRAC_RESET                                0x1 // 1
+#define AUDIO_PLL_MOD_STEP_INT_MSB                                   13
+#define AUDIO_PLL_MOD_STEP_INT_LSB                                   4
+#define AUDIO_PLL_MOD_STEP_INT_MASK                                  0x00003ff0
+#define AUDIO_PLL_MOD_STEP_INT_GET(x)                                (((x) & AUDIO_PLL_MOD_STEP_INT_MASK) >> AUDIO_PLL_MOD_STEP_INT_LSB)
+#define AUDIO_PLL_MOD_STEP_INT_SET(x)                                (((x) << AUDIO_PLL_MOD_STEP_INT_LSB) & AUDIO_PLL_MOD_STEP_INT_MASK)
+#define AUDIO_PLL_MOD_STEP_INT_RESET                                 0x0 // 0
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_MSB                            3
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_LSB                            0
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_MASK                           0x0000000f
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_GET(x)                         (((x) & AUDIO_PLL_MOD_STEP_UPDATE_CNT_MASK) >> AUDIO_PLL_MOD_STEP_UPDATE_CNT_LSB)
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_SET(x)                         (((x) << AUDIO_PLL_MOD_STEP_UPDATE_CNT_LSB) & AUDIO_PLL_MOD_STEP_UPDATE_CNT_MASK)
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_RESET                          0x0 // 0
+#define AUDIO_PLL_MOD_STEP_ADDRESS                                   0x18050034
+
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_MSB                        27
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_LSB                        10
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_MASK                       0x0ffffc00
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_GET(x)                     (((x) & CURRENT_AUDIO_PLL_MODULATION_FRAC_MASK) >> CURRENT_AUDIO_PLL_MODULATION_FRAC_LSB)
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_SET(x)                     (((x) << CURRENT_AUDIO_PLL_MODULATION_FRAC_LSB) & CURRENT_AUDIO_PLL_MODULATION_FRAC_MASK)
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_RESET                      0x1 // 1
+#define CURRENT_AUDIO_PLL_MODULATION_INT_MSB                         6
+#define CURRENT_AUDIO_PLL_MODULATION_INT_LSB                         1
+#define CURRENT_AUDIO_PLL_MODULATION_INT_MASK                        0x0000007e
+#define CURRENT_AUDIO_PLL_MODULATION_INT_GET(x)                      (((x) & CURRENT_AUDIO_PLL_MODULATION_INT_MASK) >> CURRENT_AUDIO_PLL_MODULATION_INT_LSB)
+#define CURRENT_AUDIO_PLL_MODULATION_INT_SET(x)                      (((x) << CURRENT_AUDIO_PLL_MODULATION_INT_LSB) & CURRENT_AUDIO_PLL_MODULATION_INT_MASK)
+#define CURRENT_AUDIO_PLL_MODULATION_INT_RESET                       0x0 // 0
+#define CURRENT_AUDIO_PLL_MODULATION_ADDRESS                         0x18050038
+
+#define BB_PLL_CONFIG_UPDATING_MSB                                   31
+#define BB_PLL_CONFIG_UPDATING_LSB                                   31
+#define BB_PLL_CONFIG_UPDATING_MASK                                  0x80000000
+#define BB_PLL_CONFIG_UPDATING_GET(x)                                (((x) & BB_PLL_CONFIG_UPDATING_MASK) >> BB_PLL_CONFIG_UPDATING_LSB)
+#define BB_PLL_CONFIG_UPDATING_SET(x)                                (((x) << BB_PLL_CONFIG_UPDATING_LSB) & BB_PLL_CONFIG_UPDATING_MASK)
+#define BB_PLL_CONFIG_UPDATING_RESET                                 0x1 // 1
+#define BB_PLL_CONFIG_PLLPWD_MSB                                     30
+#define BB_PLL_CONFIG_PLLPWD_LSB                                     30
+#define BB_PLL_CONFIG_PLLPWD_MASK                                    0x40000000
+#define BB_PLL_CONFIG_PLLPWD_GET(x)                                  (((x) & BB_PLL_CONFIG_PLLPWD_MASK) >> BB_PLL_CONFIG_PLLPWD_LSB)
+#define BB_PLL_CONFIG_PLLPWD_SET(x)                                  (((x) << BB_PLL_CONFIG_PLLPWD_LSB) & BB_PLL_CONFIG_PLLPWD_MASK)
+#define BB_PLL_CONFIG_PLLPWD_RESET                                   0x1 // 1
+#define BB_PLL_CONFIG_SPARE_MSB                                      29
+#define BB_PLL_CONFIG_SPARE_LSB                                      29
+#define BB_PLL_CONFIG_SPARE_MASK                                     0x20000000
+#define BB_PLL_CONFIG_SPARE_GET(x)                                   (((x) & BB_PLL_CONFIG_SPARE_MASK) >> BB_PLL_CONFIG_SPARE_LSB)
+#define BB_PLL_CONFIG_SPARE_SET(x)                                   (((x) << BB_PLL_CONFIG_SPARE_LSB) & BB_PLL_CONFIG_SPARE_MASK)
+#define BB_PLL_CONFIG_SPARE_RESET                                    0x0 // 0
+#define BB_PLL_CONFIG_REFDIV_MSB                                     28
+#define BB_PLL_CONFIG_REFDIV_LSB                                     24
+#define BB_PLL_CONFIG_REFDIV_MASK                                    0x1f000000
+#define BB_PLL_CONFIG_REFDIV_GET(x)                                  (((x) & BB_PLL_CONFIG_REFDIV_MASK) >> BB_PLL_CONFIG_REFDIV_LSB)
+#define BB_PLL_CONFIG_REFDIV_SET(x)                                  (((x) << BB_PLL_CONFIG_REFDIV_LSB) & BB_PLL_CONFIG_REFDIV_MASK)
+#define BB_PLL_CONFIG_REFDIV_RESET                                   0x1 // 1
+#define BB_PLL_CONFIG_NINT_MSB                                       21
+#define BB_PLL_CONFIG_NINT_LSB                                       16
+#define BB_PLL_CONFIG_NINT_MASK                                      0x003f0000
+#define BB_PLL_CONFIG_NINT_GET(x)                                    (((x) & BB_PLL_CONFIG_NINT_MASK) >> BB_PLL_CONFIG_NINT_LSB)
+#define BB_PLL_CONFIG_NINT_SET(x)                                    (((x) << BB_PLL_CONFIG_NINT_LSB) & BB_PLL_CONFIG_NINT_MASK)
+#define BB_PLL_CONFIG_NINT_RESET                                     0x2 // 2
+#define BB_PLL_CONFIG_NFRAC_MSB                                      13
+#define BB_PLL_CONFIG_NFRAC_LSB                                      0
+#define BB_PLL_CONFIG_NFRAC_MASK                                     0x00003fff
+#define BB_PLL_CONFIG_NFRAC_GET(x)                                   (((x) & BB_PLL_CONFIG_NFRAC_MASK) >> BB_PLL_CONFIG_NFRAC_LSB)
+#define BB_PLL_CONFIG_NFRAC_SET(x)                                   (((x) << BB_PLL_CONFIG_NFRAC_LSB) & BB_PLL_CONFIG_NFRAC_MASK)
+#define BB_PLL_CONFIG_NFRAC_RESET                                    0xccc // 3276
+#define BB_PLL_CONFIG_ADDRESS                                        0x1805003c
+
+#define DDR_PLL_DITHER_DITHER_EN_MSB                                 31
+#define DDR_PLL_DITHER_DITHER_EN_LSB                                 31
+#define DDR_PLL_DITHER_DITHER_EN_MASK                                0x80000000
+#define DDR_PLL_DITHER_DITHER_EN_GET(x)                              (((x) & DDR_PLL_DITHER_DITHER_EN_MASK) >> DDR_PLL_DITHER_DITHER_EN_LSB)
+#define DDR_PLL_DITHER_DITHER_EN_SET(x)                              (((x) << DDR_PLL_DITHER_DITHER_EN_LSB) & DDR_PLL_DITHER_DITHER_EN_MASK)
+#define DDR_PLL_DITHER_DITHER_EN_RESET                               0x0 // 0
+#define DDR_PLL_DITHER_UPDATE_COUNT_MSB                              30
+#define DDR_PLL_DITHER_UPDATE_COUNT_LSB                              27
+#define DDR_PLL_DITHER_UPDATE_COUNT_MASK                             0x78000000
+#define DDR_PLL_DITHER_UPDATE_COUNT_GET(x)                           (((x) & DDR_PLL_DITHER_UPDATE_COUNT_MASK) >> DDR_PLL_DITHER_UPDATE_COUNT_LSB)
+#define DDR_PLL_DITHER_UPDATE_COUNT_SET(x)                           (((x) << DDR_PLL_DITHER_UPDATE_COUNT_LSB) & DDR_PLL_DITHER_UPDATE_COUNT_MASK)
+#define DDR_PLL_DITHER_UPDATE_COUNT_RESET                            0xf // 15
+#define DDR_PLL_DITHER_NFRAC_STEP_MSB                                26
+#define DDR_PLL_DITHER_NFRAC_STEP_LSB                                20
+#define DDR_PLL_DITHER_NFRAC_STEP_MASK                               0x07f00000
+#define DDR_PLL_DITHER_NFRAC_STEP_GET(x)                             (((x) & DDR_PLL_DITHER_NFRAC_STEP_MASK) >> DDR_PLL_DITHER_NFRAC_STEP_LSB)
+#define DDR_PLL_DITHER_NFRAC_STEP_SET(x)                             (((x) << DDR_PLL_DITHER_NFRAC_STEP_LSB) & DDR_PLL_DITHER_NFRAC_STEP_MASK)
+#define DDR_PLL_DITHER_NFRAC_STEP_RESET                              0x1 // 1
+#define DDR_PLL_DITHER_NFRAC_MIN_MSB                                 19
+#define DDR_PLL_DITHER_NFRAC_MIN_LSB                                 10
+#define DDR_PLL_DITHER_NFRAC_MIN_MASK                                0x000ffc00
+#define DDR_PLL_DITHER_NFRAC_MIN_GET(x)                              (((x) & DDR_PLL_DITHER_NFRAC_MIN_MASK) >> DDR_PLL_DITHER_NFRAC_MIN_LSB)
+#define DDR_PLL_DITHER_NFRAC_MIN_SET(x)                              (((x) << DDR_PLL_DITHER_NFRAC_MIN_LSB) & DDR_PLL_DITHER_NFRAC_MIN_MASK)
+#define DDR_PLL_DITHER_NFRAC_MIN_RESET                               0x19 // 25
+#define DDR_PLL_DITHER_NFRAC_MAX_MSB                                 9
+#define DDR_PLL_DITHER_NFRAC_MAX_LSB                                 0
+#define DDR_PLL_DITHER_NFRAC_MAX_MASK                                0x000003ff
+#define DDR_PLL_DITHER_NFRAC_MAX_GET(x)                              (((x) & DDR_PLL_DITHER_NFRAC_MAX_MASK) >> DDR_PLL_DITHER_NFRAC_MAX_LSB)
+#define DDR_PLL_DITHER_NFRAC_MAX_SET(x)                              (((x) << DDR_PLL_DITHER_NFRAC_MAX_LSB) & DDR_PLL_DITHER_NFRAC_MAX_MASK)
+#define DDR_PLL_DITHER_NFRAC_MAX_RESET                               0x3e8 // 1000
+#define DDR_PLL_DITHER_ADDRESS                                       0x18050040
+
+#define CPU_PLL_DITHER_DITHER_EN_MSB                                 31
+#define CPU_PLL_DITHER_DITHER_EN_LSB                                 31
+#define CPU_PLL_DITHER_DITHER_EN_MASK                                0x80000000
+#define CPU_PLL_DITHER_DITHER_EN_GET(x)                              (((x) & CPU_PLL_DITHER_DITHER_EN_MASK) >> CPU_PLL_DITHER_DITHER_EN_LSB)
+#define CPU_PLL_DITHER_DITHER_EN_SET(x)                              (((x) << CPU_PLL_DITHER_DITHER_EN_LSB) & CPU_PLL_DITHER_DITHER_EN_MASK)
+#define CPU_PLL_DITHER_DITHER_EN_RESET                               0x0 // 0
+#define CPU_PLL_DITHER_UPDATE_COUNT_MSB                              23
+#define CPU_PLL_DITHER_UPDATE_COUNT_LSB                              18
+#define CPU_PLL_DITHER_UPDATE_COUNT_MASK                             0x00fc0000
+#define CPU_PLL_DITHER_UPDATE_COUNT_GET(x)                           (((x) & CPU_PLL_DITHER_UPDATE_COUNT_MASK) >> CPU_PLL_DITHER_UPDATE_COUNT_LSB)
+#define CPU_PLL_DITHER_UPDATE_COUNT_SET(x)                           (((x) << CPU_PLL_DITHER_UPDATE_COUNT_LSB) & CPU_PLL_DITHER_UPDATE_COUNT_MASK)
+#define CPU_PLL_DITHER_UPDATE_COUNT_RESET                            0x14 // 20
+#define CPU_PLL_DITHER_NFRAC_STEP_MSB                                17
+#define CPU_PLL_DITHER_NFRAC_STEP_LSB                                12
+#define CPU_PLL_DITHER_NFRAC_STEP_MASK                               0x0003f000
+#define CPU_PLL_DITHER_NFRAC_STEP_GET(x)                             (((x) & CPU_PLL_DITHER_NFRAC_STEP_MASK) >> CPU_PLL_DITHER_NFRAC_STEP_LSB)
+#define CPU_PLL_DITHER_NFRAC_STEP_SET(x)                             (((x) << CPU_PLL_DITHER_NFRAC_STEP_LSB) & CPU_PLL_DITHER_NFRAC_STEP_MASK)
+#define CPU_PLL_DITHER_NFRAC_STEP_RESET                              0x1 // 1
+#define CPU_PLL_DITHER_NFRAC_MIN_MSB                                 11
+#define CPU_PLL_DITHER_NFRAC_MIN_LSB                                 6
+#define CPU_PLL_DITHER_NFRAC_MIN_MASK                                0x00000fc0
+#define CPU_PLL_DITHER_NFRAC_MIN_GET(x)                              (((x) & CPU_PLL_DITHER_NFRAC_MIN_MASK) >> CPU_PLL_DITHER_NFRAC_MIN_LSB)
+#define CPU_PLL_DITHER_NFRAC_MIN_SET(x)                              (((x) << CPU_PLL_DITHER_NFRAC_MIN_LSB) & CPU_PLL_DITHER_NFRAC_MIN_MASK)
+#define CPU_PLL_DITHER_NFRAC_MIN_RESET                               0x3 // 3
+#define CPU_PLL_DITHER_NFRAC_MAX_MSB                                 5
+#define CPU_PLL_DITHER_NFRAC_MAX_LSB                                 0
+#define CPU_PLL_DITHER_NFRAC_MAX_MASK                                0x0000003f
+#define CPU_PLL_DITHER_NFRAC_MAX_GET(x)                              (((x) & CPU_PLL_DITHER_NFRAC_MAX_MASK) >> CPU_PLL_DITHER_NFRAC_MAX_LSB)
+#define CPU_PLL_DITHER_NFRAC_MAX_SET(x)                              (((x) << CPU_PLL_DITHER_NFRAC_MAX_LSB) & CPU_PLL_DITHER_NFRAC_MAX_MASK)
+#define CPU_PLL_DITHER_NFRAC_MAX_RESET                               0x3c // 60
+#define CPU_PLL_DITHER_ADDRESS                                       0x18050044
+
+#define RST_RESET_HOST_RESET_MSB                                     31
+#define RST_RESET_HOST_RESET_LSB                                     31
+#define RST_RESET_HOST_RESET_MASK                                    0x80000000
+#define RST_RESET_HOST_RESET_GET(x)                                  (((x) & RST_RESET_HOST_RESET_MASK) >> RST_RESET_HOST_RESET_LSB)
+#define RST_RESET_HOST_RESET_SET(x)                                  (((x) << RST_RESET_HOST_RESET_LSB) & RST_RESET_HOST_RESET_MASK)
+#define RST_RESET_HOST_RESET_RESET                                   0x0 // 0
+#define RST_RESET_SLIC_RESET_MSB                                     30
+#define RST_RESET_SLIC_RESET_LSB                                     30
+#define RST_RESET_SLIC_RESET_MASK                                    0x40000000
+#define RST_RESET_SLIC_RESET_GET(x)                                  (((x) & RST_RESET_SLIC_RESET_MASK) >> RST_RESET_SLIC_RESET_LSB)
+#define RST_RESET_SLIC_RESET_SET(x)                                  (((x) << RST_RESET_SLIC_RESET_LSB) & RST_RESET_SLIC_RESET_MASK)
+#define RST_RESET_SLIC_RESET_RESET                                   0x0 // 0
+#define RST_RESET_HDMA_RESET_MSB                                     29
+#define RST_RESET_HDMA_RESET_LSB                                     29
+#define RST_RESET_HDMA_RESET_MASK                                    0x20000000
+#define RST_RESET_HDMA_RESET_GET(x)                                  (((x) & RST_RESET_HDMA_RESET_MASK) >> RST_RESET_HDMA_RESET_LSB)
+#define RST_RESET_HDMA_RESET_SET(x)                                  (((x) << RST_RESET_HDMA_RESET_LSB) & RST_RESET_HDMA_RESET_MASK)
+#define RST_RESET_HDMA_RESET_RESET                                   0x1 // 1
+#define RST_RESET_EXTERNAL_RESET_MSB                                 28
+#define RST_RESET_EXTERNAL_RESET_LSB                                 28
+#define RST_RESET_EXTERNAL_RESET_MASK                                0x10000000
+#define RST_RESET_EXTERNAL_RESET_GET(x)                              (((x) & RST_RESET_EXTERNAL_RESET_MASK) >> RST_RESET_EXTERNAL_RESET_LSB)
+#define RST_RESET_EXTERNAL_RESET_SET(x)                              (((x) << RST_RESET_EXTERNAL_RESET_LSB) & RST_RESET_EXTERNAL_RESET_MASK)
+#define RST_RESET_EXTERNAL_RESET_RESET                               0x0 // 0
+#define RST_RESET_RTC_RESET_MSB                                      27
+#define RST_RESET_RTC_RESET_LSB                                      27
+#define RST_RESET_RTC_RESET_MASK                                     0x08000000
+#define RST_RESET_RTC_RESET_GET(x)                                   (((x) & RST_RESET_RTC_RESET_MASK) >> RST_RESET_RTC_RESET_LSB)
+#define RST_RESET_RTC_RESET_SET(x)                                   (((x) << RST_RESET_RTC_RESET_LSB) & RST_RESET_RTC_RESET_MASK)
+#define RST_RESET_RTC_RESET_RESET                                    0x1 // 1
+#define RST_RESET_PCIEEP_RST_INT_MSB                                 26
+#define RST_RESET_PCIEEP_RST_INT_LSB                                 26
+#define RST_RESET_PCIEEP_RST_INT_MASK                                0x04000000
+#define RST_RESET_PCIEEP_RST_INT_GET(x)                              (((x) & RST_RESET_PCIEEP_RST_INT_MASK) >> RST_RESET_PCIEEP_RST_INT_LSB)
+#define RST_RESET_PCIEEP_RST_INT_SET(x)                              (((x) << RST_RESET_PCIEEP_RST_INT_LSB) & RST_RESET_PCIEEP_RST_INT_MASK)
+#define RST_RESET_PCIEEP_RST_INT_RESET                               0x0 // 0
+#define RST_RESET_CHKSUM_ACC_RESET_MSB                               25
+#define RST_RESET_CHKSUM_ACC_RESET_LSB                               25
+#define RST_RESET_CHKSUM_ACC_RESET_MASK                              0x02000000
+#define RST_RESET_CHKSUM_ACC_RESET_GET(x)                            (((x) & RST_RESET_CHKSUM_ACC_RESET_MASK) >> RST_RESET_CHKSUM_ACC_RESET_LSB)
+#define RST_RESET_CHKSUM_ACC_RESET_SET(x)                            (((x) << RST_RESET_CHKSUM_ACC_RESET_LSB) & RST_RESET_CHKSUM_ACC_RESET_MASK)
+#define RST_RESET_CHKSUM_ACC_RESET_RESET                             0x0 // 0
+#define RST_RESET_FULL_CHIP_RESET_MSB                                24
+#define RST_RESET_FULL_CHIP_RESET_LSB                                24
+#define RST_RESET_FULL_CHIP_RESET_MASK                               0x01000000
+#define RST_RESET_FULL_CHIP_RESET_GET(x)                             (((x) & RST_RESET_FULL_CHIP_RESET_MASK) >> RST_RESET_FULL_CHIP_RESET_LSB)
+#define RST_RESET_FULL_CHIP_RESET_SET(x)                             (((x) << RST_RESET_FULL_CHIP_RESET_LSB) & RST_RESET_FULL_CHIP_RESET_MASK)
+#define RST_RESET_FULL_CHIP_RESET_RESET                              0x0 // 0
+#define RST_RESET_GE1_MDIO_RESET_MSB                                 23
+#define RST_RESET_GE1_MDIO_RESET_LSB                                 23
+#define RST_RESET_GE1_MDIO_RESET_MASK                                0x00800000
+#define RST_RESET_GE1_MDIO_RESET_GET(x)                              (((x) & RST_RESET_GE1_MDIO_RESET_MASK) >> RST_RESET_GE1_MDIO_RESET_LSB)
+#define RST_RESET_GE1_MDIO_RESET_SET(x)                              (((x) << RST_RESET_GE1_MDIO_RESET_LSB) & RST_RESET_GE1_MDIO_RESET_MASK)
+#define RST_RESET_GE1_MDIO_RESET_RESET                               0x1 // 1
+#define RST_RESET_GE0_MDIO_RESET_MSB                                 22
+#define RST_RESET_GE0_MDIO_RESET_LSB                                 22
+#define RST_RESET_GE0_MDIO_RESET_MASK                                0x00400000
+#define RST_RESET_GE0_MDIO_RESET_GET(x)                              (((x) & RST_RESET_GE0_MDIO_RESET_MASK) >> RST_RESET_GE0_MDIO_RESET_LSB)
+#define RST_RESET_GE0_MDIO_RESET_SET(x)                              (((x) << RST_RESET_GE0_MDIO_RESET_LSB) & RST_RESET_GE0_MDIO_RESET_MASK)
+#define RST_RESET_GE0_MDIO_RESET_RESET                               0x1 // 1
+#define RST_RESET_CPU_NMI_MSB                                        21
+#define RST_RESET_CPU_NMI_LSB                                        21
+#define RST_RESET_CPU_NMI_MASK                                       0x00200000
+#define RST_RESET_CPU_NMI_GET(x)                                     (((x) & RST_RESET_CPU_NMI_MASK) >> RST_RESET_CPU_NMI_LSB)
+#define RST_RESET_CPU_NMI_SET(x)                                     (((x) << RST_RESET_CPU_NMI_LSB) & RST_RESET_CPU_NMI_MASK)
+#define RST_RESET_CPU_NMI_RESET                                      0x0 // 0
+#define RST_RESET_CPU_COLD_RESET_MSB                                 20
+#define RST_RESET_CPU_COLD_RESET_LSB                                 20
+#define RST_RESET_CPU_COLD_RESET_MASK                                0x00100000
+#define RST_RESET_CPU_COLD_RESET_GET(x)                              (((x) & RST_RESET_CPU_COLD_RESET_MASK) >> RST_RESET_CPU_COLD_RESET_LSB)
+#define RST_RESET_CPU_COLD_RESET_SET(x)                              (((x) << RST_RESET_CPU_COLD_RESET_LSB) & RST_RESET_CPU_COLD_RESET_MASK)
+#define RST_RESET_CPU_COLD_RESET_RESET                               0x0 // 0
+#define RST_RESET_HOST_RESET_INT_MSB                                 19
+#define RST_RESET_HOST_RESET_INT_LSB                                 19
+#define RST_RESET_HOST_RESET_INT_MASK                                0x00080000
+#define RST_RESET_HOST_RESET_INT_GET(x)                              (((x) & RST_RESET_HOST_RESET_INT_MASK) >> RST_RESET_HOST_RESET_INT_LSB)
+#define RST_RESET_HOST_RESET_INT_SET(x)                              (((x) << RST_RESET_HOST_RESET_INT_LSB) & RST_RESET_HOST_RESET_INT_MASK)
+#define RST_RESET_HOST_RESET_INT_RESET                               0x0 // 0
+#define RST_RESET_PCIEEP_RESET_MSB                                   18
+#define RST_RESET_PCIEEP_RESET_LSB                                   18
+#define RST_RESET_PCIEEP_RESET_MASK                                  0x00040000
+#define RST_RESET_PCIEEP_RESET_GET(x)                                (((x) & RST_RESET_PCIEEP_RESET_MASK) >> RST_RESET_PCIEEP_RESET_LSB)
+#define RST_RESET_PCIEEP_RESET_SET(x)                                (((x) << RST_RESET_PCIEEP_RESET_LSB) & RST_RESET_PCIEEP_RESET_MASK)
+#define RST_RESET_PCIEEP_RESET_RESET                                 0x0 // 0
+#define RST_RESET_UART1_RESET_MSB                                    17
+#define RST_RESET_UART1_RESET_LSB                                    17
+#define RST_RESET_UART1_RESET_MASK                                   0x00020000
+#define RST_RESET_UART1_RESET_GET(x)                                 (((x) & RST_RESET_UART1_RESET_MASK) >> RST_RESET_UART1_RESET_LSB)
+#define RST_RESET_UART1_RESET_SET(x)                                 (((x) << RST_RESET_UART1_RESET_LSB) & RST_RESET_UART1_RESET_MASK)
+#define RST_RESET_UART1_RESET_RESET                                  0x0 // 0
+#define RST_RESET_DDR_RESET_MSB                                      16
+#define RST_RESET_DDR_RESET_LSB                                      16
+#define RST_RESET_DDR_RESET_MASK                                     0x00010000
+#define RST_RESET_DDR_RESET_GET(x)                                   (((x) & RST_RESET_DDR_RESET_MASK) >> RST_RESET_DDR_RESET_LSB)
+#define RST_RESET_DDR_RESET_SET(x)                                   (((x) << RST_RESET_DDR_RESET_LSB) & RST_RESET_DDR_RESET_MASK)
+#define RST_RESET_DDR_RESET_RESET                                    0x0 // 0
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_MSB                            15
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_LSB                            15
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_MASK                           0x00008000
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_GET(x)                         (((x) & RST_RESET_USB_PHY_PLL_PWD_EXT_MASK) >> RST_RESET_USB_PHY_PLL_PWD_EXT_LSB)
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_SET(x)                         (((x) << RST_RESET_USB_PHY_PLL_PWD_EXT_LSB) & RST_RESET_USB_PHY_PLL_PWD_EXT_MASK)
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_RESET                          0x0 // 0
+#define RST_RESET_NANDF_RESET_MSB                                    14
+#define RST_RESET_NANDF_RESET_LSB                                    14
+#define RST_RESET_NANDF_RESET_MASK                                   0x00004000
+#define RST_RESET_NANDF_RESET_GET(x)                                 (((x) & RST_RESET_NANDF_RESET_MASK) >> RST_RESET_NANDF_RESET_LSB)
+#define RST_RESET_NANDF_RESET_SET(x)                                 (((x) << RST_RESET_NANDF_RESET_LSB) & RST_RESET_NANDF_RESET_MASK)
+#define RST_RESET_NANDF_RESET_RESET                                  0x1 // 1
+#define RST_RESET_GE1_MAC_RESET_MSB                                  13
+#define RST_RESET_GE1_MAC_RESET_LSB                                  13
+#define RST_RESET_GE1_MAC_RESET_MASK                                 0x00002000
+#define RST_RESET_GE1_MAC_RESET_GET(x)                               (((x) & RST_RESET_GE1_MAC_RESET_MASK) >> RST_RESET_GE1_MAC_RESET_LSB)
+#define RST_RESET_GE1_MAC_RESET_SET(x)                               (((x) << RST_RESET_GE1_MAC_RESET_LSB) & RST_RESET_GE1_MAC_RESET_MASK)
+#define RST_RESET_GE1_MAC_RESET_RESET                                0x1 // 1
+#define RST_RESET_ETH_SGMII_ARESET_MSB                               12
+#define RST_RESET_ETH_SGMII_ARESET_LSB                               12
+#define RST_RESET_ETH_SGMII_ARESET_MASK                              0x00001000
+#define RST_RESET_ETH_SGMII_ARESET_GET(x)                            (((x) & RST_RESET_ETH_SGMII_ARESET_MASK) >> RST_RESET_ETH_SGMII_ARESET_LSB)
+#define RST_RESET_ETH_SGMII_ARESET_SET(x)                            (((x) << RST_RESET_ETH_SGMII_ARESET_LSB) & RST_RESET_ETH_SGMII_ARESET_MASK)
+#define RST_RESET_ETH_SGMII_ARESET_RESET                             0x1 // 1
+#define RST_RESET_USB_PHY_ARESET_MSB                                 11
+#define RST_RESET_USB_PHY_ARESET_LSB                                 11
+#define RST_RESET_USB_PHY_ARESET_MASK                                0x00000800
+#define RST_RESET_USB_PHY_ARESET_GET(x)                              (((x) & RST_RESET_USB_PHY_ARESET_MASK) >> RST_RESET_USB_PHY_ARESET_LSB)
+#define RST_RESET_USB_PHY_ARESET_SET(x)                              (((x) << RST_RESET_USB_PHY_ARESET_LSB) & RST_RESET_USB_PHY_ARESET_MASK)
+#define RST_RESET_USB_PHY_ARESET_RESET                               0x1 // 1
+#define RST_RESET_HOST_DMA_INT_MSB                                   10
+#define RST_RESET_HOST_DMA_INT_LSB                                   10
+#define RST_RESET_HOST_DMA_INT_MASK                                  0x00000400
+#define RST_RESET_HOST_DMA_INT_GET(x)                                (((x) & RST_RESET_HOST_DMA_INT_MASK) >> RST_RESET_HOST_DMA_INT_LSB)
+#define RST_RESET_HOST_DMA_INT_SET(x)                                (((x) << RST_RESET_HOST_DMA_INT_LSB) & RST_RESET_HOST_DMA_INT_MASK)
+#define RST_RESET_HOST_DMA_INT_RESET                                 0x0 // 0
+#define RST_RESET_GE0_MAC_RESET_MSB                                  9
+#define RST_RESET_GE0_MAC_RESET_LSB                                  9
+#define RST_RESET_GE0_MAC_RESET_MASK                                 0x00000200
+#define RST_RESET_GE0_MAC_RESET_GET(x)                               (((x) & RST_RESET_GE0_MAC_RESET_MASK) >> RST_RESET_GE0_MAC_RESET_LSB)
+#define RST_RESET_GE0_MAC_RESET_SET(x)                               (((x) << RST_RESET_GE0_MAC_RESET_LSB) & RST_RESET_GE0_MAC_RESET_MASK)
+#define RST_RESET_GE0_MAC_RESET_RESET                                0x1 // 1
+#define RST_RESET_ETH_SGMII_RESET_MSB                                8
+#define RST_RESET_ETH_SGMII_RESET_LSB                                8
+#define RST_RESET_ETH_SGMII_RESET_MASK                               0x00000100
+#define RST_RESET_ETH_SGMII_RESET_GET(x)                             (((x) & RST_RESET_ETH_SGMII_RESET_MASK) >> RST_RESET_ETH_SGMII_RESET_LSB)
+#define RST_RESET_ETH_SGMII_RESET_SET(x)                             (((x) << RST_RESET_ETH_SGMII_RESET_LSB) & RST_RESET_ETH_SGMII_RESET_MASK)
+#define RST_RESET_ETH_SGMII_RESET_RESET                              0x1 // 1
+#define RST_RESET_PCIE_PHY_RESET_MSB                                 7
+#define RST_RESET_PCIE_PHY_RESET_LSB                                 7
+#define RST_RESET_PCIE_PHY_RESET_MASK                                0x00000080
+#define RST_RESET_PCIE_PHY_RESET_GET(x)                              (((x) & RST_RESET_PCIE_PHY_RESET_MASK) >> RST_RESET_PCIE_PHY_RESET_LSB)
+#define RST_RESET_PCIE_PHY_RESET_SET(x)                              (((x) << RST_RESET_PCIE_PHY_RESET_LSB) & RST_RESET_PCIE_PHY_RESET_MASK)
+#define RST_RESET_PCIE_PHY_RESET_RESET                               0x1 // 1
+#define RST_RESET_PCIE_RESET_MSB                                     6
+#define RST_RESET_PCIE_RESET_LSB                                     6
+#define RST_RESET_PCIE_RESET_MASK                                    0x00000040
+#define RST_RESET_PCIE_RESET_GET(x)                                  (((x) & RST_RESET_PCIE_RESET_MASK) >> RST_RESET_PCIE_RESET_LSB)
+#define RST_RESET_PCIE_RESET_SET(x)                                  (((x) << RST_RESET_PCIE_RESET_LSB) & RST_RESET_PCIE_RESET_MASK)
+#define RST_RESET_PCIE_RESET_RESET                                   0x1 // 1
+#define RST_RESET_USB_HOST_RESET_MSB                                 5
+#define RST_RESET_USB_HOST_RESET_LSB                                 5
+#define RST_RESET_USB_HOST_RESET_MASK                                0x00000020
+#define RST_RESET_USB_HOST_RESET_GET(x)                              (((x) & RST_RESET_USB_HOST_RESET_MASK) >> RST_RESET_USB_HOST_RESET_LSB)
+#define RST_RESET_USB_HOST_RESET_SET(x)                              (((x) << RST_RESET_USB_HOST_RESET_LSB) & RST_RESET_USB_HOST_RESET_MASK)
+#define RST_RESET_USB_HOST_RESET_RESET                               0x1 // 1
+#define RST_RESET_USB_PHY_RESET_MSB                                  4
+#define RST_RESET_USB_PHY_RESET_LSB                                  4
+#define RST_RESET_USB_PHY_RESET_MASK                                 0x00000010
+#define RST_RESET_USB_PHY_RESET_GET(x)                               (((x) & RST_RESET_USB_PHY_RESET_MASK) >> RST_RESET_USB_PHY_RESET_LSB)
+#define RST_RESET_USB_PHY_RESET_SET(x)                               (((x) << RST_RESET_USB_PHY_RESET_LSB) & RST_RESET_USB_PHY_RESET_MASK)
+#define RST_RESET_USB_PHY_RESET_RESET                                0x1 // 1
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MSB                       3
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB                       3
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK                      0x00000008
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_GET(x)                    (((x) & RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK) >> RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB)
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(x)                    (((x) << RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB) & RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK)
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_RESET                     0x0 // 0
+#define RST_RESET_LUT_RESET_MSB                                      2
+#define RST_RESET_LUT_RESET_LSB                                      2
+#define RST_RESET_LUT_RESET_MASK                                     0x00000004
+#define RST_RESET_LUT_RESET_GET(x)                                   (((x) & RST_RESET_LUT_RESET_MASK) >> RST_RESET_LUT_RESET_LSB)
+#define RST_RESET_LUT_RESET_SET(x)                                   (((x) << RST_RESET_LUT_RESET_LSB) & RST_RESET_LUT_RESET_MASK)
+#define RST_RESET_LUT_RESET_RESET                                    0x0 // 0
+#define RST_RESET_MBOX_RESET_MSB                                     1
+#define RST_RESET_MBOX_RESET_LSB                                     1
+#define RST_RESET_MBOX_RESET_MASK                                    0x00000002
+#define RST_RESET_MBOX_RESET_GET(x)                                  (((x) & RST_RESET_MBOX_RESET_MASK) >> RST_RESET_MBOX_RESET_LSB)
+#define RST_RESET_MBOX_RESET_SET(x)                                  (((x) << RST_RESET_MBOX_RESET_LSB) & RST_RESET_MBOX_RESET_MASK)
+#define RST_RESET_MBOX_RESET_RESET                                   0x0 // 0
+#define RST_RESET_I2S_RESET_MSB                                      0
+#define RST_RESET_I2S_RESET_LSB                                      0
+#define RST_RESET_I2S_RESET_MASK                                     0x00000001
+#define RST_RESET_I2S_RESET_GET(x)                                   (((x) & RST_RESET_I2S_RESET_MASK) >> RST_RESET_I2S_RESET_LSB)
+#define RST_RESET_I2S_RESET_SET(x)                                   (((x) << RST_RESET_I2S_RESET_LSB) & RST_RESET_I2S_RESET_MASK)
+#define RST_RESET_I2S_RESET_RESET                                    0x0 // 0
+#define RST_RESET_ADDRESS                                            0x1806001c
+
+#define RST_MISC2_PCIEEP_LINK_UP_MSB                                 30
+#define RST_MISC2_PCIEEP_LINK_UP_LSB                                 30
+#define RST_MISC2_PCIEEP_LINK_UP_MASK                                0x40000000
+#define RST_MISC2_PCIEEP_LINK_UP_GET(x)                              (((x) & RST_MISC2_PCIEEP_LINK_UP_MASK) >> RST_MISC2_PCIEEP_LINK_UP_LSB)
+#define RST_MISC2_PCIEEP_LINK_UP_SET(x)                              (((x) << RST_MISC2_PCIEEP_LINK_UP_LSB) & RST_MISC2_PCIEEP_LINK_UP_MASK)
+#define RST_MISC2_PCIEEP_LINK_UP_RESET                               0x0 // 0
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_MSB                             29
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_LSB                             29
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_MASK                            0x20000000
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_GET(x)                          (((x) & RST_MISC2_PCIEEP_CLKOBS2_SEL_MASK) >> RST_MISC2_PCIEEP_CLKOBS2_SEL_LSB)
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_SET(x)                          (((x) << RST_MISC2_PCIEEP_CLKOBS2_SEL_LSB) & RST_MISC2_PCIEEP_CLKOBS2_SEL_MASK)
+#define RST_MISC2_PCIEEP_CLKOBS2_SEL_RESET                           0x0 // 0
+#define RST_MISC2_PCIE_CLKOBS1_SEL_MSB                               28
+#define RST_MISC2_PCIE_CLKOBS1_SEL_LSB                               28
+#define RST_MISC2_PCIE_CLKOBS1_SEL_MASK                              0x10000000
+#define RST_MISC2_PCIE_CLKOBS1_SEL_GET(x)                            (((x) & RST_MISC2_PCIE_CLKOBS1_SEL_MASK) >> RST_MISC2_PCIE_CLKOBS1_SEL_LSB)
+#define RST_MISC2_PCIE_CLKOBS1_SEL_SET(x)                            (((x) << RST_MISC2_PCIE_CLKOBS1_SEL_LSB) & RST_MISC2_PCIE_CLKOBS1_SEL_MASK)
+#define RST_MISC2_PCIE_CLKOBS1_SEL_RESET                             0x0 // 0
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_MSB                     27
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_LSB                     27
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_MASK                    0x08000000
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_GET(x)                  (((x) & RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_MASK) >> RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_LSB)
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_SET(x)                  (((x) << RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_LSB) & RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_MASK)
+#define RST_MISC2_JTAG_EJTAG_SWITCH_CPU_CTRL_RESET                   0x0 // 0
+#define RST_MISC2_WOW_STATUS_MSB                                     26
+#define RST_MISC2_WOW_STATUS_LSB                                     26
+#define RST_MISC2_WOW_STATUS_MASK                                    0x04000000
+#define RST_MISC2_WOW_STATUS_GET(x)                                  (((x) & RST_MISC2_WOW_STATUS_MASK) >> RST_MISC2_WOW_STATUS_LSB)
+#define RST_MISC2_WOW_STATUS_SET(x)                                  (((x) << RST_MISC2_WOW_STATUS_LSB) & RST_MISC2_WOW_STATUS_MASK)
+#define RST_MISC2_WOW_STATUS_RESET                                   0x0 // 0
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_MSB                             25
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_LSB                             25
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_MASK                            0x02000000
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L2_EXIT_INT_MASK) >> RST_MISC2_PCIEEP_L2_EXIT_INT_LSB)
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L2_EXIT_INT_LSB) & RST_MISC2_PCIEEP_L2_EXIT_INT_MASK)
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_MSB                             24
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_LSB                             24
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_MASK                            0x01000000
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L2_ENTR_INT_MASK) >> RST_MISC2_PCIEEP_L2_ENTR_INT_LSB)
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L2_ENTR_INT_LSB) & RST_MISC2_PCIEEP_L2_ENTR_INT_MASK)
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_MSB                             23
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_LSB                             23
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_MASK                            0x00800000
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L1_EXIT_INT_MASK) >> RST_MISC2_PCIEEP_L1_EXIT_INT_LSB)
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L1_EXIT_INT_LSB) & RST_MISC2_PCIEEP_L1_EXIT_INT_MASK)
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_MSB                             22
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_LSB                             22
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_MASK                            0x00400000
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L1_ENTR_INT_MASK) >> RST_MISC2_PCIEEP_L1_ENTR_INT_LSB)
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L1_ENTR_INT_LSB) & RST_MISC2_PCIEEP_L1_ENTR_INT_MASK)
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_MSB                            21
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_LSB                            21
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_MASK                           0x00200000
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_GET(x)                         (((x) & RST_MISC2_PCIEEP_L0S_EXIT_INT_MASK) >> RST_MISC2_PCIEEP_L0S_EXIT_INT_LSB)
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_SET(x)                         (((x) << RST_MISC2_PCIEEP_L0S_EXIT_INT_LSB) & RST_MISC2_PCIEEP_L0S_EXIT_INT_MASK)
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_RESET                          0x0 // 0
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_MSB                            20
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_LSB                            20
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_MASK                           0x00100000
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_GET(x)                         (((x) & RST_MISC2_PCIEEP_L0S_ENTR_INT_MASK) >> RST_MISC2_PCIEEP_L0S_ENTR_INT_LSB)
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_SET(x)                         (((x) << RST_MISC2_PCIEEP_L0S_ENTR_INT_LSB) & RST_MISC2_PCIEEP_L0S_ENTR_INT_MASK)
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_RESET                          0x0 // 0
+#define RST_MISC2_PCIEEP_REGWR_EN_MSB                                19
+#define RST_MISC2_PCIEEP_REGWR_EN_LSB                                19
+#define RST_MISC2_PCIEEP_REGWR_EN_MASK                               0x00080000
+#define RST_MISC2_PCIEEP_REGWR_EN_GET(x)                             (((x) & RST_MISC2_PCIEEP_REGWR_EN_MASK) >> RST_MISC2_PCIEEP_REGWR_EN_LSB)
+#define RST_MISC2_PCIEEP_REGWR_EN_SET(x)                             (((x) << RST_MISC2_PCIEEP_REGWR_EN_LSB) & RST_MISC2_PCIEEP_REGWR_EN_MASK)
+#define RST_MISC2_PCIEEP_REGWR_EN_RESET                              0x1 // 1
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_MSB                           18
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_LSB                           18
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_MASK                          0x00040000
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_GET(x)                        (((x) & RST_MISC2_EXT_HOST_WASP_RST_EN_MASK) >> RST_MISC2_EXT_HOST_WASP_RST_EN_LSB)
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_SET(x)                        (((x) << RST_MISC2_EXT_HOST_WASP_RST_EN_LSB) & RST_MISC2_EXT_HOST_WASP_RST_EN_MASK)
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_RESET                         0x0 // 0
+#define RST_MISC2_PCIEEP_RST_INT_MSB                                 17
+#define RST_MISC2_PCIEEP_RST_INT_LSB                                 17
+#define RST_MISC2_PCIEEP_RST_INT_MASK                                0x00020000
+#define RST_MISC2_PCIEEP_RST_INT_GET(x)                              (((x) & RST_MISC2_PCIEEP_RST_INT_MASK) >> RST_MISC2_PCIEEP_RST_INT_LSB)
+#define RST_MISC2_PCIEEP_RST_INT_SET(x)                              (((x) << RST_MISC2_PCIEEP_RST_INT_LSB) & RST_MISC2_PCIEEP_RST_INT_MASK)
+#define RST_MISC2_PCIEEP_RST_INT_RESET                               0x0 // 0
+#define RST_MISC2_HOST_RESET_INT_MSB                                 16
+#define RST_MISC2_HOST_RESET_INT_LSB                                 16
+#define RST_MISC2_HOST_RESET_INT_MASK                                0x00010000
+#define RST_MISC2_HOST_RESET_INT_GET(x)                              (((x) & RST_MISC2_HOST_RESET_INT_MASK) >> RST_MISC2_HOST_RESET_INT_LSB)
+#define RST_MISC2_HOST_RESET_INT_SET(x)                              (((x) << RST_MISC2_HOST_RESET_INT_LSB) & RST_MISC2_HOST_RESET_INT_MASK)
+#define RST_MISC2_HOST_RESET_INT_RESET                               0x0 // 0
+#define RST_MISC2_CPU_HOST_WA_MSB                                    15
+#define RST_MISC2_CPU_HOST_WA_LSB                                    15
+#define RST_MISC2_CPU_HOST_WA_MASK                                   0x00008000
+#define RST_MISC2_CPU_HOST_WA_GET(x)                                 (((x) & RST_MISC2_CPU_HOST_WA_MASK) >> RST_MISC2_CPU_HOST_WA_LSB)
+#define RST_MISC2_CPU_HOST_WA_SET(x)                                 (((x) << RST_MISC2_CPU_HOST_WA_LSB) & RST_MISC2_CPU_HOST_WA_MASK)
+#define RST_MISC2_CPU_HOST_WA_RESET                                  0x0 // 0
+#define RST_MISC2_PERSTN_RCPHY2_MSB                                  14
+#define RST_MISC2_PERSTN_RCPHY2_LSB                                  14
+#define RST_MISC2_PERSTN_RCPHY2_MASK                                 0x00004000
+#define RST_MISC2_PERSTN_RCPHY2_GET(x)                               (((x) & RST_MISC2_PERSTN_RCPHY2_MASK) >> RST_MISC2_PERSTN_RCPHY2_LSB)
+#define RST_MISC2_PERSTN_RCPHY2_SET(x)                               (((x) << RST_MISC2_PERSTN_RCPHY2_LSB) & RST_MISC2_PERSTN_RCPHY2_MASK)
+#define RST_MISC2_PERSTN_RCPHY2_RESET                                0x1 // 1
+#define RST_MISC2_PERSTN_RCPHY_MSB                                   13
+#define RST_MISC2_PERSTN_RCPHY_LSB                                   13
+#define RST_MISC2_PERSTN_RCPHY_MASK                                  0x00002000
+#define RST_MISC2_PERSTN_RCPHY_GET(x)                                (((x) & RST_MISC2_PERSTN_RCPHY_MASK) >> RST_MISC2_PERSTN_RCPHY_LSB)
+#define RST_MISC2_PERSTN_RCPHY_SET(x)                                (((x) << RST_MISC2_PERSTN_RCPHY_LSB) & RST_MISC2_PERSTN_RCPHY_MASK)
+#define RST_MISC2_PERSTN_RCPHY_RESET                                 0x1 // 1
+#define RST_MISC2_PCIEEP_LTSSM_STATE_MSB                             12
+#define RST_MISC2_PCIEEP_LTSSM_STATE_LSB                             8
+#define RST_MISC2_PCIEEP_LTSSM_STATE_MASK                            0x00001f00
+#define RST_MISC2_PCIEEP_LTSSM_STATE_GET(x)                          (((x) & RST_MISC2_PCIEEP_LTSSM_STATE_MASK) >> RST_MISC2_PCIEEP_LTSSM_STATE_LSB)
+#define RST_MISC2_PCIEEP_LTSSM_STATE_SET(x)                          (((x) << RST_MISC2_PCIEEP_LTSSM_STATE_LSB) & RST_MISC2_PCIEEP_LTSSM_STATE_MASK)
+#define RST_MISC2_PCIEEP_LTSSM_STATE_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_LINK_STATUS_MSB                             4
+#define RST_MISC2_PCIEEP_LINK_STATUS_LSB                             4
+#define RST_MISC2_PCIEEP_LINK_STATUS_MASK                            0x00000010
+#define RST_MISC2_PCIEEP_LINK_STATUS_GET(x)                          (((x) & RST_MISC2_PCIEEP_LINK_STATUS_MASK) >> RST_MISC2_PCIEEP_LINK_STATUS_LSB)
+#define RST_MISC2_PCIEEP_LINK_STATUS_SET(x)                          (((x) << RST_MISC2_PCIEEP_LINK_STATUS_LSB) & RST_MISC2_PCIEEP_LINK_STATUS_MASK)
+#define RST_MISC2_PCIEEP_LINK_STATUS_RESET                           0x0 // 0
+#define RST_MISC2_WOW_DETECT_MSB                                     3
+#define RST_MISC2_WOW_DETECT_LSB                                     3
+#define RST_MISC2_WOW_DETECT_MASK                                    0x00000008
+#define RST_MISC2_WOW_DETECT_GET(x)                                  (((x) & RST_MISC2_WOW_DETECT_MASK) >> RST_MISC2_WOW_DETECT_LSB)
+#define RST_MISC2_WOW_DETECT_SET(x)                                  (((x) << RST_MISC2_WOW_DETECT_LSB) & RST_MISC2_WOW_DETECT_MASK)
+#define RST_MISC2_WOW_DETECT_RESET                                   0x0 // 0
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_MSB                           2
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_LSB                           2
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_MASK                          0x00000004
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_GET(x)                        (((x) & RST_MISC2_PCIEEP_RXDETECT_DONE_MASK) >> RST_MISC2_PCIEEP_RXDETECT_DONE_LSB)
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_SET(x)                        (((x) << RST_MISC2_PCIEEP_RXDETECT_DONE_LSB) & RST_MISC2_PCIEEP_RXDETECT_DONE_MASK)
+#define RST_MISC2_PCIEEP_RXDETECT_DONE_RESET                         0x0 // 0
+#define RST_MISC2_PCIEEP_WOW_INT_MSB                                 1
+#define RST_MISC2_PCIEEP_WOW_INT_LSB                                 1
+#define RST_MISC2_PCIEEP_WOW_INT_MASK                                0x00000002
+#define RST_MISC2_PCIEEP_WOW_INT_GET(x)                              (((x) & RST_MISC2_PCIEEP_WOW_INT_MASK) >> RST_MISC2_PCIEEP_WOW_INT_LSB)
+#define RST_MISC2_PCIEEP_WOW_INT_SET(x)                              (((x) << RST_MISC2_PCIEEP_WOW_INT_LSB) & RST_MISC2_PCIEEP_WOW_INT_MASK)
+#define RST_MISC2_PCIEEP_WOW_INT_RESET                               0x0 // 0
+#define RST_MISC2_PCIEEP_CFG_DONE_MSB                                0
+#define RST_MISC2_PCIEEP_CFG_DONE_LSB                                0
+#define RST_MISC2_PCIEEP_CFG_DONE_MASK                               0x00000001
+#define RST_MISC2_PCIEEP_CFG_DONE_GET(x)                             (((x) & RST_MISC2_PCIEEP_CFG_DONE_MASK) >> RST_MISC2_PCIEEP_CFG_DONE_LSB)
+#define RST_MISC2_PCIEEP_CFG_DONE_SET(x)                             (((x) << RST_MISC2_PCIEEP_CFG_DONE_LSB) & RST_MISC2_PCIEEP_CFG_DONE_MASK)
+#define RST_MISC2_PCIEEP_CFG_DONE_RESET                              0x0 // 0
+#define RST_MISC2_ADDRESS                                            0x180600bc
+
+#define PCIE_APP_CFG_TYPE_MSB                                        21
+#define PCIE_APP_CFG_TYPE_LSB                                        20
+#define PCIE_APP_CFG_TYPE_MASK                                       0x00300000
+#define PCIE_APP_CFG_TYPE_GET(x)                                     (((x) & PCIE_APP_CFG_TYPE_MASK) >> PCIE_APP_CFG_TYPE_LSB)
+#define PCIE_APP_CFG_TYPE_SET(x)                                     (((x) << PCIE_APP_CFG_TYPE_LSB) & PCIE_APP_CFG_TYPE_MASK)
+#define PCIE_APP_CFG_TYPE_RESET                                      0x0 // 0
+#define PCIE_APP_PCIE_BAR_MSN_MSB                                    19
+#define PCIE_APP_PCIE_BAR_MSN_LSB                                    16
+#define PCIE_APP_PCIE_BAR_MSN_MASK                                   0x000f0000
+#define PCIE_APP_PCIE_BAR_MSN_GET(x)                                 (((x) & PCIE_APP_PCIE_BAR_MSN_MASK) >> PCIE_APP_PCIE_BAR_MSN_LSB)
+#define PCIE_APP_PCIE_BAR_MSN_SET(x)                                 (((x) << PCIE_APP_PCIE_BAR_MSN_LSB) & PCIE_APP_PCIE_BAR_MSN_MASK)
+#define PCIE_APP_PCIE_BAR_MSN_RESET                                  0x1 // 1
+#define PCIE_APP_CFG_BE_MSB                                          15
+#define PCIE_APP_CFG_BE_LSB                                          12
+#define PCIE_APP_CFG_BE_MASK                                         0x0000f000
+#define PCIE_APP_CFG_BE_GET(x)                                       (((x) & PCIE_APP_CFG_BE_MASK) >> PCIE_APP_CFG_BE_LSB)
+#define PCIE_APP_CFG_BE_SET(x)                                       (((x) << PCIE_APP_CFG_BE_LSB) & PCIE_APP_CFG_BE_MASK)
+#define PCIE_APP_CFG_BE_RESET                                        0xf // 15
+#define PCIE_APP_SLV_RESP_ERR_MAP_MSB                                11
+#define PCIE_APP_SLV_RESP_ERR_MAP_LSB                                6
+#define PCIE_APP_SLV_RESP_ERR_MAP_MASK                               0x00000fc0
+#define PCIE_APP_SLV_RESP_ERR_MAP_GET(x)                             (((x) & PCIE_APP_SLV_RESP_ERR_MAP_MASK) >> PCIE_APP_SLV_RESP_ERR_MAP_LSB)
+#define PCIE_APP_SLV_RESP_ERR_MAP_SET(x)                             (((x) << PCIE_APP_SLV_RESP_ERR_MAP_LSB) & PCIE_APP_SLV_RESP_ERR_MAP_MASK)
+#define PCIE_APP_SLV_RESP_ERR_MAP_RESET                              0x3f // 63
+#define PCIE_APP_MSTR_RESP_ERR_MAP_MSB                               5
+#define PCIE_APP_MSTR_RESP_ERR_MAP_LSB                               4
+#define PCIE_APP_MSTR_RESP_ERR_MAP_MASK                              0x00000030
+#define PCIE_APP_MSTR_RESP_ERR_MAP_GET(x)                            (((x) & PCIE_APP_MSTR_RESP_ERR_MAP_MASK) >> PCIE_APP_MSTR_RESP_ERR_MAP_LSB)
+#define PCIE_APP_MSTR_RESP_ERR_MAP_SET(x)                            (((x) << PCIE_APP_MSTR_RESP_ERR_MAP_LSB) & PCIE_APP_MSTR_RESP_ERR_MAP_MASK)
+#define PCIE_APP_MSTR_RESP_ERR_MAP_RESET                             0x0 // 0
+#define PCIE_APP_INIT_RST_MSB                                        3
+#define PCIE_APP_INIT_RST_LSB                                        3
+#define PCIE_APP_INIT_RST_MASK                                       0x00000008
+#define PCIE_APP_INIT_RST_GET(x)                                     (((x) & PCIE_APP_INIT_RST_MASK) >> PCIE_APP_INIT_RST_LSB)
+#define PCIE_APP_INIT_RST_SET(x)                                     (((x) << PCIE_APP_INIT_RST_LSB) & PCIE_APP_INIT_RST_MASK)
+#define PCIE_APP_INIT_RST_RESET                                      0x0 // 0
+#define PCIE_APP_PM_XMT_TURNOFF_MSB                                  2
+#define PCIE_APP_PM_XMT_TURNOFF_LSB                                  2
+#define PCIE_APP_PM_XMT_TURNOFF_MASK                                 0x00000004
+#define PCIE_APP_PM_XMT_TURNOFF_GET(x)                               (((x) & PCIE_APP_PM_XMT_TURNOFF_MASK) >> PCIE_APP_PM_XMT_TURNOFF_LSB)
+#define PCIE_APP_PM_XMT_TURNOFF_SET(x)                               (((x) << PCIE_APP_PM_XMT_TURNOFF_LSB) & PCIE_APP_PM_XMT_TURNOFF_MASK)
+#define PCIE_APP_PM_XMT_TURNOFF_RESET                                0x0 // 0
+#define PCIE_APP_UNLOCK_MSG_MSB                                      1
+#define PCIE_APP_UNLOCK_MSG_LSB                                      1
+#define PCIE_APP_UNLOCK_MSG_MASK                                     0x00000002
+#define PCIE_APP_UNLOCK_MSG_GET(x)                                   (((x) & PCIE_APP_UNLOCK_MSG_MASK) >> PCIE_APP_UNLOCK_MSG_LSB)
+#define PCIE_APP_UNLOCK_MSG_SET(x)                                   (((x) << PCIE_APP_UNLOCK_MSG_LSB) & PCIE_APP_UNLOCK_MSG_MASK)
+#define PCIE_APP_UNLOCK_MSG_RESET                                    0x0 // 0
+#define PCIE_APP_LTSSM_ENABLE_MSB                                    0
+#define PCIE_APP_LTSSM_ENABLE_LSB                                    0
+#define PCIE_APP_LTSSM_ENABLE_MASK                                   0x00000001
+#define PCIE_APP_LTSSM_ENABLE_GET(x)                                 (((x) & PCIE_APP_LTSSM_ENABLE_MASK) >> PCIE_APP_LTSSM_ENABLE_LSB)
+#define PCIE_APP_LTSSM_ENABLE_SET(x)                                 (((x) << PCIE_APP_LTSSM_ENABLE_LSB) & PCIE_APP_LTSSM_ENABLE_MASK)
+#define PCIE_APP_LTSSM_ENABLE_RESET                                  0x0 // 0
+#define PCIE_APP_ADDRESS                                             0x180f0000
+
+
+#define XTAL_TCXODET_MSB                                             31
+#define XTAL_TCXODET_LSB                                             31
+#define XTAL_TCXODET_MASK                                            0x80000000
+#define XTAL_TCXODET_GET(x)                                          (((x) & XTAL_TCXODET_MASK) >> XTAL_TCXODET_LSB)
+#define XTAL_TCXODET_SET(x)                                          (((x) << XTAL_TCXODET_LSB) & XTAL_TCXODET_MASK)
+#define XTAL_TCXODET_RESET                                           0x0 // 0
+#define XTAL_XTAL_CAPINDAC_MSB                                       30
+#define XTAL_XTAL_CAPINDAC_LSB                                       24
+#define XTAL_XTAL_CAPINDAC_MASK                                      0x7f000000
+#define XTAL_XTAL_CAPINDAC_GET(x)                                    (((x) & XTAL_XTAL_CAPINDAC_MASK) >> XTAL_XTAL_CAPINDAC_LSB)
+#define XTAL_XTAL_CAPINDAC_SET(x)                                    (((x) << XTAL_XTAL_CAPINDAC_LSB) & XTAL_XTAL_CAPINDAC_MASK)
+#define XTAL_XTAL_CAPINDAC_RESET                                     0x4b // 75
+#define XTAL_XTAL_CAPOUTDAC_MSB                                      23
+#define XTAL_XTAL_CAPOUTDAC_LSB                                      17
+#define XTAL_XTAL_CAPOUTDAC_MASK                                     0x00fe0000
+#define XTAL_XTAL_CAPOUTDAC_GET(x)                                   (((x) & XTAL_XTAL_CAPOUTDAC_MASK) >> XTAL_XTAL_CAPOUTDAC_LSB)
+#define XTAL_XTAL_CAPOUTDAC_SET(x)                                   (((x) << XTAL_XTAL_CAPOUTDAC_LSB) & XTAL_XTAL_CAPOUTDAC_MASK)
+#define XTAL_XTAL_CAPOUTDAC_RESET                                    0x4b // 75
+#define XTAL_XTAL_DRVSTR_MSB                                         16
+#define XTAL_XTAL_DRVSTR_LSB                                         15
+#define XTAL_XTAL_DRVSTR_MASK                                        0x00018000
+#define XTAL_XTAL_DRVSTR_GET(x)                                      (((x) & XTAL_XTAL_DRVSTR_MASK) >> XTAL_XTAL_DRVSTR_LSB)
+#define XTAL_XTAL_DRVSTR_SET(x)                                      (((x) << XTAL_XTAL_DRVSTR_LSB) & XTAL_XTAL_DRVSTR_MASK)
+#define XTAL_XTAL_DRVSTR_RESET                                       0x0 // 0
+#define XTAL_XTAL_SHORTXIN_MSB                                       14
+#define XTAL_XTAL_SHORTXIN_LSB                                       14
+#define XTAL_XTAL_SHORTXIN_MASK                                      0x00004000
+#define XTAL_XTAL_SHORTXIN_GET(x)                                    (((x) & XTAL_XTAL_SHORTXIN_MASK) >> XTAL_XTAL_SHORTXIN_LSB)
+#define XTAL_XTAL_SHORTXIN_SET(x)                                    (((x) << XTAL_XTAL_SHORTXIN_LSB) & XTAL_XTAL_SHORTXIN_MASK)
+#define XTAL_XTAL_SHORTXIN_RESET                                     0x0 // 0
+#define XTAL_XTAL_LOCALBIAS_MSB                                      13
+#define XTAL_XTAL_LOCALBIAS_LSB                                      13
+#define XTAL_XTAL_LOCALBIAS_MASK                                     0x00002000
+#define XTAL_XTAL_LOCALBIAS_GET(x)                                   (((x) & XTAL_XTAL_LOCALBIAS_MASK) >> XTAL_XTAL_LOCALBIAS_LSB)
+#define XTAL_XTAL_LOCALBIAS_SET(x)                                   (((x) << XTAL_XTAL_LOCALBIAS_LSB) & XTAL_XTAL_LOCALBIAS_MASK)
+#define XTAL_XTAL_LOCALBIAS_RESET                                    0x1 // 1
+#define XTAL_XTAL_PWDCLKD_MSB                                        12
+#define XTAL_XTAL_PWDCLKD_LSB                                        12
+#define XTAL_XTAL_PWDCLKD_MASK                                       0x00001000
+#define XTAL_XTAL_PWDCLKD_GET(x)                                     (((x) & XTAL_XTAL_PWDCLKD_MASK) >> XTAL_XTAL_PWDCLKD_LSB)
+#define XTAL_XTAL_PWDCLKD_SET(x)                                     (((x) << XTAL_XTAL_PWDCLKD_LSB) & XTAL_XTAL_PWDCLKD_MASK)
+#define XTAL_XTAL_PWDCLKD_RESET                                      0x0 // 0
+#define XTAL_XTAL_BIAS2X_MSB                                         11
+#define XTAL_XTAL_BIAS2X_LSB                                         11
+#define XTAL_XTAL_BIAS2X_MASK                                        0x00000800
+#define XTAL_XTAL_BIAS2X_GET(x)                                      (((x) & XTAL_XTAL_BIAS2X_MASK) >> XTAL_XTAL_BIAS2X_LSB)
+#define XTAL_XTAL_BIAS2X_SET(x)                                      (((x) << XTAL_XTAL_BIAS2X_LSB) & XTAL_XTAL_BIAS2X_MASK)
+#define XTAL_XTAL_BIAS2X_RESET                                       0x1 // 1
+#define XTAL_XTAL_LBIAS2X_MSB                                        10
+#define XTAL_XTAL_LBIAS2X_LSB                                        10
+#define XTAL_XTAL_LBIAS2X_MASK                                       0x00000400
+#define XTAL_XTAL_LBIAS2X_GET(x)                                     (((x) & XTAL_XTAL_LBIAS2X_MASK) >> XTAL_XTAL_LBIAS2X_LSB)
+#define XTAL_XTAL_LBIAS2X_SET(x)                                     (((x) << XTAL_XTAL_LBIAS2X_LSB) & XTAL_XTAL_LBIAS2X_MASK)
+#define XTAL_XTAL_LBIAS2X_RESET                                      0x1 // 1
+#define XTAL_XTAL_ATBVREG_MSB                                        9
+#define XTAL_XTAL_ATBVREG_LSB                                        9
+#define XTAL_XTAL_ATBVREG_MASK                                       0x00000200
+#define XTAL_XTAL_ATBVREG_GET(x)                                     (((x) & XTAL_XTAL_ATBVREG_MASK) >> XTAL_XTAL_ATBVREG_LSB)
+#define XTAL_XTAL_ATBVREG_SET(x)                                     (((x) << XTAL_XTAL_ATBVREG_LSB) & XTAL_XTAL_ATBVREG_MASK)
+#define XTAL_XTAL_ATBVREG_RESET                                      0x0 // 0
+#define XTAL_XTAL_OSCON_MSB                                          8
+#define XTAL_XTAL_OSCON_LSB                                          8
+#define XTAL_XTAL_OSCON_MASK                                         0x00000100
+#define XTAL_XTAL_OSCON_GET(x)                                       (((x) & XTAL_XTAL_OSCON_MASK) >> XTAL_XTAL_OSCON_LSB)
+#define XTAL_XTAL_OSCON_SET(x)                                       (((x) << XTAL_XTAL_OSCON_LSB) & XTAL_XTAL_OSCON_MASK)
+#define XTAL_XTAL_OSCON_RESET                                        0x1 // 1
+#define XTAL_XTAL_PWDCLKIN_MSB                                       7
+#define XTAL_XTAL_PWDCLKIN_LSB                                       7
+#define XTAL_XTAL_PWDCLKIN_MASK                                      0x00000080
+#define XTAL_XTAL_PWDCLKIN_GET(x)                                    (((x) & XTAL_XTAL_PWDCLKIN_MASK) >> XTAL_XTAL_PWDCLKIN_LSB)
+#define XTAL_XTAL_PWDCLKIN_SET(x)                                    (((x) << XTAL_XTAL_PWDCLKIN_LSB) & XTAL_XTAL_PWDCLKIN_MASK)
+#define XTAL_XTAL_PWDCLKIN_RESET                                     0x0 // 0
+#define XTAL_LOCAL_XTAL_MSB                                          6
+#define XTAL_LOCAL_XTAL_LSB                                          6
+#define XTAL_LOCAL_XTAL_MASK                                         0x00000040
+#define XTAL_LOCAL_XTAL_GET(x)                                       (((x) & XTAL_LOCAL_XTAL_MASK) >> XTAL_LOCAL_XTAL_LSB)
+#define XTAL_LOCAL_XTAL_SET(x)                                       (((x) << XTAL_LOCAL_XTAL_LSB) & XTAL_LOCAL_XTAL_MASK)
+#define XTAL_LOCAL_XTAL_RESET                                        0x0 // 0
+#define XTAL_PWD_SWREGCLK_MSB                                        5
+#define XTAL_PWD_SWREGCLK_LSB                                        5
+#define XTAL_PWD_SWREGCLK_MASK                                       0x00000020
+#define XTAL_PWD_SWREGCLK_GET(x)                                     (((x) & XTAL_PWD_SWREGCLK_MASK) >> XTAL_PWD_SWREGCLK_LSB)
+#define XTAL_PWD_SWREGCLK_SET(x)                                     (((x) << XTAL_PWD_SWREGCLK_LSB) & XTAL_PWD_SWREGCLK_MASK)
+#define XTAL_PWD_SWREGCLK_RESET                                      0x0 // 0
+#define XTAL_SWREGCLK_EDGE_SEL_MSB                                   4
+#define XTAL_SWREGCLK_EDGE_SEL_LSB                                   4
+#define XTAL_SWREGCLK_EDGE_SEL_MASK                                  0x00000010
+#define XTAL_SWREGCLK_EDGE_SEL_GET(x)                                (((x) & XTAL_SWREGCLK_EDGE_SEL_MASK) >> XTAL_SWREGCLK_EDGE_SEL_LSB)
+#define XTAL_SWREGCLK_EDGE_SEL_SET(x)                                (((x) << XTAL_SWREGCLK_EDGE_SEL_LSB) & XTAL_SWREGCLK_EDGE_SEL_MASK)
+#define XTAL_SWREGCLK_EDGE_SEL_RESET                                 0x0 // 0
+#define XTAL_SPARE_MSB                                               3
+#define XTAL_SPARE_LSB                                               0
+#define XTAL_SPARE_MASK                                              0x0000000f
+#define XTAL_SPARE_GET(x)                                            (((x) & XTAL_SPARE_MASK) >> XTAL_SPARE_LSB)
+#define XTAL_SPARE_SET(x)                                            (((x) << XTAL_SPARE_LSB) & XTAL_SPARE_MASK)
+#define XTAL_SPARE_RESET                                             0xf // 15
+#define XTAL_ADDRESS                                                 0x18116290
+
+#define RST_REVISION_ID_ADDRESS                                      0x18060090
+#define is_drqfn()	(!(ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0x1000))
+
+#define RST_BOOTSTRAP_BOOT_INTF_SEL_MSB                              17
+#define RST_BOOTSTRAP_BOOT_INTF_SEL_LSB                              16
+#define RST_BOOTSTRAP_BOOT_INTF_SEL_MASK                             0x00030000
+#define RST_BOOTSTRAP_BOOT_INTF_SEL_GET(x)                           (((x) & RST_BOOTSTRAP_BOOT_INTF_SEL_MASK) >> RST_BOOTSTRAP_BOOT_INTF_SEL_LSB)
+#define RST_BOOTSTRAP_BOOT_INTF_SEL_SET(x)                           (((x) << RST_BOOTSTRAP_BOOT_INTF_SEL_LSB) & RST_BOOTSTRAP_BOOT_INTF_SEL_MASK)
+#define RST_BOOTSTRAP_BOOT_INTF_SEL_RESET                            0x0 // 0
+#define RST_BOOTSTRAP_RES0_MSB                                       15
+#define RST_BOOTSTRAP_RES0_LSB                                       13
+#define RST_BOOTSTRAP_RES0_MASK                                      0x0000e000
+#define RST_BOOTSTRAP_RES0_GET(x)                                    (((x) & RST_BOOTSTRAP_RES0_MASK) >> RST_BOOTSTRAP_RES0_LSB)
+#define RST_BOOTSTRAP_RES0_SET(x)                                    (((x) << RST_BOOTSTRAP_RES0_LSB) & RST_BOOTSTRAP_RES0_MASK)
+#define RST_BOOTSTRAP_RES0_RESET                                     0x0 // 0
+#define RST_BOOTSTRAP_SW_OPTION2_MSB                                 12
+#define RST_BOOTSTRAP_SW_OPTION2_LSB                                 12
+#define RST_BOOTSTRAP_SW_OPTION2_MASK                                0x00001000
+#define RST_BOOTSTRAP_SW_OPTION2_GET(x)                              (((x) & RST_BOOTSTRAP_SW_OPTION2_MASK) >> RST_BOOTSTRAP_SW_OPTION2_LSB)
+#define RST_BOOTSTRAP_SW_OPTION2_SET(x)                              (((x) << RST_BOOTSTRAP_SW_OPTION2_LSB) & RST_BOOTSTRAP_SW_OPTION2_MASK)
+#define RST_BOOTSTRAP_SW_OPTION2_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_SW_OPTION1_MSB                                 11
+#define RST_BOOTSTRAP_SW_OPTION1_LSB                                 11
+#define RST_BOOTSTRAP_SW_OPTION1_MASK                                0x00000800
+#define RST_BOOTSTRAP_SW_OPTION1_GET(x)                              (((x) & RST_BOOTSTRAP_SW_OPTION1_MASK) >> RST_BOOTSTRAP_SW_OPTION1_LSB)
+#define RST_BOOTSTRAP_SW_OPTION1_SET(x)                              (((x) << RST_BOOTSTRAP_SW_OPTION1_LSB) & RST_BOOTSTRAP_SW_OPTION1_MASK)
+#define RST_BOOTSTRAP_SW_OPTION1_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_TESTROM_DISABLE_MSB                            10
+#define RST_BOOTSTRAP_TESTROM_DISABLE_LSB                            10
+#define RST_BOOTSTRAP_TESTROM_DISABLE_MASK                           0x00000400
+#define RST_BOOTSTRAP_TESTROM_DISABLE_GET(x)                         (((x) & RST_BOOTSTRAP_TESTROM_DISABLE_MASK) >> RST_BOOTSTRAP_TESTROM_DISABLE_LSB)
+#define RST_BOOTSTRAP_TESTROM_DISABLE_SET(x)                         (((x) << RST_BOOTSTRAP_TESTROM_DISABLE_LSB) & RST_BOOTSTRAP_TESTROM_DISABLE_MASK)
+#define RST_BOOTSTRAP_TESTROM_DISABLE_RESET                          0x1 // 1
+#define RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_MSB                      9
+#define RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_LSB                      9
+#define RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_MASK                     0x00000200
+#define RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_GET(x)                   (((x) & RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_MASK) >> RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_LSB)
+#define RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_SET(x)                   (((x) << RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_LSB) & RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_MASK)
+#define RST_BOOTSTRAP_DISABLE_OTPMEM_ACCESS_RESET                    0x0 // 0
+#define RST_BOOTSTRAP_SRIF_ENABLE_MSB                                8
+#define RST_BOOTSTRAP_SRIF_ENABLE_LSB                                8
+#define RST_BOOTSTRAP_SRIF_ENABLE_MASK                               0x00000100
+#define RST_BOOTSTRAP_SRIF_ENABLE_GET(x)                             (((x) & RST_BOOTSTRAP_SRIF_ENABLE_MASK) >> RST_BOOTSTRAP_SRIF_ENABLE_LSB)
+#define RST_BOOTSTRAP_SRIF_ENABLE_SET(x)                             (((x) << RST_BOOTSTRAP_SRIF_ENABLE_LSB) & RST_BOOTSTRAP_SRIF_ENABLE_MASK)
+#define RST_BOOTSTRAP_SRIF_ENABLE_RESET                              0x0 // 0
+#define RST_BOOTSTRAP_USB_MODE_MSB                                   7
+#define RST_BOOTSTRAP_USB_MODE_LSB                                   7
+#define RST_BOOTSTRAP_USB_MODE_MASK                                  0x00000080
+#define RST_BOOTSTRAP_USB_MODE_GET(x)                                (((x) & RST_BOOTSTRAP_USB_MODE_MASK) >> RST_BOOTSTRAP_USB_MODE_LSB)
+#define RST_BOOTSTRAP_USB_MODE_SET(x)                                (((x) << RST_BOOTSTRAP_USB_MODE_LSB) & RST_BOOTSTRAP_USB_MODE_MASK)
+#define RST_BOOTSTRAP_USB_MODE_RESET                                 0x0 // 0
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_MSB                          6
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_LSB                          6
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_MASK                         0x00000040
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_GET(x)                       (((x) & RST_BOOTSTRAP_PCIE_RC_EP_SELECT_MASK) >> RST_BOOTSTRAP_PCIE_RC_EP_SELECT_LSB)
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_SET(x)                       (((x) << RST_BOOTSTRAP_PCIE_RC_EP_SELECT_LSB) & RST_BOOTSTRAP_PCIE_RC_EP_SELECT_MASK)
+#define RST_BOOTSTRAP_PCIE_RC_EP_SELECT_RESET                        0x0 // 0
+#define RST_BOOTSTRAP_JTAG_MODE_MSB                                  5
+#define RST_BOOTSTRAP_JTAG_MODE_LSB                                  5
+#define RST_BOOTSTRAP_JTAG_MODE_MASK                                 0x00000020
+#define RST_BOOTSTRAP_JTAG_MODE_GET(x)                               (((x) & RST_BOOTSTRAP_JTAG_MODE_MASK) >> RST_BOOTSTRAP_JTAG_MODE_LSB)
+#define RST_BOOTSTRAP_JTAG_MODE_SET(x)                               (((x) << RST_BOOTSTRAP_JTAG_MODE_LSB) & RST_BOOTSTRAP_JTAG_MODE_MASK)
+#define RST_BOOTSTRAP_JTAG_MODE_RESET                                0x1 // 1
+#define RST_BOOTSTRAP_REF_CLK_MSB                                    4
+#define RST_BOOTSTRAP_REF_CLK_LSB                                    4
+#define RST_BOOTSTRAP_REF_CLK_MASK                                   0x00000010
+#define RST_BOOTSTRAP_REF_CLK_GET(x)                                 (((x) & RST_BOOTSTRAP_REF_CLK_MASK) >> RST_BOOTSTRAP_REF_CLK_LSB)
+#define RST_BOOTSTRAP_REF_CLK_SET(x)                                 (((x) << RST_BOOTSTRAP_REF_CLK_LSB) & RST_BOOTSTRAP_REF_CLK_MASK)
+#define RST_BOOTSTRAP_REF_CLK_RESET                                  0x0 // 0
+#define RST_BOOTSTRAP_DDR_WIDTH_MSB                                  3
+#define RST_BOOTSTRAP_DDR_WIDTH_LSB                                  3
+#define RST_BOOTSTRAP_DDR_WIDTH_MASK                                 0x00000008
+#define RST_BOOTSTRAP_DDR_WIDTH_GET(x)                               (((x) & RST_BOOTSTRAP_DDR_WIDTH_MASK) >> RST_BOOTSTRAP_DDR_WIDTH_LSB)
+#define RST_BOOTSTRAP_DDR_WIDTH_SET(x)                               (((x) << RST_BOOTSTRAP_DDR_WIDTH_LSB) & RST_BOOTSTRAP_DDR_WIDTH_MASK)
+#define RST_BOOTSTRAP_DDR_WIDTH_RESET                                0x0 // 0
+#define RST_BOOTSTRAP_BOOT_SELECT_MSB                                2
+#define RST_BOOTSTRAP_BOOT_SELECT_LSB                                2
+#define RST_BOOTSTRAP_BOOT_SELECT_MASK                               0x00000004
+#define RST_BOOTSTRAP_BOOT_SELECT_GET(x)                             (((x) & RST_BOOTSTRAP_BOOT_SELECT_MASK) >> RST_BOOTSTRAP_BOOT_SELECT_LSB)
+#define RST_BOOTSTRAP_BOOT_SELECT_SET(x)                             (((x) << RST_BOOTSTRAP_BOOT_SELECT_LSB) & RST_BOOTSTRAP_BOOT_SELECT_MASK)
+#define RST_BOOTSTRAP_BOOT_SELECT_RESET                              0x0 // 0
+#define RST_BOOTSTRAP_SDRAM_DISABLE_MSB                              1
+#define RST_BOOTSTRAP_SDRAM_DISABLE_LSB                              1
+#define RST_BOOTSTRAP_SDRAM_DISABLE_MASK                             0x00000002
+#define RST_BOOTSTRAP_SDRAM_DISABLE_GET(x)                           (((x) & RST_BOOTSTRAP_SDRAM_DISABLE_MASK) >> RST_BOOTSTRAP_SDRAM_DISABLE_LSB)
+#define RST_BOOTSTRAP_SDRAM_DISABLE_SET(x)                           (((x) << RST_BOOTSTRAP_SDRAM_DISABLE_LSB) & RST_BOOTSTRAP_SDRAM_DISABLE_MASK)
+#define RST_BOOTSTRAP_SDRAM_DISABLE_RESET                            0x0 // 0
+#define RST_BOOTSTRAP_DDR_SELECT_MSB                                 0
+#define RST_BOOTSTRAP_DDR_SELECT_LSB                                 0
+#define RST_BOOTSTRAP_DDR_SELECT_MASK                                0x00000001
+#define RST_BOOTSTRAP_DDR_SELECT_GET(x)                              (((x) & RST_BOOTSTRAP_DDR_SELECT_MASK) >> RST_BOOTSTRAP_DDR_SELECT_LSB)
+#define RST_BOOTSTRAP_DDR_SELECT_SET(x)                              (((x) << RST_BOOTSTRAP_DDR_SELECT_LSB) & RST_BOOTSTRAP_DDR_SELECT_MASK)
+#define RST_BOOTSTRAP_DDR_SELECT_RESET                               0x0 // 0
+#define RST_BOOTSTRAP_ADDRESS                                        0x180600b0
+
+#define GPIO_OE_ADDRESS                                              0x18040000
+#define GPIO_OUT_ADDRESS                                             0x18040008
+#define GPIO_SPARE_ADDRESS                                           0x18040028
+
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MSB                         31
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB                         24
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK                        0xff000000
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_RESET                       0xb // 11
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MSB                         23
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB                         16
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK                        0x00ff0000
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_RESET                       0xa // 10
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MSB                         15
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB                         8
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK                        0x0000ff00
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_RESET                       0x9 // 9
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MSB                         7
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB                         0
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK                        0x000000ff
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_RESET                       0x14 // 20
+#define GPIO_OUT_FUNCTION1_ADDRESS                                   0x18040030
+
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MSB                        31
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_LSB                        24
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MASK                       0xff000000
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_GET(x)                     (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_SET(x)                     (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_11_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MSB                        23
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_LSB                        16
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MASK                       0x00ff0000
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_GET(x)                     (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_SET(x)                     (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MSB                         15
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_LSB                         8
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MASK                        0x0000ff00
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_GET(x)                      (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_SET(x)                      (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_9_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MSB                         7
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_LSB                         0
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MASK                        0x000000ff
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_GET(x)                      (((x) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MASK) >> GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_LSB)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_SET(x)                      (((x) << GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_LSB) & GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_MASK)
+#define GPIO_OUT_FUNCTION2_ENABLE_GPIO_8_RESET                       0x0 // 0
+#define GPIO_OUT_FUNCTION2_ADDRESS                                   0x18040034
+
+#define GPIO_IN_ENABLE0_UART_SIN_MSB                                 15
+#define GPIO_IN_ENABLE0_UART_SIN_LSB                                 8
+#define GPIO_IN_ENABLE0_UART_SIN_MASK                                0x0000ff00
+#define GPIO_IN_ENABLE0_UART_SIN_GET(x)                              (((x) & GPIO_IN_ENABLE0_UART_SIN_MASK) >> GPIO_IN_ENABLE0_UART_SIN_LSB)
+#define GPIO_IN_ENABLE0_UART_SIN_SET(x)                              (((x) << GPIO_IN_ENABLE0_UART_SIN_LSB) & GPIO_IN_ENABLE0_UART_SIN_MASK)
+#define GPIO_IN_ENABLE0_UART_SIN_RESET                               0x0 // 0
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_MSB                              7
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_LSB                              0
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_MASK                             0x000000ff
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_GET(x)                           (((x) & GPIO_IN_ENABLE0_SPI_DATA_IN_MASK) >> GPIO_IN_ENABLE0_SPI_DATA_IN_LSB)
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_SET(x)                           (((x) << GPIO_IN_ENABLE0_SPI_DATA_IN_LSB) & GPIO_IN_ENABLE0_SPI_DATA_IN_MASK)
+#define GPIO_IN_ENABLE0_SPI_DATA_IN_RESET                            0x8 // 8
+#define GPIO_IN_ENABLE0_ADDRESS                                      0x18040044
+
+
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_MSB                              23
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_LSB                              16
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_MASK                             0x00ff0000
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_GET(x)                           (((x) & GPIO_IN_ENABLE3_MII_GE1_MDI_MASK) >> GPIO_IN_ENABLE3_MII_GE1_MDI_LSB)
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_SET(x)                           (((x) << GPIO_IN_ENABLE3_MII_GE1_MDI_LSB) & GPIO_IN_ENABLE3_MII_GE1_MDI_MASK)
+#define GPIO_IN_ENABLE3_MII_GE1_MDI_RESET                            0x80 // 128
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDC_MSB                             15
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDC_LSB                             8
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDC_MASK                            0x0000ff00
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDC_GET(x)                          (((x) & GPIO_IN_ENABLE3_BOOT_EXT_MDC_MASK) >> GPIO_IN_ENABLE3_BOOT_EXT_MDC_LSB)
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDC_SET(x)                          (((x) << GPIO_IN_ENABLE3_BOOT_EXT_MDC_LSB) & GPIO_IN_ENABLE3_BOOT_EXT_MDC_MASK)
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDC_RESET                           0x80 // 128
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDO_MSB                             7
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDO_LSB                             0
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDO_MASK                            0x000000ff
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDO_GET(x)                          (((x) & GPIO_IN_ENABLE3_BOOT_EXT_MDO_MASK) >> GPIO_IN_ENABLE3_BOOT_EXT_MDO_LSB)
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDO_SET(x)                          (((x) << GPIO_IN_ENABLE3_BOOT_EXT_MDO_LSB) & GPIO_IN_ENABLE3_BOOT_EXT_MDO_MASK)
+#define GPIO_IN_ENABLE3_BOOT_EXT_MDO_RESET                           0x80 // 128
+#define GPIO_IN_ENABLE3_ADDRESS                                      0x18040050
+
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MSB                        31
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_LSB                        24
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK                       0xff000000
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MSB                        23
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_LSB                        16
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK                       0x00ff0000
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MSB                        15
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_LSB                        8
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK                       0x0000ff00
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MSB                        7
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_LSB                        0
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK                       0x000000ff
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_GET(x)                     (((x) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK) >> GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_LSB)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_SET(x)                     (((x) << GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_LSB) & GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK)
+#define GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION3_ADDRESS				     0x18040038
+
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MSB                        31
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_LSB                        24
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK                       0xff000000
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_MSB                        23
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_LSB                        16
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_MASK                       0x00ff0000
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MSB                        15
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB                        8
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK                       0x0000ff00
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MSB                        7
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB                        0
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK                       0x000000ff
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_GET(x)                     (((x) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK) >> GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_SET(x)                     (((x) << GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_LSB) & GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK)
+#define GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_RESET                      0x0 // 0
+#define GPIO_OUT_FUNCTION4_ADDRESS                                   0x1804003c
+
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_MSB                            11
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_LSB                            11
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_MASK                           0x00000800
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS9_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS9_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS9_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS9_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS9_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_MSB                            10
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_LSB                            10
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_MASK                           0x00000400
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS8_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS8_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS8_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS8_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS8_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_MSB                            9
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_LSB                            9
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_MASK                           0x00000200
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS7_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS7_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS7_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS7_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS7_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_MSB                            8
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_LSB                            8
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_MASK                           0x00000100
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS6_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS6_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS6_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS6_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS6_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_MSB                            7
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_LSB                            7
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_MASK                           0x00000080
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS5_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS5_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS5_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS5_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS5_ENABLE_RESET                          0x1 // 1
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_MSB                            6
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_LSB                            6
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_MASK                           0x00000040
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS4_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS4_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS4_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS4_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS4_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_MSB                            5
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_LSB                            5
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_MASK                           0x00000020
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS3_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS3_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS3_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS3_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS3_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_MSB                            4
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_LSB                            4
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_MASK                           0x00000010
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS2_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS2_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS2_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS2_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS2_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_MSB                            3
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_LSB                            3
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_MASK                           0x00000008
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS1_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS1_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS1_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS1_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS1_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_MSB                            2
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_LSB                            2
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_MASK                           0x00000004
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_GET(x)                         (((x) & GPIO_FUNCTION_CLK_OBS0_ENABLE_MASK) >> GPIO_FUNCTION_CLK_OBS0_ENABLE_LSB)
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_SET(x)                         (((x) << GPIO_FUNCTION_CLK_OBS0_ENABLE_LSB) & GPIO_FUNCTION_CLK_OBS0_ENABLE_MASK)
+#define GPIO_FUNCTION_CLK_OBS0_ENABLE_RESET                          0x0 // 0
+#define GPIO_FUNCTION_DISABLE_JTAG_MSB                               1
+#define GPIO_FUNCTION_DISABLE_JTAG_LSB                               1
+#define GPIO_FUNCTION_DISABLE_JTAG_MASK                              0x00000002
+#define GPIO_FUNCTION_DISABLE_JTAG_GET(x)                            (((x) & GPIO_FUNCTION_DISABLE_JTAG_MASK) >> GPIO_FUNCTION_DISABLE_JTAG_LSB)
+#define GPIO_FUNCTION_DISABLE_JTAG_SET(x)                            (((x) << GPIO_FUNCTION_DISABLE_JTAG_LSB) & GPIO_FUNCTION_DISABLE_JTAG_MASK)
+#define GPIO_FUNCTION_DISABLE_JTAG_RESET                             0x0 // 0
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_MSB                           0
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_LSB                           0
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_MASK                          0x00000001
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_GET(x)                        (((x) & GPIO_FUNCTION_ENABLE_GPIO_SRIF_MASK) >> GPIO_FUNCTION_ENABLE_GPIO_SRIF_LSB)
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_SET(x)                        (((x) << GPIO_FUNCTION_ENABLE_GPIO_SRIF_LSB) & GPIO_FUNCTION_ENABLE_GPIO_SRIF_MASK)
+#define GPIO_FUNCTION_ENABLE_GPIO_SRIF_RESET                         0x0 // 0
+#define GPIO_FUNCTION_ADDRESS                                        0x1804006c
+
+
+
+#define PCIE_RESET_EP_RESET_L_MSB                                    2
+#define PCIE_RESET_EP_RESET_L_LSB                                    2
+#define PCIE_RESET_EP_RESET_L_MASK                                   0x00000004
+#define PCIE_RESET_EP_RESET_L_GET(x)                                 (((x) & PCIE_RESET_EP_RESET_L_MASK) >> PCIE_RESET_EP_RESET_L_LSB)
+#define PCIE_RESET_EP_RESET_L_SET(x)                                 (((x) << PCIE_RESET_EP_RESET_L_LSB) & PCIE_RESET_EP_RESET_L_MASK)
+#define PCIE_RESET_EP_RESET_L_RESET                                  0x0 // 0
+#define PCIE_RESET_LINK_REQ_RESET_MSB                                1
+#define PCIE_RESET_LINK_REQ_RESET_LSB                                1
+#define PCIE_RESET_LINK_REQ_RESET_MASK                               0x00000002
+#define PCIE_RESET_LINK_REQ_RESET_GET(x)                             (((x) & PCIE_RESET_LINK_REQ_RESET_MASK) >> PCIE_RESET_LINK_REQ_RESET_LSB)
+#define PCIE_RESET_LINK_REQ_RESET_SET(x)                             (((x) << PCIE_RESET_LINK_REQ_RESET_LSB) & PCIE_RESET_LINK_REQ_RESET_MASK)
+#define PCIE_RESET_LINK_REQ_RESET_RESET                              0x0 // 0
+#define PCIE_RESET_LINK_UP_MSB                                       0
+#define PCIE_RESET_LINK_UP_LSB                                       0
+#define PCIE_RESET_LINK_UP_MASK                                      0x00000001
+#define PCIE_RESET_LINK_UP_GET(x)                                    (((x) & PCIE_RESET_LINK_UP_MASK) >> PCIE_RESET_LINK_UP_LSB)
+#define PCIE_RESET_LINK_UP_SET(x)                                    (((x) << PCIE_RESET_LINK_UP_LSB) & PCIE_RESET_LINK_UP_MASK)
+#define PCIE_RESET_LINK_UP_RESET                                     0x0 // 0
+#define PCIE_RESET_ADDRESS                                           0x180f0018
+
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_MSB                          2
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_LSB                          2
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_MASK                         0x00000004
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_GET(x)                       (((x) & ETH_SGMII_SERDES_EN_LOCK_DETECT_MASK) >> ETH_SGMII_SERDES_EN_LOCK_DETECT_LSB)
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_SET(x)                       (((x) << ETH_SGMII_SERDES_EN_LOCK_DETECT_LSB) & ETH_SGMII_SERDES_EN_LOCK_DETECT_MASK)
+#define ETH_SGMII_SERDES_EN_LOCK_DETECT_RESET                        0x0 // 0
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_MSB                          1
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_LSB                          1
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_MASK                         0x00000002
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_GET(x)                       (((x) & ETH_SGMII_SERDES_PLL_REFCLK_SEL_MASK) >> ETH_SGMII_SERDES_PLL_REFCLK_SEL_LSB)
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_SET(x)                       (((x) << ETH_SGMII_SERDES_PLL_REFCLK_SEL_LSB) & ETH_SGMII_SERDES_PLL_REFCLK_SEL_MASK)
+#define ETH_SGMII_SERDES_PLL_REFCLK_SEL_RESET                        0x0 // 0
+#define ETH_SGMII_SERDES_EN_PLL_MSB                                  0
+#define ETH_SGMII_SERDES_EN_PLL_LSB                                  0
+#define ETH_SGMII_SERDES_EN_PLL_MASK                                 0x00000001
+#define ETH_SGMII_SERDES_EN_PLL_GET(x)                               (((x) & ETH_SGMII_SERDES_EN_PLL_MASK) >> ETH_SGMII_SERDES_EN_PLL_LSB)
+#define ETH_SGMII_SERDES_EN_PLL_SET(x)                               (((x) << ETH_SGMII_SERDES_EN_PLL_LSB) & ETH_SGMII_SERDES_EN_PLL_MASK)
+#define ETH_SGMII_SERDES_EN_PLL_RESET                                0x1 // 1
+#define ETH_SGMII_SERDES_ADDRESS                                     0x1805004c
+
+
+#define ETH_CFG_ETH_SPARE_MSB                                        31
+#define ETH_CFG_ETH_SPARE_LSB                                        22
+#define ETH_CFG_ETH_SPARE_MASK                                       0xffc00000
+#define ETH_CFG_ETH_SPARE_GET(x)                                     (((x) & ETH_CFG_ETH_SPARE_MASK) >> ETH_CFG_ETH_SPARE_LSB)
+#define ETH_CFG_ETH_SPARE_SET(x)                                     (((x) << ETH_CFG_ETH_SPARE_LSB) & ETH_CFG_ETH_SPARE_MASK)
+#define ETH_CFG_ETH_SPARE_RESET                                      0x0 // 0
+#define ETH_CFG_ETH_TXEN_DELAY_MSB                                   21
+#define ETH_CFG_ETH_TXEN_DELAY_LSB                                   20
+#define ETH_CFG_ETH_TXEN_DELAY_MASK                                  0x00300000
+#define ETH_CFG_ETH_TXEN_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_TXEN_DELAY_MASK) >> ETH_CFG_ETH_TXEN_DELAY_LSB)
+#define ETH_CFG_ETH_TXEN_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_TXEN_DELAY_LSB) & ETH_CFG_ETH_TXEN_DELAY_MASK)
+#define ETH_CFG_ETH_TXEN_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_TXD_DELAY_MSB                                    19
+#define ETH_CFG_ETH_TXD_DELAY_LSB                                    18
+#define ETH_CFG_ETH_TXD_DELAY_MASK                                   0x000c0000
+#define ETH_CFG_ETH_TXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_TXD_DELAY_MASK) >> ETH_CFG_ETH_TXD_DELAY_LSB)
+#define ETH_CFG_ETH_TXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_TXD_DELAY_LSB) & ETH_CFG_ETH_TXD_DELAY_MASK)
+#define ETH_CFG_ETH_TXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_ETH_RXDV_DELAY_MSB                                   17
+#define ETH_CFG_ETH_RXDV_DELAY_LSB                                   16
+#define ETH_CFG_ETH_RXDV_DELAY_MASK                                  0x00030000
+#define ETH_CFG_ETH_RXDV_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_RXDV_DELAY_MASK) >> ETH_CFG_ETH_RXDV_DELAY_LSB)
+#define ETH_CFG_ETH_RXDV_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_RXDV_DELAY_LSB) & ETH_CFG_ETH_RXDV_DELAY_MASK)
+#define ETH_CFG_ETH_RXDV_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_RXD_DELAY_MSB                                    15
+#define ETH_CFG_ETH_RXD_DELAY_LSB                                    14
+#define ETH_CFG_ETH_RXD_DELAY_MASK                                   0x0000c000
+#define ETH_CFG_ETH_RXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_RXD_DELAY_MASK) >> ETH_CFG_ETH_RXD_DELAY_LSB)
+#define ETH_CFG_ETH_RXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_RXD_DELAY_LSB) & ETH_CFG_ETH_RXD_DELAY_MASK)
+#define ETH_CFG_ETH_RXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_RMII_GE0_MASTER_MSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_LSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_MASK                                 0x00001000
+#define ETH_CFG_RMII_GE0_MASTER_GET(x)                               (((x) & ETH_CFG_RMII_GE0_MASTER_MASK) >> ETH_CFG_RMII_GE0_MASTER_LSB)
+#define ETH_CFG_RMII_GE0_MASTER_SET(x)                               (((x) << ETH_CFG_RMII_GE0_MASTER_LSB) & ETH_CFG_RMII_GE0_MASTER_MASK)
+#define ETH_CFG_RMII_GE0_MASTER_RESET                                0x1 // 1
+#define ETH_CFG_MII_CNTL_SPEED_MSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_LSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_MASK                                  0x00000800
+#define ETH_CFG_MII_CNTL_SPEED_GET(x)                                (((x) & ETH_CFG_MII_CNTL_SPEED_MASK) >> ETH_CFG_MII_CNTL_SPEED_LSB)
+#define ETH_CFG_MII_CNTL_SPEED_SET(x)                                (((x) << ETH_CFG_MII_CNTL_SPEED_LSB) & ETH_CFG_MII_CNTL_SPEED_MASK)
+#define ETH_CFG_MII_CNTL_SPEED_RESET                                 0x0 // 0
+#define ETH_CFG_RMII_GE0_MSB                                         10
+#define ETH_CFG_RMII_GE0_LSB                                         10
+#define ETH_CFG_RMII_GE0_MASK                                        0x00000400
+#define ETH_CFG_RMII_GE0_GET(x)                                      (((x) & ETH_CFG_RMII_GE0_MASK) >> ETH_CFG_RMII_GE0_LSB)
+#define ETH_CFG_RMII_GE0_SET(x)                                      (((x) << ETH_CFG_RMII_GE0_LSB) & ETH_CFG_RMII_GE0_MASK)
+#define ETH_CFG_RMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_GE0_SGMII_MSB                                        6
+#define ETH_CFG_GE0_SGMII_LSB                                        6
+#define ETH_CFG_GE0_SGMII_MASK                                       0x00000040
+#define ETH_CFG_GE0_SGMII_GET(x)                                     (((x) & ETH_CFG_GE0_SGMII_MASK) >> ETH_CFG_GE0_SGMII_LSB)
+#define ETH_CFG_GE0_SGMII_SET(x)                                     (((x) << ETH_CFG_GE0_SGMII_LSB) & ETH_CFG_GE0_SGMII_MASK)
+#define ETH_CFG_GE0_SGMII_RESET                                      0x0 // 0
+#define ETH_CFG_GE0_ERR_EN_MSB                                       5
+#define ETH_CFG_GE0_ERR_EN_LSB                                       5
+#define ETH_CFG_GE0_ERR_EN_MASK                                      0x00000020
+#define ETH_CFG_GE0_ERR_EN_GET(x)                                    (((x) & ETH_CFG_GE0_ERR_EN_MASK) >> ETH_CFG_GE0_ERR_EN_LSB)
+#define ETH_CFG_GE0_ERR_EN_SET(x)                                    (((x) << ETH_CFG_GE0_ERR_EN_LSB) & ETH_CFG_GE0_ERR_EN_MASK)
+#define ETH_CFG_GE0_ERR_EN_RESET                                     0x0 // 0
+#define ETH_CFG_MII_GE0_SLAVE_MSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_LSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_MASK                                   0x00000010
+#define ETH_CFG_MII_GE0_SLAVE_GET(x)                                 (((x) & ETH_CFG_MII_GE0_SLAVE_MASK) >> ETH_CFG_MII_GE0_SLAVE_LSB)
+#define ETH_CFG_MII_GE0_SLAVE_SET(x)                                 (((x) << ETH_CFG_MII_GE0_SLAVE_LSB) & ETH_CFG_MII_GE0_SLAVE_MASK)
+#define ETH_CFG_MII_GE0_SLAVE_RESET                                  0x0 // 0
+#define ETH_CFG_MII_GE0_MASTER_MSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_LSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_MASK                                  0x00000008
+#define ETH_CFG_MII_GE0_MASTER_GET(x)                                (((x) & ETH_CFG_MII_GE0_MASTER_MASK) >> ETH_CFG_MII_GE0_MASTER_LSB)
+#define ETH_CFG_MII_GE0_MASTER_SET(x)                                (((x) << ETH_CFG_MII_GE0_MASTER_LSB) & ETH_CFG_MII_GE0_MASTER_MASK)
+#define ETH_CFG_MII_GE0_MASTER_RESET                                 0x0 // 0
+#define ETH_CFG_GMII_GE0_MSB                                         2
+#define ETH_CFG_GMII_GE0_LSB                                         2
+#define ETH_CFG_GMII_GE0_MASK                                        0x00000004
+#define ETH_CFG_GMII_GE0_GET(x)                                      (((x) & ETH_CFG_GMII_GE0_MASK) >> ETH_CFG_GMII_GE0_LSB)
+#define ETH_CFG_GMII_GE0_SET(x)                                      (((x) << ETH_CFG_GMII_GE0_LSB) & ETH_CFG_GMII_GE0_MASK)
+#define ETH_CFG_GMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_MII_GE0_MSB                                          1
+#define ETH_CFG_MII_GE0_LSB                                          1
+#define ETH_CFG_MII_GE0_MASK                                         0x00000002
+#define ETH_CFG_MII_GE0_GET(x)                                       (((x) & ETH_CFG_MII_GE0_MASK) >> ETH_CFG_MII_GE0_LSB)
+#define ETH_CFG_MII_GE0_SET(x)                                       (((x) << ETH_CFG_MII_GE0_LSB) & ETH_CFG_MII_GE0_MASK)
+#define ETH_CFG_MII_GE0_RESET                                        0x0 // 0
+#define ETH_CFG_RGMII_GE0_MSB                                        0
+#define ETH_CFG_RGMII_GE0_LSB                                        0
+#define ETH_CFG_RGMII_GE0_MASK                                       0x00000001
+#define ETH_CFG_RGMII_GE0_GET(x)                                     (((x) & ETH_CFG_RGMII_GE0_MASK) >> ETH_CFG_RGMII_GE0_LSB)
+#define ETH_CFG_RGMII_GE0_SET(x)                                     (((x) << ETH_CFG_RGMII_GE0_LSB) & ETH_CFG_RGMII_GE0_MASK)
+#define ETH_CFG_RGMII_GE0_RESET                                      0x0 // 0
+#define ETH_CFG_ADDRESS                                              0x18070000
+
+
+
+#define SGMII_SERDES_VCO_REG_MSB                                     30
+#define SGMII_SERDES_VCO_REG_LSB                                     27
+#define SGMII_SERDES_VCO_REG_MASK                                    0x78000000
+#define SGMII_SERDES_VCO_REG_GET(x)                                  (((x) & SGMII_SERDES_VCO_REG_MASK) >> SGMII_SERDES_VCO_REG_LSB)
+#define SGMII_SERDES_VCO_REG_SET(x)                                  (((x) << SGMII_SERDES_VCO_REG_LSB) & SGMII_SERDES_VCO_REG_MASK)
+#define SGMII_SERDES_VCO_REG_RESET                                   0x3 // 3
+#define SGMII_SERDES_RES_CALIBRATION_MSB                             26
+#define SGMII_SERDES_RES_CALIBRATION_LSB                             23
+#define SGMII_SERDES_RES_CALIBRATION_MASK                            0x07800000
+#define SGMII_SERDES_RES_CALIBRATION_GET(x)                          (((x) & SGMII_SERDES_RES_CALIBRATION_MASK) >> SGMII_SERDES_RES_CALIBRATION_LSB)
+#define SGMII_SERDES_RES_CALIBRATION_SET(x)                          (((x) << SGMII_SERDES_RES_CALIBRATION_LSB) & SGMII_SERDES_RES_CALIBRATION_MASK)
+#define SGMII_SERDES_RES_CALIBRATION_RESET                           0x0 // 0
+#define SGMII_SERDES_FIBER_MODE_MSB                                  21
+#define SGMII_SERDES_FIBER_MODE_LSB                                  20
+#define SGMII_SERDES_FIBER_MODE_MASK                                 0x00300000
+#define SGMII_SERDES_FIBER_MODE_GET(x)                               (((x) & SGMII_SERDES_FIBER_MODE_MASK) >> SGMII_SERDES_FIBER_MODE_LSB)
+#define SGMII_SERDES_FIBER_MODE_SET(x)                               (((x) << SGMII_SERDES_FIBER_MODE_LSB) & SGMII_SERDES_FIBER_MODE_MASK)
+#define SGMII_SERDES_FIBER_MODE_RESET                                0x0 // 0
+#define SGMII_SERDES_THRESHOLD_CTRL_MSB                              19
+#define SGMII_SERDES_THRESHOLD_CTRL_LSB                              18
+#define SGMII_SERDES_THRESHOLD_CTRL_MASK                             0x000c0000
+#define SGMII_SERDES_THRESHOLD_CTRL_GET(x)                           (((x) & SGMII_SERDES_THRESHOLD_CTRL_MASK) >> SGMII_SERDES_THRESHOLD_CTRL_LSB)
+#define SGMII_SERDES_THRESHOLD_CTRL_SET(x)                           (((x) << SGMII_SERDES_THRESHOLD_CTRL_LSB) & SGMII_SERDES_THRESHOLD_CTRL_MASK)
+#define SGMII_SERDES_THRESHOLD_CTRL_RESET                            0x0 // 0
+#define SGMII_SERDES_FIBER_SDO_MSB                                   17
+#define SGMII_SERDES_FIBER_SDO_LSB                                   17
+#define SGMII_SERDES_FIBER_SDO_MASK                                  0x00020000
+#define SGMII_SERDES_FIBER_SDO_GET(x)                                (((x) & SGMII_SERDES_FIBER_SDO_MASK) >> SGMII_SERDES_FIBER_SDO_LSB)
+#define SGMII_SERDES_FIBER_SDO_SET(x)                                (((x) << SGMII_SERDES_FIBER_SDO_LSB) & SGMII_SERDES_FIBER_SDO_MASK)
+#define SGMII_SERDES_FIBER_SDO_RESET                                 0x0 // 0
+#define SGMII_SERDES_EN_SIGNAL_DETECT_MSB                            16
+#define SGMII_SERDES_EN_SIGNAL_DETECT_LSB                            16
+#define SGMII_SERDES_EN_SIGNAL_DETECT_MASK                           0x00010000
+#define SGMII_SERDES_EN_SIGNAL_DETECT_GET(x)                         (((x) & SGMII_SERDES_EN_SIGNAL_DETECT_MASK) >> SGMII_SERDES_EN_SIGNAL_DETECT_LSB)
+#define SGMII_SERDES_EN_SIGNAL_DETECT_SET(x)                         (((x) << SGMII_SERDES_EN_SIGNAL_DETECT_LSB) & SGMII_SERDES_EN_SIGNAL_DETECT_MASK)
+#define SGMII_SERDES_EN_SIGNAL_DETECT_RESET                          0x1 // 1
+#define SGMII_SERDES_LOCK_DETECT_STATUS_MSB                          15
+#define SGMII_SERDES_LOCK_DETECT_STATUS_LSB                          15
+#define SGMII_SERDES_LOCK_DETECT_STATUS_MASK                         0x00008000
+#define SGMII_SERDES_LOCK_DETECT_STATUS_GET(x)                       (((x) & SGMII_SERDES_LOCK_DETECT_STATUS_MASK) >> SGMII_SERDES_LOCK_DETECT_STATUS_LSB)
+#define SGMII_SERDES_LOCK_DETECT_STATUS_SET(x)                       (((x) << SGMII_SERDES_LOCK_DETECT_STATUS_LSB) & SGMII_SERDES_LOCK_DETECT_STATUS_MASK)
+#define SGMII_SERDES_LOCK_DETECT_STATUS_RESET                        0x0 // 0
+#define SGMII_SERDES_SPARE0_MSB                                      14
+#define SGMII_SERDES_SPARE0_LSB                                      11
+#define SGMII_SERDES_SPARE0_MASK                                     0x00007800
+#define SGMII_SERDES_SPARE0_GET(x)                                   (((x) & SGMII_SERDES_SPARE0_MASK) >> SGMII_SERDES_SPARE0_LSB)
+#define SGMII_SERDES_SPARE0_SET(x)                                   (((x) << SGMII_SERDES_SPARE0_LSB) & SGMII_SERDES_SPARE0_MASK)
+#define SGMII_SERDES_SPARE0_RESET                                    0x0 // 0
+#define SGMII_SERDES_VCO_SLOW_MSB                                    10
+#define SGMII_SERDES_VCO_SLOW_LSB                                    10
+#define SGMII_SERDES_VCO_SLOW_MASK                                   0x00000400
+#define SGMII_SERDES_VCO_SLOW_GET(x)                                 (((x) & SGMII_SERDES_VCO_SLOW_MASK) >> SGMII_SERDES_VCO_SLOW_LSB)
+#define SGMII_SERDES_VCO_SLOW_SET(x)                                 (((x) << SGMII_SERDES_VCO_SLOW_LSB) & SGMII_SERDES_VCO_SLOW_MASK)
+#define SGMII_SERDES_VCO_SLOW_RESET                                  0x0 // 0
+#define SGMII_SERDES_VCO_FAST_MSB                                    9
+#define SGMII_SERDES_VCO_FAST_LSB                                    9
+#define SGMII_SERDES_VCO_FAST_MASK                                   0x00000200
+#define SGMII_SERDES_VCO_FAST_GET(x)                                 (((x) & SGMII_SERDES_VCO_FAST_MASK) >> SGMII_SERDES_VCO_FAST_LSB)
+#define SGMII_SERDES_VCO_FAST_SET(x)                                 (((x) << SGMII_SERDES_VCO_FAST_LSB) & SGMII_SERDES_VCO_FAST_MASK)
+#define SGMII_SERDES_VCO_FAST_RESET                                  0x0 // 0
+#define SGMII_SERDES_PLL_BW_MSB                                      8
+#define SGMII_SERDES_PLL_BW_LSB                                      8
+#define SGMII_SERDES_PLL_BW_MASK                                     0x00000100
+#define SGMII_SERDES_PLL_BW_GET(x)                                   (((x) & SGMII_SERDES_PLL_BW_MASK) >> SGMII_SERDES_PLL_BW_LSB)
+#define SGMII_SERDES_PLL_BW_SET(x)                                   (((x) << SGMII_SERDES_PLL_BW_LSB) & SGMII_SERDES_PLL_BW_MASK)
+#define SGMII_SERDES_PLL_BW_RESET                                    0x1 // 1
+#define SGMII_SERDES_TX_IMPEDANCE_MSB                                7
+#define SGMII_SERDES_TX_IMPEDANCE_LSB                                7
+#define SGMII_SERDES_TX_IMPEDANCE_MASK                               0x00000080
+#define SGMII_SERDES_TX_IMPEDANCE_GET(x)                             (((x) & SGMII_SERDES_TX_IMPEDANCE_MASK) >> SGMII_SERDES_TX_IMPEDANCE_LSB)
+#define SGMII_SERDES_TX_IMPEDANCE_SET(x)                             (((x) << SGMII_SERDES_TX_IMPEDANCE_LSB) & SGMII_SERDES_TX_IMPEDANCE_MASK)
+#define SGMII_SERDES_TX_IMPEDANCE_RESET                              0x0 // 0
+#define SGMII_SERDES_TX_DR_CTRL_MSB                                  6
+#define SGMII_SERDES_TX_DR_CTRL_LSB                                  4
+#define SGMII_SERDES_TX_DR_CTRL_MASK                                 0x00000070
+#define SGMII_SERDES_TX_DR_CTRL_GET(x)                               (((x) & SGMII_SERDES_TX_DR_CTRL_MASK) >> SGMII_SERDES_TX_DR_CTRL_LSB)
+#define SGMII_SERDES_TX_DR_CTRL_SET(x)                               (((x) << SGMII_SERDES_TX_DR_CTRL_LSB) & SGMII_SERDES_TX_DR_CTRL_MASK)
+#define SGMII_SERDES_TX_DR_CTRL_RESET                                0x1 // 1
+#define SGMII_SERDES_HALF_TX_MSB                                     3
+#define SGMII_SERDES_HALF_TX_LSB                                     3
+#define SGMII_SERDES_HALF_TX_MASK                                    0x00000008
+#define SGMII_SERDES_HALF_TX_GET(x)                                  (((x) & SGMII_SERDES_HALF_TX_MASK) >> SGMII_SERDES_HALF_TX_LSB)
+#define SGMII_SERDES_HALF_TX_SET(x)                                  (((x) << SGMII_SERDES_HALF_TX_LSB) & SGMII_SERDES_HALF_TX_MASK)
+#define SGMII_SERDES_HALF_TX_RESET                                   0x0 // 0
+#define SGMII_SERDES_CDR_BW_MSB                                      2
+#define SGMII_SERDES_CDR_BW_LSB                                      1
+#define SGMII_SERDES_CDR_BW_MASK                                     0x00000006
+#define SGMII_SERDES_CDR_BW_GET(x)                                   (((x) & SGMII_SERDES_CDR_BW_MASK) >> SGMII_SERDES_CDR_BW_LSB)
+#define SGMII_SERDES_CDR_BW_SET(x)                                   (((x) << SGMII_SERDES_CDR_BW_LSB) & SGMII_SERDES_CDR_BW_MASK)
+#define SGMII_SERDES_CDR_BW_RESET                                    0x3 // 3
+#define SGMII_SERDES_RX_IMPEDANCE_MSB                                0
+#define SGMII_SERDES_RX_IMPEDANCE_LSB                                0
+#define SGMII_SERDES_RX_IMPEDANCE_MASK                               0x00000001
+#define SGMII_SERDES_RX_IMPEDANCE_GET(x)                             (((x) & SGMII_SERDES_RX_IMPEDANCE_MASK) >> SGMII_SERDES_RX_IMPEDANCE_LSB)
+#define SGMII_SERDES_RX_IMPEDANCE_SET(x)                             (((x) << SGMII_SERDES_RX_IMPEDANCE_LSB) & SGMII_SERDES_RX_IMPEDANCE_MASK)
+#define SGMII_SERDES_RX_IMPEDANCE_RESET                              0x0 // 0
+#define SGMII_SERDES_ADDRESS                                         0x18070018
+
+#define RST_RESET2_SPARE_MSB                                         31
+#define RST_RESET2_SPARE_LSB                                         19
+#define RST_RESET2_SPARE_MASK                                        0xfff80000
+#define RST_RESET2_SPARE_GET(x)                                      (((x) & RST_RESET2_SPARE_MASK) >> RST_RESET2_SPARE_LSB)
+#define RST_RESET2_SPARE_SET(x)                                      (((x) << RST_RESET2_SPARE_LSB) & RST_RESET2_SPARE_MASK)
+#define RST_RESET2_SPARE_RESET                                       0x0 // 0
+#define RST_RESET2_EP_MODE_MSB                                       18
+#define RST_RESET2_EP_MODE_LSB                                       18
+#define RST_RESET2_EP_MODE_MASK                                      0x00040000
+#define RST_RESET2_EP_MODE_GET(x)                                    (((x) & RST_RESET2_EP_MODE_MASK) >> RST_RESET2_EP_MODE_LSB)
+#define RST_RESET2_EP_MODE_SET(x)                                    (((x) << RST_RESET2_EP_MODE_LSB) & RST_RESET2_EP_MODE_MASK)
+#define RST_RESET2_EP_MODE_RESET                                     0x0 // 0
+#define RST_RESET2_USB2_EXT_PWR_SEQ_MSB                              17
+#define RST_RESET2_USB2_EXT_PWR_SEQ_LSB                              17
+#define RST_RESET2_USB2_EXT_PWR_SEQ_MASK                             0x00020000
+#define RST_RESET2_USB2_EXT_PWR_SEQ_GET(x)                           (((x) & RST_RESET2_USB2_EXT_PWR_SEQ_MASK) >> RST_RESET2_USB2_EXT_PWR_SEQ_LSB)
+#define RST_RESET2_USB2_EXT_PWR_SEQ_SET(x)                           (((x) << RST_RESET2_USB2_EXT_PWR_SEQ_LSB) & RST_RESET2_USB2_EXT_PWR_SEQ_MASK)
+#define RST_RESET2_USB2_EXT_PWR_SEQ_RESET                            0x1 // 1
+#define RST_RESET2_USB1_EXT_PWR_SEQ_MSB                              16
+#define RST_RESET2_USB1_EXT_PWR_SEQ_LSB                              16
+#define RST_RESET2_USB1_EXT_PWR_SEQ_MASK                             0x00010000
+#define RST_RESET2_USB1_EXT_PWR_SEQ_GET(x)                           (((x) & RST_RESET2_USB1_EXT_PWR_SEQ_MASK) >> RST_RESET2_USB1_EXT_PWR_SEQ_LSB)
+#define RST_RESET2_USB1_EXT_PWR_SEQ_SET(x)                           (((x) << RST_RESET2_USB1_EXT_PWR_SEQ_LSB) & RST_RESET2_USB1_EXT_PWR_SEQ_MASK)
+#define RST_RESET2_USB1_EXT_PWR_SEQ_RESET                            0x1 // 1
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_MSB                          15
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_LSB                          15
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_MASK                         0x00008000
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_GET(x)                       (((x) & RST_RESET2_USB_PHY2_PLL_PWD_EXT_MASK) >> RST_RESET2_USB_PHY2_PLL_PWD_EXT_LSB)
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_SET(x)                       (((x) << RST_RESET2_USB_PHY2_PLL_PWD_EXT_LSB) & RST_RESET2_USB_PHY2_PLL_PWD_EXT_MASK)
+#define RST_RESET2_USB_PHY2_PLL_PWD_EXT_RESET                        0x0 // 0
+#define RST_RESET2_USB_PHY2_ARESET_MSB                               11
+#define RST_RESET2_USB_PHY2_ARESET_LSB                               11
+#define RST_RESET2_USB_PHY2_ARESET_MASK                              0x00000800
+#define RST_RESET2_USB_PHY2_ARESET_GET(x)                            (((x) & RST_RESET2_USB_PHY2_ARESET_MASK) >> RST_RESET2_USB_PHY2_ARESET_LSB)
+#define RST_RESET2_USB_PHY2_ARESET_SET(x)                            (((x) << RST_RESET2_USB_PHY2_ARESET_LSB) & RST_RESET2_USB_PHY2_ARESET_MASK)
+#define RST_RESET2_USB_PHY2_ARESET_RESET                             0x1 // 1
+#define RST_RESET2_PCIE2_PHY_RESET_MSB                               7
+#define RST_RESET2_PCIE2_PHY_RESET_LSB                               7
+#define RST_RESET2_PCIE2_PHY_RESET_MASK                              0x00000080
+#define RST_RESET2_PCIE2_PHY_RESET_GET(x)                            (((x) & RST_RESET2_PCIE2_PHY_RESET_MASK) >> RST_RESET2_PCIE2_PHY_RESET_LSB)
+#define RST_RESET2_PCIE2_PHY_RESET_SET(x)                            (((x) << RST_RESET2_PCIE2_PHY_RESET_LSB) & RST_RESET2_PCIE2_PHY_RESET_MASK)
+#define RST_RESET2_PCIE2_PHY_RESET_RESET                             0x1 // 1
+#define RST_RESET2_PCIE2_RESET_MSB                                   6
+#define RST_RESET2_PCIE2_RESET_LSB                                   6
+#define RST_RESET2_PCIE2_RESET_MASK                                  0x00000040
+#define RST_RESET2_PCIE2_RESET_GET(x)                                (((x) & RST_RESET2_PCIE2_RESET_MASK) >> RST_RESET2_PCIE2_RESET_LSB)
+#define RST_RESET2_PCIE2_RESET_SET(x)                                (((x) << RST_RESET2_PCIE2_RESET_LSB) & RST_RESET2_PCIE2_RESET_MASK)
+#define RST_RESET2_PCIE2_RESET_RESET                                 0x1 // 1
+#define RST_RESET2_USB_HOST2_RESET_MSB                               5
+#define RST_RESET2_USB_HOST2_RESET_LSB                               5
+#define RST_RESET2_USB_HOST2_RESET_MASK                              0x00000020
+#define RST_RESET2_USB_HOST2_RESET_GET(x)                            (((x) & RST_RESET2_USB_HOST2_RESET_MASK) >> RST_RESET2_USB_HOST2_RESET_LSB)
+#define RST_RESET2_USB_HOST2_RESET_SET(x)                            (((x) << RST_RESET2_USB_HOST2_RESET_LSB) & RST_RESET2_USB_HOST2_RESET_MASK)
+#define RST_RESET2_USB_HOST2_RESET_RESET                             0x1 // 1
+#define RST_RESET2_USB_PHY2_RESET_MSB                                4
+#define RST_RESET2_USB_PHY2_RESET_LSB                                4
+#define RST_RESET2_USB_PHY2_RESET_MASK                               0x00000010
+#define RST_RESET2_USB_PHY2_RESET_GET(x)                             (((x) & RST_RESET2_USB_PHY2_RESET_MASK) >> RST_RESET2_USB_PHY2_RESET_LSB)
+#define RST_RESET2_USB_PHY2_RESET_SET(x)                             (((x) << RST_RESET2_USB_PHY2_RESET_LSB) & RST_RESET2_USB_PHY2_RESET_MASK)
+#define RST_RESET2_USB_PHY2_RESET_RESET                              0x1 // 1
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_MSB                     3
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_LSB                     3
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_MASK                    0x00000008
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_GET(x)                  (((x) & RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_MASK) >> RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_LSB)
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_SET(x)                  (((x) << RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_LSB) & RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_MASK)
+#define RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_RESET                   0x0 // 0
+#define RST_RESET2_USB2_MODE_MSB                                     0
+#define RST_RESET2_USB2_MODE_LSB                                     0
+#define RST_RESET2_USB2_MODE_MASK                                    0x00000001
+#define RST_RESET2_USB2_MODE_GET(x)                                  (((x) & RST_RESET2_USB2_MODE_MASK) >> RST_RESET2_USB2_MODE_LSB)
+#define RST_RESET2_USB2_MODE_SET(x)                                  (((x) << RST_RESET2_USB2_MODE_LSB) & RST_RESET2_USB2_MODE_MASK)
+#define RST_RESET2_USB2_MODE_RESET                                   0x1 // 1
+#define RST_RESET2_ADDRESS                                           0x180600c4
+
+#define PCIE2_RESET_EP_RESET_L_MSB                                   2
+#define PCIE2_RESET_EP_RESET_L_LSB                                   2
+#define PCIE2_RESET_EP_RESET_L_MASK                                  0x00000004
+#define PCIE2_RESET_EP_RESET_L_GET(x)                                (((x) & PCIE2_RESET_EP_RESET_L_MASK) >> PCIE2_RESET_EP_RESET_L_LSB)
+#define PCIE2_RESET_EP_RESET_L_SET(x)                                (((x) << PCIE2_RESET_EP_RESET_L_LSB) & PCIE2_RESET_EP_RESET_L_MASK)
+#define PCIE2_RESET_EP_RESET_L_RESET                                 0x0 // 0
+#define PCIE2_RESET_LINK_REQ_RESET_MSB                               1
+#define PCIE2_RESET_LINK_REQ_RESET_LSB                               1
+#define PCIE2_RESET_LINK_REQ_RESET_MASK                              0x00000002
+#define PCIE2_RESET_LINK_REQ_RESET_GET(x)                            (((x) & PCIE2_RESET_LINK_REQ_RESET_MASK) >> PCIE2_RESET_LINK_REQ_RESET_LSB)
+#define PCIE2_RESET_LINK_REQ_RESET_SET(x)                            (((x) << PCIE2_RESET_LINK_REQ_RESET_LSB) & PCIE2_RESET_LINK_REQ_RESET_MASK)
+#define PCIE2_RESET_LINK_REQ_RESET_RESET                             0x0 // 0
+#define PCIE2_RESET_LINK_UP_MSB                                      0
+#define PCIE2_RESET_LINK_UP_LSB                                      0
+#define PCIE2_RESET_LINK_UP_MASK                                     0x00000001
+#define PCIE2_RESET_LINK_UP_GET(x)                                   (((x) & PCIE2_RESET_LINK_UP_MASK) >> PCIE2_RESET_LINK_UP_LSB)
+#define PCIE2_RESET_LINK_UP_SET(x)                                   (((x) << PCIE2_RESET_LINK_UP_LSB) & PCIE2_RESET_LINK_UP_MASK)
+#define PCIE2_RESET_LINK_UP_RESET                                    0x0 // 0
+#define PCIE2_RESET_ADDRESS                                          0x18280018
+
+#define PCIE2_APP_CFG_TYPE_MSB                                       21
+#define PCIE2_APP_CFG_TYPE_LSB                                       20
+#define PCIE2_APP_CFG_TYPE_MASK                                      0x00300000
+#define PCIE2_APP_CFG_TYPE_GET(x)                                    (((x) & PCIE2_APP_CFG_TYPE_MASK) >> PCIE2_APP_CFG_TYPE_LSB)
+#define PCIE2_APP_CFG_TYPE_SET(x)                                    (((x) << PCIE2_APP_CFG_TYPE_LSB) & PCIE2_APP_CFG_TYPE_MASK)
+#define PCIE2_APP_CFG_TYPE_RESET                                     0x0 // 0
+#define PCIE2_APP_PCIE2_BAR_MSN_MSB                                   19
+#define PCIE2_APP_PCIE2_BAR_MSN_LSB                                   16
+#define PCIE2_APP_PCIE2_BAR_MSN_MASK                                  0x000f0000
+#define PCIE2_APP_PCIE2_BAR_MSN_GET(x)                                (((x) & PCIE2_APP_PCIE2_BAR_MSN_MASK) >> PCIE2_APP_PCIE2_BAR_MSN_LSB)
+#define PCIE2_APP_PCIE2_BAR_MSN_SET(x)                                (((x) << PCIE2_APP_PCIE2_BAR_MSN_LSB) & PCIE2_APP_PCIE2_BAR_MSN_MASK)
+#define PCIE2_APP_PCIE2_BAR_MSN_RESET                                 0x1 // 1
+#define PCIE2_APP_CFG_BE_MSB                                         15
+#define PCIE2_APP_CFG_BE_LSB                                         12
+#define PCIE2_APP_CFG_BE_MASK                                        0x0000f000
+#define PCIE2_APP_CFG_BE_GET(x)                                      (((x) & PCIE2_APP_CFG_BE_MASK) >> PCIE2_APP_CFG_BE_LSB)
+#define PCIE2_APP_CFG_BE_SET(x)                                      (((x) << PCIE2_APP_CFG_BE_LSB) & PCIE2_APP_CFG_BE_MASK)
+#define PCIE2_APP_CFG_BE_RESET                                       0xf // 15
+#define PCIE2_APP_SLV_RESP_ERR_MAP_MSB                               11
+#define PCIE2_APP_SLV_RESP_ERR_MAP_LSB                               6
+#define PCIE2_APP_SLV_RESP_ERR_MAP_MASK                              0x00000fc0
+#define PCIE2_APP_SLV_RESP_ERR_MAP_GET(x)                            (((x) & PCIE2_APP_SLV_RESP_ERR_MAP_MASK) >> PCIE2_APP_SLV_RESP_ERR_MAP_LSB)
+#define PCIE2_APP_SLV_RESP_ERR_MAP_SET(x)                            (((x) << PCIE2_APP_SLV_RESP_ERR_MAP_LSB) & PCIE2_APP_SLV_RESP_ERR_MAP_MASK)
+#define PCIE2_APP_SLV_RESP_ERR_MAP_RESET                             0x3f // 63
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_MSB                              5
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_LSB                              4
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_MASK                             0x00000030
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_GET(x)                           (((x) & PCIE2_APP_MSTR_RESP_ERR_MAP_MASK) >> PCIE2_APP_MSTR_RESP_ERR_MAP_LSB)
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_SET(x)                           (((x) << PCIE2_APP_MSTR_RESP_ERR_MAP_LSB) & PCIE2_APP_MSTR_RESP_ERR_MAP_MASK)
+#define PCIE2_APP_MSTR_RESP_ERR_MAP_RESET                            0x0 // 0
+#define PCIE2_APP_INIT_RST_MSB                                       3
+#define PCIE2_APP_INIT_RST_LSB                                       3
+#define PCIE2_APP_INIT_RST_MASK                                      0x00000008
+#define PCIE2_APP_INIT_RST_GET(x)                                    (((x) & PCIE2_APP_INIT_RST_MASK) >> PCIE2_APP_INIT_RST_LSB)
+#define PCIE2_APP_INIT_RST_SET(x)                                    (((x) << PCIE2_APP_INIT_RST_LSB) & PCIE2_APP_INIT_RST_MASK)
+#define PCIE2_APP_INIT_RST_RESET                                     0x0 // 0
+#define PCIE2_APP_PM_XMT_TURNOFF_MSB                                 2
+#define PCIE2_APP_PM_XMT_TURNOFF_LSB                                 2
+#define PCIE2_APP_PM_XMT_TURNOFF_MASK                                0x00000004
+#define PCIE2_APP_PM_XMT_TURNOFF_GET(x)                              (((x) & PCIE2_APP_PM_XMT_TURNOFF_MASK) >> PCIE2_APP_PM_XMT_TURNOFF_LSB)
+#define PCIE2_APP_PM_XMT_TURNOFF_SET(x)                              (((x) << PCIE2_APP_PM_XMT_TURNOFF_LSB) & PCIE2_APP_PM_XMT_TURNOFF_MASK)
+#define PCIE2_APP_PM_XMT_TURNOFF_RESET                               0x0 // 0
+#define PCIE2_APP_UNLOCK_MSG_MSB                                     1
+#define PCIE2_APP_UNLOCK_MSG_LSB                                     1
+#define PCIE2_APP_UNLOCK_MSG_MASK                                    0x00000002
+#define PCIE2_APP_UNLOCK_MSG_GET(x)                                  (((x) & PCIE2_APP_UNLOCK_MSG_MASK) >> PCIE2_APP_UNLOCK_MSG_LSB)
+#define PCIE2_APP_UNLOCK_MSG_SET(x)                                  (((x) << PCIE2_APP_UNLOCK_MSG_LSB) & PCIE2_APP_UNLOCK_MSG_MASK)
+#define PCIE2_APP_UNLOCK_MSG_RESET                                   0x0 // 0
+#define PCIE2_APP_LTSSM_ENABLE_MSB                                   0
+#define PCIE2_APP_LTSSM_ENABLE_LSB                                   0
+#define PCIE2_APP_LTSSM_ENABLE_MASK                                  0x00000001
+#define PCIE2_APP_LTSSM_ENABLE_GET(x)                                (((x) & PCIE2_APP_LTSSM_ENABLE_MASK) >> PCIE2_APP_LTSSM_ENABLE_LSB)
+#define PCIE2_APP_LTSSM_ENABLE_SET(x)                                (((x) << PCIE2_APP_LTSSM_ENABLE_LSB) & PCIE2_APP_LTSSM_ENABLE_MASK)
+#define PCIE2_APP_LTSSM_ENABLE_RESET                                 0x0 // 0
+#define PCIE2_APP_ADDRESS                                            0x18280000
+
+
+
+
+
+#define CONFIG_MIPS32		1	/* MIPS32 CPU core	*/
+
+#define CONFIG_BOOTDELAY	2	/* autoboot after 4 seconds	*/
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{115200}
+
+#define	CONFIG_TIMESTAMP		/* Print image info with timestamp */
+
+#define CONFIG_ROOTFS_RD
+
+#define	CONFIG_BOOTARGS_RD     "console=ttyS0,115200 root=01:00 rd_start=0x802d0000 rd_size=5242880 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),4096k(rootfs),2048k(uImage)"
+
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS_FL     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),2048k(uImage)"
+
+#ifdef CONFIG_ROOTFS_FLASH
+#define CONFIG_BOOTARGS CONFIG_BOOTARGS_FL
+#else
+#define CONFIG_BOOTARGS ""
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"ath> "		/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		512		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE		(CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		(128*1024)
+
+#define CFG_BOOTPARAMS_LEN	(128*1024)
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+//#define CFG_SDRAM_BASE	0xa0000000     /* Cached addr */
+
+#define	CFG_LOAD_ADDR		0x81000000     /* default load address	*/
+//#define CFG_LOAD_ADDR		0xa1000000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#undef CFG_MEMTEST_START
+#define CFG_MEMTEST_START       0x80200000
+#define CFG_MEMTEST_END		0x83800000
+
+/*------------------------------------------------------------------------
+ * *  * JFFS2
+ */
+#define CFG_JFFS_CUSTOM_PART            /* board defined part   */
+#define CONFIG_JFFS2_CMDLINE
+#define MTDIDS_DEFAULT		"nor0=ath-nor0"
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#define CFG_RX_ETH_BUFFER	16
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		32768
+#define CFG_ICACHE_SIZE		65536
+#define CFG_CACHELINE_SIZE	32
+
+/*
+ * Address map
+ */
+#define ATH_PCI_MEM_BASE		0x10000000	/* 128M */
+#define ATH_APB_BASE			0x18000000	/* 384M */
+#define ATH_GE0_BASE			0x19000000	/* 16M */
+#define ATH_GE1_BASE			0x1a000000	/* 16M */
+#define ATH_USB_OHCI_BASE		0x1b000000
+#define ATH_USB_EHCI_BASE		0x1b000000
+#define ATH_USB_EHCI_BASE_1		0x1b000000
+#define ATH_USB_EHCI_BASE_2		0x1b400000
+#define ATH_SPI_BASE			0x1f000000
+
+/*
+ * Added the PCI LCL RESET register from u-boot
+ * ath_soc.h so that we can query the PCI LCL RESET
+ * register for the presence of WLAN H/W.
+ */
+#define ATH_PCI_LCL_BASE		(ATH_APB_BASE+0x000f0000)
+#define ATH_PCI_LCL_APP			(ATH_PCI_LCL_BASE+0x00)
+#define ATH_PCI_LCL_RESET		(ATH_PCI_LCL_BASE+0x18)
+
+/*
+ * APB block
+ */
+#define ATH_DDR_CTL_BASE		ATH_APB_BASE+0x00000000
+#define ATH_CPU_BASE			ATH_APB_BASE+0x00010000
+#define ATH_UART_BASE			ATH_APB_BASE+0x00020000
+#define ATH_USB_CONFIG_BASE		ATH_APB_BASE+0x00030000
+#define ATH_GPIO_BASE			ATH_APB_BASE+0x00040000
+#define ATH_PLL_BASE			ATH_APB_BASE+0x00050000
+#define ATH_RESET_BASE			ATH_APB_BASE+0x00060000
+#define ATH_DMA_BASE			ATH_APB_BASE+0x000A0000
+#define ATH_SLIC_BASE			ATH_APB_BASE+0x000A9000
+#define ATH_STEREO_BASE			ATH_APB_BASE+0x000B0000
+#define ATH_PCI_CTLR_BASE		ATH_APB_BASE+0x000F0000
+#define ATH_OTP_BASE			ATH_APB_BASE+0x00130000
+#define ATH_NAND_FLASH_BASE		0x1b800000u
+
+
+/*
+ * DDR Config values
+ */
+#define ATH_DDR_CONFIG_16BIT		(1 << 31)
+#define ATH_DDR_CONFIG_PAGE_OPEN	(1 << 30)
+#define ATH_DDR_CONFIG_CAS_LAT_SHIFT	27
+#define ATH_DDR_CONFIG_TMRD_SHIFT	23
+#define ATH_DDR_CONFIG_TRFC_SHIFT	17
+#define ATH_DDR_CONFIG_TRRD_SHIFT	13
+#define ATH_DDR_CONFIG_TRP_SHIFT	9
+#define ATH_DDR_CONFIG_TRCD_SHIFT	5
+#define ATH_DDR_CONFIG_TRAS_SHIFT	0
+
+#define ATH_DDR_CONFIG2_BL2		(2 << 0)
+#define ATH_DDR_CONFIG2_BL4		(4 << 0)
+#define ATH_DDR_CONFIG2_BL8		(8 << 0)
+
+#define ATH_DDR_CONFIG2_BT_IL		(1 << 4)
+#define ATH_DDR_CONFIG2_CNTL_OE_EN	(1 << 5)
+#define ATH_DDR_CONFIG2_PHASE_SEL	(1 << 6)
+#define ATH_DDR_CONFIG2_DRAM_CKE	(1 << 7)
+#define ATH_DDR_CONFIG2_TWR_SHIFT	8
+#define ATH_DDR_CONFIG2_TRTW_SHIFT	12
+#define ATH_DDR_CONFIG2_TRTP_SHIFT	17
+#define ATH_DDR_CONFIG2_TWTR_SHIFT	21
+#define ATH_DDR_CONFIG2_HALF_WIDTH_L	(1 << 31)
+
+#define ATH_DDR_TAP_DEFAULT		0x18
+
+/*
+ * DDR block, gmac flushing
+ */
+#define ATH_DDR_GE0_FLUSH		ATH_DDR_CTL_BASE+0x9c
+#define ATH_DDR_GE1_FLUSH		ATH_DDR_CTL_BASE+0xa0
+#define ATH_DDR_USB_FLUSH		ATH_DDR_CTL_BASE+0xa4
+#define ATH_DDR_PCIE_FLUSH		ATH_DDR_CTL_BASE+0x88
+
+#define ATH_EEPROM_GE0_MAC_ADDR		0xbfff1000
+#define ATH_EEPROM_GE1_MAC_ADDR		0xbfff1006
+
+/*
+ * PLL block/CPU
+ */
+
+#define ATH_PLL_CONFIG			ATH_PLL_BASE+0x0
+#define ATH_DDR_CLK_CTRL		ATH_PLL_BASE+0x8
+
+
+#define PLL_DIV_SHIFT			0
+#define PLL_DIV_MASK			0x3ff
+#define REF_DIV_SHIFT			10
+#define REF_DIV_MASK			0xf
+#define AHB_DIV_SHIFT			19
+#define AHB_DIV_MASK			0x1
+#define DDR_DIV_SHIFT			22
+#define DDR_DIV_MASK			0x1
+#define ATH_DDR_PLL_CONFIG		ATH_PLL_BASE+0x4
+#define ATH_ETH_XMII_CONFIG		ATH_PLL_BASE+0x2c
+#define ATH_AUDIO_PLL_CONFIG		ATH_PLL_BASE+0x30
+
+#define ATH_ETH_INT0_CLK		ATH_PLL_BASE+0x14
+#define ATH_ETH_INT1_CLK		ATH_PLL_BASE+0x18
+
+
+/*
+ * USB block
+ */
+#define ATH_USB_FLADJ_VAL		ATH_USB_CONFIG_BASE
+#define ATH_USB_CONFIG			ATH_USB_CONFIG_BASE+0x4
+#define ATH_USB_WINDOW			0x10000
+#define ATH_USB_MODE			ATH_USB_EHCI_BASE+0x1a8
+
+/*
+ * PCI block
+ */
+#define ATH_PCI_WINDOW			0x8000000 /* 128MB */
+#define ATH_PCI_WINDOW0_OFFSET		ATH_DDR_CTL_BASE+0x7c
+#define ATH_PCI_WINDOW1_OFFSET		ATH_DDR_CTL_BASE+0x80
+#define ATH_PCI_WINDOW2_OFFSET		ATH_DDR_CTL_BASE+0x84
+#define ATH_PCI_WINDOW3_OFFSET		ATH_DDR_CTL_BASE+0x88
+#define ATH_PCI_WINDOW4_OFFSET		ATH_DDR_CTL_BASE+0x8c
+#define ATH_PCI_WINDOW5_OFFSET		ATH_DDR_CTL_BASE+0x90
+#define ATH_PCI_WINDOW6_OFFSET		ATH_DDR_CTL_BASE+0x94
+#define ATH_PCI_WINDOW7_OFFSET		ATH_DDR_CTL_BASE+0x98
+
+#define ATH_PCI_WINDOW0_VAL		0x10000000
+#define ATH_PCI_WINDOW1_VAL		0x11000000
+#define ATH_PCI_WINDOW2_VAL		0x12000000
+#define ATH_PCI_WINDOW3_VAL		0x13000000
+#define ATH_PCI_WINDOW4_VAL		0x14000000
+#define ATH_PCI_WINDOW5_VAL		0x15000000
+#define ATH_PCI_WINDOW6_VAL		0x16000000
+#define ATH_PCI_WINDOW7_VAL		0x07000000
+
+#define ath_write_pci_window(_no)	\
+	ath_reg_wr(ATH_PCI_WINDOW##_no##_OFFSET, ATH_PCI_WINDOW##_no##_VAL);
+
+/*
+ * CRP. To access the host controller config and status registers
+ */
+#define ATH_PCI_CRP			0x180c0000
+#define ATH_PCI_DEV_CFGBASE		0x14000000
+#define ATH_PCI_CRP_AD_CBE		ATH_PCI_CRP
+#define ATH_PCI_CRP_WRDATA		ATH_PCI_CRP+0x4
+#define ATH_PCI_CRP_RDDATA		ATH_PCI_CRP+0x8
+#define ATH_PCI_ERROR			ATH_PCI_CRP+0x1c
+#define ATH_PCI_ERROR_ADDRESS		ATH_PCI_CRP+0x20
+#define ATH_PCI_AHB_ERROR		ATH_PCI_CRP+0x24
+#define ATH_PCI_AHB_ERROR_ADDRESS	ATH_PCI_CRP+0x28
+
+#define ATH_CRP_CMD_WRITE		0x00010000
+#define ATH_CRP_CMD_READ		0x00000000
+
+/*
+ * PCI CFG. To generate config cycles
+ */
+#define ATH_PCI_CFG_AD			ATH_PCI_CRP+0xc
+#define ATH_PCI_CFG_CBE			ATH_PCI_CRP+0x10
+#define ATH_PCI_CFG_WRDATA		ATH_PCI_CRP+0x14
+#define ATH_PCI_CFG_RDDATA		ATH_PCI_CRP+0x18
+#define ATH_CFG_CMD_READ		0x0000000a
+#define ATH_CFG_CMD_WRITE		0x0000000b
+
+#define ATH_PCI_IDSEL_ADLINE_START	17
+
+#define ATH_SPI_FS		(ATH_SPI_BASE+0x00)
+#define ATH_SPI_READ		(ATH_SPI_BASE+0x00)
+#define ATH_SPI_CLOCK		(ATH_SPI_BASE+0x04)
+#define ATH_SPI_WRITE		(ATH_SPI_BASE+0x08)
+#define ATH_SPI_RD_STATUS	(ATH_SPI_BASE+0x0c)
+#define ATH_SPI_SHIFT_DO	(ATH_SPI_BASE+0x10)
+#define ATH_SPI_SHIFT_CNT	(ATH_SPI_BASE+0x14)
+#define ATH_SPI_SHIFT_DI	(ATH_SPI_BASE+0x18)
+#define ATH_SPI_D0_HIGH		(1<<0)	/* Pin spi_do */
+#define ATH_SPI_CLK_HIGH	(1<<8)	/* Pin spi_clk */
+
+#define ATH_SPI_CS_ENABLE_0	(6<<16)	/* Pin gpio/cs0 (active low) */
+#define ATH_SPI_CS_ENABLE_1	(5<<16)	/* Pin gpio/cs1 (active low) */
+#define ATH_SPI_CS_ENABLE_2	(3<<16)	/* Pin gpio/cs2 (active low) */
+#define ATH_SPI_CS_DIS		0x70000
+#define ATH_SPI_CE_LOW		0x60000
+#define ATH_SPI_CE_HIGH		0x60100
+
+#define ATH_SPI_SECTOR_SIZE	(1024*64)
+#define ATH_SPI_PAGE_SIZE	256
+
+#define ATH_RESET_GE0_MAC	RST_RESET_GE0_MAC_RESET_SET(1)
+#define ATH_RESET_GE0_PHY	(0)	// Nothing similar to wasp??
+#define ATH_RESET_GE1_MAC	RST_RESET_GE1_MAC_RESET_SET(1)
+#define ATH_RESET_GE1_PHY	(0)	// Nothing similar to wasp??
+#define ATH_RESET_GE0_MDIO	RST_RESET_GE0_MDIO_RESET_SET(1)
+#define ATH_RESET_GE1_MDIO	RST_RESET_GE1_MDIO_RESET_SET(1)
+
+/*
+ * SOC
+ */
+#define ATH_SPI_CMD_WRITE_SR		0x01
+#define ATH_SPI_CMD_WREN		0x06
+#define ATH_SPI_CMD_RD_STATUS		0x05
+#define ATH_SPI_CMD_FAST_READ		0x0b
+#define ATH_SPI_CMD_PAGE_PROG		0x02
+#define ATH_SPI_CMD_SECTOR_ERASE	0xd8
+#define ATH_SPI_CMD_CHIP_ERASE		0xc7
+#define ATH_SPI_CMD_RDID		0x9f
+
+#if defined(CFG_ATH_EMULATION)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(2)	// 80 MHz
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(1)	// 40 MHz
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_600_200)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_AND_DDR_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_600_300)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_AND_DDR_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(10)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(10)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_AND_DDR_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_680_240)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(17)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_720_600_240)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(18)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_560_450_220)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(0)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(11)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0x100) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_AND_DDR_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(0)
+#define CPU_AND_DDR_CLK_FROM_CPU		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_680_680_226)
+
+#define CPU_DDR_SYNC_MODE			DDR_CTL_CONFIG_CPU_DDR_SYNC_SET(1)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(17)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+#define CPU_PLL_DITHER_VAL			CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+						CPU_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(17)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+#define DDR_PLL_DITHER_VAL			DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+						DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+						DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+						DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define AHB_CLK_FROM_DDR			CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_AND_DDR_CLK_FROM_DDR		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_DDRPLL_SET(1)
+#define CPU_AND_DDR_CLK_FROM_CPU		CPU_DDR_CLOCK_CONTROL_CPU_DDR_CLK_FROM_CPUPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#else
+#	error "CFG_PLL_FREQ not set"
+#endif	// CFG_PLL_FREQ
+
+#if CPU_AND_DDR_CLK_FROM_DDR && CPU_AND_DDR_CLK_FROM_CPU
+#	error "Incorrect settings. Both 'from CPU' and 'from DDR' set"
+#endif
+
+
+
+#define __nint_to_mhz(n, ref)	((n) * (ref) * 1000000)
+#define __cpu_hz_40(pll)	(__nint_to_mhz(CPU_PLL_CONFIG_NINT_GET(pll), 40))
+#define __cpu_hz_25(pll)	(__nint_to_mhz(CPU_PLL_CONFIG_NINT_GET(pll), 25))
+
+/* Since the count is incremented every other tick, divide by 2 */
+#define CFG_HZ			(__cpu_hz_40(CPU_PLL_CONFIG_NINT_VAL) / 2)
+
+/* SGMII DEFINES */
+
+// 32'h18070034 (SGMII_CONFIG)
+#define SGMII_CONFIG_BERT_ENABLE_MSB                                 14
+#define SGMII_CONFIG_BERT_ENABLE_LSB                                 14
+#define SGMII_CONFIG_BERT_ENABLE_MASK                                0x00004000
+#define SGMII_CONFIG_BERT_ENABLE_GET(x)                              (((x) & SGMII_CONFIG_BERT_ENABLE_MASK) >> SGMII_CONFIG_BERT_ENABLE_LSB)
+#define SGMII_CONFIG_BERT_ENABLE_SET(x)                              (((x) << SGMII_CONFIG_BERT_ENABLE_LSB) & SGMII_CONFIG_BERT_ENABLE_MASK)
+#define SGMII_CONFIG_BERT_ENABLE_RESET                               0x0 // 0
+#define SGMII_CONFIG_PRBS_ENABLE_MSB                                 13
+#define SGMII_CONFIG_PRBS_ENABLE_LSB                                 13
+#define SGMII_CONFIG_PRBS_ENABLE_MASK                                0x00002000
+#define SGMII_CONFIG_PRBS_ENABLE_GET(x)                              (((x) & SGMII_CONFIG_PRBS_ENABLE_MASK) >> SGMII_CONFIG_PRBS_ENABLE_LSB)
+#define SGMII_CONFIG_PRBS_ENABLE_SET(x)                              (((x) << SGMII_CONFIG_PRBS_ENABLE_LSB) & SGMII_CONFIG_PRBS_ENABLE_MASK)
+#define SGMII_CONFIG_PRBS_ENABLE_RESET                               0x0 // 0
+#define SGMII_CONFIG_MDIO_COMPLETE_MSB                               12
+#define SGMII_CONFIG_MDIO_COMPLETE_LSB                               12
+#define SGMII_CONFIG_MDIO_COMPLETE_MASK                              0x00001000
+#define SGMII_CONFIG_MDIO_COMPLETE_GET(x)                            (((x) & SGMII_CONFIG_MDIO_COMPLETE_MASK) >> SGMII_CONFIG_MDIO_COMPLETE_LSB)
+#define SGMII_CONFIG_MDIO_COMPLETE_SET(x)                            (((x) << SGMII_CONFIG_MDIO_COMPLETE_LSB) & SGMII_CONFIG_MDIO_COMPLETE_MASK)
+#define SGMII_CONFIG_MDIO_COMPLETE_RESET                             0x0 // 0
+#define SGMII_CONFIG_MDIO_PULSE_MSB                                  11
+#define SGMII_CONFIG_MDIO_PULSE_LSB                                  11
+#define SGMII_CONFIG_MDIO_PULSE_MASK                                 0x00000800
+#define SGMII_CONFIG_MDIO_PULSE_GET(x)                               (((x) & SGMII_CONFIG_MDIO_PULSE_MASK) >> SGMII_CONFIG_MDIO_PULSE_LSB)
+#define SGMII_CONFIG_MDIO_PULSE_SET(x)                               (((x) << SGMII_CONFIG_MDIO_PULSE_LSB) & SGMII_CONFIG_MDIO_PULSE_MASK)
+#define SGMII_CONFIG_MDIO_PULSE_RESET                                0x0 // 0
+#define SGMII_CONFIG_MDIO_ENABLE_MSB                                 10
+#define SGMII_CONFIG_MDIO_ENABLE_LSB                                 10
+#define SGMII_CONFIG_MDIO_ENABLE_MASK                                0x00000400
+#define SGMII_CONFIG_MDIO_ENABLE_GET(x)                              (((x) & SGMII_CONFIG_MDIO_ENABLE_MASK) >> SGMII_CONFIG_MDIO_ENABLE_LSB)
+#define SGMII_CONFIG_MDIO_ENABLE_SET(x)                              (((x) << SGMII_CONFIG_MDIO_ENABLE_LSB) & SGMII_CONFIG_MDIO_ENABLE_MASK)
+#define SGMII_CONFIG_MDIO_ENABLE_RESET                               0x0 // 0
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_MSB                            9
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_LSB                            9
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_MASK                           0x00000200
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_GET(x)                         (((x) & SGMII_CONFIG_NEXT_PAGE_LOADED_MASK) >> SGMII_CONFIG_NEXT_PAGE_LOADED_LSB)
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_SET(x)                         (((x) << SGMII_CONFIG_NEXT_PAGE_LOADED_LSB) & SGMII_CONFIG_NEXT_PAGE_LOADED_MASK)
+#define SGMII_CONFIG_NEXT_PAGE_LOADED_RESET                          0x0 // 0
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MSB                         8
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_LSB                         8
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MASK                        0x00000100
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_GET(x)                      (((x) & SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MASK) >> SGMII_CONFIG_REMOTE_PHY_LOOPBACK_LSB)
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_SET(x)                      (((x) << SGMII_CONFIG_REMOTE_PHY_LOOPBACK_LSB) & SGMII_CONFIG_REMOTE_PHY_LOOPBACK_MASK)
+#define SGMII_CONFIG_REMOTE_PHY_LOOPBACK_RESET                       0x0 // 0
+#define SGMII_CONFIG_SPEED_MSB                                       7
+#define SGMII_CONFIG_SPEED_LSB                                       6
+#define SGMII_CONFIG_SPEED_MASK                                      0x000000c0
+#define SGMII_CONFIG_SPEED_GET(x)                                    (((x) & SGMII_CONFIG_SPEED_MASK) >> SGMII_CONFIG_SPEED_LSB)
+#define SGMII_CONFIG_SPEED_SET(x)                                    (((x) << SGMII_CONFIG_SPEED_LSB) & SGMII_CONFIG_SPEED_MASK)
+#define SGMII_CONFIG_SPEED_RESET                                     0x0 // 0
+#define SGMII_CONFIG_FORCE_SPEED_MSB                                 5
+#define SGMII_CONFIG_FORCE_SPEED_LSB                                 5
+#define SGMII_CONFIG_FORCE_SPEED_MASK                                0x00000020
+#define SGMII_CONFIG_FORCE_SPEED_GET(x)                              (((x) & SGMII_CONFIG_FORCE_SPEED_MASK) >> SGMII_CONFIG_FORCE_SPEED_LSB)
+#define SGMII_CONFIG_FORCE_SPEED_SET(x)                              (((x) << SGMII_CONFIG_FORCE_SPEED_LSB) & SGMII_CONFIG_FORCE_SPEED_MASK)
+#define SGMII_CONFIG_FORCE_SPEED_RESET                               0x0 // 0
+#define SGMII_CONFIG_MR_REG4_CHANGED_MSB                             4
+#define SGMII_CONFIG_MR_REG4_CHANGED_LSB                             4
+#define SGMII_CONFIG_MR_REG4_CHANGED_MASK                            0x00000010
+#define SGMII_CONFIG_MR_REG4_CHANGED_GET(x)                          (((x) & SGMII_CONFIG_MR_REG4_CHANGED_MASK) >> SGMII_CONFIG_MR_REG4_CHANGED_LSB)
+#define SGMII_CONFIG_MR_REG4_CHANGED_SET(x)                          (((x) << SGMII_CONFIG_MR_REG4_CHANGED_LSB) & SGMII_CONFIG_MR_REG4_CHANGED_MASK)
+#define SGMII_CONFIG_MR_REG4_CHANGED_RESET                           0x0 // 0
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MSB                       3
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_LSB                       3
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MASK                      0x00000008
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_GET(x)                    (((x) & SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MASK) >> SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_LSB)
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_SET(x)                    (((x) << SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_LSB) & SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_MASK)
+#define SGMII_CONFIG_ENABLE_SGMII_TX_PAUSE_RESET                     0x0 // 0
+#define SGMII_CONFIG_MODE_CTRL_MSB                                   2
+#define SGMII_CONFIG_MODE_CTRL_LSB                                   0
+#define SGMII_CONFIG_MODE_CTRL_MASK                                  0x00000007
+#define SGMII_CONFIG_MODE_CTRL_GET(x)                                (((x) & SGMII_CONFIG_MODE_CTRL_MASK) >> SGMII_CONFIG_MODE_CTRL_LSB)
+#define SGMII_CONFIG_MODE_CTRL_SET(x)                                (((x) << SGMII_CONFIG_MODE_CTRL_LSB) & SGMII_CONFIG_MODE_CTRL_MASK)
+#define SGMII_CONFIG_MODE_CTRL_RESET                                 0x0 // 0
+#define SGMII_CONFIG_ADDRESS                                         0x18070034
+
+
+
+// 32'h1807001c (MR_AN_CONTROL)
+#define MR_AN_CONTROL_PHY_RESET_MSB                                  15
+#define MR_AN_CONTROL_PHY_RESET_LSB                                  15
+#define MR_AN_CONTROL_PHY_RESET_MASK                                 0x00008000
+#define MR_AN_CONTROL_PHY_RESET_GET(x)                               (((x) & MR_AN_CONTROL_PHY_RESET_MASK) >> MR_AN_CONTROL_PHY_RESET_LSB)
+#define MR_AN_CONTROL_PHY_RESET_SET(x)                               (((x) << MR_AN_CONTROL_PHY_RESET_LSB) & MR_AN_CONTROL_PHY_RESET_MASK)
+#define MR_AN_CONTROL_PHY_RESET_RESET                                0x0 // 0
+#define MR_AN_CONTROL_LOOPBACK_MSB                                   14
+#define MR_AN_CONTROL_LOOPBACK_LSB                                   14
+#define MR_AN_CONTROL_LOOPBACK_MASK                                  0x00004000
+#define MR_AN_CONTROL_LOOPBACK_GET(x)                                (((x) & MR_AN_CONTROL_LOOPBACK_MASK) >> MR_AN_CONTROL_LOOPBACK_LSB)
+#define MR_AN_CONTROL_LOOPBACK_SET(x)                                (((x) << MR_AN_CONTROL_LOOPBACK_LSB) & MR_AN_CONTROL_LOOPBACK_MASK)
+#define MR_AN_CONTROL_LOOPBACK_RESET                                 0x0 // 0
+#define MR_AN_CONTROL_SPEED_SEL0_MSB                                 13
+#define MR_AN_CONTROL_SPEED_SEL0_LSB                                 13
+#define MR_AN_CONTROL_SPEED_SEL0_MASK                                0x00002000
+#define MR_AN_CONTROL_SPEED_SEL0_GET(x)                              (((x) & MR_AN_CONTROL_SPEED_SEL0_MASK) >> MR_AN_CONTROL_SPEED_SEL0_LSB)
+#define MR_AN_CONTROL_SPEED_SEL0_SET(x)                              (((x) << MR_AN_CONTROL_SPEED_SEL0_LSB) & MR_AN_CONTROL_SPEED_SEL0_MASK)
+#define MR_AN_CONTROL_SPEED_SEL0_RESET                               0x0 // 0
+#define MR_AN_CONTROL_AN_ENABLE_MSB                                  12
+#define MR_AN_CONTROL_AN_ENABLE_LSB                                  12
+#define MR_AN_CONTROL_AN_ENABLE_MASK                                 0x00001000
+#define MR_AN_CONTROL_AN_ENABLE_GET(x)                               (((x) & MR_AN_CONTROL_AN_ENABLE_MASK) >> MR_AN_CONTROL_AN_ENABLE_LSB)
+#define MR_AN_CONTROL_AN_ENABLE_SET(x)                               (((x) << MR_AN_CONTROL_AN_ENABLE_LSB) & MR_AN_CONTROL_AN_ENABLE_MASK)
+#define MR_AN_CONTROL_AN_ENABLE_RESET                                0x1 // 1
+#define MR_AN_CONTROL_POWER_DOWN_MSB                                 11
+#define MR_AN_CONTROL_POWER_DOWN_LSB                                 11
+#define MR_AN_CONTROL_POWER_DOWN_MASK                                0x00000800
+#define MR_AN_CONTROL_POWER_DOWN_GET(x)                              (((x) & MR_AN_CONTROL_POWER_DOWN_MASK) >> MR_AN_CONTROL_POWER_DOWN_LSB)
+#define MR_AN_CONTROL_POWER_DOWN_SET(x)                              (((x) << MR_AN_CONTROL_POWER_DOWN_LSB) & MR_AN_CONTROL_POWER_DOWN_MASK)
+#define MR_AN_CONTROL_POWER_DOWN_RESET                               0x0 // 0
+#define MR_AN_CONTROL_RESTART_AN_MSB                                 9
+#define MR_AN_CONTROL_RESTART_AN_LSB                                 9
+#define MR_AN_CONTROL_RESTART_AN_MASK                                0x00000200
+#define MR_AN_CONTROL_RESTART_AN_GET(x)                              (((x) & MR_AN_CONTROL_RESTART_AN_MASK) >> MR_AN_CONTROL_RESTART_AN_LSB)
+#define MR_AN_CONTROL_RESTART_AN_SET(x)                              (((x) << MR_AN_CONTROL_RESTART_AN_LSB) & MR_AN_CONTROL_RESTART_AN_MASK)
+#define MR_AN_CONTROL_RESTART_AN_RESET                               0x0 // 0
+#define MR_AN_CONTROL_DUPLEX_MODE_MSB                                8
+#define MR_AN_CONTROL_DUPLEX_MODE_LSB                                8
+#define MR_AN_CONTROL_DUPLEX_MODE_MASK                               0x00000100
+#define MR_AN_CONTROL_DUPLEX_MODE_GET(x)                             (((x) & MR_AN_CONTROL_DUPLEX_MODE_MASK) >> MR_AN_CONTROL_DUPLEX_MODE_LSB)
+#define MR_AN_CONTROL_DUPLEX_MODE_SET(x)                             (((x) << MR_AN_CONTROL_DUPLEX_MODE_LSB) & MR_AN_CONTROL_DUPLEX_MODE_MASK)
+#define MR_AN_CONTROL_DUPLEX_MODE_RESET                              0x1 // 1
+#define MR_AN_CONTROL_SPEED_SEL1_MSB                                 6
+#define MR_AN_CONTROL_SPEED_SEL1_LSB                                 6
+#define MR_AN_CONTROL_SPEED_SEL1_MASK                                0x00000040
+#define MR_AN_CONTROL_SPEED_SEL1_GET(x)                              (((x) & MR_AN_CONTROL_SPEED_SEL1_MASK) >> MR_AN_CONTROL_SPEED_SEL1_LSB)
+#define MR_AN_CONTROL_SPEED_SEL1_SET(x)                              (((x) << MR_AN_CONTROL_SPEED_SEL1_LSB) & MR_AN_CONTROL_SPEED_SEL1_MASK)
+#define MR_AN_CONTROL_SPEED_SEL1_RESET                               0x1 // 1
+#define MR_AN_CONTROL_ADDRESS                                        0x1807001c
+
+
+
+
+
+// 32'h18070014 (SGMII_RESET)
+#define SGMII_RESET_HW_RX_125M_N_MSB                                 4
+#define SGMII_RESET_HW_RX_125M_N_LSB                                 4
+#define SGMII_RESET_HW_RX_125M_N_MASK                                0x00000010
+#define SGMII_RESET_HW_RX_125M_N_GET(x)                              (((x) & SGMII_RESET_HW_RX_125M_N_MASK) >> SGMII_RESET_HW_RX_125M_N_LSB)
+#define SGMII_RESET_HW_RX_125M_N_SET(x)                              (((x) << SGMII_RESET_HW_RX_125M_N_LSB) & SGMII_RESET_HW_RX_125M_N_MASK)
+#define SGMII_RESET_HW_RX_125M_N_RESET                               0x0 // 0
+#define SGMII_RESET_TX_125M_N_MSB                                    3
+#define SGMII_RESET_TX_125M_N_LSB                                    3
+#define SGMII_RESET_TX_125M_N_MASK                                   0x00000008
+#define SGMII_RESET_TX_125M_N_GET(x)                                 (((x) & SGMII_RESET_TX_125M_N_MASK) >> SGMII_RESET_TX_125M_N_LSB)
+#define SGMII_RESET_TX_125M_N_SET(x)                                 (((x) << SGMII_RESET_TX_125M_N_LSB) & SGMII_RESET_TX_125M_N_MASK)
+#define SGMII_RESET_TX_125M_N_RESET                                  0x0 // 0
+#define SGMII_RESET_RX_125M_N_MSB                                    2
+#define SGMII_RESET_RX_125M_N_LSB                                    2
+#define SGMII_RESET_RX_125M_N_MASK                                   0x00000004
+#define SGMII_RESET_RX_125M_N_GET(x)                                 (((x) & SGMII_RESET_RX_125M_N_MASK) >> SGMII_RESET_RX_125M_N_LSB)
+#define SGMII_RESET_RX_125M_N_SET(x)                                 (((x) << SGMII_RESET_RX_125M_N_LSB) & SGMII_RESET_RX_125M_N_MASK)
+#define SGMII_RESET_RX_125M_N_RESET                                  0x0 // 0
+#define SGMII_RESET_TX_CLK_N_MSB                                     1
+#define SGMII_RESET_TX_CLK_N_LSB                                     1
+#define SGMII_RESET_TX_CLK_N_MASK                                    0x00000002
+#define SGMII_RESET_TX_CLK_N_GET(x)                                  (((x) & SGMII_RESET_TX_CLK_N_MASK) >> SGMII_RESET_TX_CLK_N_LSB)
+#define SGMII_RESET_TX_CLK_N_SET(x)                                  (((x) << SGMII_RESET_TX_CLK_N_LSB) & SGMII_RESET_TX_CLK_N_MASK)
+#define SGMII_RESET_TX_CLK_N_RESET                                   0x0 // 0
+#define SGMII_RESET_RX_CLK_N_MSB                                     0
+#define SGMII_RESET_RX_CLK_N_LSB                                     0
+#define SGMII_RESET_RX_CLK_N_MASK                                    0x00000001
+#define SGMII_RESET_RX_CLK_N_GET(x)                                  (((x) & SGMII_RESET_RX_CLK_N_MASK) >> SGMII_RESET_RX_CLK_N_LSB)
+#define SGMII_RESET_RX_CLK_N_SET(x)                                  (((x) << SGMII_RESET_RX_CLK_N_LSB) & SGMII_RESET_RX_CLK_N_MASK)
+#define SGMII_RESET_RX_CLK_N_RESET                                   0x0 // 0
+#define SGMII_RESET_ADDRESS                                          0x18070014
+
+
+
+// 32'h18070038 (SGMII_MAC_RX_CONFIG)
+#define SGMII_MAC_RX_CONFIG_LINK_MSB                                 15
+#define SGMII_MAC_RX_CONFIG_LINK_LSB                                 15
+#define SGMII_MAC_RX_CONFIG_LINK_MASK                                0x00008000
+#define SGMII_MAC_RX_CONFIG_LINK_GET(x)                              (((x) & SGMII_MAC_RX_CONFIG_LINK_MASK) >> SGMII_MAC_RX_CONFIG_LINK_LSB)
+#define SGMII_MAC_RX_CONFIG_LINK_SET(x)                              (((x) << SGMII_MAC_RX_CONFIG_LINK_LSB) & SGMII_MAC_RX_CONFIG_LINK_MASK)
+#define SGMII_MAC_RX_CONFIG_LINK_RESET                               0x0 // 0
+#define SGMII_MAC_RX_CONFIG_ACK_MSB                                  14
+#define SGMII_MAC_RX_CONFIG_ACK_LSB                                  14
+#define SGMII_MAC_RX_CONFIG_ACK_MASK                                 0x00004000
+#define SGMII_MAC_RX_CONFIG_ACK_GET(x)                               (((x) & SGMII_MAC_RX_CONFIG_ACK_MASK) >> SGMII_MAC_RX_CONFIG_ACK_LSB)
+#define SGMII_MAC_RX_CONFIG_ACK_SET(x)                               (((x) << SGMII_MAC_RX_CONFIG_ACK_LSB) & SGMII_MAC_RX_CONFIG_ACK_MASK)
+#define SGMII_MAC_RX_CONFIG_ACK_RESET                                0x0 // 0
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MSB                          12
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_LSB                          12
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MASK                         0x00001000
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_GET(x)                       (((x) & SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MASK) >> SGMII_MAC_RX_CONFIG_DUPLEX_MODE_LSB)
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_SET(x)                       (((x) << SGMII_MAC_RX_CONFIG_DUPLEX_MODE_LSB) & SGMII_MAC_RX_CONFIG_DUPLEX_MODE_MASK)
+#define SGMII_MAC_RX_CONFIG_DUPLEX_MODE_RESET                        0x0 // 0
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_MSB                           11
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_LSB                           10
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_MASK                          0x00000c00
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_GET(x)                        (((x) & SGMII_MAC_RX_CONFIG_SPEED_MODE_MASK) >> SGMII_MAC_RX_CONFIG_SPEED_MODE_LSB)
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_SET(x)                        (((x) << SGMII_MAC_RX_CONFIG_SPEED_MODE_LSB) & SGMII_MAC_RX_CONFIG_SPEED_MODE_MASK)
+#define SGMII_MAC_RX_CONFIG_SPEED_MODE_RESET                         0x0 // 0
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_MSB                            8
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_LSB                            8
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_MASK                           0x00000100
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_GET(x)                         (((x) & SGMII_MAC_RX_CONFIG_ASM_PAUSE_MASK) >> SGMII_MAC_RX_CONFIG_ASM_PAUSE_LSB)
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_SET(x)                         (((x) << SGMII_MAC_RX_CONFIG_ASM_PAUSE_LSB) & SGMII_MAC_RX_CONFIG_ASM_PAUSE_MASK)
+#define SGMII_MAC_RX_CONFIG_ASM_PAUSE_RESET                          0x0 // 0
+#define SGMII_MAC_RX_CONFIG_PAUSE_MSB                                7
+#define SGMII_MAC_RX_CONFIG_PAUSE_LSB                                7
+#define SGMII_MAC_RX_CONFIG_PAUSE_MASK                               0x00000080
+#define SGMII_MAC_RX_CONFIG_PAUSE_GET(x)                             (((x) & SGMII_MAC_RX_CONFIG_PAUSE_MASK) >> SGMII_MAC_RX_CONFIG_PAUSE_LSB)
+#define SGMII_MAC_RX_CONFIG_PAUSE_SET(x)                             (((x) << SGMII_MAC_RX_CONFIG_PAUSE_LSB) & SGMII_MAC_RX_CONFIG_PAUSE_MASK)
+#define SGMII_MAC_RX_CONFIG_PAUSE_RESET                              0x0 // 0
+#define SGMII_MAC_RX_CONFIG_RES0_MSB                                 0
+#define SGMII_MAC_RX_CONFIG_RES0_LSB                                 0
+#define SGMII_MAC_RX_CONFIG_RES0_MASK                                0x00000001
+#define SGMII_MAC_RX_CONFIG_RES0_GET(x)                              (((x) & SGMII_MAC_RX_CONFIG_RES0_MASK) >> SGMII_MAC_RX_CONFIG_RES0_LSB)
+#define SGMII_MAC_RX_CONFIG_RES0_SET(x)                              (((x) << SGMII_MAC_RX_CONFIG_RES0_LSB) & SGMII_MAC_RX_CONFIG_RES0_MASK)
+#define SGMII_MAC_RX_CONFIG_RES0_RESET                               0x1 // 1
+#define SGMII_MAC_RX_CONFIG_ADDRESS                                  0x18070038
+
+// 32'h18070058 (SGMII_DEBUG)
+#define SGMII_DEBUG_ARB_STATE_MSB                                    27
+#define SGMII_DEBUG_ARB_STATE_LSB                                    24
+#define SGMII_DEBUG_ARB_STATE_MASK                                   0x0f000000
+#define SGMII_DEBUG_ARB_STATE_GET(x)                                 (((x) & SGMII_DEBUG_ARB_STATE_MASK) >> SGMII_DEBUG_ARB_STATE_LSB)
+#define SGMII_DEBUG_ARB_STATE_SET(x)                                 (((x) << SGMII_DEBUG_ARB_STATE_LSB) & SGMII_DEBUG_ARB_STATE_MASK)
+#define SGMII_DEBUG_ARB_STATE_RESET                                  0x0 // 0
+#define SGMII_DEBUG_RX_SYNC_STATE_MSB                                23
+#define SGMII_DEBUG_RX_SYNC_STATE_LSB                                16
+#define SGMII_DEBUG_RX_SYNC_STATE_MASK                               0x00ff0000
+#define SGMII_DEBUG_RX_SYNC_STATE_GET(x)                             (((x) & SGMII_DEBUG_RX_SYNC_STATE_MASK) >> SGMII_DEBUG_RX_SYNC_STATE_LSB)
+#define SGMII_DEBUG_RX_SYNC_STATE_SET(x)                             (((x) << SGMII_DEBUG_RX_SYNC_STATE_LSB) & SGMII_DEBUG_RX_SYNC_STATE_MASK)
+#define SGMII_DEBUG_RX_SYNC_STATE_RESET                              0x0 // 0
+#define SGMII_DEBUG_RX_STATE_MSB                                     15
+#define SGMII_DEBUG_RX_STATE_LSB                                     8
+#define SGMII_DEBUG_RX_STATE_MASK                                    0x0000ff00
+#define SGMII_DEBUG_RX_STATE_GET(x)                                  (((x) & SGMII_DEBUG_RX_STATE_MASK) >> SGMII_DEBUG_RX_STATE_LSB)
+#define SGMII_DEBUG_RX_STATE_SET(x)                                  (((x) << SGMII_DEBUG_RX_STATE_LSB) & SGMII_DEBUG_RX_STATE_MASK)
+#define SGMII_DEBUG_RX_STATE_RESET                                   0x0 // 0
+#define SGMII_DEBUG_TX_STATE_MSB                                     7
+#define SGMII_DEBUG_TX_STATE_LSB                                     0
+#define SGMII_DEBUG_TX_STATE_MASK                                    0x000000ff
+#define SGMII_DEBUG_TX_STATE_GET(x)                                  (((x) & SGMII_DEBUG_TX_STATE_MASK) >> SGMII_DEBUG_TX_STATE_LSB)
+#define SGMII_DEBUG_TX_STATE_SET(x)                                  (((x) << SGMII_DEBUG_TX_STATE_LSB) & SGMII_DEBUG_TX_STATE_MASK)
+#define SGMII_DEBUG_TX_STATE_RESET                                   0x0 // 0
+#define SGMII_DEBUG_ADDRESS                                          0x18070058
+#define SGMII_DEBUG_OFFSET                                           0x0058
+
+
+
+// 32'h18070060 (SGMII_INTERRUPT_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_MSB                                7
+#define SGMII_INTERRUPT_MASK_MASK_LSB                                0
+#define SGMII_INTERRUPT_MASK_MASK_MASK                               0x000000ff
+#define SGMII_INTERRUPT_MASK_MASK_GET(x)                             (((x) & SGMII_INTERRUPT_MASK_MASK_MASK) >> SGMII_INTERRUPT_MASK_MASK_LSB)
+#define SGMII_INTERRUPT_MASK_MASK_SET(x)                             (((x) << SGMII_INTERRUPT_MASK_MASK_LSB) & SGMII_INTERRUPT_MASK_MASK_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_RESET                              0x0 // 0
+#define SGMII_INTERRUPT_MASK_ADDRESS                                 0x18070060
+
+
+
+
+// 32'h1807005c (SGMII_INTERRUPT)
+#define SGMII_INTERRUPT_INTR_MSB                                     7
+#define SGMII_INTERRUPT_INTR_LSB                                     0
+#define SGMII_INTERRUPT_INTR_MASK                                    0x000000ff
+#define SGMII_INTERRUPT_INTR_GET(x)                                  (((x) & SGMII_INTERRUPT_INTR_MASK) >> SGMII_INTERRUPT_INTR_LSB)
+#define SGMII_INTERRUPT_INTR_SET(x)                                  (((x) << SGMII_INTERRUPT_INTR_LSB) & SGMII_INTERRUPT_INTR_MASK)
+#define SGMII_INTERRUPT_INTR_RESET                                   0x0 // 0
+#define SGMII_INTERRUPT_ADDRESS                                      0x1807005c
+#define SGMII_INTERRUPT_OFFSET                                       0x005c
+// SW modifiable bits
+#define SGMII_INTERRUPT_SW_MASK                                      0x000000ff
+// bits defined at reset
+#define SGMII_INTERRUPT_RSTMASK                                      0xffffffff
+// reset value (ignore bits undefined at reset)
+#define SGMII_INTERRUPT_RESET                                        0x00000000
+
+// 32'h18070060 (SGMII_INTERRUPT_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_MSB                                7
+#define SGMII_INTERRUPT_MASK_MASK_LSB                                0
+#define SGMII_INTERRUPT_MASK_MASK_MASK                               0x000000ff
+#define SGMII_INTERRUPT_MASK_MASK_GET(x)                             (((x) & SGMII_INTERRUPT_MASK_MASK_MASK) >> SGMII_INTERRUPT_MASK_MASK_LSB)
+#define SGMII_INTERRUPT_MASK_MASK_SET(x)                             (((x) << SGMII_INTERRUPT_MASK_MASK_LSB) & SGMII_INTERRUPT_MASK_MASK_MASK)
+#define SGMII_INTERRUPT_MASK_MASK_RESET                              0x0 // 0
+#define SGMII_INTERRUPT_MASK_ADDRESS                                 0x18070060
+
+
+#define SGMII_LINK_FAIL				(1 << 0)
+#define SGMII_DUPLEX_ERR			(1 << 1)
+#define SGMII_MR_AN_COMPLETE			(1 << 2)
+#define SGMII_LINK_MAC_CHANGE			(1 << 3)
+#define SGMII_DUPLEX_MODE_CHANGE		(1 << 4)
+#define SGMII_SPEED_MODE_MAC_CHANGE		(1 << 5)
+#define SGMII_RX_QUIET_CHANGE			(1 << 6)
+#define SGMII_RX_MDIO_COMP_CHANGE		(1 << 7)
+
+#define SGMII_INTR				SGMII_LINK_FAIL | \
+						SGMII_LINK_MAC_CHANGE | \
+						SGMII_DUPLEX_MODE_CHANGE | \
+						SGMII_SPEED_MODE_MAC_CHANGE
+
+
+// 32'h18050048 (ETH_SGMII)
+#define ETH_SGMII_TX_INVERT_MSB                                      31
+#define ETH_SGMII_TX_INVERT_LSB                                      31
+#define ETH_SGMII_TX_INVERT_MASK                                     0x80000000
+#define ETH_SGMII_TX_INVERT_GET(x)                                   (((x) & ETH_SGMII_TX_INVERT_MASK) >> ETH_SGMII_TX_INVERT_LSB)
+#define ETH_SGMII_TX_INVERT_SET(x)                                   (((x) << ETH_SGMII_TX_INVERT_LSB) & ETH_SGMII_TX_INVERT_MASK)
+#define ETH_SGMII_TX_INVERT_RESET                                    0x0 // 0
+#define ETH_SGMII_GIGE_QUAD_MSB                                      30
+#define ETH_SGMII_GIGE_QUAD_LSB                                      30
+#define ETH_SGMII_GIGE_QUAD_MASK                                     0x40000000
+#define ETH_SGMII_GIGE_QUAD_GET(x)                                   (((x) & ETH_SGMII_GIGE_QUAD_MASK) >> ETH_SGMII_GIGE_QUAD_LSB)
+#define ETH_SGMII_GIGE_QUAD_SET(x)                                   (((x) << ETH_SGMII_GIGE_QUAD_LSB) & ETH_SGMII_GIGE_QUAD_MASK)
+#define ETH_SGMII_GIGE_QUAD_RESET                                    0x0 // 0
+#define ETH_SGMII_RX_DELAY_MSB                                       29
+#define ETH_SGMII_RX_DELAY_LSB                                       28
+#define ETH_SGMII_RX_DELAY_MASK                                      0x30000000
+#define ETH_SGMII_RX_DELAY_GET(x)                                    (((x) & ETH_SGMII_RX_DELAY_MASK) >> ETH_SGMII_RX_DELAY_LSB)
+#define ETH_SGMII_RX_DELAY_SET(x)                                    (((x) << ETH_SGMII_RX_DELAY_LSB) & ETH_SGMII_RX_DELAY_MASK)
+#define ETH_SGMII_RX_DELAY_RESET                                     0x0 // 0
+#define ETH_SGMII_TX_DELAY_MSB                                       27
+#define ETH_SGMII_TX_DELAY_LSB                                       26
+#define ETH_SGMII_TX_DELAY_MASK                                      0x0c000000
+#define ETH_SGMII_TX_DELAY_GET(x)                                    (((x) & ETH_SGMII_TX_DELAY_MASK) >> ETH_SGMII_TX_DELAY_LSB)
+#define ETH_SGMII_TX_DELAY_SET(x)                                    (((x) << ETH_SGMII_TX_DELAY_LSB) & ETH_SGMII_TX_DELAY_MASK)
+#define ETH_SGMII_TX_DELAY_RESET                                     0x0 // 0
+#define ETH_SGMII_CLK_SEL_MSB                                        25
+#define ETH_SGMII_CLK_SEL_LSB                                        25
+#define ETH_SGMII_CLK_SEL_MASK                                       0x02000000
+#define ETH_SGMII_CLK_SEL_GET(x)                                     (((x) & ETH_SGMII_CLK_SEL_MASK) >> ETH_SGMII_CLK_SEL_LSB)
+#define ETH_SGMII_CLK_SEL_SET(x)                                     (((x) << ETH_SGMII_CLK_SEL_LSB) & ETH_SGMII_CLK_SEL_MASK)
+#define ETH_SGMII_CLK_SEL_RESET                                      0x1 // 1
+#define ETH_SGMII_GIGE_MSB                                           24
+#define ETH_SGMII_GIGE_LSB                                           24
+#define ETH_SGMII_GIGE_MASK                                          0x01000000
+#define ETH_SGMII_GIGE_GET(x)                                        (((x) & ETH_SGMII_GIGE_MASK) >> ETH_SGMII_GIGE_LSB)
+#define ETH_SGMII_GIGE_SET(x)                                        (((x) << ETH_SGMII_GIGE_LSB) & ETH_SGMII_GIGE_MASK)
+#define ETH_SGMII_GIGE_RESET                                         0x1 // 1
+#define ETH_SGMII_PHASE1_COUNT_MSB                                   15
+#define ETH_SGMII_PHASE1_COUNT_LSB                                   8
+#define ETH_SGMII_PHASE1_COUNT_MASK                                  0x0000ff00
+#define ETH_SGMII_PHASE1_COUNT_GET(x)                                (((x) & ETH_SGMII_PHASE1_COUNT_MASK) >> ETH_SGMII_PHASE1_COUNT_LSB)
+#define ETH_SGMII_PHASE1_COUNT_SET(x)                                (((x) << ETH_SGMII_PHASE1_COUNT_LSB) & ETH_SGMII_PHASE1_COUNT_MASK)
+#define ETH_SGMII_PHASE1_COUNT_RESET                                 0x1 // 1
+#define ETH_SGMII_PHASE0_COUNT_MSB                                   7
+#define ETH_SGMII_PHASE0_COUNT_LSB                                   0
+#define ETH_SGMII_PHASE0_COUNT_MASK                                  0x000000ff
+#define ETH_SGMII_PHASE0_COUNT_GET(x)                                (((x) & ETH_SGMII_PHASE0_COUNT_MASK) >> ETH_SGMII_PHASE0_COUNT_LSB)
+#define ETH_SGMII_PHASE0_COUNT_SET(x)                                (((x) << ETH_SGMII_PHASE0_COUNT_LSB) & ETH_SGMII_PHASE0_COUNT_MASK)
+#define ETH_SGMII_PHASE0_COUNT_RESET                                 0x1 // 1
+#define ETH_SGMII_ADDRESS                                            0x18050048
+
+
+#define OTP_INTF2_ADDRESS                                            0x18131008
+#define OTP_LDO_CONTROL_ADDRESS                                      0x18131024
+
+#define OTP_LDO_STATUS_POWER_ON_MSB                                  0
+#define OTP_LDO_STATUS_POWER_ON_LSB                                  0
+#define OTP_LDO_STATUS_POWER_ON_MASK                                 0x00000001
+#define OTP_LDO_STATUS_POWER_ON_GET(x)                               (((x) & OTP_LDO_STATUS_POWER_ON_MASK) >> OTP_LDO_STATUS_POWER_ON_LSB)
+#define OTP_LDO_STATUS_POWER_ON_SET(x)                               (((x) << OTP_LDO_STATUS_POWER_ON_LSB) & OTP_LDO_STATUS_POWER_ON_MASK)
+#define OTP_LDO_STATUS_POWER_ON_RESET                                0x0 // 0
+#define OTP_LDO_STATUS_ADDRESS                                       0x1813102c
+
+#define OTP_MEM_0_ADDRESS                                            0x18130000
+
+#define OTP_STATUS0_EFUSE_READ_DATA_VALID_MSB                        2
+#define OTP_STATUS0_EFUSE_READ_DATA_VALID_LSB                        2
+#define OTP_STATUS0_EFUSE_READ_DATA_VALID_MASK                       0x00000004
+#define OTP_STATUS0_EFUSE_READ_DATA_VALID_GET(x)                     (((x) & OTP_STATUS0_EFUSE_READ_DATA_VALID_MASK) >> OTP_STATUS0_EFUSE_READ_DATA_VALID_LSB)
+#define OTP_STATUS0_EFUSE_READ_DATA_VALID_SET(x)                     (((x) << OTP_STATUS0_EFUSE_READ_DATA_VALID_LSB) & OTP_STATUS0_EFUSE_READ_DATA_VALID_MASK)
+#define OTP_STATUS0_EFUSE_READ_DATA_VALID_RESET                      0x0 // 0
+#define OTP_STATUS0_EFUSE_ACCESS_BUSY_MSB                            1
+#define OTP_STATUS0_EFUSE_ACCESS_BUSY_LSB                            1
+#define OTP_STATUS0_EFUSE_ACCESS_BUSY_MASK                           0x00000002
+#define OTP_STATUS0_EFUSE_ACCESS_BUSY_GET(x)                         (((x) & OTP_STATUS0_EFUSE_ACCESS_BUSY_MASK) >> OTP_STATUS0_EFUSE_ACCESS_BUSY_LSB)
+#define OTP_STATUS0_EFUSE_ACCESS_BUSY_SET(x)                         (((x) << OTP_STATUS0_EFUSE_ACCESS_BUSY_LSB) & OTP_STATUS0_EFUSE_ACCESS_BUSY_MASK)
+#define OTP_STATUS0_EFUSE_ACCESS_BUSY_RESET                          0x0 // 0
+#define OTP_STATUS0_OTP_SM_BUSY_MSB                                  0
+#define OTP_STATUS0_OTP_SM_BUSY_LSB                                  0
+#define OTP_STATUS0_OTP_SM_BUSY_MASK                                 0x00000001
+#define OTP_STATUS0_OTP_SM_BUSY_GET(x)                               (((x) & OTP_STATUS0_OTP_SM_BUSY_MASK) >> OTP_STATUS0_OTP_SM_BUSY_LSB)
+#define OTP_STATUS0_OTP_SM_BUSY_SET(x)                               (((x) << OTP_STATUS0_OTP_SM_BUSY_LSB) & OTP_STATUS0_OTP_SM_BUSY_MASK)
+#define OTP_STATUS0_OTP_SM_BUSY_RESET                                0x0 // 0
+#define OTP_STATUS0_ADDRESS                                          0x18131018
+
+#define OTP_STATUS1_ADDRESS                                          0x1813101c
+
+
+
+
+
+#endif /* _QCA955X_H */
diff --git a/include/LzmaWrapper.h b/include/LzmaWrapper.h
new file mode 100644
index 0000000000..2f9a3ffbbb
--- /dev/null
+++ b/include/LzmaWrapper.h
@@ -0,0 +1,36 @@
+/******************************************************************************
+**
+** FILE NAME    : LzmaWrapper.h
+** PROJECT      : bootloader
+** MODULES      : U-boot
+**
+** DATE         : 2 Nov 2006
+** AUTHOR       : Lin Mars
+** DESCRIPTION  : LZMA decoder support for U-boot 1.1.5
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 2 Nov 2006   Lin Mars        init version which derived from LzmaTest.c from
+**                              LZMA v4.43 SDK
+*******************************************************************************/
+#ifndef  __LZMA_WRAPPER_H__
+#define  __LZMA_WRAPPER_H__
+
+#ifndef LZMA_RESULT_OK
+#define LZMA_RESULT_OK 0
+#endif
+#ifndef LZMA_RESULT_DATA_ERROR
+#define LZMA_RESULT_DATA_ERROR 1
+#endif
+
+extern int lzma_inflate(unsigned char *source, int s_len, unsigned char *dest, int *d_len);
+
+#endif /*__LZMA_WRAPPER_H__*/
diff --git a/include/ar7100_soc.h b/include/ar7100_soc.h
new file mode 100644
index 0000000000..0d2f5a043b
--- /dev/null
+++ b/include/ar7100_soc.h
@@ -0,0 +1,603 @@
+#ifndef _AR7100_SOC_H
+#define _AR7100_SOC_H
+
+#include <config.h>
+#ifdef CONFIG_AR9100
+#define AR9100
+#endif
+
+/*
+ * Address map
+ */
+#ifndef AR9100
+#define AR7100_PCI_MEM_BASE             0x10000000  /* 128M */
+#endif
+#define AR7100_APB_BASE                 0x18000000  /* 384M */
+#define AR7100_GE0_BASE                 0x19000000  /* 16M */
+#define AR7100_GE1_BASE                 0x1a000000  /* 16M */
+#define AR7100_USB_EHCI_BASE            0x1b000000
+#define AR7100_USB_OHCI_BASE            0x1c000000
+#define AR7100_SPI_BASE                 0x1f000000
+
+/*
+ * APB block
+ */
+#define AR7100_DDR_CTL_BASE             AR7100_APB_BASE+0x00000000
+#define AR7100_CPU_BASE                 AR7100_APB_BASE+0x00010000
+#define AR7100_UART_BASE                AR7100_APB_BASE+0x00020000
+#define AR7100_USB_CONFIG_BASE          AR7100_APB_BASE+0x00030000
+#define AR7100_GPIO_BASE                AR7100_APB_BASE+0x00040000
+#define AR7100_PLL_BASE                 AR7100_APB_BASE+0x00050000
+#define AR7100_RESET_BASE               AR7100_APB_BASE+0x00060000
+#define AR7100_MII_BASE                 AR7100_APB_BASE+0x00070000
+
+/*
+ * DDR block
+ */
+
+#define AR7100_DDR_CONFIG               AR7100_DDR_CTL_BASE+0
+#define AR7100_DDR_CONFIG2              AR7100_DDR_CTL_BASE+4
+#define AR7100_DDR_MODE                 AR7100_DDR_CTL_BASE+0x08
+#define AR7100_DDR_EXT_MODE             AR7100_DDR_CTL_BASE+0x0c
+#define AR7100_DDR_CONTROL              AR7100_DDR_CTL_BASE+0x10
+#define AR7100_DDR_REFRESH              AR7100_DDR_CTL_BASE+0x14
+#define AR7100_DDR_RD_DATA_THIS_CYCLE   AR7100_DDR_CTL_BASE+0x18
+#define AR7100_DDR_TAP_CONTROL0         AR7100_DDR_CTL_BASE+0x1c
+#define AR7100_DDR_TAP_CONTROL1         AR7100_DDR_CTL_BASE+0x20
+#define AR7100_DDR_TAP_CONTROL2         AR7100_DDR_CTL_BASE+0x24
+#define AR7100_DDR_TAP_CONTROL3         AR7100_DDR_CTL_BASE+0x28
+
+#define AR7100_DDR_CONFIG_16BIT             (1 << 31)
+#define AR7100_DDR_CONFIG_PAGE_OPEN         (1 << 30)
+#define AR7100_DDR_CONFIG_CAS_LAT_SHIFT      27
+#define AR7100_DDR_CONFIG_TMRD_SHIFT         23
+#define AR7100_DDR_CONFIG_TRFC_SHIFT         17
+#define AR7100_DDR_CONFIG_TRRD_SHIFT         13
+#define AR7100_DDR_CONFIG_TRP_SHIFT          9
+#define AR7100_DDR_CONFIG_TRCD_SHIFT         5
+#define AR7100_DDR_CONFIG_TRAS_SHIFT         0
+
+#define AR7100_DDR_CONFIG2_BL2          (2 << 0)
+#define AR7100_DDR_CONFIG2_BL4          (4 << 0)
+#define AR7100_DDR_CONFIG2_BL8          (8 << 0)
+
+#define AR7100_DDR_CONFIG2_BT_IL        (1 << 4)
+#define AR7100_DDR_CONFIG2_CNTL_OE_EN   (1 << 5)
+#define AR7100_DDR_CONFIG2_PHASE_SEL    (1 << 6)
+#define AR7100_DDR_CONFIG2_DRAM_CKE     (1 << 7)
+#define AR7100_DDR_CONFIG2_TWR_SHIFT    8
+#define AR7100_DDR_CONFIG2_TRTW_SHIFT   12
+#define AR7100_DDR_CONFIG2_TRTP_SHIFT   17
+#define AR7100_DDR_CONFIG2_TWTR_SHIFT   21
+#define AR7100_DDR_CONFIG2_HALF_WIDTH_L (1 << 31)
+
+#define AR7100_DDR_TAP_DEFAULT          0x18
+
+/*
+ * PLL
+ */
+#define AR7100_CPU_PLL_CONFIG           AR7100_PLL_BASE
+#ifndef AR9100
+
+#ifdef CONFIG_AR7100
+/* JK legacy: not sure if still valid */
+#define AR7100_USB_PLL_CONFIG           AR7100_PLL_BASE+0x4
+#define AR7100_USB_PLL_GE0_OFFSET       AR7100_PLL_BASE+0x10
+#define AR7100_USB_PLL_GE1_OFFSET       AR7100_PLL_BASE+0x14
+#endif
+
+#define AR7100_SEC_PLL_CONFIG           AR7100_PLL_BASE+0x04
+#define AR7100_CPU_CLOCK_CONTROL        AR7100_PLL_BASE+0x08
+#define AR7100_ETH_INT0_CLK				AR7100_PLL_BASE+0x10
+#define AR7100_ETH_INT1_CLK				AR7100_PLL_BASE+0x14
+#define AR7100_ETH_EXT_CLK				AR7100_PLL_BASE+0x18
+#define AR7100_PCI_CLK                  AR7100_PLL_BASE+0x1c
+
+#else
+
+#define AR7100_ETH_PLL_CONFIG           AR7100_PLL_BASE+0x4
+#define AR7100_USB_PLL_CONFIG           AR7100_PLL_BASE+0x8
+#define AR7100_CPU_CLOCK_CONTROL        AR7100_PLL_BASE+0xc
+#define AR7100_ETH_INT0_CLK             AR7100_PLL_BASE+0x14
+#define AR7100_ETH_INT1_CLK             AR7100_PLL_BASE+0x18
+#define AR7100_ETH_EXT_CLK              AR7100_PLL_BASE+0x1c
+
+#endif
+
+#ifdef AR9100
+#define PLL_CONFIG_PLL_FB_SHIFT         0
+#define PLL_CONFIG_PLL_FB_MASK          (0x3ff << PLL_CONFIG_PLL_FB_SHIFT)
+#define PLL_CONFIG_REF_DIV_SHIFT        10
+#define PLL_CONFIG_REF_DIV_MASK         (0xf << PLL_CONFIG_REF_DIV_SHIFT)
+#define PLL_CONFIG_PLL_BYPASS_SHIFT     16
+#define PLL_CONFIG_PLL_BYPASS_MASK      (1 << PLL_CONFIG_PLL_BYPASS_SHIFT)
+#define PLL_CONFIG_SW_UPDATE_SHIFT      17
+#define PLL_CONFIG_SW_UPDATE_MASK       (1 << PLL_CONFIG_SW_UPDATE_SHIFT)
+#define PLL_CONFIG_PLL_NOPWD_SHIFT 18
+#define PLL_CONFIG_PLL_NOPWD_MASK  (1 << PLL_CONFIG_PLL_POWER_DOWN_SHIFT)
+#define PLL_CONFIG_AHB_DIV_SHIFT        19
+#define PLL_CONFIG_AHB_DIV_MASK         (1 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_DDR_DIV_SHIFT        22
+#define PLL_CONFIG_DDR_DIV_MASK         (3 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_PLL_RESET_SHIFT      25
+#define PLL_CONFIG_PLL_RESET_MASK       (1 << PLL_CONFIG_PLL_RESET_SHIFT)
+#else
+#define PLL_CONFIG_PLL_POWER_DOWN_MASK  (1 << 0)
+#define PLL_CONFIG_PLL_BYPASS_MASK      (1 << 1)
+#define PLL_CONFIG_PLL_FB_SHIFT         3
+#define PLL_CONFIG_PLL_FB_MASK          (0x1f << PLL_CONFIG_PLL_FB_SHIFT)
+#define PLL_CONFIG_PLL_DIVOUT_SHIFT     8
+#define PLL_CONFIG_PLL_DIVOUT_MASK      (0x03 << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+#define PLL_CONFIG_PLL_LOOP_BW_SHIFT    12
+#define PLL_CONFIG_PLL_LOOP_BW_MASK     (0xf << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+#define PLL_CONFIG_CPU_DIV_SHIFT        16
+#define PLL_CONFIG_CPU_DIV_MASK         (3 << PLL_CONFIG_CPU_DIV_SHIFT)
+#define PLL_CONFIG_DDR_DIV_SHIFT        18
+#define PLL_CONFIG_DDR_DIV_MASK         (3 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_SHIFT        20
+#define PLL_CONFIG_AHB_DIV_MASK         (7 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_LOCKED_SHIFT         30
+#define PLL_CONFIG_LOCKED_MASK          (1 << PLL_CONFIG_LOCKED_SHIFT)
+#define PLL_CONFIG_SW_UPDATE_SHIFT      31
+#define PLL_CONFIG_SW_UPDATE_MASK       (1 << 31)
+#endif
+
+#define CLOCK_CONTROL_CLOCK_SWITCH_SHIFT  0
+#define CLOCK_CONTROL_CLOCK_SWITCH_MASK  (1 << CLOCK_CONTROL_CLOCK_SWITCH_SHIFT)
+#define CLOCK_CONTROL_RST_SWITCH_SHIFT    1
+#define CLOCK_CONTROL_RST_SWITCH_MASK    (1 << CLOCK_CONTROL_RST_SWITCH_SHIFT)
+
+/*
+** PLL config for different CPU/DDR/AHB frequencies
+*/
+#ifdef AR9100
+
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#define PLL_CONFIG_PLL_FB_VAL    (0x28 << PLL_CONFIG_PLL_FB_SHIFT)
+#define PLL_CONFIG_DDR_DIV_VAL   (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+
+#define PLL_CONFIG_PLL_FB_VAL    (0x3c << PLL_CONFIG_PLL_FB_SHIFT)
+#define PLL_CONFIG_DDR_DIV_VAL   (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+
+#define PLL_CONFIG_PLL_FB_VAL    (0x50 << PLL_CONFIG_PLL_FB_SHIFT)
+#define PLL_CONFIG_DDR_DIV_VAL   (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_360_360_180)
+
+#define PLL_CONFIG_PLL_FB_VAL    (0x48 << PLL_CONFIG_PLL_FB_SHIFT)
+#define PLL_CONFIG_DDR_DIV_VAL   (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+
+#define PLL_CONFIG_PLL_FB_VAL    (0x50 << PLL_CONFIG_PLL_FB_SHIFT)
+#define PLL_CONFIG_DDR_DIV_VAL   (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x1 << PLL_CONFIG_AHB_DIV_SHIFT)
+#endif
+
+#else
+/*
+** Standard ar7100 values
+*/
+
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+
+#define PLL_CONFIG_CPU_DIV_VAL   (0x3 << PLL_CONFIG_CPU_DIV_SHIFT)
+#define PLL_CONFIG_DDR_DIV_VAL   (0x3 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_FB_VAL    (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+#define PLL_CONFIG_PLL_LOOP_BW_VAL (0x3 << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+#define PLL_CONFIG_PLL_DIVOUT_VAL (0x0 << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+
+#define PLL_CONFIG_CPU_DIV_VAL   (0x2 << PLL_CONFIG_CPU_DIV_SHIFT)
+#define PLL_CONFIG_DDR_DIV_VAL   (0x2 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_FB_VAL    (0x18 << PLL_CONFIG_PLL_FB_SHIFT)
+#define PLL_CONFIG_PLL_LOOP_BW_VAL (0x3 << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+#define PLL_CONFIG_PLL_DIVOUT_VAL (0x0 << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+
+#define PLL_CONFIG_CPU_DIV_VAL   (0x2 << PLL_CONFIG_CPU_DIV_SHIFT)
+#define PLL_CONFIG_DDR_DIV_VAL   (0x2 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x1 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_FB_VAL    (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+#define PLL_CONFIG_PLL_LOOP_BW_VAL (0x3 << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+#define PLL_CONFIG_PLL_DIVOUT_VAL (0x0 << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+
+#define PLL_CONFIG_CPU_DIV_VAL   (0x1 << PLL_CONFIG_CPU_DIV_SHIFT)
+#define PLL_CONFIG_DDR_DIV_VAL   (0x1 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_FB_VAL    (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+#define PLL_CONFIG_PLL_LOOP_BW_VAL (0x3 << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+#define PLL_CONFIG_PLL_DIVOUT_VAL (0x0 << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+
+#define PLL_CONFIG_CPU_DIV_VAL   (0x2 << PLL_CONFIG_CPU_DIV_SHIFT)
+#define PLL_CONFIG_DDR_DIV_VAL   (0x2 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_FB_VAL    (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+#define PLL_CONFIG_PLL_LOOP_BW_VAL (0x3 << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+#define PLL_CONFIG_PLL_DIVOUT_VAL (0x0 << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_680_340_170)
+
+#define PLL_CONFIG_CPU_DIV_VAL   	(0x0 << PLL_CONFIG_CPU_DIV_SHIFT)
+#define PLL_CONFIG_DDR_DIV_VAL   	(0x1 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   	(0x1 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_FB_VAL    	(0x10 << PLL_CONFIG_PLL_FB_SHIFT)
+#define PLL_CONFIG_PLL_LOOP_BW_VAL	(0x0 << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+#define PLL_CONFIG_PLL_DIVOUT_VAL	(0x1 << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+
+#define PLL_CONFIG_CPU_DIV_VAL   	(0x1 << PLL_CONFIG_CPU_DIV_SHIFT)
+#define PLL_CONFIG_DDR_DIV_VAL   	(0x3 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   	(0x1 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_FB_VAL    	(0x1d << PLL_CONFIG_PLL_FB_SHIFT)
+#define PLL_CONFIG_PLL_LOOP_BW_VAL	(0x0 << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+#define PLL_CONFIG_PLL_DIVOUT_VAL	(0x0 << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+
+#else /* default is 300/300/150 */
+
+#define PLL_CONFIG_CPU_DIV_VAL   (0x3 << PLL_CONFIG_CPU_DIV_SHIFT)
+#define PLL_CONFIG_DDR_DIV_VAL   (0x3 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_FB_VAL    (0x1d << PLL_CONFIG_PLL_FB_SHIFT)
+#define PLL_CONFIG_PLL_LOOP_BW_VAL (0x0 << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+
+#endif  /* CFG_PLL_FREQ */
+#endif
+
+#define AR7100_PLL_200_200_100   1
+#define AR7100_PLL_300_300_150   2
+#define AR7100_PLL_333_333_166   3
+#define AR7100_PLL_266_266_133   4
+#define AR7100_PLL_266_266_66    5
+#define AR7100_PLL_400_400_200   6
+#define AR7100_PLL_600_400_150   7
+
+#if 0
+/*
+ * PLL block
+ */
+#define AR7100_PLL_CONFIG               AR7100_PLL_BASE+0x0
+
+#define PLL_DIV_SHIFT   3
+#define PLL_DIV_MASK    0x1f
+#define CPU_DIV_SHIFT   16
+#define CPU_DIV_MASK    0x3
+#define DDR_DIV_SHIFT   18
+#define DDR_DIV_MASK    0x3
+#define AHB_DIV_SHIFT   20
+#define AHB_DIV_MASK    0x7
+
+/*
+ * CLOCK
+ */
+#define AR7100_CPU_CLOCK_CONTROL        AR7100_PLL_BASE+8
+#define CLOCK_CONTROL_CLOCK_SWITCH_SHIFT  0
+#define CLOCK_CONTROL_CLOCK_SWITCH_MASK  (1 << CLOCK_CONTROL_CLOCK_SWITCH_SHIFT)
+#define CLOCK_CONTROL_RST_SWITCH_SHIFT    1
+#define CLOCK_CONTROL_RST_SWITCH_MASK    (1 << CLOCK_CONTROL_RST_SWITCH_SHIFT)
+#endif
+
+/*
+ * FIFO flushes
+ */
+#ifdef AR9100
+#define AR7100_DDR_GE0_FLUSH            AR7100_DDR_CTL_BASE+0x7c
+#define AR7100_DDR_GE1_FLUSH            AR7100_DDR_CTL_BASE+0x80
+#define AR7100_DDR_WMAC_FLUSH            AR7100_DDR_CTL_BASE+0x88
+#else
+#define AR7100_DDR_GE0_FLUSH            AR7100_DDR_CTL_BASE+0x9c
+#define AR7100_DDR_GE1_FLUSH            AR7100_DDR_CTL_BASE+0xa0
+#define AR7100_DDR_PCI_FLUSH            AR7100_DDR_CTL_BASE+0xa8
+#endif
+
+/*
+ * USB block
+ */
+#define AR7100_USB_FLADJ_VAL            AR7100_USB_CONFIG_BASE
+#define AR7100_USB_CONFIG               AR7100_USB_CONFIG_BASE+0x4
+#define AR7100_USB_WINDOW               0x1000000
+
+#ifndef AR9100
+/*
+ * PCI block
+ */
+#define AR7100_PCI_WINDOW           0x8000000       /* 128MB */
+#define AR7100_PCI_WINDOW0_OFFSET   AR7100_DDR_CTL_BASE+0x7c
+#define AR7100_PCI_WINDOW1_OFFSET   AR7100_DDR_CTL_BASE+0x80
+#define AR7100_PCI_WINDOW2_OFFSET   AR7100_DDR_CTL_BASE+0x84
+#define AR7100_PCI_WINDOW3_OFFSET   AR7100_DDR_CTL_BASE+0x88
+#define AR7100_PCI_WINDOW4_OFFSET   AR7100_DDR_CTL_BASE+0x8c
+#define AR7100_PCI_WINDOW5_OFFSET   AR7100_DDR_CTL_BASE+0x90
+#define AR7100_PCI_WINDOW6_OFFSET   AR7100_DDR_CTL_BASE+0x94
+#define AR7100_PCI_WINDOW7_OFFSET   AR7100_DDR_CTL_BASE+0x98
+
+#define AR7100_PCI_WINDOW0_VAL      0x10000000
+#define AR7100_PCI_WINDOW1_VAL      0x11000000
+#define AR7100_PCI_WINDOW2_VAL      0x12000000
+#define AR7100_PCI_WINDOW3_VAL      0x13000000
+#define AR7100_PCI_WINDOW4_VAL      0x14000000
+#define AR7100_PCI_WINDOW5_VAL      0x15000000
+#define AR7100_PCI_WINDOW6_VAL      0x16000000
+#define AR7100_PCI_WINDOW7_VAL      0x07000000
+
+
+/*
+ * CRP. To access the host controller config and status registers
+ */
+#define AR7100_PCI_CRP   (AR7100_PCI_MEM_BASE|(AR7100_PCI_WINDOW7_VAL+0x10000))
+
+#define AR7100_PCI_CRP_AD_CBE               AR7100_PCI_CRP
+#define AR7100_PCI_CRP_WRDATA               AR7100_PCI_CRP+0x4
+#define AR7100_PCI_CRP_RDDATA               AR7100_PCI_CRP+0x8
+#define AR7100_PCI_ERROR            AR7100_PCI_CRP+0x1c
+#define AR7100_PCI_ERROR_ADDRESS    AR7100_PCI_CRP+0x20
+#define AR7100_PCI_AHB_ERROR            AR7100_PCI_CRP+0x24
+#define AR7100_PCI_AHB_ERROR_ADDRESS    AR7100_PCI_CRP+0x28
+
+#define AR7100_CRP_CMD_WRITE             0x00010000
+#define AR7100_CRP_CMD_READ              0x00000000
+
+/*
+ * PCI CFG. To generate config cycles
+ */
+#define AR7100_PCI_CFG_AD           AR7100_PCI_CRP+0xc
+#define AR7100_PCI_CFG_CBE          AR7100_PCI_CRP+0x10
+#define AR7100_PCI_CFG_WRDATA       AR7100_PCI_CRP+0x14
+#define AR7100_PCI_CFG_RDDATA       AR7100_PCI_CRP+0x18
+#define AR7100_CFG_CMD_READ         0x0000000a
+#define AR7100_CFG_CMD_WRITE        0x0000000b
+
+#define AR7100_PCI_IDSEL_ADLINE_START           17
+#endif //#ifndef AR9100
+
+/*
+ * gpio configs
+ */
+#define AR7100_GPIO_OE                  AR7100_GPIO_BASE+0x0
+#define AR7100_GPIO_IN                  AR7100_GPIO_BASE+0x4
+#define AR7100_GPIO_OUT                 AR7100_GPIO_BASE+0x8
+#define AR7100_GPIO_SET                 AR7100_GPIO_BASE+0xc
+#define AR7100_GPIO_CLEAR               AR7100_GPIO_BASE+0x10
+#define AR7100_GPIO_INT_ENABLE          AR7100_GPIO_BASE+0x14
+#define AR7100_GPIO_INT_TYPE            AR7100_GPIO_BASE+0x18
+#define AR7100_GPIO_INT_POLARITY        AR7100_GPIO_BASE+0x1c
+#define AR7100_GPIO_INT_PENDING         AR7100_GPIO_BASE+0x20
+#define AR7100_GPIO_INT_MASK            AR7100_GPIO_BASE+0x24
+#define AR7100_GPIO_FUNCTIONS           AR7100_GPIO_BASE+0x28
+
+/*
+ * GPIO Function Enables
+ */
+#define AR7100_GPIO_FUNCTION_SPI_CS_1_EN     (1<<15)
+#define AR7100_GPIO_FUNCTION_SPI_CS_0_EN     (1<<14)
+
+/*
+ * IRQ Map.
+ * There are 4 conceptual ICs in the system. We generally give a block of 16
+ * irqs to each IC.
+ * CPU:                     0    - 0xf
+ *      MISC:               0x10 - 0x1f
+ *          GPIO:           0x20 - 0x2f
+ *      PCI :               0x30 - 0x40
+ *
+ */
+#define AR7100_CPU_IRQ_BASE         0x00
+#define AR7100_MISC_IRQ_BASE        0x10
+#define AR7100_GPIO_IRQ_BASE        0x20
+#ifndef AR9100
+#define AR7100_PCI_IRQ_BASE         0x30
+#endif
+
+/*
+ * The IPs. Connected to CPU (hardware IP's; the first two are software)
+ */
+#ifdef AR9100
+#define AR7100_CPU_IRQ_WMAC                 AR7100_CPU_IRQ_BASE+2
+#else
+#define AR7100_CPU_IRQ_PCI                  AR7100_CPU_IRQ_BASE+2
+#endif
+#define AR7100_CPU_IRQ_USB                  AR7100_CPU_IRQ_BASE+3
+#define AR7100_CPU_IRQ_GE0                  AR7100_CPU_IRQ_BASE+4
+#define AR7100_CPU_IRQ_GE1                  AR7100_CPU_IRQ_BASE+5
+#define AR7100_CPU_IRQ_MISC                 AR7100_CPU_IRQ_BASE+6
+#define AR7100_CPU_IRQ_TIMER                AR7100_CPU_IRQ_BASE+7
+
+/*
+ * Interrupts connected to the CPU->Misc line.
+ */
+#define AR7100_MISC_IRQ_TIMER               AR7100_MISC_IRQ_BASE+0
+#define AR7100_MISC_IRQ_ERROR               AR7100_MISC_IRQ_BASE+1
+#define AR7100_MISC_IRQ_GPIO                AR7100_MISC_IRQ_BASE+2
+#define AR7100_MISC_IRQ_UART                AR7100_MISC_IRQ_BASE+3
+#define AR7100_MISC_IRQ_WATCHDOG            AR7100_MISC_IRQ_BASE+4
+#define AR7100_MISC_IRQ_COUNT                 5
+
+#define MIMR_TIMER                          0x01
+#define MIMR_ERROR                          0x02
+#define MIMR_GPIO                           0x04
+#define MIMR_UART                           0x08
+#define MIMR_WATCHDOG                       0x10
+
+#define MISR_TIMER                          MIMR_TIMER
+#define MISR_ERROR                          MIMR_ERROR
+#define MISR_GPIO                           MIMR_GPIO
+#define MISR_UART                           MIMR_UART
+#define MISR_WATCHDOG                       MIMR_WATCHDOG
+
+/*
+ * Interrupts connected to the Misc->GPIO line
+ */
+#define AR7100_GPIO_IRQn(_gpio)             AR7100_GPIO_IRQ_BASE+(_gpio)
+#define AR7100_GPIO_IRQ_COUNT                 16
+
+#ifndef AR9100
+/*
+ * Interrupts connected to CPU->PCI
+ */
+#define AR7100_PCI_IRQ_DEV0                  AR7100_PCI_IRQ_BASE+0
+#define AR7100_PCI_IRQ_DEV1                  AR7100_PCI_IRQ_BASE+1
+#define AR7100_PCI_IRQ_DEV2                  AR7100_PCI_IRQ_BASE+2
+#define AR7100_PCI_IRQ_CORE                  AR7100_PCI_IRQ_BASE+3
+#define AR7100_PCI_IRQ_COUNT                 4
+
+/*
+ * PCI interrupt mask and status
+ */
+#define PIMR_DEV0                           0x01
+#define PIMR_DEV1                           0x02
+#define PIMR_DEV2                           0x04
+#define PIMR_CORE                           0x10
+
+#define PISR_DEV0                           PIMR_DEV0
+#define PISR_DEV1                           PIMR_DEV1
+#define PISR_DEV2                           PIMR_DEV2
+#define PISR_CORE                           PIMR_CORE
+#endif
+
+#define AR7100_GPIO_COUNT                   16
+
+/*
+ * Reset block
+ */
+#define AR7100_GENERAL_TMR            AR7100_RESET_BASE+0
+#define AR7100_GENERAL_TMR_RELOAD     AR7100_RESET_BASE+4
+#define AR7100_WATCHDOG_TMR_CONTROL   AR7100_RESET_BASE+8
+#define AR7100_WATCHDOG_TMR           AR7100_RESET_BASE+0xc
+#define AR7100_MISC_INT_STATUS        AR7100_RESET_BASE+0x10
+#define AR7100_MISC_INT_MASK          AR7100_RESET_BASE+0x14
+#ifndef AR9100
+#define AR7100_PCI_INT_STATUS         AR7100_RESET_BASE+0x18
+#define AR7100_PCI_INT_MASK           AR7100_RESET_BASE+0x1c
+#define AR7100_GLOBAL_INT_STATUS      AR7100_RESET_BASE+0x20
+#define AR7100_RESET                  AR7100_RESET_BASE+0x24
+#else
+#define AR7100_GLOBAL_INT_STATUS      AR7100_RESET_BASE+0x18
+#define AR7100_RESET                  AR7100_RESET_BASE+0x1c
+#endif
+
+/*
+ * AR7100_RESET bit defines
+ */
+#define AR7100_RESET_EXTERNAL               (1 << 28)
+#define AR7100_RESET_FULL_CHIP              (1 << 24)
+#define AR7100_RESET_CPU_NMI                (1 << 21)
+#define AR7100_RESET_CPU_COLD_RESET_MASK    (1 << 20)
+#define AR7100_RESET_DDR                    (1 << 16)
+#define AR7100_RESET_GE1_MAC                (1 << 13)
+#define AR7100_RESET_GE1_PHY                (1 << 12)
+#define AR7100_RESET_GE0_MAC                (1 << 9)
+#define AR7100_RESET_GE0_PHY                (1 << 8)
+#define AR7100_RESET_USB_HOST               (1 << 5)
+#define AR7100_RESET_USB_PHY                (1 << 4)
+#ifndef AR9100
+#define AR7100_RESET_PCI_BUS                (1 << 1)
+#define AR7100_RESET_PCI_CORE               (1 << 0)
+#endif
+
+#define AR7100_MII0_CTRL                    0x18070000
+#define AR7100_MII1_CTRL                    0x18070004
+
+#define K1BASE KSEG1
+
+#ifndef __ASSEMBLY__
+typedef enum {
+    AR7100_DDR_16B_LOW,
+    AR7100_DDR_16B_HIGH,
+    AR7100_DDR_32B,
+}ar7100_ddr_width_t;
+
+#define ar7100_reg_rd(_phys)    (*(volatile unsigned int *)KSEG1ADDR(_phys))
+#define ar7100_reg_wr_nf(_phys, _val) \
+                    ((*(volatile unsigned int *)KSEG1ADDR(_phys)) = (_val))
+
+#define ar7100_reg_wr(_phys, _val) do {     \
+                    ar7100_reg_wr_nf(_phys, _val);  \
+                    ar7100_reg_rd(_phys);       \
+}while(0);
+
+#define ar7100_write_pci_window(_no)             \
+  ar7100_reg_wr(AR7100_PCI_WINDOW##_no##_OFFSET, AR7100_PCI_WINDOW##_no##_VAL);
+
+#define BIT(_x) (1 << (_x))
+
+#define ar7100_reg_rmw_set(_reg, _mask)  do {                        \
+    ar7100_reg_wr((_reg), (ar7100_reg_rd((_reg)) | (_mask)));      \
+    ar7100_reg_rd((_reg));                                           \
+}while(0);
+
+#define ar7100_reg_rmw_clear(_reg, _mask)  do {                        \
+    ar7100_reg_wr((_reg), (ar7100_reg_rd((_reg)) & ~(_mask)));      \
+    ar7100_reg_rd((_reg));                                           \
+}while(0);
+
+#define ar7100_get_bit(_reg, _bit)  (ar7100_reg_rd((_reg)) & (1 << (_bit)))
+
+#define ar7100_flush_ge(_unit) do {                             \
+    u32     reg = (_unit) ? AR7100_DDR_GE1_FLUSH : AR7100_DDR_GE0_FLUSH;   \
+    ar7100_reg_wr(reg, 1);                 \
+    while((ar7100_reg_rd(reg) & 0x1));   \
+    ar7100_reg_wr(reg, 1);                 \
+    while((ar7100_reg_rd(reg) & 0x1));   \
+}while(0);
+
+#ifndef AR9100
+#define ar7100_flush_pci() do {                             \
+    ar7100_reg_wr(AR7100_DDR_PCI_FLUSH, 1);                 \
+    while((ar7100_reg_rd(AR7100_DDR_PCI_FLUSH) & 0x1));   \
+    ar7100_reg_wr(AR7100_DDR_PCI_FLUSH, 1);                 \
+    while((ar7100_reg_rd(AR7100_DDR_PCI_FLUSH) & 0x1));   \
+}while(0);
+/* drive bits in mask low */
+#define ar7100_gpio_drive_low(_mask) do {                   \
+    ar7100_reg_wr      (AR7100_GPIO_CLEAR, _mask);          \
+    ar7100_reg_rmw_set (AR7100_GPIO_OE,    _mask);          \
+}while(0);
+/* drive bits in mask high */
+#define ar7100_gpio_drive_high(_mask) do {                  \
+    ar7100_reg_wr      (AR7100_GPIO_CLEAR, _mask);          \
+    ar7100_reg_rmw_set (AR7100_GPIO_OE,    _mask);          \
+}while(0);
+/* allow GPIO0/GPIO1 to be used as SCL/SDA for software based i2c */
+#define ar7100_gpio_enable_i2c_on_gpio_0_1() do {           \
+    ar7100_reg_rmw_clear( AR7100_GPIO_FUNCTIONS,   AR7100_GPIO_FUNCTION_SPI_CS_0_EN|AR7100_GPIO_FUNCTION_SPI_CS_1_EN); \
+    ar7100_reg_rmw_clear (AR7100_GPIO_INT_ENABLE,  3);      \
+    ar7100_reg_rmw_clear (AR7100_GPIO_OE,          3);      \
+}while(0);
+/* Allow bits in mask to float to their quiescent state and test results */
+static inline unsigned int ar7100_gpio_float_high_test(unsigned int mask)
+{
+  volatile unsigned int d;
+  ar7100_reg_rmw_clear(AR7100_GPIO_OE,  mask);
+  d = ar7100_reg_rd(AR7100_GPIO_IN);
+  d = ar7100_reg_rd(AR7100_GPIO_IN) & mask;
+  return d!=mask;
+}
+#else
+#define ar9100_flush_wmac() do {                             \
+    ar7100_reg_wr(AR7100_DDR_WMAC_FLUSH, 1);                 \
+    while((ar7100_reg_rd(AR7100_DDR_WMAC_FLUSH) & 0x1));   \
+    ar7100_reg_wr(AR7100_DDR_WMAC_FLUSH, 1);                 \
+    while((ar7100_reg_rd(AR7100_DDR_WMAC_FLUSH) & 0x1));   \
+}while(0);
+#endif
+
+#endif  /*__ASSEMBLY*/
+
+#endif
diff --git a/include/ar7240_soc.h b/include/ar7240_soc.h
new file mode 100644
index 0000000000..f33c4f161a
--- /dev/null
+++ b/include/ar7240_soc.h
@@ -0,0 +1,768 @@
+/*
+ * Atheror AR7240 series processor SOC registers
+ *
+ * (C) Copyright 2008 Atheros Communications, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _AR7240_SOC_H
+#define _AR7240_SOC_H
+
+#include <config.h>
+
+#ifdef CONFIG_WASP_SUPPORT
+#include <ar934x_soc.h>
+#endif
+
+#ifdef CONFIG_AR7240_EMU
+#define AR7240_EMU 1
+#endif
+
+#ifdef CONFIG_WASP_EMU
+#define WASP_EMU 1
+#endif
+/*
+ * Address map
+ */
+#define AR7240_PCI_MEM_BASE             0x10000000  /* 128M */
+#define AR7240_APB_BASE                 0x18000000  /* 384M */
+#define AR7240_GE0_BASE                 0x19000000  /* 16M */
+#define AR7240_GE1_BASE                 0x1a000000  /* 16M */
+#define AR7240_USB_EHCI_BASE            0x1b000000
+#define AR7240_USB_OHCI_BASE            0x1c000000
+#define AR7240_SPI_BASE                 0x1f000000
+#define ATH_NAND_FLASH_BASE		0x1b000000u
+
+
+/*
+ * APB block
+ */
+#define AR7240_DDR_CTL_BASE             AR7240_APB_BASE+0x00000000
+#define AR7240_CPU_BASE                 AR7240_APB_BASE+0x00010000
+#define AR7240_UART_BASE                AR7240_APB_BASE+0x00020000
+#define AR7240_USB_CONFIG_BASE          AR7240_APB_BASE+0x00030000
+#define AR7240_GPIO_BASE                AR7240_APB_BASE+0x00040000
+#define AR7240_PLL_BASE                 AR7240_APB_BASE+0x00050000
+#define AR7240_RESET_BASE               AR7240_APB_BASE+0x00060000
+#define AR7240_PCI_LCL_BASE             AR7240_APB_BASE+0x000f0000
+
+/*
+ * DDR block
+ */
+
+#define AR7240_DDR_CONFIG               AR7240_DDR_CTL_BASE+0
+#define AR7240_DDR_CONFIG2              AR7240_DDR_CTL_BASE+4
+#define AR7240_DDR_MODE                 AR7240_DDR_CTL_BASE+0x08
+#define AR7240_DDR_EXT_MODE             AR7240_DDR_CTL_BASE+0x0c
+#define AR7240_DDR_CONTROL              AR7240_DDR_CTL_BASE+0x10
+#define AR7240_DDR_REFRESH              AR7240_DDR_CTL_BASE+0x14
+#define AR7240_DDR_RD_DATA_THIS_CYCLE   AR7240_DDR_CTL_BASE+0x18
+#define AR7240_DDR_TAP_CONTROL0         AR7240_DDR_CTL_BASE+0x1c
+#define AR7240_DDR_TAP_CONTROL1         AR7240_DDR_CTL_BASE+0x20
+#define AR7240_DDR_TAP_CONTROL2         AR7240_DDR_CTL_BASE+0x24
+#define AR7240_DDR_TAP_CONTROL3         AR7240_DDR_CTL_BASE+0x28
+#ifdef CONFIG_WASP
+#define AR7240_DDR_DDR2_CONFIG          AR7240_DDR_CTL_BASE+0xb8
+#else
+#define AR7240_DDR_DDR2_CONFIG          AR7240_DDR_CTL_BASE+0x8c
+#endif
+#define AR7240_DDR_BURST                AR7240_DDR_CTL_BASE+0xc4
+#define AR7240_DDR_BURST2               AR7240_DDR_CTL_BASE+0xc8
+#define AR7240_AHB_MASTER_TIMEOUT       AR7240_DDR_CTL_BASE+0xcc
+#define AR7240_DDR_CTL_CONFIG           AR7240_DDR_CTL_BASE+0x108
+#define AR7240_DDR_DEBUG_RD_CNTL	AR7240_DDR_CTL_BASE+0x118
+
+#define AR7240_DDR_CONFIG_16BIT             (1 << 31)
+#define AR7240_DDR_CONFIG_PAGE_OPEN         (1 << 30)
+#define AR7240_DDR_CONFIG_CAS_LAT_SHIFT      27
+#define AR7240_DDR_CONFIG_TMRD_SHIFT         23
+#define AR7240_DDR_CONFIG_TRFC_SHIFT         17
+#define AR7240_DDR_CONFIG_TRRD_SHIFT         13
+#define AR7240_DDR_CONFIG_TRP_SHIFT          9
+#define AR7240_DDR_CONFIG_TRCD_SHIFT         5
+#define AR7240_DDR_CONFIG_TRAS_SHIFT         0
+
+#define AR7240_DDR_CONFIG2_BL2          (2 << 0)
+#define AR7240_DDR_CONFIG2_BL4          (4 << 0)
+#define AR7240_DDR_CONFIG2_BL8          (8 << 0)
+
+#define AR7240_DDR_CONFIG2_BT_IL        (1 << 4)
+#define AR7240_DDR_CONFIG2_CNTL_OE_EN   (1 << 5)
+#define AR7240_DDR_CONFIG2_PHASE_SEL    (1 << 6)
+#define AR7240_DDR_CONFIG2_DRAM_CKE     (1 << 7)
+#define AR7240_DDR_CONFIG2_TWR_SHIFT    8
+#define AR7240_DDR_CONFIG2_TRTW_SHIFT   12
+#define AR7240_DDR_CONFIG2_TRTP_SHIFT   17
+#define AR7240_DDR_CONFIG2_TWTR_SHIFT   21
+#define AR7240_DDR_CONFIG2_HALF_WIDTH_L (1 << 31)
+
+#define AR7240_DDR_TAP_DEFAULT          0x18
+
+/*
+ * PLL
+ */
+#define AR7240_CPU_PLL_CONFIG           AR7240_PLL_BASE
+#define AR7240_USB_PLL_CONFIG           AR7240_PLL_BASE+0x4
+#define AR7240_PCIE_PLL_CONFIG          AR7240_PLL_BASE+0x10
+#define AR7240_CPU_CLOCK_CONTROL        AR7240_PLL_BASE+8
+
+#ifndef CONFIG_WASP_SUPPORT
+#define AR7240_USB_PLL_GE0_OFFSET       AR7240_PLL_BASE+0x10
+#define AR7240_USB_PLL_GE1_OFFSET       AR7240_PLL_BASE+0x14
+#define AR7240_S26_CLK_CTRL_OFFSET      AR7240_PLL_BASE+0x24
+#endif
+#define AR7242_ETH_XMII_CONFIG          AR7240_PLL_BASE+0x2c
+
+#define AR934X_CPU_PLL_DITHER                 AR7240_PLL_BASE+0x0048
+#define AR934X_DDR_PLL_DITHER                 AR7240_PLL_BASE+0x0044
+#define AR934X_BB_PLL_CONFIG                  AR7240_PLL_BASE+0x0040
+#define AR934X_CURRENT_AUDIO_PLL_MODULATION   AR7240_PLL_BASE+0x003c
+#define AR934X_AUDIO_PLL_MOD_STEP             AR7240_PLL_BASE+0x0038
+#define AR934X_AUDIO_PLL_MODULATION           AR7240_PLL_BASE+0x0034
+#define AR934X_AUDIO_PLL_CONFIG               AR7240_PLL_BASE+0x0030
+#define AR934X_ETH_XMII                       AR7240_PLL_BASE+0x002c
+#define AR934X_CURRENT_PCIE_PLL_DITHER        AR7240_PLL_BASE+0x0028
+#define AR934X_SWITCH_CLOCK_SPARE             AR7240_PLL_BASE+0x0024
+#define AR934X_LDO_POWER_CONTROL              AR7240_PLL_BASE+0x0020
+#define AR934X_PCIE_PLL_DITHER_STEP           AR7240_PLL_BASE+0x001c
+#define AR934X_PCIE_PLL_DITHER_DIV_MIN        AR7240_PLL_BASE+0x0018
+#define AR934X_PCIE_PLL_DITHER_DIV_MAX        AR7240_PLL_BASE+0x0014
+#define AR934X_PCIE_PLL_CONFIG                AR7240_PLL_BASE+0x0010
+#define AR934X_CPU_SYNC                       AR7240_PLL_BASE+0x000c
+#define AR934X_CPU_DDR_CLOCK_CONTROL          AR7240_PLL_BASE+0x0008
+#define AR934X_DDR_PLL_CONFIG                 AR7240_PLL_BASE+0x0004
+#define AR934X_CPU_PLL_CONFIG                 AR7240_PLL_BASE+0x0000
+
+#define PLL_CONFIG_PLL_DIV_SHIFT        0
+#define PLL_CONFIG_PLL_DIV_MASK         (0x3ff<< PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_SHIFT    10
+#define PLL_CONFIG_PLL_REF_DIV_MASK     (0xf << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+#define PLL_CONFIG_PLL_BYPASS_SHIFT     16
+#define PLL_CONFIG_PLL_BYPASS_MASK      (0x1 << PLL_CONFIG_PLL_BYPASS_SHIFT)
+#define PLL_CONFIG_PLL_UPDATE_SHIFT     17
+#define PLL_CONFIG_PLL_UPDATE_MASK      (0x1 << PLL_CONFIG_PLL_UPDATE_SHIFT)
+#define PLL_CONFIG_PLL_NOPWD_SHIFT      18
+#define PLL_CONFIG_PLL_NOPWD_MASK       (0x1 << PLL_CONFIG_PLL_NOPWD_SHIFT)
+#define PLL_CONFIG_AHB_DIV_SHIFT        19
+#define PLL_CONFIG_AHB_DIV_MASK         (0x1 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_DDR_DIV_SHIFT        22
+#define PLL_CONFIG_DDR_DIV_MASK         (0x1 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_PLL_RESET_SHIFT      25
+#define PLL_CONFIG_PLL_RESET_MASK       (0x1 << PLL_CONFIG_PLL_RESET_SHIFT)
+
+/* Hornet's CPU PLL Configuration Register */
+#define HORNET_PLL_CONFIG_NINT_SHIFT            10
+#define HORNET_PLL_CONFIG_NINT_MASK             (0x3f << HORNET_PLL_CONFIG_NINT_SHIFT)
+#define HORNET_PLL_CONFIG_REFDIV_SHIFT          16
+#define HORNET_PLL_CONFIG_REFDIV_MASK           (0x1f << HORNET_PLL_CONFIG_REFDIV_SHIFT)
+#define HORNET_PLL_CONFIG_OUTDIV_SHIFT          23
+#define HORNET_PLL_CONFIG_OUTDIV_MASK           (0x7 << HORNET_PLL_CONFIG_OUTDIV_SHIFT)
+#define HORNET_PLL_CONFIG_PLLPWD_SHIFT          30
+#define HORNET_PLL_CONFIG_PLLPWD_MASK           (0x1 << HORNET_PLL_CONFIG_PLLPWD_SHIFT)
+#define HORNET_PLL_CONFIG_UPDATING_SHIFT        31
+#define HORNET_PLL_CONFIG_UPDATING_MASK         (0x1 << HORNET_PLL_CONFIG_UPDATING_SHIFT)
+/* Hornet's CPU PLL Configuration 2 Register */
+#define HORNET_PLL_CONFIG2_SETTLE_TIME_SHIFT    0
+#define HORNET_PLL_CONFIG2_SETTLE_TIME_MASK     (0xfff << HORNET_PLL_CONFIG2_SETTLE_TIME_SHIFT)
+/* Hornet's CPU Clock Control Register */
+#define HORNET_CLOCK_CONTROL_BYPASS_SHIFT       2
+#define HORNET_CLOCK_CONTROL_BYPASS_MASK        (0x1 << HORNET_CLOCK_CONTROL_BYPASS_SHIFT)
+#define HORNET_CLOCK_CONTROL_CPU_POST_DIV_SHIFT 5
+#define HORNET_CLOCK_CONTROL_CPU_POST_DIV_MASK  (0x3 << HORNET_CLOCK_CONTROL_CPU_POST_DIV_SHIFT)
+#define HORNET_CLOCK_CONTROL_DDR_POST_DIV_SFIFT 10
+#define HORNET_CLOCK_CONTROL_DDR_POST_DIV_MASK  (0x3 << HORNET_CLOCK_CONTROL_DDR_POST_DIV_SFIFT)
+#define HORNET_CLOCK_CONTROL_AHB_POST_DIV_SFIFT 15
+#define HORNET_CLOCK_CONTROL_AHB_POST_DIV_MASK  (0x3 << HORNET_CLOCK_CONTROL_AHB_POST_DIV_SFIFT)
+
+#define CLOCK_CONTROL_CLOCK_SWITCH_SHIFT  0
+#define CLOCK_CONTROL_CLOCK_SWITCH_MASK  (1 << CLOCK_CONTROL_CLOCK_SWITCH_SHIFT)
+#define CLOCK_CONTROL_RST_SWITCH_SHIFT    1
+#define CLOCK_CONTROL_RST_SWITCH_MASK    (1 << CLOCK_CONTROL_RST_SWITCH_SHIFT)
+
+/*
+** PLL config for different CPU/DDR/AHB frequencies
+*/
+#define PLL_CONFIG_PLL_NOPWD_VAL        (1 << PLL_CONFIG_PLL_NOPWD_SHIFT)
+
+
+#define UBOOT_SIZE			(256 * 1024)
+#define PLL_FLASH_ADDR  		(CFG_FLASH_BASE + UBOOT_SIZE)
+#define PLL_CONFIG_VAL_F		(PLL_FLASH_ADDR + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define PLL_MAGIC  			 0xaabbccdd
+#define SRIF_PLL_CONFIG_VAL_F		(PLL_CONFIG_VAL_F - 12)
+#define SRIF_PLL_MAGIC 			0x73726966 /* srif */
+
+#ifndef CONFIG_WASP_SUPPORT
+#if (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x28 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x1 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x28 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_360_360_180)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x24 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x23 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+
+#elif (CFG_PLL_FREQ == CFG_PLL_340_340_170)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x22 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x20 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x1 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x20 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x1e << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_75)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x1 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x1e << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+
+#define PLL_CONFIG_DDR_DIV_VAL   (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL    (0x14 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+
+#define PLL_CONFIG_DDR_DIV_VAL   (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL    (0x18 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+
+#define PLL_CONFIG_DDR_DIV_VAL   (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL    (0x10 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+
+#define PLL_CONFIG_DDR_DIV_VAL     (0x1 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL     (0x28 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#else /* default is 400/400/200 */
+
+#define PLL_CONFIG_DDR_DIV_VAL   (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_CONFIG_PLL_DIV_VAL    (0x28 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#endif
+#ifdef CONFIG_SUPPORT_AR7241
+#if (CFG_AR7241_PLL_FREQ == CFG_PLL_400_200_200)
+
+#define PLL_7241_CONFIG_DDR_DIV_VAL     (0x1 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_7241_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_DIV_VAL     (0x28 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_AR7241_PLL_FREQ == CFG_PLL_280_280_130)
+
+#define PLL_7241_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_7241_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_DIV_VAL     (0x1c << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#elif (CFG_AR7241_PLL_FREQ == CFG_PLL_260_260_130)
+
+#define PLL_7241_CONFIG_DDR_DIV_VAL     (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_7241_CONFIG_AHB_DIV_VAL     (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_DIV_VAL     (0x1a << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+
+#else /* default is 400/400/200 */
+
+#define PLL_7241_CONFIG_DDR_DIV_VAL   (0x0 << PLL_CONFIG_DDR_DIV_SHIFT)
+#define PLL_7241_CONFIG_AHB_DIV_VAL   (0x0 << PLL_CONFIG_AHB_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_DIV_VAL    (0x28 << PLL_CONFIG_PLL_DIV_SHIFT)
+#define PLL_7241_CONFIG_PLL_REF_DIV_VAL (0x2 << PLL_CONFIG_PLL_REF_DIV_SHIFT)
+
+#endif
+#endif
+#endif
+
+
+/*
+ * PLL block
+ */
+#define AR7240_PLL_CONFIG               AR7240_PLL_BASE+0x0
+
+/*
+ * CLOCK
+ */
+#define AR7240_CPU_CLOCK_CONTROL        AR7240_PLL_BASE+8
+
+/*
+ * FIFO flushes
+ */
+#define AR7240_DDR_GE0_FLUSH            AR7240_DDR_CTL_BASE+0x9c
+#define AR7240_DDR_GE1_FLUSH            AR7240_DDR_CTL_BASE+0xa0
+#define AR7240_DDR_PCI_FLUSH            AR7240_DDR_CTL_BASE+0xa8
+
+/*
+ * USB block
+ */
+#define AR7240_USB_FLADJ_VAL            AR7240_USB_CONFIG_BASE
+#define AR7240_USB_CONFIG               AR7240_USB_CONFIG_BASE+0x4
+#define AR7240_USB_WINDOW               0x1000000
+
+/*
+ * PCI block
+ */
+#define AR7240_PCI_WINDOW           0x8000000       /* 128MB */
+#define AR7240_PCI_WINDOW0_OFFSET   AR7240_DDR_CTL_BASE+0x7c
+#define AR7240_PCI_WINDOW1_OFFSET   AR7240_DDR_CTL_BASE+0x80
+#define AR7240_PCI_WINDOW2_OFFSET   AR7240_DDR_CTL_BASE+0x84
+#define AR7240_PCI_WINDOW3_OFFSET   AR7240_DDR_CTL_BASE+0x88
+#define AR7240_PCI_WINDOW4_OFFSET   AR7240_DDR_CTL_BASE+0x8c
+#define AR7240_PCI_WINDOW5_OFFSET   AR7240_DDR_CTL_BASE+0x90
+#define AR7240_PCI_WINDOW6_OFFSET   AR7240_DDR_CTL_BASE+0x94
+#define AR7240_PCI_WINDOW7_OFFSET   AR7240_DDR_CTL_BASE+0x98
+
+#define AR7240_PCI_WINDOW0_VAL      0x10000000
+#define AR7240_PCI_WINDOW1_VAL      0x11000000
+#define AR7240_PCI_WINDOW2_VAL      0x12000000
+#define AR7240_PCI_WINDOW3_VAL      0x13000000
+#define AR7240_PCI_WINDOW4_VAL      0x14000000
+#define AR7240_PCI_WINDOW5_VAL      0x15000000
+#define AR7240_PCI_WINDOW6_VAL      0x16000000
+#define AR7240_PCI_WINDOW7_VAL      0x07000000
+
+
+/*
+ * CRP. To access the host controller config and status registers
+ */
+#define AR7240_PCI_CRP   	   0x180c0000
+#define AR7240_PCI_DEV_CFGBASE     0x14000000
+
+#define AR7240_PCI_CRP_AD_CBE               AR7240_PCI_CRP
+#define AR7240_PCI_CRP_WRDATA               AR7240_PCI_CRP+0x4
+#define AR7240_PCI_CRP_RDDATA               AR7240_PCI_CRP+0x8
+#define AR7240_PCI_ERROR            AR7240_PCI_CRP+0x1c
+#define AR7240_PCI_ERROR_ADDRESS    AR7240_PCI_CRP+0x20
+#define AR7240_PCI_AHB_ERROR            AR7240_PCI_CRP+0x24
+#define AR7240_PCI_AHB_ERROR_ADDRESS    AR7240_PCI_CRP+0x28
+
+#define AR7240_CRP_CMD_WRITE             0x00010000
+#define AR7240_CRP_CMD_READ              0x00000000
+
+/*
+ * PCI CFG. To generate config cycles
+ */
+#define AR7240_PCI_CFG_AD           AR7240_PCI_CRP+0xc
+#define AR7240_PCI_CFG_CBE          AR7240_PCI_CRP+0x10
+#define AR7240_PCI_CFG_WRDATA       AR7240_PCI_CRP+0x14
+#define AR7240_PCI_CFG_RDDATA       AR7240_PCI_CRP+0x18
+#define AR7240_CFG_CMD_READ         0x0000000a
+#define AR7240_CFG_CMD_WRITE        0x0000000b
+
+#define AR7240_PCI_IDSEL_ADLINE_START           17
+
+#define AR7240_PCI_LCL_RESET        AR7240_PCI_LCL_BASE+0x18
+
+/*
+ * gpio configs
+ */
+#define AR7240_GPIO_OE                  AR7240_GPIO_BASE+0x0
+#define AR7240_GPIO_IN                  AR7240_GPIO_BASE+0x4
+#define AR7240_GPIO_OUT                 AR7240_GPIO_BASE+0x8
+#define AR7240_GPIO_SET                 AR7240_GPIO_BASE+0xc
+#define AR7240_GPIO_CLEAR               AR7240_GPIO_BASE+0x10
+#define AR7240_GPIO_INT_ENABLE          AR7240_GPIO_BASE+0x14
+#define AR7240_GPIO_INT_TYPE            AR7240_GPIO_BASE+0x18
+#define AR7240_GPIO_INT_POLARITY        AR7240_GPIO_BASE+0x1c
+#define AR7240_GPIO_INT_PENDING         AR7240_GPIO_BASE+0x20
+#define AR7240_GPIO_INT_MASK            AR7240_GPIO_BASE+0x24
+#define AR7240_GPIO_FUNC                AR7240_GPIO_BASE+0x28
+#define AR7240_GPIO_FUNC4               AR7240_GPIO_BASE+0x3c
+#define AR7240_GPIO_FUNC5               AR7240_GPIO_BASE+0x40
+
+/*
+ * IRQ Map.
+ * There are 4 conceptual ICs in the system. We generally give a block of 16
+ * irqs to each IC.
+ * CPU:                     0    - 0xf
+ *      MISC:               0x10 - 0x1f
+ *          GPIO:           0x20 - 0x2f
+ *      PCI :               0x30 - 0x40
+ *
+ */
+#define AR7240_CPU_IRQ_BASE         0x00
+#define AR7240_MISC_IRQ_BASE        0x10
+#define AR7240_GPIO_IRQ_BASE        0x20
+#define AR7240_PCI_IRQ_BASE         0x30
+
+/*
+ * The IPs. Connected to CPU (hardware IP's; the first two are software)
+ */
+#define AR7240_CPU_IRQ_PCI                  AR7240_CPU_IRQ_BASE+2
+#define AR7240_CPU_IRQ_USB                  AR7240_CPU_IRQ_BASE+3
+#define AR7240_CPU_IRQ_GE0                  AR7240_CPU_IRQ_BASE+4
+#define AR7240_CPU_IRQ_GE1                  AR7240_CPU_IRQ_BASE+5
+#define AR7240_CPU_IRQ_MISC                 AR7240_CPU_IRQ_BASE+6
+#define AR7240_CPU_IRQ_TIMER                AR7240_CPU_IRQ_BASE+7
+
+/*
+ * Interrupts connected to the CPU->Misc line.
+ */
+#define AR7240_MISC_IRQ_TIMER               AR7240_MISC_IRQ_BASE+0
+#define AR7240_MISC_IRQ_ERROR               AR7240_MISC_IRQ_BASE+1
+#define AR7240_MISC_IRQ_GPIO                AR7240_MISC_IRQ_BASE+2
+#define AR7240_MISC_IRQ_UART                AR7240_MISC_IRQ_BASE+3
+#define AR7240_MISC_IRQ_WATCHDOG            AR7240_MISC_IRQ_BASE+4
+#define AR7240_MISC_IRQ_COUNT                 5
+
+#define MIMR_TIMER                          0x01
+#define MIMR_ERROR                          0x02
+#define MIMR_GPIO                           0x04
+#define MIMR_UART                           0x08
+#define MIMR_WATCHDOG                       0x10
+
+#define MISR_TIMER                          MIMR_TIMER
+#define MISR_ERROR                          MIMR_ERROR
+#define MISR_GPIO                           MIMR_GPIO
+#define MISR_UART                           MIMR_UART
+#define MISR_WATCHDOG                       MIMR_WATCHDOG
+
+/*
+ * Interrupts connected to the Misc->GPIO line
+ */
+#define AR7240_GPIO_IRQn(_gpio)             AR7240_GPIO_IRQ_BASE+(_gpio)
+#define AR7240_GPIO_IRQ_COUNT                 16
+
+/*
+ * Interrupts connected to CPU->PCI
+ */
+#define AR7240_PCI_IRQ_DEV0                  AR7240_PCI_IRQ_BASE+0
+#define AR7240_PCI_IRQ_DEV1                  AR7240_PCI_IRQ_BASE+1
+#define AR7240_PCI_IRQ_DEV2                  AR7240_PCI_IRQ_BASE+2
+#define AR7240_PCI_IRQ_CORE                  AR7240_PCI_IRQ_BASE+3
+#define AR7240_PCI_IRQ_COUNT                 4
+
+/*
+ * PCI interrupt mask and status
+ */
+#define PIMR_DEV0                           0x01
+#define PIMR_DEV1                           0x02
+#define PIMR_DEV2                           0x04
+#define PIMR_CORE                           0x10
+
+#define PISR_DEV0                           PIMR_DEV0
+#define PISR_DEV1                           PIMR_DEV1
+#define PISR_DEV2                           PIMR_DEV2
+#define PISR_CORE                           PIMR_CORE
+
+#define AR7240_GPIO_COUNT                   16
+
+/*
+ * Reset block
+ */
+#define AR7240_GENERAL_TMR            AR7240_RESET_BASE+0
+#define AR7240_GENERAL_TMR_RELOAD     AR7240_RESET_BASE+4
+#define AR7240_WATCHDOG_TMR_CONTROL   AR7240_RESET_BASE+8
+#define AR7240_WATCHDOG_TMR           AR7240_RESET_BASE+0xc
+#define AR7240_MISC_INT_STATUS        AR7240_RESET_BASE+0x10
+#define AR7240_MISC_INT_MASK          AR7240_RESET_BASE+0x14
+#define AR7240_GLOBAL_INT_STATUS      AR7240_RESET_BASE+0x18
+#define AR7240_RESET                  AR7240_RESET_BASE+0x1c
+#define HORNET_BOOTSTRAP_STATUS       AR7240_RESET_BASE+0xac /* Hornet's bootstrap register */
+#define AR7240_REV_ID                 (AR7240_RESET_BASE + 0x90)
+#define AR7240_REV_ID_MASK            0xffff
+#define AR7240_REV_ID_MASK_MINOR      0xfu
+#define HORNET_REV_ID_MASK            0xfff
+#define AR9344_REV_ID_MASK            0xfff0	/* Ignore minor id */
+#define HORNET_BOOTSTRAP_SEL_25M_40M_MASK   0x00000001 /* Hornet's bootstrap register */
+#define HORNET_BOOTSTRAP_MEM_TYPE_MASK      0x00003000 /* Hornet's bootstrap register */
+#define HORNET_BOOTSTRAP_MDIO_SLAVE_MASK    0x00020000 /* Hornet's bootstrap register */
+
+// WASP BootStrap Register
+#define WASP_BOOTSTRAP_REG		(AR7240_RESET_BASE + 0xb0)
+#define WASP_REF_CLK_25			(1 << 4) /* 0 - 25MHz	1 - 40 MHz */
+#define WASP_RAM_TYPE(a)		((a) & 0x3)
+
+#define CFG_934X_SDRAM_CONFIG_VAL	0x7fbe8cd0
+#define CFG_934X_SDRAM_MODE_VAL_INIT	0x133
+#define CFG_934X_SDRAM_MODE_VAL		0x33
+#define CFG_934X_SDRAM_CONFIG2_VAL	0x959f66a8
+#define CFG_934X_SDRAM_TAP_VAL		0x1f1f
+
+#define CFG_934X_DDR1_CONFIG_VAL	0x7fd48cd0
+#define CFG_934X_DDR1_MODE_VAL_INIT	0x133
+#define CFG_934X_DDR1_EXT_MODE_VAL	0x2
+#define CFG_934X_DDR1_MODE_VAL		0x33
+#define CFG_934X_DDR1_CONFIG2_VAL	0x99d0e6a8
+
+#if (CFG_PLL_FREQ == CFG_PLL_500_500_250)
+#define CFG_934X_DDR2_CONFIG_VAL	0xcfbc8cd0
+#define CFG_934X_DDR2_MODE_VAL_INIT	0x143
+#define CFG_934X_DDR2_EXT_MODE_VAL	0x402
+#define CFG_934X_DDR2_MODE_VAL		0x43
+#define CFG_934X_DDR2_CONFIG2_VAL	0xa5d0e6a8
+#define CFG_934X_DDR2_EN_TWL_VAL	0x1659
+#define CFG_934X_DDR2_TAP_VAL		0
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_575_287)
+
+#define CFG_934X_DDR2_CONFIG_VAL	0xcfd48cd0
+#define CFG_934X_DDR2_MODE_VAL_INIT	0x143
+#define CFG_934X_DDR2_EXT_MODE_VAL	0x402
+#define CFG_934X_DDR2_MODE_VAL		0x43
+#define CFG_934X_DDR2_CONFIG2_VAL	0xa1d0e6a8
+#define CFG_934X_DDR2_EN_TWL_VAL	0x1659
+#define CFG_934X_DDR2_TAP_VAL		0x5
+#else
+#ifdef CONFIG_MI124
+#define CFG_934X_DDR2_CONFIG_VAL	0x7fd48cd0
+#define CFG_934X_DDR2_MODE_VAL_INIT	0x133
+#define CFG_934X_DDR2_EXT_MODE_VAL_INIT	0x382
+#define CFG_934X_DDR2_EXT_MODE_VAL	0x402
+#define CFG_934X_DDR2_MODE_VAL		0x33
+#define CFG_934X_DDR2_CONFIG2_VAL	0x99d0e6a8
+#define CFG_934X_DDR2_EN_TWL_VAL	0xe59
+#define CFG_934X_DDR2_TAP_VAL		0x10012
+#else // db12x
+#define CFG_934X_DDR2_CONFIG_VAL	0xc7d48cd0
+#define CFG_934X_DDR2_MODE_VAL_INIT	0x133
+#define CFG_934X_DDR2_EXT_MODE_VAL_INIT	0x382
+#define CFG_934X_DDR2_EXT_MODE_VAL	0x402
+#define CFG_934X_DDR2_MODE_VAL		0x33
+#define CFG_934X_DDR2_CONFIG2_VAL	0x9dd0e6a8
+#define CFG_934X_DDR2_EN_TWL_VAL	0xe59
+#define CFG_934X_DDR2_TAP_VAL		0x10012
+#endif
+#endif
+
+#define CFG_934X_DDR1_TAP_VAL		0x14
+
+#define AR7240_REV_ID_AR7130    0xa0
+#define AR7240_REV_ID_AR7141    0xa1
+#define AR7240_REV_ID_AR7161    0xa2
+#define AR7240_REV_1_0          0xc0
+#define AR7240_REV_1_1          0xc1
+#define AR7240_REV_1_2          0xc2
+#define AR7241_REV_1_0          0x0100
+#define AR7242_REV_1_0          0x1100
+#define AR7241_REV_1_1          0x0101
+#define AR7242_REV_1_1          0x1101
+
+#define AR9330_REV_1_0			0x0110                  /* 5-port:0x110, 4-port 0x1110 */
+#define AR9331_REV_1_0			0x1110
+#define AR9330_REV_1_1			0x0111                  /* 5-port:0x111, 4-port 0x1111 */
+#define AR9331_REV_1_1			0x1111
+#define AR9330_REV_1_2			0x0112
+#define AR9331_REV_1_2			0x1112
+
+#define AR9344_REV_1_x		0x2120	/* Wasp 1.x, ignore minor id */
+#define AR9342_REV_1_x		0x1120
+#define AR9341_REV_1_x		0x0120
+
+#define AR9344_REV_1_0		0x2120	/* Wasp 1.0 */
+#define AR9342_REV_1_0		0x1120
+#define AR9341_REV_1_0		0x0120
+
+#define AR9344_REV_1_1		0x2121	/* Wasp 1.1 */
+#define AR9342_REV_1_1		0x1121
+#define AR9341_REV_1_1		0x0121
+
+#define is_ar7240()     (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7240_REV_1_2) || \
+                         ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7240_REV_1_1) || \
+                         ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7240_REV_1_0))
+
+#define is_ar7241()     (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7241_REV_1_0) || \
+                         ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7241_REV_1_1))
+
+#define is_ar7242()     (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7242_REV_1_0) || \
+                         ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7242_REV_1_1))
+
+#define is_ar9330() (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9330_REV_1_0) || \
+                        ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9330_REV_1_1) || \
+                        ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9330_REV_1_2))
+
+#define is_ar9331() (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9331_REV_1_0) || \
+                        ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9331_REV_1_1) || \
+                        ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9331_REV_1_2))
+
+#define is_ar933x_10()  (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9330_REV_1_0) || \
+                            ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9331_REV_1_0))
+
+#define is_ar933x_11()  (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9330_REV_1_1) || \
+                            ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9331_REV_1_1))
+   
+#define is_ar933x_12()  (((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9330_REV_1_2) || \
+                            ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR9331_REV_1_2))
+
+
+#define is_ar933x() (is_ar9330() || is_ar9331())
+
+#define is_ar9344()	((ar7240_reg_rd(AR7240_REV_ID) & AR9344_REV_ID_MASK) == AR9344_REV_1_x)
+#define is_ar9342()	((ar7240_reg_rd(AR7240_REV_ID) & AR9344_REV_ID_MASK) == AR9342_REV_1_x)
+#define is_ar9341()	((ar7240_reg_rd(AR7240_REV_ID) & AR9344_REV_ID_MASK) == AR9341_REV_1_x)
+
+#ifdef CONFIG_WASP_SUPPORT
+#define is_wasp()	1
+#define is_ar934x()	1
+#else
+#define is_wasp()	0
+#define is_ar934x()	0
+#endif
+#ifdef CONFIG_AR7240_EMU
+#define is_emu()	1
+#else
+#define is_emu()	0
+#endif
+#ifdef CONFIG_F1E_PHY
+#define is_f1e()	1
+#else
+#define is_f1e()	0
+#endif
+#ifdef CONFIG_F2E_PHY
+#define is_f2e()	1
+#else
+#define is_f2e()	0
+#endif
+#ifdef CONFIG_ATHRS16_PHY
+#define is_s16()	1
+#else
+#define is_s16()	0
+#endif
+
+#define is_ar934x_12_or_later() (is_ar934x() && ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK_MINOR) >= 2))
+
+/*
+ * AR7240_RESET bit defines
+ */
+#define AR7240_RESET_EXTERNAL               (1 << 28)
+#define AR7240_RESET_WMAC                   (1 << 27)
+#define AR7240_RESET_FULL_CHIP              (1 << 24)
+#define AR7240_RESET_CPU_NMI                (1 << 21)
+#define AR7240_RESET_CPU_COLD_RESET_MASK    (1 << 20)
+#define AR7240_RESET_DDR                    (1 << 16)
+#define AR7240_RESET_GE1_MAC                (1 << 13)
+#define AR7240_RESET_GE1_MDIO               (1 << 23)
+#define AR7240_RESET_GE1_PHY                (1 << 12) /* Not valid */
+#define AR7240_RESET_PCIE_PHY_SERIAL        (1 << 10)
+#define AR7240_RESET_GE0_MAC                (1 << 9)
+#define AR7240_RESET_GE0_MDIO               (1 << 22)
+#define AR7240_RESET_GE0_PHY                (1 << 8) /* Switch reset */
+#define AR7240_RESET_PCIE_PHY               (1 << 7)
+#define AR7240_RESET_PCIE                   (1 << 6)
+#define AR7240_RESET_USB_HOST               (1 << 5)
+#define AR7240_RESET_USB_OHCI_DLL           (1 << 3)
+
+#define AR7240_MII0_CTRL                    0x18070000
+#define AR7240_MII1_CTRL                    0x18070004
+
+#define K1BASE KSEG1
+
+#ifndef __ASSEMBLY__
+typedef enum {
+    AR7240_DDR_16B_LOW,
+    AR7240_DDR_16B_HIGH,
+    AR7240_DDR_32B,
+}ar7240_ddr_width_t;
+
+#define ar7240_reg_rd(_phys)    (*(volatile unsigned int *)KSEG1ADDR(_phys))
+#define ar7240_reg_wr_nf(_phys, _val) \
+                    ((*(volatile unsigned int *)KSEG1ADDR(_phys)) = (_val))
+
+#define ar7240_reg_wr(_phys, _val) do {     \
+                    ar7240_reg_wr_nf(_phys, _val);  \
+                    ar7240_reg_rd(_phys);       \
+}while(0);
+
+#define ar7240_write_pci_window(_no)             \
+  ar7240_reg_wr(AR7240_PCI_WINDOW##_no##_OFFSET, AR7240_PCI_WINDOW##_no##_VAL);
+
+#define BIT(_x) (1 << (_x))
+
+#define ar7240_reg_rmw_set(_reg, _mask)  do {                        \
+    ar7240_reg_wr((_reg), (ar7240_reg_rd((_reg)) | (_mask)));      \
+    ar7240_reg_rd((_reg));                                           \
+}while(0);
+
+#define ar7240_reg_rmw_clear(_reg, _mask)  do {                        \
+    ar7240_reg_wr((_reg), (ar7240_reg_rd((_reg)) & ~(_mask)));      \
+    ar7240_reg_rd((_reg));                                           \
+}while(0);
+
+#define ar7240_get_bit(_reg, _bit)  (ar7240_reg_rd((_reg)) & (1 << (_bit)))
+
+#define ar7240_flush_ge(_unit) do {                             \
+    u32     reg = (_unit) ? AR7240_DDR_GE1_FLUSH : AR7240_DDR_GE0_FLUSH;   \
+    ar7240_reg_wr(reg, 1);                 \
+    while((ar7240_reg_rd(reg) & 0x1));   \
+    ar7240_reg_wr(reg, 1);                 \
+    while((ar7240_reg_rd(reg) & 0x1));   \
+}while(0);
+
+#define ar7240_flush_pci() do {                             \
+    ar7240_reg_wr(AR7240_DDR_PCI_FLUSH, 1);                 \
+    while((ar7240_reg_rd(AR7240_DDR_PCI_FLUSH) & 0x1));   \
+    ar7240_reg_wr(AR7240_DDR_PCI_FLUSH, 1);                 \
+    while((ar7240_reg_rd(AR7240_DDR_PCI_FLUSH) & 0x1));   \
+}while(0);
+
+#endif  /*__ASSEMBLY*/
+#endif
diff --git a/include/ar934x_soc.h b/include/ar934x_soc.h
new file mode 100644
index 0000000000..23b44c3c51
--- /dev/null
+++ b/include/ar934x_soc.h
@@ -0,0 +1,3148 @@
+/*
+ * Atheros AR924X series processor SOC registers
+ *
+ * (C) Copyright 2008 Atheros Communications, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _AR934X_SOC_H
+#define _AR934X_SOC_H
+
+// 32'h0000 (CPU_PLL_CONFIG)
+#define CPU_PLL_CONFIG_UPDATING_MSB                                  31
+#define CPU_PLL_CONFIG_UPDATING_LSB                                  31
+#define CPU_PLL_CONFIG_UPDATING_MASK                                 0x80000000
+#define CPU_PLL_CONFIG_UPDATING_GET(x)                               (((x) & CPU_PLL_CONFIG_UPDATING_MASK) >> CPU_PLL_CONFIG_UPDATING_LSB)
+#define CPU_PLL_CONFIG_UPDATING_SET(x)                               (((x) << CPU_PLL_CONFIG_UPDATING_LSB) & CPU_PLL_CONFIG_UPDATING_MASK)
+#define CPU_PLL_CONFIG_UPDATING_RESET                                1
+#define CPU_PLL_CONFIG_PLLPWD_MSB                                    30
+#define CPU_PLL_CONFIG_PLLPWD_LSB                                    30
+#define CPU_PLL_CONFIG_PLLPWD_MASK                                   0x40000000
+#define CPU_PLL_CONFIG_PLLPWD_GET(x)                                 (((x) & CPU_PLL_CONFIG_PLLPWD_MASK) >> CPU_PLL_CONFIG_PLLPWD_LSB)
+#define CPU_PLL_CONFIG_PLLPWD_SET(x)                                 (((x) << CPU_PLL_CONFIG_PLLPWD_LSB) & CPU_PLL_CONFIG_PLLPWD_MASK)
+#define CPU_PLL_CONFIG_PLLPWD_RESET                                  1
+#define CPU_PLL_CONFIG_SPARE_MSB                                     29
+#define CPU_PLL_CONFIG_SPARE_LSB                                     22
+#define CPU_PLL_CONFIG_SPARE_MASK                                    0x3fc00000
+#define CPU_PLL_CONFIG_SPARE_GET(x)                                  (((x) & CPU_PLL_CONFIG_SPARE_MASK) >> CPU_PLL_CONFIG_SPARE_LSB)
+#define CPU_PLL_CONFIG_SPARE_SET(x)                                  (((x) << CPU_PLL_CONFIG_SPARE_LSB) & CPU_PLL_CONFIG_SPARE_MASK)
+#define CPU_PLL_CONFIG_SPARE_RESET                                   0
+#define CPU_PLL_CONFIG_OUTDIV_MSB                                    21
+#define CPU_PLL_CONFIG_OUTDIV_LSB                                    19
+#define CPU_PLL_CONFIG_OUTDIV_MASK                                   0x00380000
+#define CPU_PLL_CONFIG_OUTDIV_GET(x)                                 (((x) & CPU_PLL_CONFIG_OUTDIV_MASK) >> CPU_PLL_CONFIG_OUTDIV_LSB)
+#define CPU_PLL_CONFIG_OUTDIV_SET(x)                                 (((x) << CPU_PLL_CONFIG_OUTDIV_LSB) & CPU_PLL_CONFIG_OUTDIV_MASK)
+#define CPU_PLL_CONFIG_OUTDIV_RESET                                  0
+#define CPU_PLL_CONFIG_RANGE_MSB                                     18
+#define CPU_PLL_CONFIG_RANGE_LSB                                     17
+#define CPU_PLL_CONFIG_RANGE_MASK                                    0x00060000
+#define CPU_PLL_CONFIG_RANGE_GET(x)                                  (((x) & CPU_PLL_CONFIG_RANGE_MASK) >> CPU_PLL_CONFIG_RANGE_LSB)
+#define CPU_PLL_CONFIG_RANGE_SET(x)                                  (((x) << CPU_PLL_CONFIG_RANGE_LSB) & CPU_PLL_CONFIG_RANGE_MASK)
+#define CPU_PLL_CONFIG_RANGE_RESET                                   3
+#define CPU_PLL_CONFIG_REFDIV_MSB                                    16
+#define CPU_PLL_CONFIG_REFDIV_LSB                                    12
+#define CPU_PLL_CONFIG_REFDIV_MASK                                   0x0001f000
+#define CPU_PLL_CONFIG_REFDIV_GET(x)                                 (((x) & CPU_PLL_CONFIG_REFDIV_MASK) >> CPU_PLL_CONFIG_REFDIV_LSB)
+#define CPU_PLL_CONFIG_REFDIV_SET(x)                                 (((x) << CPU_PLL_CONFIG_REFDIV_LSB) & CPU_PLL_CONFIG_REFDIV_MASK)
+#define CPU_PLL_CONFIG_REFDIV_RESET                                  2
+#define CPU_PLL_CONFIG_NINT_MSB                                      11
+#define CPU_PLL_CONFIG_NINT_LSB                                      6
+#define CPU_PLL_CONFIG_NINT_MASK                                     0x00000fc0
+#define CPU_PLL_CONFIG_NINT_GET(x)                                   (((x) & CPU_PLL_CONFIG_NINT_MASK) >> CPU_PLL_CONFIG_NINT_LSB)
+#define CPU_PLL_CONFIG_NINT_SET(x)                                   (((x) << CPU_PLL_CONFIG_NINT_LSB) & CPU_PLL_CONFIG_NINT_MASK)
+#define CPU_PLL_CONFIG_NINT_RESET                                    20
+#define CPU_PLL_CONFIG_NFRAC_MSB                                     5
+#define CPU_PLL_CONFIG_NFRAC_LSB                                     0
+#define CPU_PLL_CONFIG_NFRAC_MASK                                    0x0000003f
+#define CPU_PLL_CONFIG_NFRAC_GET(x)                                  (((x) & CPU_PLL_CONFIG_NFRAC_MASK) >> CPU_PLL_CONFIG_NFRAC_LSB)
+#define CPU_PLL_CONFIG_NFRAC_SET(x)                                  (((x) << CPU_PLL_CONFIG_NFRAC_LSB) & CPU_PLL_CONFIG_NFRAC_MASK)
+#define CPU_PLL_CONFIG_NFRAC_RESET                                   16
+#define CPU_PLL_CONFIG_ADDRESS                                       0x0000
+#define CPU_PLL_CONFIG_OFFSET                                        0x0000
+// SW modifiable bits
+#define CPU_PLL_CONFIG_SW_MASK                                       0xffffffff
+// bits defined at reset
+#define CPU_PLL_CONFIG_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define CPU_PLL_CONFIG_RESET                                         0xc0062510
+
+// 32'h0004 (DDR_PLL_CONFIG)
+#define DDR_PLL_CONFIG_UPDATING_MSB                                  31
+#define DDR_PLL_CONFIG_UPDATING_LSB                                  31
+#define DDR_PLL_CONFIG_UPDATING_MASK                                 0x80000000
+#define DDR_PLL_CONFIG_UPDATING_GET(x)                               (((x) & DDR_PLL_CONFIG_UPDATING_MASK) >> DDR_PLL_CONFIG_UPDATING_LSB)
+#define DDR_PLL_CONFIG_UPDATING_SET(x)                               (((x) << DDR_PLL_CONFIG_UPDATING_LSB) & DDR_PLL_CONFIG_UPDATING_MASK)
+#define DDR_PLL_CONFIG_UPDATING_RESET                                1
+#define DDR_PLL_CONFIG_PLLPWD_MSB                                    30
+#define DDR_PLL_CONFIG_PLLPWD_LSB                                    30
+#define DDR_PLL_CONFIG_PLLPWD_MASK                                   0x40000000
+#define DDR_PLL_CONFIG_PLLPWD_GET(x)                                 (((x) & DDR_PLL_CONFIG_PLLPWD_MASK) >> DDR_PLL_CONFIG_PLLPWD_LSB)
+#define DDR_PLL_CONFIG_PLLPWD_SET(x)                                 (((x) << DDR_PLL_CONFIG_PLLPWD_LSB) & DDR_PLL_CONFIG_PLLPWD_MASK)
+#define DDR_PLL_CONFIG_PLLPWD_RESET                                  1
+#define DDR_PLL_CONFIG_SPARE_MSB                                     29
+#define DDR_PLL_CONFIG_SPARE_LSB                                     26
+#define DDR_PLL_CONFIG_SPARE_MASK                                    0x3c000000
+#define DDR_PLL_CONFIG_SPARE_GET(x)                                  (((x) & DDR_PLL_CONFIG_SPARE_MASK) >> DDR_PLL_CONFIG_SPARE_LSB)
+#define DDR_PLL_CONFIG_SPARE_SET(x)                                  (((x) << DDR_PLL_CONFIG_SPARE_LSB) & DDR_PLL_CONFIG_SPARE_MASK)
+#define DDR_PLL_CONFIG_SPARE_RESET                                   0
+#define DDR_PLL_CONFIG_OUTDIV_MSB                                    25
+#define DDR_PLL_CONFIG_OUTDIV_LSB                                    23
+#define DDR_PLL_CONFIG_OUTDIV_MASK                                   0x03800000
+#define DDR_PLL_CONFIG_OUTDIV_GET(x)                                 (((x) & DDR_PLL_CONFIG_OUTDIV_MASK) >> DDR_PLL_CONFIG_OUTDIV_LSB)
+#define DDR_PLL_CONFIG_OUTDIV_SET(x)                                 (((x) << DDR_PLL_CONFIG_OUTDIV_LSB) & DDR_PLL_CONFIG_OUTDIV_MASK)
+#define DDR_PLL_CONFIG_OUTDIV_RESET                                  0
+#define DDR_PLL_CONFIG_RANGE_MSB                                     22
+#define DDR_PLL_CONFIG_RANGE_LSB                                     21
+#define DDR_PLL_CONFIG_RANGE_MASK                                    0x00600000
+#define DDR_PLL_CONFIG_RANGE_GET(x)                                  (((x) & DDR_PLL_CONFIG_RANGE_MASK) >> DDR_PLL_CONFIG_RANGE_LSB)
+#define DDR_PLL_CONFIG_RANGE_SET(x)                                  (((x) << DDR_PLL_CONFIG_RANGE_LSB) & DDR_PLL_CONFIG_RANGE_MASK)
+#define DDR_PLL_CONFIG_RANGE_RESET                                   3
+#define DDR_PLL_CONFIG_REFDIV_MSB                                    20
+#define DDR_PLL_CONFIG_REFDIV_LSB                                    16
+#define DDR_PLL_CONFIG_REFDIV_MASK                                   0x001f0000
+#define DDR_PLL_CONFIG_REFDIV_GET(x)                                 (((x) & DDR_PLL_CONFIG_REFDIV_MASK) >> DDR_PLL_CONFIG_REFDIV_LSB)
+#define DDR_PLL_CONFIG_REFDIV_SET(x)                                 (((x) << DDR_PLL_CONFIG_REFDIV_LSB) & DDR_PLL_CONFIG_REFDIV_MASK)
+#define DDR_PLL_CONFIG_REFDIV_RESET                                  2
+#define DDR_PLL_CONFIG_NINT_MSB                                      15
+#define DDR_PLL_CONFIG_NINT_LSB                                      10
+#define DDR_PLL_CONFIG_NINT_MASK                                     0x0000fc00
+#define DDR_PLL_CONFIG_NINT_GET(x)                                   (((x) & DDR_PLL_CONFIG_NINT_MASK) >> DDR_PLL_CONFIG_NINT_LSB)
+#define DDR_PLL_CONFIG_NINT_SET(x)                                   (((x) << DDR_PLL_CONFIG_NINT_LSB) & DDR_PLL_CONFIG_NINT_MASK)
+#define DDR_PLL_CONFIG_NINT_RESET                                    20
+#define DDR_PLL_CONFIG_NFRAC_MSB                                     9
+#define DDR_PLL_CONFIG_NFRAC_LSB                                     0
+#define DDR_PLL_CONFIG_NFRAC_MASK                                    0x000003ff
+#define DDR_PLL_CONFIG_NFRAC_GET(x)                                  (((x) & DDR_PLL_CONFIG_NFRAC_MASK) >> DDR_PLL_CONFIG_NFRAC_LSB)
+#define DDR_PLL_CONFIG_NFRAC_SET(x)                                  (((x) << DDR_PLL_CONFIG_NFRAC_LSB) & DDR_PLL_CONFIG_NFRAC_MASK)
+#define DDR_PLL_CONFIG_NFRAC_RESET                                   512
+#define DDR_PLL_CONFIG_ADDRESS                                       0x0004
+#define DDR_PLL_CONFIG_OFFSET                                        0x0004
+// SW modifiable bits
+#define DDR_PLL_CONFIG_SW_MASK                                       0xffffffff
+// bits defined at reset
+#define DDR_PLL_CONFIG_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define DDR_PLL_CONFIG_RESET                                         0xc0625200
+
+// 32'h0008 (CPU_DDR_CLOCK_CONTROL)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_MSB                              31
+#define CPU_DDR_CLOCK_CONTROL_SPARE_LSB                              25
+#define CPU_DDR_CLOCK_CONTROL_SPARE_MASK                             0xfe000000
+#define CPU_DDR_CLOCK_CONTROL_SPARE_GET(x)                           (((x) & CPU_DDR_CLOCK_CONTROL_SPARE_MASK) >> CPU_DDR_CLOCK_CONTROL_SPARE_LSB)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_SET(x)                           (((x) << CPU_DDR_CLOCK_CONTROL_SPARE_LSB) & CPU_DDR_CLOCK_CONTROL_SPARE_MASK)
+#define CPU_DDR_CLOCK_CONTROL_SPARE_RESET                            0
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MSB                 24
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB                 24
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK                0x01000000
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_GET(x)              (((x) & CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(x)              (((x) << CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_LSB) & CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_RESET               1
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MSB            23
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB            23
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK           0x00800000
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_GET(x)         (((x) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_SET(x)         (((x) << CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_DEASSRT_RESET          0
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MSB               22
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB               22
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK              0x00400000
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_GET(x)            (((x) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_SET(x)            (((x) << CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_RESET_EN_BP_ASRT_RESET             0
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MSB                 21
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_LSB                 21
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MASK                0x00200000
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_GET(x)              (((x) & CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(x)              (((x) << CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_LSB) & CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_RESET               1
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MSB                 20
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_LSB                 20
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MASK                0x00100000
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_GET(x)              (((x) & CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MASK) >> CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(x)              (((x) << CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_LSB) & CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_RESET               1
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MSB                       19
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB                       15
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK                      0x000f8000
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MSB                       14
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB                       10
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK                      0x00007c00
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MSB                       9
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB                       5
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK                      0x000003e0
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MSB                     4
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB                     4
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK                    0x00000010
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_RESET                   1
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MSB                     3
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB                     3
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK                    0x00000008
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_RESET                   1
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MSB                     2
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB                     2
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK                    0x00000004
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_GET(x)                  (((x) & CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK) >> CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(x)                  (((x) << CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_LSB) & CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_RESET                   1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MSB                       1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB                       1
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK                      0x00000002
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK) >> CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB)
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_LSB) & CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_MASK)
+#define CPU_DDR_CLOCK_CONTROL_RESET_SWITCH_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MSB                       0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB                       0
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK                      0x00000001
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_GET(x)                    (((x) & CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK) >> CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB)
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_SET(x)                    (((x) << CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_LSB) & CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_MASK)
+#define CPU_DDR_CLOCK_CONTROL_CLOCK_SWITCH_RESET                     0
+#define CPU_DDR_CLOCK_CONTROL_ADDRESS                                0x0008
+#define CPU_DDR_CLOCK_CONTROL_OFFSET                                 0x0008
+// SW modifiable bits
+#define CPU_DDR_CLOCK_CONTROL_SW_MASK                                0xffffffff
+// bits defined at reset
+#define CPU_DDR_CLOCK_CONTROL_RSTMASK                                0xffffffff
+// reset value (ignore bits undefined at reset)
+#define CPU_DDR_CLOCK_CONTROL_RESET                                  0x0130001c
+
+// 32'h000c (CPU_SYNC)
+#define CPU_SYNC_LENGTH_MSB                                          19
+#define CPU_SYNC_LENGTH_LSB                                          16
+#define CPU_SYNC_LENGTH_MASK                                         0x000f0000
+#define CPU_SYNC_LENGTH_GET(x)                                       (((x) & CPU_SYNC_LENGTH_MASK) >> CPU_SYNC_LENGTH_LSB)
+#define CPU_SYNC_LENGTH_SET(x)                                       (((x) << CPU_SYNC_LENGTH_LSB) & CPU_SYNC_LENGTH_MASK)
+#define CPU_SYNC_LENGTH_RESET                                        0
+#define CPU_SYNC_PATTERN_MSB                                         15
+#define CPU_SYNC_PATTERN_LSB                                         0
+#define CPU_SYNC_PATTERN_MASK                                        0x0000ffff
+#define CPU_SYNC_PATTERN_GET(x)                                      (((x) & CPU_SYNC_PATTERN_MASK) >> CPU_SYNC_PATTERN_LSB)
+#define CPU_SYNC_PATTERN_SET(x)                                      (((x) << CPU_SYNC_PATTERN_LSB) & CPU_SYNC_PATTERN_MASK)
+#define CPU_SYNC_PATTERN_RESET                                       65535
+#define CPU_SYNC_ADDRESS                                             0x000c
+#define CPU_SYNC_OFFSET                                              0x000c
+// SW modifiable bits
+#define CPU_SYNC_SW_MASK                                             0x000fffff
+// bits defined at reset
+#define CPU_SYNC_RSTMASK                                             0xffffffff
+// reset value (ignore bits undefined at reset)
+#define CPU_SYNC_RESET                                               0x0000ffff
+
+// 32'h0010 (PCIE_PLL_CONFIG)
+#define PCIE_PLL_CONFIG_UPDATING_MSB                                 31
+#define PCIE_PLL_CONFIG_UPDATING_LSB                                 31
+#define PCIE_PLL_CONFIG_UPDATING_MASK                                0x80000000
+#define PCIE_PLL_CONFIG_UPDATING_GET(x)                              (((x) & PCIE_PLL_CONFIG_UPDATING_MASK) >> PCIE_PLL_CONFIG_UPDATING_LSB)
+#define PCIE_PLL_CONFIG_UPDATING_SET(x)                              (((x) << PCIE_PLL_CONFIG_UPDATING_LSB) & PCIE_PLL_CONFIG_UPDATING_MASK)
+#define PCIE_PLL_CONFIG_UPDATING_RESET                               0
+#define PCIE_PLL_CONFIG_PLLPWD_MSB                                   30
+#define PCIE_PLL_CONFIG_PLLPWD_LSB                                   30
+#define PCIE_PLL_CONFIG_PLLPWD_MASK                                  0x40000000
+#define PCIE_PLL_CONFIG_PLLPWD_GET(x)                                (((x) & PCIE_PLL_CONFIG_PLLPWD_MASK) >> PCIE_PLL_CONFIG_PLLPWD_LSB)
+#define PCIE_PLL_CONFIG_PLLPWD_SET(x)                                (((x) << PCIE_PLL_CONFIG_PLLPWD_LSB) & PCIE_PLL_CONFIG_PLLPWD_MASK)
+#define PCIE_PLL_CONFIG_PLLPWD_RESET                                 1
+#define PCIE_PLL_CONFIG_BYPASS_MSB                                   16
+#define PCIE_PLL_CONFIG_BYPASS_LSB                                   16
+#define PCIE_PLL_CONFIG_BYPASS_MASK                                  0x00010000
+#define PCIE_PLL_CONFIG_BYPASS_GET(x)                                (((x) & PCIE_PLL_CONFIG_BYPASS_MASK) >> PCIE_PLL_CONFIG_BYPASS_LSB)
+#define PCIE_PLL_CONFIG_BYPASS_SET(x)                                (((x) << PCIE_PLL_CONFIG_BYPASS_LSB) & PCIE_PLL_CONFIG_BYPASS_MASK)
+#define PCIE_PLL_CONFIG_BYPASS_RESET                                 1
+#define PCIE_PLL_CONFIG_REFDIV_MSB                                   14
+#define PCIE_PLL_CONFIG_REFDIV_LSB                                   10
+#define PCIE_PLL_CONFIG_REFDIV_MASK                                  0x00007c00
+#define PCIE_PLL_CONFIG_REFDIV_GET(x)                                (((x) & PCIE_PLL_CONFIG_REFDIV_MASK) >> PCIE_PLL_CONFIG_REFDIV_LSB)
+#define PCIE_PLL_CONFIG_REFDIV_SET(x)                                (((x) << PCIE_PLL_CONFIG_REFDIV_LSB) & PCIE_PLL_CONFIG_REFDIV_MASK)
+#define PCIE_PLL_CONFIG_REFDIV_RESET                                 1
+#define PCIE_PLL_CONFIG_ADDRESS                                      0x0010
+#define PCIE_PLL_CONFIG_OFFSET                                       0x0010
+// SW modifiable bits
+#define PCIE_PLL_CONFIG_SW_MASK                                      0xc0017c00
+// bits defined at reset
+#define PCIE_PLL_CONFIG_RSTMASK                                      0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PLL_CONFIG_RESET                                        0x40010400
+
+// 32'h0014 (PCIE_PLL_DITHER_DIV_MAX)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MSB                        31
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB                        31
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK                       0x80000000
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_GET(x)                     (((x) & PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK) >> PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_SET(x)                     (((x) << PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_LSB) & PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_RESET                      1
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MSB                          30
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB                          30
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK                         0x40000000
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_GET(x)                       (((x) & PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK) >> PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_SET(x)                       (((x) << PCIE_PLL_DITHER_DIV_MAX_USE_MAX_LSB) & PCIE_PLL_DITHER_DIV_MAX_USE_MAX_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_USE_MAX_RESET                        1
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MSB                      20
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB                      15
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK                     0x001f8000
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_GET(x)                   (((x) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK) >> PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_SET(x)                   (((x) << PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_LSB) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_RESET                    19
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MSB                     14
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB                     1
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK                    0x00007ffe
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_GET(x)                  (((x) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK) >> PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_SET(x)                  (((x) << PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_LSB) & PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_MASK)
+#define PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_RESET                   16383
+#define PCIE_PLL_DITHER_DIV_MAX_ADDRESS                              0x0014
+#define PCIE_PLL_DITHER_DIV_MAX_OFFSET                               0x0014
+// SW modifiable bits
+#define PCIE_PLL_DITHER_DIV_MAX_SW_MASK                              0xc01ffffe
+// bits defined at reset
+#define PCIE_PLL_DITHER_DIV_MAX_RSTMASK                              0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PLL_DITHER_DIV_MAX_RESET                                0xc009fffe
+
+// 32'h0018 (PCIE_PLL_DITHER_DIV_MIN)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MSB                      20
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB                      15
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK                     0x001f8000
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_GET(x)                   (((x) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK) >> PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_SET(x)                   (((x) << PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_LSB) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_MASK)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_RESET                    19
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MSB                     14
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB                     1
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK                    0x00007ffe
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_GET(x)                  (((x) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK) >> PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_SET(x)                  (((x) << PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_LSB) & PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_MASK)
+#define PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_FRAC_RESET                   14749
+#define PCIE_PLL_DITHER_DIV_MIN_ADDRESS                              0x0018
+#define PCIE_PLL_DITHER_DIV_MIN_OFFSET                               0x0018
+// SW modifiable bits
+#define PCIE_PLL_DITHER_DIV_MIN_SW_MASK                              0x001ffffe
+// bits defined at reset
+#define PCIE_PLL_DITHER_DIV_MIN_RSTMASK                              0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PLL_DITHER_DIV_MIN_RESET                                0x0009f33a
+
+// 32'h001c (PCIE_PLL_DITHER_STEP)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_MSB                          31
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB                          28
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK                         0xf0000000
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_GET(x)                       (((x) & PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK) >> PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_SET(x)                       (((x) << PCIE_PLL_DITHER_STEP_UPDATE_CNT_LSB) & PCIE_PLL_DITHER_STEP_UPDATE_CNT_MASK)
+#define PCIE_PLL_DITHER_STEP_UPDATE_CNT_RESET                        0
+#define PCIE_PLL_DITHER_STEP_STEP_INT_MSB                            24
+#define PCIE_PLL_DITHER_STEP_STEP_INT_LSB                            15
+#define PCIE_PLL_DITHER_STEP_STEP_INT_MASK                           0x01ff8000
+#define PCIE_PLL_DITHER_STEP_STEP_INT_GET(x)                         (((x) & PCIE_PLL_DITHER_STEP_STEP_INT_MASK) >> PCIE_PLL_DITHER_STEP_STEP_INT_LSB)
+#define PCIE_PLL_DITHER_STEP_STEP_INT_SET(x)                         (((x) << PCIE_PLL_DITHER_STEP_STEP_INT_LSB) & PCIE_PLL_DITHER_STEP_STEP_INT_MASK)
+#define PCIE_PLL_DITHER_STEP_STEP_INT_RESET                          0
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_MSB                           14
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB                           1
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK                          0x00007ffe
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_GET(x)                        (((x) & PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK) >> PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB)
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_SET(x)                        (((x) << PCIE_PLL_DITHER_STEP_STEP_FRAC_LSB) & PCIE_PLL_DITHER_STEP_STEP_FRAC_MASK)
+#define PCIE_PLL_DITHER_STEP_STEP_FRAC_RESET                         10
+#define PCIE_PLL_DITHER_STEP_ADDRESS                                 0x001c
+#define PCIE_PLL_DITHER_STEP_OFFSET                                  0x001c
+// SW modifiable bits
+#define PCIE_PLL_DITHER_STEP_SW_MASK                                 0xf1fffffe
+// bits defined at reset
+#define PCIE_PLL_DITHER_STEP_RSTMASK                                 0xffffffff
+// reset value (ignore bits undefined at reset)
+#define PCIE_PLL_DITHER_STEP_RESET                                   0x00000014
+
+// 32'h0020 (LDO_POWER_CONTROL)
+#define LDO_POWER_CONTROL_PKG_SEL_MSB                                5
+#define LDO_POWER_CONTROL_PKG_SEL_LSB                                5
+#define LDO_POWER_CONTROL_PKG_SEL_MASK                               0x00000020
+#define LDO_POWER_CONTROL_PKG_SEL_GET(x)                             (((x) & LDO_POWER_CONTROL_PKG_SEL_MASK) >> LDO_POWER_CONTROL_PKG_SEL_LSB)
+#define LDO_POWER_CONTROL_PKG_SEL_SET(x)                             (((x) << LDO_POWER_CONTROL_PKG_SEL_LSB) & LDO_POWER_CONTROL_PKG_SEL_MASK)
+#define LDO_POWER_CONTROL_PKG_SEL_RESET                              0
+#define LDO_POWER_CONTROL_PWDLDO_CPU_MSB                             4
+#define LDO_POWER_CONTROL_PWDLDO_CPU_LSB                             4
+#define LDO_POWER_CONTROL_PWDLDO_CPU_MASK                            0x00000010
+#define LDO_POWER_CONTROL_PWDLDO_CPU_GET(x)                          (((x) & LDO_POWER_CONTROL_PWDLDO_CPU_MASK) >> LDO_POWER_CONTROL_PWDLDO_CPU_LSB)
+#define LDO_POWER_CONTROL_PWDLDO_CPU_SET(x)                          (((x) << LDO_POWER_CONTROL_PWDLDO_CPU_LSB) & LDO_POWER_CONTROL_PWDLDO_CPU_MASK)
+#define LDO_POWER_CONTROL_PWDLDO_CPU_RESET                           0
+#define LDO_POWER_CONTROL_PWDLDO_DDR_MSB                             3
+#define LDO_POWER_CONTROL_PWDLDO_DDR_LSB                             3
+#define LDO_POWER_CONTROL_PWDLDO_DDR_MASK                            0x00000008
+#define LDO_POWER_CONTROL_PWDLDO_DDR_GET(x)                          (((x) & LDO_POWER_CONTROL_PWDLDO_DDR_MASK) >> LDO_POWER_CONTROL_PWDLDO_DDR_LSB)
+#define LDO_POWER_CONTROL_PWDLDO_DDR_SET(x)                          (((x) << LDO_POWER_CONTROL_PWDLDO_DDR_LSB) & LDO_POWER_CONTROL_PWDLDO_DDR_MASK)
+#define LDO_POWER_CONTROL_PWDLDO_DDR_RESET                           0
+#define LDO_POWER_CONTROL_CPU_REFSEL_MSB                             2
+#define LDO_POWER_CONTROL_CPU_REFSEL_LSB                             1
+#define LDO_POWER_CONTROL_CPU_REFSEL_MASK                            0x00000006
+#define LDO_POWER_CONTROL_CPU_REFSEL_GET(x)                          (((x) & LDO_POWER_CONTROL_CPU_REFSEL_MASK) >> LDO_POWER_CONTROL_CPU_REFSEL_LSB)
+#define LDO_POWER_CONTROL_CPU_REFSEL_SET(x)                          (((x) << LDO_POWER_CONTROL_CPU_REFSEL_LSB) & LDO_POWER_CONTROL_CPU_REFSEL_MASK)
+#define LDO_POWER_CONTROL_CPU_REFSEL_RESET                           3
+#define LDO_POWER_CONTROL_SELECT_DDR1_MSB                            0
+#define LDO_POWER_CONTROL_SELECT_DDR1_LSB                            0
+#define LDO_POWER_CONTROL_SELECT_DDR1_MASK                           0x00000001
+#define LDO_POWER_CONTROL_SELECT_DDR1_GET(x)                         (((x) & LDO_POWER_CONTROL_SELECT_DDR1_MASK) >> LDO_POWER_CONTROL_SELECT_DDR1_LSB)
+#define LDO_POWER_CONTROL_SELECT_DDR1_SET(x)                         (((x) << LDO_POWER_CONTROL_SELECT_DDR1_LSB) & LDO_POWER_CONTROL_SELECT_DDR1_MASK)
+#define LDO_POWER_CONTROL_SELECT_DDR1_RESET                          0
+#define LDO_POWER_CONTROL_ADDRESS                                    0x0020
+#define LDO_POWER_CONTROL_OFFSET                                     0x0020
+// SW modifiable bits
+#define LDO_POWER_CONTROL_SW_MASK                                    0x0000003f
+// bits defined at reset
+#define LDO_POWER_CONTROL_RSTMASK                                    0xffffffff
+// reset value (ignore bits undefined at reset)
+#define LDO_POWER_CONTROL_RESET                                      0x00000006
+
+// 32'h0024 (SWITCH_CLOCK_SPARE)
+#define SWITCH_CLOCK_SPARE_SPARE_MSB                                 31
+#define SWITCH_CLOCK_SPARE_SPARE_LSB                                 12
+#define SWITCH_CLOCK_SPARE_SPARE_MASK                                0xfffff000
+#define SWITCH_CLOCK_SPARE_SPARE_GET(x)                              (((x) & SWITCH_CLOCK_SPARE_SPARE_MASK) >> SWITCH_CLOCK_SPARE_SPARE_LSB)
+#define SWITCH_CLOCK_SPARE_SPARE_SET(x)                              (((x) << SWITCH_CLOCK_SPARE_SPARE_LSB) & SWITCH_CLOCK_SPARE_SPARE_MASK)
+#define SWITCH_CLOCK_SPARE_SPARE_RESET                               0
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MSB                   11
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB                   8
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK                  0x00000f00
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_GET(x)                (((x) & SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK) >> SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(x)                (((x) << SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_LSB) & SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_RESET                 5
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MSB                         7
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB                         7
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK                        0x00000080
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_GET(x)                      (((x) & SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_SET(x)                      (((x) << SWITCH_CLOCK_SPARE_UART1_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_UART1_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_UART1_CLK_SEL_RESET                       0
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MSB                          6
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_LSB                          6
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MASK                         0x00000040
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_GET(x)                       (((x) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_SET(x)                       (((x) << SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_LSB) & SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_MDIO_CLK_SEL_RESET                        0
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MSB                       5
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_LSB                       5
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MASK                      0x00000020
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_GET(x)                    (((x) & SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MASK) >> SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_LSB)
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_SET(x)                    (((x) << SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_LSB) & SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_MASK)
+#define SWITCH_CLOCK_SPARE_OEN_CLK125M_PLL_RESET                     1
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_MSB                            4
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_LSB                            4
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_MASK                           0x00000010
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_GET(x)                         (((x) & SWITCH_CLOCK_SPARE_EN_PLL_TOP_MASK) >> SWITCH_CLOCK_SPARE_EN_PLL_TOP_LSB)
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_SET(x)                         (((x) << SWITCH_CLOCK_SPARE_EN_PLL_TOP_LSB) & SWITCH_CLOCK_SPARE_EN_PLL_TOP_MASK)
+#define SWITCH_CLOCK_SPARE_EN_PLL_TOP_RESET                          1
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_MSB                            3
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_LSB                            3
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_MASK                           0x00000008
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_GET(x)                         (((x) & SWITCH_CLOCK_SPARE_EEE_ENABLE_MASK) >> SWITCH_CLOCK_SPARE_EEE_ENABLE_LSB)
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_SET(x)                         (((x) << SWITCH_CLOCK_SPARE_EEE_ENABLE_LSB) & SWITCH_CLOCK_SPARE_EEE_ENABLE_MASK)
+#define SWITCH_CLOCK_SPARE_EEE_ENABLE_RESET                          0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MSB             2
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_LSB             2
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MASK            0x00000004
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_GET(x)          (((x) & SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MASK) >> SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_LSB)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_SET(x)          (((x) << SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_LSB) & SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_MASK)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_FROM_PYTHON_OFF_RESET           0
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MSB                  1
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_LSB                  1
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MASK                 0x00000002
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_GET(x)               (((x) & SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MASK) >> SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_LSB)
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_SET(x)               (((x) << SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_LSB) & SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_MASK)
+#define SWITCH_CLOCK_SPARE_SWITCH_FUNC_TST_MODE_RESET                0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MSB                         0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_LSB                         0
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MASK                        0x00000001
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_GET(x)                      (((x) & SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MASK) >> SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_LSB)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_SET(x)                      (((x) << SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_LSB) & SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_MASK)
+#define SWITCH_CLOCK_SPARE_SWITCHCLK_SEL_RESET                       1
+#define SWITCH_CLOCK_SPARE_ADDRESS                                   0x0024
+#define SWITCH_CLOCK_SPARE_OFFSET                                    0x0024
+// SW modifiable bits
+#define SWITCH_CLOCK_SPARE_SW_MASK                                   0xffffffff
+// bits defined at reset
+#define SWITCH_CLOCK_SPARE_RSTMASK                                   0xffffffff
+// reset value (ignore bits undefined at reset)
+#define SWITCH_CLOCK_SPARE_RESET                                     0x00000531
+
+// 32'h0028 (CURRENT_PCIE_PLL_DITHER)
+#define CURRENT_PCIE_PLL_DITHER_INT_MSB                              20
+#define CURRENT_PCIE_PLL_DITHER_INT_LSB                              15
+#define CURRENT_PCIE_PLL_DITHER_INT_MASK                             0x001f8000
+#define CURRENT_PCIE_PLL_DITHER_INT_GET(x)                           (((x) & CURRENT_PCIE_PLL_DITHER_INT_MASK) >> CURRENT_PCIE_PLL_DITHER_INT_LSB)
+#define CURRENT_PCIE_PLL_DITHER_INT_SET(x)                           (((x) << CURRENT_PCIE_PLL_DITHER_INT_LSB) & CURRENT_PCIE_PLL_DITHER_INT_MASK)
+#define CURRENT_PCIE_PLL_DITHER_INT_RESET                            1
+#define CURRENT_PCIE_PLL_DITHER_FRAC_MSB                             13
+#define CURRENT_PCIE_PLL_DITHER_FRAC_LSB                             0
+#define CURRENT_PCIE_PLL_DITHER_FRAC_MASK                            0x00003fff
+#define CURRENT_PCIE_PLL_DITHER_FRAC_GET(x)                          (((x) & CURRENT_PCIE_PLL_DITHER_FRAC_MASK) >> CURRENT_PCIE_PLL_DITHER_FRAC_LSB)
+#define CURRENT_PCIE_PLL_DITHER_FRAC_SET(x)                          (((x) << CURRENT_PCIE_PLL_DITHER_FRAC_LSB) & CURRENT_PCIE_PLL_DITHER_FRAC_MASK)
+#define CURRENT_PCIE_PLL_DITHER_FRAC_RESET                           0
+#define CURRENT_PCIE_PLL_DITHER_ADDRESS                              0x0028
+#define CURRENT_PCIE_PLL_DITHER_OFFSET                               0x0028
+// SW modifiable bits
+#define CURRENT_PCIE_PLL_DITHER_SW_MASK                              0x001fbfff
+// bits defined at reset
+#define CURRENT_PCIE_PLL_DITHER_RSTMASK                              0xffffffff
+// reset value (ignore bits undefined at reset)
+#define CURRENT_PCIE_PLL_DITHER_RESET                                0x00008000
+
+// 32'h002c (ETH_XMII)
+#define ETH_XMII_TX_INVERT_MSB                                       31
+#define ETH_XMII_TX_INVERT_LSB                                       31
+#define ETH_XMII_TX_INVERT_MASK                                      0x80000000
+#define ETH_XMII_TX_INVERT_GET(x)                                    (((x) & ETH_XMII_TX_INVERT_MASK) >> ETH_XMII_TX_INVERT_LSB)
+#define ETH_XMII_TX_INVERT_SET(x)                                    (((x) << ETH_XMII_TX_INVERT_LSB) & ETH_XMII_TX_INVERT_MASK)
+#define ETH_XMII_TX_INVERT_RESET                                     0
+#define ETH_XMII_GIGE_QUAD_MSB                                       30
+#define ETH_XMII_GIGE_QUAD_LSB                                       30
+#define ETH_XMII_GIGE_QUAD_MASK                                      0x40000000
+#define ETH_XMII_GIGE_QUAD_GET(x)                                    (((x) & ETH_XMII_GIGE_QUAD_MASK) >> ETH_XMII_GIGE_QUAD_LSB)
+#define ETH_XMII_GIGE_QUAD_SET(x)                                    (((x) << ETH_XMII_GIGE_QUAD_LSB) & ETH_XMII_GIGE_QUAD_MASK)
+#define ETH_XMII_GIGE_QUAD_RESET                                     0
+#define ETH_XMII_RX_DELAY_MSB                                        29
+#define ETH_XMII_RX_DELAY_LSB                                        28
+#define ETH_XMII_RX_DELAY_MASK                                       0x30000000
+#define ETH_XMII_RX_DELAY_GET(x)                                     (((x) & ETH_XMII_RX_DELAY_MASK) >> ETH_XMII_RX_DELAY_LSB)
+#define ETH_XMII_RX_DELAY_SET(x)                                     (((x) << ETH_XMII_RX_DELAY_LSB) & ETH_XMII_RX_DELAY_MASK)
+#define ETH_XMII_RX_DELAY_RESET                                      0
+#define ETH_XMII_TX_DELAY_MSB                                        27
+#define ETH_XMII_TX_DELAY_LSB                                        26
+#define ETH_XMII_TX_DELAY_MASK                                       0x0c000000
+#define ETH_XMII_TX_DELAY_GET(x)                                     (((x) & ETH_XMII_TX_DELAY_MASK) >> ETH_XMII_TX_DELAY_LSB)
+#define ETH_XMII_TX_DELAY_SET(x)                                     (((x) << ETH_XMII_TX_DELAY_LSB) & ETH_XMII_TX_DELAY_MASK)
+#define ETH_XMII_TX_DELAY_RESET                                      0
+#define ETH_XMII_GIGE_MSB                                            25
+#define ETH_XMII_GIGE_LSB                                            25
+#define ETH_XMII_GIGE_MASK                                           0x02000000
+#define ETH_XMII_GIGE_GET(x)                                         (((x) & ETH_XMII_GIGE_MASK) >> ETH_XMII_GIGE_LSB)
+#define ETH_XMII_GIGE_SET(x)                                         (((x) << ETH_XMII_GIGE_LSB) & ETH_XMII_GIGE_MASK)
+#define ETH_XMII_GIGE_RESET                                          0
+#define ETH_XMII_OFFSET_PHASE_MSB                                    24
+#define ETH_XMII_OFFSET_PHASE_LSB                                    24
+#define ETH_XMII_OFFSET_PHASE_MASK                                   0x01000000
+#define ETH_XMII_OFFSET_PHASE_GET(x)                                 (((x) & ETH_XMII_OFFSET_PHASE_MASK) >> ETH_XMII_OFFSET_PHASE_LSB)
+#define ETH_XMII_OFFSET_PHASE_SET(x)                                 (((x) << ETH_XMII_OFFSET_PHASE_LSB) & ETH_XMII_OFFSET_PHASE_MASK)
+#define ETH_XMII_OFFSET_PHASE_RESET                                  0
+#define ETH_XMII_OFFSET_COUNT_MSB                                    23
+#define ETH_XMII_OFFSET_COUNT_LSB                                    16
+#define ETH_XMII_OFFSET_COUNT_MASK                                   0x00ff0000
+#define ETH_XMII_OFFSET_COUNT_GET(x)                                 (((x) & ETH_XMII_OFFSET_COUNT_MASK) >> ETH_XMII_OFFSET_COUNT_LSB)
+#define ETH_XMII_OFFSET_COUNT_SET(x)                                 (((x) << ETH_XMII_OFFSET_COUNT_LSB) & ETH_XMII_OFFSET_COUNT_MASK)
+#define ETH_XMII_OFFSET_COUNT_RESET                                  0
+#define ETH_XMII_PHASE1_COUNT_MSB                                    15
+#define ETH_XMII_PHASE1_COUNT_LSB                                    8
+#define ETH_XMII_PHASE1_COUNT_MASK                                   0x0000ff00
+#define ETH_XMII_PHASE1_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE1_COUNT_MASK) >> ETH_XMII_PHASE1_COUNT_LSB)
+#define ETH_XMII_PHASE1_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE1_COUNT_LSB) & ETH_XMII_PHASE1_COUNT_MASK)
+#define ETH_XMII_PHASE1_COUNT_RESET                                  1
+#define ETH_XMII_PHASE0_COUNT_MSB                                    7
+#define ETH_XMII_PHASE0_COUNT_LSB                                    0
+#define ETH_XMII_PHASE0_COUNT_MASK                                   0x000000ff
+#define ETH_XMII_PHASE0_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE0_COUNT_MASK) >> ETH_XMII_PHASE0_COUNT_LSB)
+#define ETH_XMII_PHASE0_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE0_COUNT_LSB) & ETH_XMII_PHASE0_COUNT_MASK)
+#define ETH_XMII_PHASE0_COUNT_RESET                                  1
+#define ETH_XMII_ADDRESS                                             0x002c
+#define ETH_XMII_OFFSET                                              0x002c
+// SW modifiable bits
+#define ETH_XMII_SW_MASK                                             0xffffffff
+// bits defined at reset
+#define ETH_XMII_RSTMASK                                             0xffffffff
+// reset value (ignore bits undefined at reset)
+#define ETH_XMII_RESET                                               0x00000101
+
+// 32'h0030 (AUDIO_PLL_CONFIG)
+#define AUDIO_PLL_CONFIG_UPDATING_MSB                                31
+#define AUDIO_PLL_CONFIG_UPDATING_LSB                                31
+#define AUDIO_PLL_CONFIG_UPDATING_MASK                               0x80000000
+#define AUDIO_PLL_CONFIG_UPDATING_GET(x)                             (((x) & AUDIO_PLL_CONFIG_UPDATING_MASK) >> AUDIO_PLL_CONFIG_UPDATING_LSB)
+#define AUDIO_PLL_CONFIG_UPDATING_SET(x)                             (((x) << AUDIO_PLL_CONFIG_UPDATING_LSB) & AUDIO_PLL_CONFIG_UPDATING_MASK)
+#define AUDIO_PLL_CONFIG_UPDATING_RESET                              1
+#define AUDIO_PLL_CONFIG_EXT_DIV_MSB                                 14
+#define AUDIO_PLL_CONFIG_EXT_DIV_LSB                                 12
+#define AUDIO_PLL_CONFIG_EXT_DIV_MASK                                0x00007000
+#define AUDIO_PLL_CONFIG_EXT_DIV_GET(x)                              (((x) & AUDIO_PLL_CONFIG_EXT_DIV_MASK) >> AUDIO_PLL_CONFIG_EXT_DIV_LSB)
+#define AUDIO_PLL_CONFIG_EXT_DIV_SET(x)                              (((x) << AUDIO_PLL_CONFIG_EXT_DIV_LSB) & AUDIO_PLL_CONFIG_EXT_DIV_MASK)
+#define AUDIO_PLL_CONFIG_EXT_DIV_RESET                               1
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_MSB                              9
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_LSB                              7
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_MASK                             0x00000380
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_GET(x)                           (((x) & AUDIO_PLL_CONFIG_POSTPLLDIV_MASK) >> AUDIO_PLL_CONFIG_POSTPLLDIV_LSB)
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_SET(x)                           (((x) << AUDIO_PLL_CONFIG_POSTPLLDIV_LSB) & AUDIO_PLL_CONFIG_POSTPLLDIV_MASK)
+#define AUDIO_PLL_CONFIG_POSTPLLDIV_RESET                            1
+#define AUDIO_PLL_CONFIG_PLLPWD_MSB                                  5
+#define AUDIO_PLL_CONFIG_PLLPWD_LSB                                  5
+#define AUDIO_PLL_CONFIG_PLLPWD_MASK                                 0x00000020
+#define AUDIO_PLL_CONFIG_PLLPWD_GET(x)                               (((x) & AUDIO_PLL_CONFIG_PLLPWD_MASK) >> AUDIO_PLL_CONFIG_PLLPWD_LSB)
+#define AUDIO_PLL_CONFIG_PLLPWD_SET(x)                               (((x) << AUDIO_PLL_CONFIG_PLLPWD_LSB) & AUDIO_PLL_CONFIG_PLLPWD_MASK)
+#define AUDIO_PLL_CONFIG_PLLPWD_RESET                                1
+#define AUDIO_PLL_CONFIG_BYPASS_MSB                                  4
+#define AUDIO_PLL_CONFIG_BYPASS_LSB                                  4
+#define AUDIO_PLL_CONFIG_BYPASS_MASK                                 0x00000010
+#define AUDIO_PLL_CONFIG_BYPASS_GET(x)                               (((x) & AUDIO_PLL_CONFIG_BYPASS_MASK) >> AUDIO_PLL_CONFIG_BYPASS_LSB)
+#define AUDIO_PLL_CONFIG_BYPASS_SET(x)                               (((x) << AUDIO_PLL_CONFIG_BYPASS_LSB) & AUDIO_PLL_CONFIG_BYPASS_MASK)
+#define AUDIO_PLL_CONFIG_BYPASS_RESET                                1
+#define AUDIO_PLL_CONFIG_REFDIV_MSB                                  3
+#define AUDIO_PLL_CONFIG_REFDIV_LSB                                  0
+#define AUDIO_PLL_CONFIG_REFDIV_MASK                                 0x0000000f
+#define AUDIO_PLL_CONFIG_REFDIV_GET(x)                               (((x) & AUDIO_PLL_CONFIG_REFDIV_MASK) >> AUDIO_PLL_CONFIG_REFDIV_LSB)
+#define AUDIO_PLL_CONFIG_REFDIV_SET(x)                               (((x) << AUDIO_PLL_CONFIG_REFDIV_LSB) & AUDIO_PLL_CONFIG_REFDIV_MASK)
+#define AUDIO_PLL_CONFIG_REFDIV_RESET                                3
+#define AUDIO_PLL_CONFIG_ADDRESS                                     0x0030
+#define AUDIO_PLL_CONFIG_OFFSET                                      0x0030
+// SW modifiable bits
+#define AUDIO_PLL_CONFIG_SW_MASK                                     0x800073bf
+// bits defined at reset
+#define AUDIO_PLL_CONFIG_RSTMASK                                     0xffffffff
+// reset value (ignore bits undefined at reset)
+#define AUDIO_PLL_CONFIG_RESET                                       0x800010b3
+
+// 32'h0034 (AUDIO_PLL_MODULATION)
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MSB                        28
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_LSB                        11
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MASK                       0x1ffff800
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_GET(x)                     (((x) & AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MASK) >> AUDIO_PLL_MODULATION_TGT_DIV_FRAC_LSB)
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_SET(x)                     (((x) << AUDIO_PLL_MODULATION_TGT_DIV_FRAC_LSB) & AUDIO_PLL_MODULATION_TGT_DIV_FRAC_MASK)
+#define AUDIO_PLL_MODULATION_TGT_DIV_FRAC_RESET                      84222
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_MSB                         6
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_LSB                         1
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_MASK                        0x0000007e
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_GET(x)                      (((x) & AUDIO_PLL_MODULATION_TGT_DIV_INT_MASK) >> AUDIO_PLL_MODULATION_TGT_DIV_INT_LSB)
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_SET(x)                      (((x) << AUDIO_PLL_MODULATION_TGT_DIV_INT_LSB) & AUDIO_PLL_MODULATION_TGT_DIV_INT_MASK)
+#define AUDIO_PLL_MODULATION_TGT_DIV_INT_RESET                       20
+#define AUDIO_PLL_MODULATION_START_MSB                               0
+#define AUDIO_PLL_MODULATION_START_LSB                               0
+#define AUDIO_PLL_MODULATION_START_MASK                              0x00000001
+#define AUDIO_PLL_MODULATION_START_GET(x)                            (((x) & AUDIO_PLL_MODULATION_START_MASK) >> AUDIO_PLL_MODULATION_START_LSB)
+#define AUDIO_PLL_MODULATION_START_SET(x)                            (((x) << AUDIO_PLL_MODULATION_START_LSB) & AUDIO_PLL_MODULATION_START_MASK)
+#define AUDIO_PLL_MODULATION_START_RESET                             0
+#define AUDIO_PLL_MODULATION_ADDRESS                                 0x0034
+#define AUDIO_PLL_MODULATION_OFFSET                                  0x0034
+// SW modifiable bits
+#define AUDIO_PLL_MODULATION_SW_MASK                                 0x1ffff87f
+// bits defined at reset
+#define AUDIO_PLL_MODULATION_RSTMASK                                 0xffffffff
+// reset value (ignore bits undefined at reset)
+#define AUDIO_PLL_MODULATION_RESET                                   0x0a47f028
+
+// 32'h0038 (AUDIO_PLL_MOD_STEP)
+#define AUDIO_PLL_MOD_STEP_FRAC_MSB                                  31
+#define AUDIO_PLL_MOD_STEP_FRAC_LSB                                  14
+#define AUDIO_PLL_MOD_STEP_FRAC_MASK                                 0xffffc000
+#define AUDIO_PLL_MOD_STEP_FRAC_GET(x)                               (((x) & AUDIO_PLL_MOD_STEP_FRAC_MASK) >> AUDIO_PLL_MOD_STEP_FRAC_LSB)
+#define AUDIO_PLL_MOD_STEP_FRAC_SET(x)                               (((x) << AUDIO_PLL_MOD_STEP_FRAC_LSB) & AUDIO_PLL_MOD_STEP_FRAC_MASK)
+#define AUDIO_PLL_MOD_STEP_FRAC_RESET                                1
+#define AUDIO_PLL_MOD_STEP_INT_MSB                                   13
+#define AUDIO_PLL_MOD_STEP_INT_LSB                                   4
+#define AUDIO_PLL_MOD_STEP_INT_MASK                                  0x00003ff0
+#define AUDIO_PLL_MOD_STEP_INT_GET(x)                                (((x) & AUDIO_PLL_MOD_STEP_INT_MASK) >> AUDIO_PLL_MOD_STEP_INT_LSB)
+#define AUDIO_PLL_MOD_STEP_INT_SET(x)                                (((x) << AUDIO_PLL_MOD_STEP_INT_LSB) & AUDIO_PLL_MOD_STEP_INT_MASK)
+#define AUDIO_PLL_MOD_STEP_INT_RESET                                 0
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_MSB                            3
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_LSB                            0
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_MASK                           0x0000000f
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_GET(x)                         (((x) & AUDIO_PLL_MOD_STEP_UPDATE_CNT_MASK) >> AUDIO_PLL_MOD_STEP_UPDATE_CNT_LSB)
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_SET(x)                         (((x) << AUDIO_PLL_MOD_STEP_UPDATE_CNT_LSB) & AUDIO_PLL_MOD_STEP_UPDATE_CNT_MASK)
+#define AUDIO_PLL_MOD_STEP_UPDATE_CNT_RESET                          0
+#define AUDIO_PLL_MOD_STEP_ADDRESS                                   0x0038
+#define AUDIO_PLL_MOD_STEP_OFFSET                                    0x0038
+// SW modifiable bits
+#define AUDIO_PLL_MOD_STEP_SW_MASK                                   0xffffffff
+// bits defined at reset
+#define AUDIO_PLL_MOD_STEP_RSTMASK                                   0xffffffff
+// reset value (ignore bits undefined at reset)
+#define AUDIO_PLL_MOD_STEP_RESET                                     0x00004000
+
+// 32'h003c (CURRENT_AUDIO_PLL_MODULATION)
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_MSB                        27
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_LSB                        10
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_MASK                       0x0ffffc00
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_GET(x)                     (((x) & CURRENT_AUDIO_PLL_MODULATION_FRAC_MASK) >> CURRENT_AUDIO_PLL_MODULATION_FRAC_LSB)
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_SET(x)                     (((x) << CURRENT_AUDIO_PLL_MODULATION_FRAC_LSB) & CURRENT_AUDIO_PLL_MODULATION_FRAC_MASK)
+#define CURRENT_AUDIO_PLL_MODULATION_FRAC_RESET                      1
+#define CURRENT_AUDIO_PLL_MODULATION_INT_MSB                         6
+#define CURRENT_AUDIO_PLL_MODULATION_INT_LSB                         1
+#define CURRENT_AUDIO_PLL_MODULATION_INT_MASK                        0x0000007e
+#define CURRENT_AUDIO_PLL_MODULATION_INT_GET(x)                      (((x) & CURRENT_AUDIO_PLL_MODULATION_INT_MASK) >> CURRENT_AUDIO_PLL_MODULATION_INT_LSB)
+#define CURRENT_AUDIO_PLL_MODULATION_INT_SET(x)                      (((x) << CURRENT_AUDIO_PLL_MODULATION_INT_LSB) & CURRENT_AUDIO_PLL_MODULATION_INT_MASK)
+#define CURRENT_AUDIO_PLL_MODULATION_INT_RESET                       0
+#define CURRENT_AUDIO_PLL_MODULATION_ADDRESS                         0x003c
+#define CURRENT_AUDIO_PLL_MODULATION_OFFSET                          0x003c
+// SW modifiable bits
+#define CURRENT_AUDIO_PLL_MODULATION_SW_MASK                         0x0ffffc7e
+// bits defined at reset
+#define CURRENT_AUDIO_PLL_MODULATION_RSTMASK                         0xffffffff
+// reset value (ignore bits undefined at reset)
+#define CURRENT_AUDIO_PLL_MODULATION_RESET                           0x00000400
+
+#define RST_BOOTSTRAP_ADDRESS                                        0x180600b0
+
+// 32'h0040 (BB_PLL_CONFIG)
+#define BB_PLL_CONFIG_UPDATING_MSB                                   31
+#define BB_PLL_CONFIG_UPDATING_LSB                                   31
+#define BB_PLL_CONFIG_UPDATING_MASK                                  0x80000000
+#define BB_PLL_CONFIG_UPDATING_GET(x)                                (((x) & BB_PLL_CONFIG_UPDATING_MASK) >> BB_PLL_CONFIG_UPDATING_LSB)
+#define BB_PLL_CONFIG_UPDATING_SET(x)                                (((x) << BB_PLL_CONFIG_UPDATING_LSB) & BB_PLL_CONFIG_UPDATING_MASK)
+#define BB_PLL_CONFIG_UPDATING_RESET                                 1
+#define BB_PLL_CONFIG_PLLPWD_MSB                                     30
+#define BB_PLL_CONFIG_PLLPWD_LSB                                     30
+#define BB_PLL_CONFIG_PLLPWD_MASK                                    0x40000000
+#define BB_PLL_CONFIG_PLLPWD_GET(x)                                  (((x) & BB_PLL_CONFIG_PLLPWD_MASK) >> BB_PLL_CONFIG_PLLPWD_LSB)
+#define BB_PLL_CONFIG_PLLPWD_SET(x)                                  (((x) << BB_PLL_CONFIG_PLLPWD_LSB) & BB_PLL_CONFIG_PLLPWD_MASK)
+#define BB_PLL_CONFIG_PLLPWD_RESET                                   1
+#define BB_PLL_CONFIG_SPARE_MSB                                      29
+#define BB_PLL_CONFIG_SPARE_LSB                                      29
+#define BB_PLL_CONFIG_SPARE_MASK                                     0x20000000
+#define BB_PLL_CONFIG_SPARE_GET(x)                                   (((x) & BB_PLL_CONFIG_SPARE_MASK) >> BB_PLL_CONFIG_SPARE_LSB)
+#define BB_PLL_CONFIG_SPARE_SET(x)                                   (((x) << BB_PLL_CONFIG_SPARE_LSB) & BB_PLL_CONFIG_SPARE_MASK)
+#define BB_PLL_CONFIG_SPARE_RESET                                    0
+#define BB_PLL_CONFIG_REFDIV_MSB                                     28
+#define BB_PLL_CONFIG_REFDIV_LSB                                     24
+#define BB_PLL_CONFIG_REFDIV_MASK                                    0x1f000000
+#define BB_PLL_CONFIG_REFDIV_GET(x)                                  (((x) & BB_PLL_CONFIG_REFDIV_MASK) >> BB_PLL_CONFIG_REFDIV_LSB)
+#define BB_PLL_CONFIG_REFDIV_SET(x)                                  (((x) << BB_PLL_CONFIG_REFDIV_LSB) & BB_PLL_CONFIG_REFDIV_MASK)
+#define BB_PLL_CONFIG_REFDIV_RESET                                   1
+#define BB_PLL_CONFIG_NINT_MSB                                       21
+#define BB_PLL_CONFIG_NINT_LSB                                       16
+#define BB_PLL_CONFIG_NINT_MASK                                      0x003f0000
+#define BB_PLL_CONFIG_NINT_GET(x)                                    (((x) & BB_PLL_CONFIG_NINT_MASK) >> BB_PLL_CONFIG_NINT_LSB)
+#define BB_PLL_CONFIG_NINT_SET(x)                                    (((x) << BB_PLL_CONFIG_NINT_LSB) & BB_PLL_CONFIG_NINT_MASK)
+#define BB_PLL_CONFIG_NINT_RESET                                     2
+#define BB_PLL_CONFIG_NFRAC_MSB                                      13
+#define BB_PLL_CONFIG_NFRAC_LSB                                      0
+#define BB_PLL_CONFIG_NFRAC_MASK                                     0x00003fff
+#define BB_PLL_CONFIG_NFRAC_GET(x)                                   (((x) & BB_PLL_CONFIG_NFRAC_MASK) >> BB_PLL_CONFIG_NFRAC_LSB)
+#define BB_PLL_CONFIG_NFRAC_SET(x)                                   (((x) << BB_PLL_CONFIG_NFRAC_LSB) & BB_PLL_CONFIG_NFRAC_MASK)
+#define BB_PLL_CONFIG_NFRAC_RESET                                    3276
+#define BB_PLL_CONFIG_ADDRESS                                        0x0040
+#define BB_PLL_CONFIG_OFFSET                                         0x0040
+// SW modifiable bits
+#define BB_PLL_CONFIG_SW_MASK                                        0xff3f3fff
+// bits defined at reset
+#define BB_PLL_CONFIG_RSTMASK                                        0xffffffff
+// reset value (ignore bits undefined at reset)
+#define BB_PLL_CONFIG_RESET                                          0xc1020ccc
+
+// 32'h0044 (DDR_PLL_DITHER)
+#define DDR_PLL_DITHER_DITHER_EN_MSB                                 31
+#define DDR_PLL_DITHER_DITHER_EN_LSB                                 31
+#define DDR_PLL_DITHER_DITHER_EN_MASK                                0x80000000
+#define DDR_PLL_DITHER_DITHER_EN_GET(x)                              (((x) & DDR_PLL_DITHER_DITHER_EN_MASK) >> DDR_PLL_DITHER_DITHER_EN_LSB)
+#define DDR_PLL_DITHER_DITHER_EN_SET(x)                              (((x) << DDR_PLL_DITHER_DITHER_EN_LSB) & DDR_PLL_DITHER_DITHER_EN_MASK)
+#define DDR_PLL_DITHER_DITHER_EN_RESET                               0
+#define DDR_PLL_DITHER_UPDATE_COUNT_MSB                              30
+#define DDR_PLL_DITHER_UPDATE_COUNT_LSB                              27
+#define DDR_PLL_DITHER_UPDATE_COUNT_MASK                             0x78000000
+#define DDR_PLL_DITHER_UPDATE_COUNT_GET(x)                           (((x) & DDR_PLL_DITHER_UPDATE_COUNT_MASK) >> DDR_PLL_DITHER_UPDATE_COUNT_LSB)
+#define DDR_PLL_DITHER_UPDATE_COUNT_SET(x)                           (((x) << DDR_PLL_DITHER_UPDATE_COUNT_LSB) & DDR_PLL_DITHER_UPDATE_COUNT_MASK)
+#define DDR_PLL_DITHER_UPDATE_COUNT_RESET                            15
+#define DDR_PLL_DITHER_NFRAC_STEP_MSB                                26
+#define DDR_PLL_DITHER_NFRAC_STEP_LSB                                20
+#define DDR_PLL_DITHER_NFRAC_STEP_MASK                               0x07f00000
+#define DDR_PLL_DITHER_NFRAC_STEP_GET(x)                             (((x) & DDR_PLL_DITHER_NFRAC_STEP_MASK) >> DDR_PLL_DITHER_NFRAC_STEP_LSB)
+#define DDR_PLL_DITHER_NFRAC_STEP_SET(x)                             (((x) << DDR_PLL_DITHER_NFRAC_STEP_LSB) & DDR_PLL_DITHER_NFRAC_STEP_MASK)
+#define DDR_PLL_DITHER_NFRAC_STEP_RESET                              1
+#define DDR_PLL_DITHER_NFRAC_MIN_MSB                                 19
+#define DDR_PLL_DITHER_NFRAC_MIN_LSB                                 10
+#define DDR_PLL_DITHER_NFRAC_MIN_MASK                                0x000ffc00
+#define DDR_PLL_DITHER_NFRAC_MIN_GET(x)                              (((x) & DDR_PLL_DITHER_NFRAC_MIN_MASK) >> DDR_PLL_DITHER_NFRAC_MIN_LSB)
+#define DDR_PLL_DITHER_NFRAC_MIN_SET(x)                              (((x) << DDR_PLL_DITHER_NFRAC_MIN_LSB) & DDR_PLL_DITHER_NFRAC_MIN_MASK)
+#define DDR_PLL_DITHER_NFRAC_MIN_RESET                               25
+#define DDR_PLL_DITHER_NFRAC_MAX_MSB                                 9
+#define DDR_PLL_DITHER_NFRAC_MAX_LSB                                 0
+#define DDR_PLL_DITHER_NFRAC_MAX_MASK                                0x000003ff
+#define DDR_PLL_DITHER_NFRAC_MAX_GET(x)                              (((x) & DDR_PLL_DITHER_NFRAC_MAX_MASK) >> DDR_PLL_DITHER_NFRAC_MAX_LSB)
+#define DDR_PLL_DITHER_NFRAC_MAX_SET(x)                              (((x) << DDR_PLL_DITHER_NFRAC_MAX_LSB) & DDR_PLL_DITHER_NFRAC_MAX_MASK)
+#define DDR_PLL_DITHER_NFRAC_MAX_RESET                               1000
+#define DDR_PLL_DITHER_ADDRESS                                       0x0044
+#define DDR_PLL_DITHER_OFFSET                                        0x0044
+// SW modifiable bits
+#define DDR_PLL_DITHER_SW_MASK                                       0xffffffff
+// bits defined at reset
+#define DDR_PLL_DITHER_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define DDR_PLL_DITHER_RESET                                         0x781067e8
+
+// 32'h0048 (CPU_PLL_DITHER)
+#define CPU_PLL_DITHER_DITHER_EN_MSB                                 31
+#define CPU_PLL_DITHER_DITHER_EN_LSB                                 31
+#define CPU_PLL_DITHER_DITHER_EN_MASK                                0x80000000
+#define CPU_PLL_DITHER_DITHER_EN_GET(x)                              (((x) & CPU_PLL_DITHER_DITHER_EN_MASK) >> CPU_PLL_DITHER_DITHER_EN_LSB)
+#define CPU_PLL_DITHER_DITHER_EN_SET(x)                              (((x) << CPU_PLL_DITHER_DITHER_EN_LSB) & CPU_PLL_DITHER_DITHER_EN_MASK)
+#define CPU_PLL_DITHER_DITHER_EN_RESET                               0
+#define CPU_PLL_DITHER_UPDATE_COUNT_MSB                              23
+#define CPU_PLL_DITHER_UPDATE_COUNT_LSB                              18
+#define CPU_PLL_DITHER_UPDATE_COUNT_MASK                             0x00fc0000
+#define CPU_PLL_DITHER_UPDATE_COUNT_GET(x)                           (((x) & CPU_PLL_DITHER_UPDATE_COUNT_MASK) >> CPU_PLL_DITHER_UPDATE_COUNT_LSB)
+#define CPU_PLL_DITHER_UPDATE_COUNT_SET(x)                           (((x) << CPU_PLL_DITHER_UPDATE_COUNT_LSB) & CPU_PLL_DITHER_UPDATE_COUNT_MASK)
+#define CPU_PLL_DITHER_UPDATE_COUNT_RESET                            20
+#define CPU_PLL_DITHER_NFRAC_STEP_MSB                                17
+#define CPU_PLL_DITHER_NFRAC_STEP_LSB                                12
+#define CPU_PLL_DITHER_NFRAC_STEP_MASK                               0x0003f000
+#define CPU_PLL_DITHER_NFRAC_STEP_GET(x)                             (((x) & CPU_PLL_DITHER_NFRAC_STEP_MASK) >> CPU_PLL_DITHER_NFRAC_STEP_LSB)
+#define CPU_PLL_DITHER_NFRAC_STEP_SET(x)                             (((x) << CPU_PLL_DITHER_NFRAC_STEP_LSB) & CPU_PLL_DITHER_NFRAC_STEP_MASK)
+#define CPU_PLL_DITHER_NFRAC_STEP_RESET                              1
+#define CPU_PLL_DITHER_NFRAC_MIN_MSB                                 11
+#define CPU_PLL_DITHER_NFRAC_MIN_LSB                                 6
+#define CPU_PLL_DITHER_NFRAC_MIN_MASK                                0x00000fc0
+#define CPU_PLL_DITHER_NFRAC_MIN_GET(x)                              (((x) & CPU_PLL_DITHER_NFRAC_MIN_MASK) >> CPU_PLL_DITHER_NFRAC_MIN_LSB)
+#define CPU_PLL_DITHER_NFRAC_MIN_SET(x)                              (((x) << CPU_PLL_DITHER_NFRAC_MIN_LSB) & CPU_PLL_DITHER_NFRAC_MIN_MASK)
+#define CPU_PLL_DITHER_NFRAC_MIN_RESET                               3
+#define CPU_PLL_DITHER_NFRAC_MAX_MSB                                 5
+#define CPU_PLL_DITHER_NFRAC_MAX_LSB                                 0
+#define CPU_PLL_DITHER_NFRAC_MAX_MASK                                0x0000003f
+#define CPU_PLL_DITHER_NFRAC_MAX_GET(x)                              (((x) & CPU_PLL_DITHER_NFRAC_MAX_MASK) >> CPU_PLL_DITHER_NFRAC_MAX_LSB)
+#define CPU_PLL_DITHER_NFRAC_MAX_SET(x)                              (((x) << CPU_PLL_DITHER_NFRAC_MAX_LSB) & CPU_PLL_DITHER_NFRAC_MAX_MASK)
+#define CPU_PLL_DITHER_NFRAC_MAX_RESET                               60
+#define CPU_PLL_DITHER_ADDRESS                                       0x0048
+#define CPU_PLL_DITHER_OFFSET                                        0x0048
+// SW modifiable bits
+#define CPU_PLL_DITHER_SW_MASK                                       0x80ffffff
+// bits defined at reset
+#define CPU_PLL_DITHER_RSTMASK                                       0xffffffff
+// reset value (ignore bits undefined at reset)
+#define CPU_PLL_DITHER_RESET                                         0x005010fc
+
+// 32'h1806001c (RST_RESET)
+#define RST_RESET_HOST_RESET_MSB                                     31
+#define RST_RESET_HOST_RESET_LSB                                     31
+#define RST_RESET_HOST_RESET_MASK                                    0x80000000
+#define RST_RESET_HOST_RESET_GET(x)                                  (((x) & RST_RESET_HOST_RESET_MASK) >> RST_RESET_HOST_RESET_LSB)
+#define RST_RESET_HOST_RESET_SET(x)                                  (((x) << RST_RESET_HOST_RESET_LSB) & RST_RESET_HOST_RESET_MASK)
+#define RST_RESET_HOST_RESET_RESET                                   0
+#define RST_RESET_SLIC_RESET_MSB                                     30
+#define RST_RESET_SLIC_RESET_LSB                                     30
+#define RST_RESET_SLIC_RESET_MASK                                    0x40000000
+#define RST_RESET_SLIC_RESET_GET(x)                                  (((x) & RST_RESET_SLIC_RESET_MASK) >> RST_RESET_SLIC_RESET_LSB)
+#define RST_RESET_SLIC_RESET_SET(x)                                  (((x) << RST_RESET_SLIC_RESET_LSB) & RST_RESET_SLIC_RESET_MASK)
+#define RST_RESET_SLIC_RESET_RESET                                   0
+#define RST_RESET_HDMA_RESET_MSB                                     29
+#define RST_RESET_HDMA_RESET_LSB                                     29
+#define RST_RESET_HDMA_RESET_MASK                                    0x20000000
+#define RST_RESET_HDMA_RESET_GET(x)                                  (((x) & RST_RESET_HDMA_RESET_MASK) >> RST_RESET_HDMA_RESET_LSB)
+#define RST_RESET_HDMA_RESET_SET(x)                                  (((x) << RST_RESET_HDMA_RESET_LSB) & RST_RESET_HDMA_RESET_MASK)
+#define RST_RESET_HDMA_RESET_RESET                                   1
+#define RST_RESET_EXTERNAL_RESET_MSB                                 28
+#define RST_RESET_EXTERNAL_RESET_LSB                                 28
+#define RST_RESET_EXTERNAL_RESET_MASK                                0x10000000
+#define RST_RESET_EXTERNAL_RESET_GET(x)                              (((x) & RST_RESET_EXTERNAL_RESET_MASK) >> RST_RESET_EXTERNAL_RESET_LSB)
+#define RST_RESET_EXTERNAL_RESET_SET(x)                              (((x) << RST_RESET_EXTERNAL_RESET_LSB) & RST_RESET_EXTERNAL_RESET_MASK)
+#define RST_RESET_EXTERNAL_RESET_RESET                               0
+#define RST_RESET_RTC_RESET_MSB                                      27
+#define RST_RESET_RTC_RESET_LSB                                      27
+#define RST_RESET_RTC_RESET_MASK                                     0x08000000
+#define RST_RESET_RTC_RESET_GET(x)                                   (((x) & RST_RESET_RTC_RESET_MASK) >> RST_RESET_RTC_RESET_LSB)
+#define RST_RESET_RTC_RESET_SET(x)                                   (((x) << RST_RESET_RTC_RESET_LSB) & RST_RESET_RTC_RESET_MASK)
+#define RST_RESET_RTC_RESET_RESET                                    1
+#define RST_RESET_PCIEEP_RST_INT_MSB                                 26
+#define RST_RESET_PCIEEP_RST_INT_LSB                                 26
+#define RST_RESET_PCIEEP_RST_INT_MASK                                0x04000000
+#define RST_RESET_PCIEEP_RST_INT_GET(x)                              (((x) & RST_RESET_PCIEEP_RST_INT_MASK) >> RST_RESET_PCIEEP_RST_INT_LSB)
+#define RST_RESET_PCIEEP_RST_INT_SET(x)                              (((x) << RST_RESET_PCIEEP_RST_INT_LSB) & RST_RESET_PCIEEP_RST_INT_MASK)
+#define RST_RESET_PCIEEP_RST_INT_RESET                               0
+#define RST_RESET_CHKSUM_ACC_RESET_MSB                               25
+#define RST_RESET_CHKSUM_ACC_RESET_LSB                               25
+#define RST_RESET_CHKSUM_ACC_RESET_MASK                              0x02000000
+#define RST_RESET_CHKSUM_ACC_RESET_GET(x)                            (((x) & RST_RESET_CHKSUM_ACC_RESET_MASK) >> RST_RESET_CHKSUM_ACC_RESET_LSB)
+#define RST_RESET_CHKSUM_ACC_RESET_SET(x)                            (((x) << RST_RESET_CHKSUM_ACC_RESET_LSB) & RST_RESET_CHKSUM_ACC_RESET_MASK)
+#define RST_RESET_CHKSUM_ACC_RESET_RESET                             0
+#define RST_RESET_FULL_CHIP_RESET_MSB                                24
+#define RST_RESET_FULL_CHIP_RESET_LSB                                24
+#define RST_RESET_FULL_CHIP_RESET_MASK                               0x01000000
+#define RST_RESET_FULL_CHIP_RESET_GET(x)                             (((x) & RST_RESET_FULL_CHIP_RESET_MASK) >> RST_RESET_FULL_CHIP_RESET_LSB)
+#define RST_RESET_FULL_CHIP_RESET_SET(x)                             (((x) << RST_RESET_FULL_CHIP_RESET_LSB) & RST_RESET_FULL_CHIP_RESET_MASK)
+#define RST_RESET_FULL_CHIP_RESET_RESET                              0
+#define RST_RESET_GE1_MDIO_RESET_MSB                                 23
+#define RST_RESET_GE1_MDIO_RESET_LSB                                 23
+#define RST_RESET_GE1_MDIO_RESET_MASK                                0x00800000
+#define RST_RESET_GE1_MDIO_RESET_GET(x)                              (((x) & RST_RESET_GE1_MDIO_RESET_MASK) >> RST_RESET_GE1_MDIO_RESET_LSB)
+#define RST_RESET_GE1_MDIO_RESET_SET(x)                              (((x) << RST_RESET_GE1_MDIO_RESET_LSB) & RST_RESET_GE1_MDIO_RESET_MASK)
+#define RST_RESET_GE1_MDIO_RESET_RESET                               1
+#define RST_RESET_GE0_MDIO_RESET_MSB                                 22
+#define RST_RESET_GE0_MDIO_RESET_LSB                                 22
+#define RST_RESET_GE0_MDIO_RESET_MASK                                0x00400000
+#define RST_RESET_GE0_MDIO_RESET_GET(x)                              (((x) & RST_RESET_GE0_MDIO_RESET_MASK) >> RST_RESET_GE0_MDIO_RESET_LSB)
+#define RST_RESET_GE0_MDIO_RESET_SET(x)                              (((x) << RST_RESET_GE0_MDIO_RESET_LSB) & RST_RESET_GE0_MDIO_RESET_MASK)
+#define RST_RESET_GE0_MDIO_RESET_RESET                               1
+#define RST_RESET_CPU_NMI_MSB                                        21
+#define RST_RESET_CPU_NMI_LSB                                        21
+#define RST_RESET_CPU_NMI_MASK                                       0x00200000
+#define RST_RESET_CPU_NMI_GET(x)                                     (((x) & RST_RESET_CPU_NMI_MASK) >> RST_RESET_CPU_NMI_LSB)
+#define RST_RESET_CPU_NMI_SET(x)                                     (((x) << RST_RESET_CPU_NMI_LSB) & RST_RESET_CPU_NMI_MASK)
+#define RST_RESET_CPU_NMI_RESET                                      0
+#define RST_RESET_CPU_COLD_RESET_MSB                                 20
+#define RST_RESET_CPU_COLD_RESET_LSB                                 20
+#define RST_RESET_CPU_COLD_RESET_MASK                                0x00100000
+#define RST_RESET_CPU_COLD_RESET_GET(x)                              (((x) & RST_RESET_CPU_COLD_RESET_MASK) >> RST_RESET_CPU_COLD_RESET_LSB)
+#define RST_RESET_CPU_COLD_RESET_SET(x)                              (((x) << RST_RESET_CPU_COLD_RESET_LSB) & RST_RESET_CPU_COLD_RESET_MASK)
+#define RST_RESET_CPU_COLD_RESET_RESET                               0
+#define RST_RESET_HOST_RESET_INT_MSB                                 19
+#define RST_RESET_HOST_RESET_INT_LSB                                 19
+#define RST_RESET_HOST_RESET_INT_MASK                                0x00080000
+#define RST_RESET_HOST_RESET_INT_GET(x)                              (((x) & RST_RESET_HOST_RESET_INT_MASK) >> RST_RESET_HOST_RESET_INT_LSB)
+#define RST_RESET_HOST_RESET_INT_SET(x)                              (((x) << RST_RESET_HOST_RESET_INT_LSB) & RST_RESET_HOST_RESET_INT_MASK)
+#define RST_RESET_HOST_RESET_INT_RESET                               0
+#define RST_RESET_PCIEEP_RESET_MSB                                   18
+#define RST_RESET_PCIEEP_RESET_LSB                                   18
+#define RST_RESET_PCIEEP_RESET_MASK                                  0x00040000
+#define RST_RESET_PCIEEP_RESET_GET(x)                                (((x) & RST_RESET_PCIEEP_RESET_MASK) >> RST_RESET_PCIEEP_RESET_LSB)
+#define RST_RESET_PCIEEP_RESET_SET(x)                                (((x) << RST_RESET_PCIEEP_RESET_LSB) & RST_RESET_PCIEEP_RESET_MASK)
+#define RST_RESET_PCIEEP_RESET_RESET                                 0
+#define RST_RESET_UART1_RESET_MSB                                    17
+#define RST_RESET_UART1_RESET_LSB                                    17
+#define RST_RESET_UART1_RESET_MASK                                   0x00020000
+#define RST_RESET_UART1_RESET_GET(x)                                 (((x) & RST_RESET_UART1_RESET_MASK) >> RST_RESET_UART1_RESET_LSB)
+#define RST_RESET_UART1_RESET_SET(x)                                 (((x) << RST_RESET_UART1_RESET_LSB) & RST_RESET_UART1_RESET_MASK)
+#define RST_RESET_UART1_RESET_RESET                                  0
+#define RST_RESET_DDR_RESET_MSB                                      16
+#define RST_RESET_DDR_RESET_LSB                                      16
+#define RST_RESET_DDR_RESET_MASK                                     0x00010000
+#define RST_RESET_DDR_RESET_GET(x)                                   (((x) & RST_RESET_DDR_RESET_MASK) >> RST_RESET_DDR_RESET_LSB)
+#define RST_RESET_DDR_RESET_SET(x)                                   (((x) << RST_RESET_DDR_RESET_LSB) & RST_RESET_DDR_RESET_MASK)
+#define RST_RESET_DDR_RESET_RESET                                    0
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_MSB                            15
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_LSB                            15
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_MASK                           0x00008000
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_GET(x)                         (((x) & RST_RESET_USB_PHY_PLL_PWD_EXT_MASK) >> RST_RESET_USB_PHY_PLL_PWD_EXT_LSB)
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_SET(x)                         (((x) << RST_RESET_USB_PHY_PLL_PWD_EXT_LSB) & RST_RESET_USB_PHY_PLL_PWD_EXT_MASK)
+#define RST_RESET_USB_PHY_PLL_PWD_EXT_RESET                          0
+#define RST_RESET_NANDF_RESET_MSB                                    14
+#define RST_RESET_NANDF_RESET_LSB                                    14
+#define RST_RESET_NANDF_RESET_MASK                                   0x00004000
+#define RST_RESET_NANDF_RESET_GET(x)                                 (((x) & RST_RESET_NANDF_RESET_MASK) >> RST_RESET_NANDF_RESET_LSB)
+#define RST_RESET_NANDF_RESET_SET(x)                                 (((x) << RST_RESET_NANDF_RESET_LSB) & RST_RESET_NANDF_RESET_MASK)
+#define RST_RESET_NANDF_RESET_RESET                                  1
+#define RST_RESET_GE1_MAC_RESET_MSB                                  13
+#define RST_RESET_GE1_MAC_RESET_LSB                                  13
+#define RST_RESET_GE1_MAC_RESET_MASK                                 0x00002000
+#define RST_RESET_GE1_MAC_RESET_GET(x)                               (((x) & RST_RESET_GE1_MAC_RESET_MASK) >> RST_RESET_GE1_MAC_RESET_LSB)
+#define RST_RESET_GE1_MAC_RESET_SET(x)                               (((x) << RST_RESET_GE1_MAC_RESET_LSB) & RST_RESET_GE1_MAC_RESET_MASK)
+#define RST_RESET_GE1_MAC_RESET_RESET                                1
+#define RST_RESET_ETH_SWITCH_ARESET_MSB                              12
+#define RST_RESET_ETH_SWITCH_ARESET_LSB                              12
+#define RST_RESET_ETH_SWITCH_ARESET_MASK                             0x00001000
+#define RST_RESET_ETH_SWITCH_ARESET_GET(x)                           (((x) & RST_RESET_ETH_SWITCH_ARESET_MASK) >> RST_RESET_ETH_SWITCH_ARESET_LSB)
+#define RST_RESET_ETH_SWITCH_ARESET_SET(x)                           (((x) << RST_RESET_ETH_SWITCH_ARESET_LSB) & RST_RESET_ETH_SWITCH_ARESET_MASK)
+#define RST_RESET_ETH_SWITCH_ARESET_RESET                            1
+#define RST_RESET_USB_PHY_ARESET_MSB                                 11
+#define RST_RESET_USB_PHY_ARESET_LSB                                 11
+#define RST_RESET_USB_PHY_ARESET_MASK                                0x00000800
+#define RST_RESET_USB_PHY_ARESET_GET(x)                              (((x) & RST_RESET_USB_PHY_ARESET_MASK) >> RST_RESET_USB_PHY_ARESET_LSB)
+#define RST_RESET_USB_PHY_ARESET_SET(x)                              (((x) << RST_RESET_USB_PHY_ARESET_LSB) & RST_RESET_USB_PHY_ARESET_MASK)
+#define RST_RESET_USB_PHY_ARESET_RESET                               1
+#define RST_RESET_RESERVED_MSB                                       10
+#define RST_RESET_RESERVED_LSB                                       10
+#define RST_RESET_RESERVED_MASK                                      0x00000400
+#define RST_RESET_RESERVED_GET(x)                                    (((x) & RST_RESET_RESERVED_MASK) >> RST_RESET_RESERVED_LSB)
+#define RST_RESET_RESERVED_SET(x)                                    (((x) << RST_RESET_RESERVED_LSB) & RST_RESET_RESERVED_MASK)
+#define RST_RESET_RESERVED_RESET                                     1
+#define RST_RESET_GE0_MAC_RESET_MSB                                  9
+#define RST_RESET_GE0_MAC_RESET_LSB                                  9
+#define RST_RESET_GE0_MAC_RESET_MASK                                 0x00000200
+#define RST_RESET_GE0_MAC_RESET_GET(x)                               (((x) & RST_RESET_GE0_MAC_RESET_MASK) >> RST_RESET_GE0_MAC_RESET_LSB)
+#define RST_RESET_GE0_MAC_RESET_SET(x)                               (((x) << RST_RESET_GE0_MAC_RESET_LSB) & RST_RESET_GE0_MAC_RESET_MASK)
+#define RST_RESET_GE0_MAC_RESET_RESET                                1
+#define RST_RESET_ETH_SWITCH_RESET_MSB                               8
+#define RST_RESET_ETH_SWITCH_RESET_LSB                               8
+#define RST_RESET_ETH_SWITCH_RESET_MASK                              0x00000100
+#define RST_RESET_ETH_SWITCH_RESET_GET(x)                            (((x) & RST_RESET_ETH_SWITCH_RESET_MASK) >> RST_RESET_ETH_SWITCH_RESET_LSB)
+#define RST_RESET_ETH_SWITCH_RESET_SET(x)                            (((x) << RST_RESET_ETH_SWITCH_RESET_LSB) & RST_RESET_ETH_SWITCH_RESET_MASK)
+#define RST_RESET_ETH_SWITCH_RESET_RESET                             1
+#define RST_RESET_PCIE_PHY_RESET_MSB                                 7
+#define RST_RESET_PCIE_PHY_RESET_LSB                                 7
+#define RST_RESET_PCIE_PHY_RESET_MASK                                0x00000080
+#define RST_RESET_PCIE_PHY_RESET_GET(x)                              (((x) & RST_RESET_PCIE_PHY_RESET_MASK) >> RST_RESET_PCIE_PHY_RESET_LSB)
+#define RST_RESET_PCIE_PHY_RESET_SET(x)                              (((x) << RST_RESET_PCIE_PHY_RESET_LSB) & RST_RESET_PCIE_PHY_RESET_MASK)
+#define RST_RESET_PCIE_PHY_RESET_RESET                               1
+#define RST_RESET_PCIE_RESET_MSB                                     6
+#define RST_RESET_PCIE_RESET_LSB                                     6
+#define RST_RESET_PCIE_RESET_MASK                                    0x00000040
+#define RST_RESET_PCIE_RESET_GET(x)                                  (((x) & RST_RESET_PCIE_RESET_MASK) >> RST_RESET_PCIE_RESET_LSB)
+#define RST_RESET_PCIE_RESET_SET(x)                                  (((x) << RST_RESET_PCIE_RESET_LSB) & RST_RESET_PCIE_RESET_MASK)
+#define RST_RESET_PCIE_RESET_RESET                                   1
+#define RST_RESET_USB_HOST_RESET_MSB                                 5
+#define RST_RESET_USB_HOST_RESET_LSB                                 5
+#define RST_RESET_USB_HOST_RESET_MASK                                0x00000020
+#define RST_RESET_USB_HOST_RESET_GET(x)                              (((x) & RST_RESET_USB_HOST_RESET_MASK) >> RST_RESET_USB_HOST_RESET_LSB)
+#define RST_RESET_USB_HOST_RESET_SET(x)                              (((x) << RST_RESET_USB_HOST_RESET_LSB) & RST_RESET_USB_HOST_RESET_MASK)
+#define RST_RESET_USB_HOST_RESET_RESET                               1
+#define RST_RESET_USB_PHY_RESET_MSB                                  4
+#define RST_RESET_USB_PHY_RESET_LSB                                  4
+#define RST_RESET_USB_PHY_RESET_MASK                                 0x00000010
+#define RST_RESET_USB_PHY_RESET_GET(x)                               (((x) & RST_RESET_USB_PHY_RESET_MASK) >> RST_RESET_USB_PHY_RESET_LSB)
+#define RST_RESET_USB_PHY_RESET_SET(x)                               (((x) << RST_RESET_USB_PHY_RESET_LSB) & RST_RESET_USB_PHY_RESET_MASK)
+#define RST_RESET_USB_PHY_RESET_RESET                                1
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MSB                       3
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB                       3
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK                      0x00000008
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_GET(x)                    (((x) & RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK) >> RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB)
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(x)                    (((x) << RST_RESET_USB_PHY_SUSPEND_OVERRIDE_LSB) & RST_RESET_USB_PHY_SUSPEND_OVERRIDE_MASK)
+#define RST_RESET_USB_PHY_SUSPEND_OVERRIDE_RESET                     0
+#define RST_RESET_LUT_RESET_MSB                                      2
+#define RST_RESET_LUT_RESET_LSB                                      2
+#define RST_RESET_LUT_RESET_MASK                                     0x00000004
+#define RST_RESET_LUT_RESET_GET(x)                                   (((x) & RST_RESET_LUT_RESET_MASK) >> RST_RESET_LUT_RESET_LSB)
+#define RST_RESET_LUT_RESET_SET(x)                                   (((x) << RST_RESET_LUT_RESET_LSB) & RST_RESET_LUT_RESET_MASK)
+#define RST_RESET_LUT_RESET_RESET                                    0
+#define RST_RESET_MBOX_RESET_MSB                                     1
+#define RST_RESET_MBOX_RESET_LSB                                     1
+#define RST_RESET_MBOX_RESET_MASK                                    0x00000002
+#define RST_RESET_MBOX_RESET_GET(x)                                  (((x) & RST_RESET_MBOX_RESET_MASK) >> RST_RESET_MBOX_RESET_LSB)
+#define RST_RESET_MBOX_RESET_SET(x)                                  (((x) << RST_RESET_MBOX_RESET_LSB) & RST_RESET_MBOX_RESET_MASK)
+#define RST_RESET_MBOX_RESET_RESET                                   0
+#define RST_RESET_I2S_RESET_MSB                                      0
+#define RST_RESET_I2S_RESET_LSB                                      0
+#define RST_RESET_I2S_RESET_MASK                                     0x00000001
+#define RST_RESET_I2S_RESET_GET(x)                                   (((x) & RST_RESET_I2S_RESET_MASK) >> RST_RESET_I2S_RESET_LSB)
+#define RST_RESET_I2S_RESET_SET(x)                                   (((x) << RST_RESET_I2S_RESET_LSB) & RST_RESET_I2S_RESET_MASK)
+#define RST_RESET_I2S_RESET_RESET                                    0
+#define RST_RESET_ADDRESS                                            0x1806001c
+#define RST_RESET_OFFSET                                             0x001c
+// SW modifiable bits
+#define RST_RESET_SW_MASK                                            0xffffffff
+// bits defined at reset
+#define RST_RESET_RSTMASK                                            0xffffffff
+// reset value (ignore bits undefined at reset)
+#define RST_RESET_RESET                                              0x28c07ff0
+
+#define RST_MISC2_SPARE_MSB                                          31
+#define RST_MISC2_SPARE_LSB                                          26
+#define RST_MISC2_SPARE_MASK                                         0xfc000000
+#define RST_MISC2_SPARE_GET(x)                                       (((x) & RST_MISC2_SPARE_MASK) >> RST_MISC2_SPARE_LSB)
+#define RST_MISC2_SPARE_SET(x)                                       (((x) << RST_MISC2_SPARE_LSB) & RST_MISC2_SPARE_MASK)
+#define RST_MISC2_SPARE_RESET                                        0x0 // 0
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_MSB                             25
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_LSB                             25
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_MASK                            0x02000000
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L2_EXIT_INT_MASK) >> RST_MISC2_PCIEEP_L2_EXIT_INT_LSB)
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L2_EXIT_INT_LSB) & RST_MISC2_PCIEEP_L2_EXIT_INT_MASK)
+#define RST_MISC2_PCIEEP_L2_EXIT_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_MSB                             24
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_LSB                             24
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_MASK                            0x01000000
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L2_ENTR_INT_MASK) >> RST_MISC2_PCIEEP_L2_ENTR_INT_LSB)
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L2_ENTR_INT_LSB) & RST_MISC2_PCIEEP_L2_ENTR_INT_MASK)
+#define RST_MISC2_PCIEEP_L2_ENTR_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_MSB                             23
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_LSB                             23
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_MASK                            0x00800000
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L1_EXIT_INT_MASK) >> RST_MISC2_PCIEEP_L1_EXIT_INT_LSB)
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L1_EXIT_INT_LSB) & RST_MISC2_PCIEEP_L1_EXIT_INT_MASK)
+#define RST_MISC2_PCIEEP_L1_EXIT_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_MSB                             22
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_LSB                             22
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_MASK                            0x00400000
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_GET(x)                          (((x) & RST_MISC2_PCIEEP_L1_ENTR_INT_MASK) >> RST_MISC2_PCIEEP_L1_ENTR_INT_LSB)
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_SET(x)                          (((x) << RST_MISC2_PCIEEP_L1_ENTR_INT_LSB) & RST_MISC2_PCIEEP_L1_ENTR_INT_MASK)
+#define RST_MISC2_PCIEEP_L1_ENTR_INT_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_MSB                            21
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_LSB                            21
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_MASK                           0x00200000
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_GET(x)                         (((x) & RST_MISC2_PCIEEP_L0S_EXIT_INT_MASK) >> RST_MISC2_PCIEEP_L0S_EXIT_INT_LSB)
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_SET(x)                         (((x) << RST_MISC2_PCIEEP_L0S_EXIT_INT_LSB) & RST_MISC2_PCIEEP_L0S_EXIT_INT_MASK)
+#define RST_MISC2_PCIEEP_L0S_EXIT_INT_RESET                          0x0 // 0
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_MSB                            20
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_LSB                            20
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_MASK                           0x00100000
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_GET(x)                         (((x) & RST_MISC2_PCIEEP_L0S_ENTR_INT_MASK) >> RST_MISC2_PCIEEP_L0S_ENTR_INT_LSB)
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_SET(x)                         (((x) << RST_MISC2_PCIEEP_L0S_ENTR_INT_LSB) & RST_MISC2_PCIEEP_L0S_ENTR_INT_MASK)
+#define RST_MISC2_PCIEEP_L0S_ENTR_INT_RESET                          0x0 // 0
+#define RST_MISC2_PCIEEP_REGWR_EN_MSB                                19
+#define RST_MISC2_PCIEEP_REGWR_EN_LSB                                19
+#define RST_MISC2_PCIEEP_REGWR_EN_MASK                               0x00080000
+#define RST_MISC2_PCIEEP_REGWR_EN_GET(x)                             (((x) & RST_MISC2_PCIEEP_REGWR_EN_MASK) >> RST_MISC2_PCIEEP_REGWR_EN_LSB)
+#define RST_MISC2_PCIEEP_REGWR_EN_SET(x)                             (((x) << RST_MISC2_PCIEEP_REGWR_EN_LSB) & RST_MISC2_PCIEEP_REGWR_EN_MASK)
+#define RST_MISC2_PCIEEP_REGWR_EN_RESET                              0x1 // 1
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_MSB                           18
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_LSB                           18
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_MASK                          0x00040000
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_GET(x)                        (((x) & RST_MISC2_EXT_HOST_WASP_RST_EN_MASK) >> RST_MISC2_EXT_HOST_WASP_RST_EN_LSB)
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_SET(x)                        (((x) << RST_MISC2_EXT_HOST_WASP_RST_EN_LSB) & RST_MISC2_EXT_HOST_WASP_RST_EN_MASK)
+#define RST_MISC2_EXT_HOST_WASP_RST_EN_RESET                         0x0 // 0
+#define RST_MISC2_PCIEEP_RST_INT_MASK_MSB                            17
+#define RST_MISC2_PCIEEP_RST_INT_MASK_LSB                            17
+#define RST_MISC2_PCIEEP_RST_INT_MASK_MASK                           0x00020000
+#define RST_MISC2_PCIEEP_RST_INT_MASK_GET(x)                         (((x) & RST_MISC2_PCIEEP_RST_INT_MASK_MASK) >> RST_MISC2_PCIEEP_RST_INT_MASK_LSB)
+#define RST_MISC2_PCIEEP_RST_INT_MASK_SET(x)                         (((x) << RST_MISC2_PCIEEP_RST_INT_MASK_LSB) & RST_MISC2_PCIEEP_RST_INT_MASK_MASK)
+#define RST_MISC2_PCIEEP_RST_INT_MASK_RESET                          0x0 // 0
+#define RST_MISC2_HOST_RESET_INT_MASK_MSB                            16
+#define RST_MISC2_HOST_RESET_INT_MASK_LSB                            16
+#define RST_MISC2_HOST_RESET_INT_MASK_MASK                           0x00010000
+#define RST_MISC2_HOST_RESET_INT_MASK_GET(x)                         (((x) & RST_MISC2_HOST_RESET_INT_MASK_MASK) >> RST_MISC2_HOST_RESET_INT_MASK_LSB)
+#define RST_MISC2_HOST_RESET_INT_MASK_SET(x)                         (((x) << RST_MISC2_HOST_RESET_INT_MASK_LSB) & RST_MISC2_HOST_RESET_INT_MASK_MASK)
+#define RST_MISC2_HOST_RESET_INT_MASK_RESET                          0x0 // 0
+#define RST_MISC2_CPU_HOST_WA_MSB                                    15
+#define RST_MISC2_CPU_HOST_WA_LSB                                    15
+#define RST_MISC2_CPU_HOST_WA_MASK                                   0x00008000
+#define RST_MISC2_CPU_HOST_WA_GET(x)                                 (((x) & RST_MISC2_CPU_HOST_WA_MASK) >> RST_MISC2_CPU_HOST_WA_LSB)
+#define RST_MISC2_CPU_HOST_WA_SET(x)                                 (((x) << RST_MISC2_CPU_HOST_WA_LSB) & RST_MISC2_CPU_HOST_WA_MASK)
+#define RST_MISC2_CPU_HOST_WA_RESET                                  0x0 // 0
+#define RST_MISC2_PERSTN_EPPHY_MSB                                   14
+#define RST_MISC2_PERSTN_EPPHY_LSB                                   14
+#define RST_MISC2_PERSTN_EPPHY_MASK                                  0x00004000
+#define RST_MISC2_PERSTN_EPPHY_GET(x)                                (((x) & RST_MISC2_PERSTN_EPPHY_MASK) >> RST_MISC2_PERSTN_EPPHY_LSB)
+#define RST_MISC2_PERSTN_EPPHY_SET(x)                                (((x) << RST_MISC2_PERSTN_EPPHY_LSB) & RST_MISC2_PERSTN_EPPHY_MASK)
+#define RST_MISC2_PERSTN_EPPHY_RESET                                 0x1 // 1
+#define RST_MISC2_PERSTN_RCPHY_MSB                                   13
+#define RST_MISC2_PERSTN_RCPHY_LSB                                   13
+#define RST_MISC2_PERSTN_RCPHY_MASK                                  0x00002000
+#define RST_MISC2_PERSTN_RCPHY_GET(x)                                (((x) & RST_MISC2_PERSTN_RCPHY_MASK) >> RST_MISC2_PERSTN_RCPHY_LSB)
+#define RST_MISC2_PERSTN_RCPHY_SET(x)                                (((x) << RST_MISC2_PERSTN_RCPHY_LSB) & RST_MISC2_PERSTN_RCPHY_MASK)
+#define RST_MISC2_PERSTN_RCPHY_RESET                                 0x1 // 1
+#define RST_MISC2_PCIEEP_LTSSM_STATE_MSB                             12
+#define RST_MISC2_PCIEEP_LTSSM_STATE_LSB                             8
+#define RST_MISC2_PCIEEP_LTSSM_STATE_MASK                            0x00001f00
+#define RST_MISC2_PCIEEP_LTSSM_STATE_GET(x)                          (((x) & RST_MISC2_PCIEEP_LTSSM_STATE_MASK) >> RST_MISC2_PCIEEP_LTSSM_STATE_LSB)
+#define RST_MISC2_PCIEEP_LTSSM_STATE_SET(x)                          (((x) << RST_MISC2_PCIEEP_LTSSM_STATE_LSB) & RST_MISC2_PCIEEP_LTSSM_STATE_MASK)
+#define RST_MISC2_PCIEEP_LTSSM_STATE_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L2_INT_MASK_MSB                             7
+#define RST_MISC2_PCIEEP_L2_INT_MASK_LSB                             7
+#define RST_MISC2_PCIEEP_L2_INT_MASK_MASK                            0x00000080
+#define RST_MISC2_PCIEEP_L2_INT_MASK_GET(x)                          (((x) & RST_MISC2_PCIEEP_L2_INT_MASK_MASK) >> RST_MISC2_PCIEEP_L2_INT_MASK_LSB)
+#define RST_MISC2_PCIEEP_L2_INT_MASK_SET(x)                          (((x) << RST_MISC2_PCIEEP_L2_INT_MASK_LSB) & RST_MISC2_PCIEEP_L2_INT_MASK_MASK)
+#define RST_MISC2_PCIEEP_L2_INT_MASK_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L1_INT_MASK_MSB                             6
+#define RST_MISC2_PCIEEP_L1_INT_MASK_LSB                             6
+#define RST_MISC2_PCIEEP_L1_INT_MASK_MASK                            0x00000040
+#define RST_MISC2_PCIEEP_L1_INT_MASK_GET(x)                          (((x) & RST_MISC2_PCIEEP_L1_INT_MASK_MASK) >> RST_MISC2_PCIEEP_L1_INT_MASK_LSB)
+#define RST_MISC2_PCIEEP_L1_INT_MASK_SET(x)                          (((x) << RST_MISC2_PCIEEP_L1_INT_MASK_LSB) & RST_MISC2_PCIEEP_L1_INT_MASK_MASK)
+#define RST_MISC2_PCIEEP_L1_INT_MASK_RESET                           0x0 // 0
+#define RST_MISC2_PCIEEP_L0S_INT_MASK_MSB                            5
+#define RST_MISC2_PCIEEP_L0S_INT_MASK_LSB                            5
+#define RST_MISC2_PCIEEP_L0S_INT_MASK_MASK                           0x00000020
+#define RST_MISC2_PCIEEP_L0S_INT_MASK_GET(x)                         (((x) & RST_MISC2_PCIEEP_L0S_INT_MASK_MASK) >> RST_MISC2_PCIEEP_L0S_INT_MASK_LSB)
+#define RST_MISC2_PCIEEP_L0S_INT_MASK_SET(x)                         (((x) << RST_MISC2_PCIEEP_L0S_INT_MASK_LSB) & RST_MISC2_PCIEEP_L0S_INT_MASK_MASK)
+#define RST_MISC2_PCIEEP_L0S_INT_MASK_RESET                          0x0 // 0
+#define RST_MISC2_PCIEEP_LINK_STATUS_MSB                             4
+#define RST_MISC2_PCIEEP_LINK_STATUS_LSB                             4
+#define RST_MISC2_PCIEEP_LINK_STATUS_MASK                            0x00000010
+#define RST_MISC2_PCIEEP_LINK_STATUS_GET(x)                          (((x) & RST_MISC2_PCIEEP_LINK_STATUS_MASK) >> RST_MISC2_PCIEEP_LINK_STATUS_LSB)
+#define RST_MISC2_PCIEEP_LINK_STATUS_SET(x)                          (((x) << RST_MISC2_PCIEEP_LINK_STATUS_LSB) & RST_MISC2_PCIEEP_LINK_STATUS_MASK)
+#define RST_MISC2_PCIEEP_LINK_STATUS_RESET                           0x0 // 0
+#define RST_MISC2_RESERVED_MSB                                       3
+#define RST_MISC2_RESERVED_LSB                                       1
+#define RST_MISC2_RESERVED_MASK                                      0x0000000e
+#define RST_MISC2_RESERVED_GET(x)                                    (((x) & RST_MISC2_RESERVED_MASK) >> RST_MISC2_RESERVED_LSB)
+#define RST_MISC2_RESERVED_SET(x)                                    (((x) << RST_MISC2_RESERVED_LSB) & RST_MISC2_RESERVED_MASK)
+#define RST_MISC2_RESERVED_RESET                                     0x0 // 0
+#define RST_MISC2_PCIEEP_CFG_DONE_MSB                                0
+#define RST_MISC2_PCIEEP_CFG_DONE_LSB                                0
+#define RST_MISC2_PCIEEP_CFG_DONE_MASK                               0x00000001
+#define RST_MISC2_PCIEEP_CFG_DONE_GET(x)                             (((x) & RST_MISC2_PCIEEP_CFG_DONE_MASK) >> RST_MISC2_PCIEEP_CFG_DONE_LSB)
+#define RST_MISC2_PCIEEP_CFG_DONE_SET(x)                             (((x) << RST_MISC2_PCIEEP_CFG_DONE_LSB) & RST_MISC2_PCIEEP_CFG_DONE_MASK)
+#define RST_MISC2_PCIEEP_CFG_DONE_RESET                              0x0 // 0
+#define RST_MISC2_ADDRESS                                            0x180600bc
+
+#define DDR_CONFIG_CAS_LATENCY_MSB_MSB                               31
+#define DDR_CONFIG_CAS_LATENCY_MSB_LSB                               31
+#define DDR_CONFIG_CAS_LATENCY_MSB_MASK                              0x80000000
+#define DDR_CONFIG_CAS_LATENCY_MSB_GET(x)                            (((x) & DDR_CONFIG_CAS_LATENCY_MSB_MASK) >> DDR_CONFIG_CAS_LATENCY_MSB_LSB)
+#define DDR_CONFIG_CAS_LATENCY_MSB_SET(x)                            (((x) << DDR_CONFIG_CAS_LATENCY_MSB_LSB) & DDR_CONFIG_CAS_LATENCY_MSB_MASK)
+//#define DDR_CONFIG_CAS_LATENCY_MSB_RESET                             1'd0
+#define DDR_CONFIG_OPEN_PAGE_MSB                                     30
+#define DDR_CONFIG_OPEN_PAGE_LSB                                     30
+#define DDR_CONFIG_OPEN_PAGE_MASK                                    0x40000000
+#define DDR_CONFIG_OPEN_PAGE_GET(x)                                  (((x) & DDR_CONFIG_OPEN_PAGE_MASK) >> DDR_CONFIG_OPEN_PAGE_LSB)
+#define DDR_CONFIG_OPEN_PAGE_SET(x)                                  (((x) << DDR_CONFIG_OPEN_PAGE_LSB) & DDR_CONFIG_OPEN_PAGE_MASK)
+//#define DDR_CONFIG_OPEN_PAGE_RESET                                   1'd1
+#define DDR_CONFIG_CAS_LATENCY_MSB                                   29
+#define DDR_CONFIG_CAS_LATENCY_LSB                                   27
+#define DDR_CONFIG_CAS_LATENCY_MASK                                  0x38000000
+#define DDR_CONFIG_CAS_LATENCY_GET(x)                                (((x) & DDR_CONFIG_CAS_LATENCY_MASK) >> DDR_CONFIG_CAS_LATENCY_LSB)
+#define DDR_CONFIG_CAS_LATENCY_SET(x)                                (((x) << DDR_CONFIG_CAS_LATENCY_LSB) & DDR_CONFIG_CAS_LATENCY_MASK)
+//#define DDR_CONFIG_CAS_LATENCY_RESET                                 3'd6
+#define DDR_CONFIG_TMRD_MSB                                          26
+#define DDR_CONFIG_TMRD_LSB                                          23
+#define DDR_CONFIG_TMRD_MASK                                         0x07800000
+#define DDR_CONFIG_TMRD_GET(x)                                       (((x) & DDR_CONFIG_TMRD_MASK) >> DDR_CONFIG_TMRD_LSB)
+#define DDR_CONFIG_TMRD_SET(x)                                       (((x) << DDR_CONFIG_TMRD_LSB) & DDR_CONFIG_TMRD_MASK)
+//#define DDR_CONFIG_TMRD_RESET                                        4'd15
+#define DDR_CONFIG_TRFC_MSB                                          22
+#define DDR_CONFIG_TRFC_LSB                                          17
+#define DDR_CONFIG_TRFC_MASK                                         0x007e0000
+#define DDR_CONFIG_TRFC_GET(x)                                       (((x) & DDR_CONFIG_TRFC_MASK) >> DDR_CONFIG_TRFC_LSB)
+#define DDR_CONFIG_TRFC_SET(x)                                       (((x) << DDR_CONFIG_TRFC_LSB) & DDR_CONFIG_TRFC_MASK)
+//#define DDR_CONFIG_TRFC_RESET                                        6'd31
+#define DDR_CONFIG_TRRD_MSB                                          16
+#define DDR_CONFIG_TRRD_LSB                                          13
+#define DDR_CONFIG_TRRD_MASK                                         0x0001e000
+#define DDR_CONFIG_TRRD_GET(x)                                       (((x) & DDR_CONFIG_TRRD_MASK) >> DDR_CONFIG_TRRD_LSB)
+#define DDR_CONFIG_TRRD_SET(x)                                       (((x) << DDR_CONFIG_TRRD_LSB) & DDR_CONFIG_TRRD_MASK)
+//#define DDR_CONFIG_TRRD_RESET                                        4'd4
+#define DDR_CONFIG_TRP_MSB                                           12
+#define DDR_CONFIG_TRP_LSB                                           9
+#define DDR_CONFIG_TRP_MASK                                          0x00001e00
+#define DDR_CONFIG_TRP_GET(x)                                        (((x) & DDR_CONFIG_TRP_MASK) >> DDR_CONFIG_TRP_LSB)
+#define DDR_CONFIG_TRP_SET(x)                                        (((x) << DDR_CONFIG_TRP_LSB) & DDR_CONFIG_TRP_MASK)
+//#define DDR_CONFIG_TRP_RESET                                         4'd6
+#define DDR_CONFIG_TRCD_MSB                                          8
+#define DDR_CONFIG_TRCD_LSB                                          5
+#define DDR_CONFIG_TRCD_MASK                                         0x000001e0
+#define DDR_CONFIG_TRCD_GET(x)                                       (((x) & DDR_CONFIG_TRCD_MASK) >> DDR_CONFIG_TRCD_LSB)
+#define DDR_CONFIG_TRCD_SET(x)                                       (((x) << DDR_CONFIG_TRCD_LSB) & DDR_CONFIG_TRCD_MASK)
+//#define DDR_CONFIG_TRCD_RESET                                        4'd6
+#define DDR_CONFIG_TRAS_MSB                                          4
+#define DDR_CONFIG_TRAS_LSB                                          0
+#define DDR_CONFIG_TRAS_MASK                                         0x0000001f
+#define DDR_CONFIG_TRAS_GET(x)                                       (((x) & DDR_CONFIG_TRAS_MASK) >> DDR_CONFIG_TRAS_LSB)
+#define DDR_CONFIG_TRAS_SET(x)                                       (((x) << DDR_CONFIG_TRAS_LSB) & DDR_CONFIG_TRAS_MASK)
+//#define DDR_CONFIG_TRAS_RESET                                        5'd16
+#define DDR_CONFIG_ADDRESS                                           0x18000000
+
+// 32'h18000004 (DDR_CONFIG2)
+#define DDR_CONFIG2_HALF_WIDTH_LOW_MSB                               31
+#define DDR_CONFIG2_HALF_WIDTH_LOW_LSB                               31
+#define DDR_CONFIG2_HALF_WIDTH_LOW_MASK                              0x80000000
+#define DDR_CONFIG2_HALF_WIDTH_LOW_GET(x)                            (((x) & DDR_CONFIG2_HALF_WIDTH_LOW_MASK) >> DDR_CONFIG2_HALF_WIDTH_LOW_LSB)
+#define DDR_CONFIG2_HALF_WIDTH_LOW_SET(x)                            (((x) << DDR_CONFIG2_HALF_WIDTH_LOW_LSB) & DDR_CONFIG2_HALF_WIDTH_LOW_MASK)
+//#define DDR_CONFIG2_HALF_WIDTH_LOW_RESET                             1'd1
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_MSB                            29
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_LSB                            26
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_MASK                           0x3c000000
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_GET(x)                         (((x) & DDR_CONFIG2_GATE_OPEN_LATENCY_MASK) >> DDR_CONFIG2_GATE_OPEN_LATENCY_LSB)
+#define DDR_CONFIG2_GATE_OPEN_LATENCY_SET(x)                         (((x) << DDR_CONFIG2_GATE_OPEN_LATENCY_LSB) & DDR_CONFIG2_GATE_OPEN_LATENCY_MASK)
+//#define DDR_CONFIG2_GATE_OPEN_LATENCY_RESET                          4'd6
+#define DDR_CONFIG2_TWTR_MSB                                         25
+#define DDR_CONFIG2_TWTR_LSB                                         21
+#define DDR_CONFIG2_TWTR_MASK                                        0x03e00000
+#define DDR_CONFIG2_TWTR_GET(x)                                      (((x) & DDR_CONFIG2_TWTR_MASK) >> DDR_CONFIG2_TWTR_LSB)
+#define DDR_CONFIG2_TWTR_SET(x)                                      (((x) << DDR_CONFIG2_TWTR_LSB) & DDR_CONFIG2_TWTR_MASK)
+//#define DDR_CONFIG2_TWTR_RESET                                       5'd14
+#define DDR_CONFIG2_TRTP_MSB                                         20
+#define DDR_CONFIG2_TRTP_LSB                                         17
+#define DDR_CONFIG2_TRTP_MASK                                        0x001e0000
+#define DDR_CONFIG2_TRTP_GET(x)                                      (((x) & DDR_CONFIG2_TRTP_MASK) >> DDR_CONFIG2_TRTP_LSB)
+#define DDR_CONFIG2_TRTP_SET(x)                                      (((x) << DDR_CONFIG2_TRTP_LSB) & DDR_CONFIG2_TRTP_MASK)
+//#define DDR_CONFIG2_TRTP_RESET                                       4'd8
+#define DDR_CONFIG2_TRTW_MSB                                         16
+#define DDR_CONFIG2_TRTW_LSB                                         12
+#define DDR_CONFIG2_TRTW_MASK                                        0x0001f000
+#define DDR_CONFIG2_TRTW_GET(x)                                      (((x) & DDR_CONFIG2_TRTW_MASK) >> DDR_CONFIG2_TRTW_LSB)
+#define DDR_CONFIG2_TRTW_SET(x)                                      (((x) << DDR_CONFIG2_TRTW_LSB) & DDR_CONFIG2_TRTW_MASK)
+//#define DDR_CONFIG2_TRTW_RESET                                       5'd16
+#define DDR_CONFIG2_TWR_MSB                                          11
+#define DDR_CONFIG2_TWR_LSB                                          8
+#define DDR_CONFIG2_TWR_MASK                                         0x00000f00
+#define DDR_CONFIG2_TWR_GET(x)                                       (((x) & DDR_CONFIG2_TWR_MASK) >> DDR_CONFIG2_TWR_LSB)
+#define DDR_CONFIG2_TWR_SET(x)                                       (((x) << DDR_CONFIG2_TWR_LSB) & DDR_CONFIG2_TWR_MASK)
+//#define DDR_CONFIG2_TWR_RESET                                        4'd6
+#define DDR_CONFIG2_CKE_MSB                                          7
+#define DDR_CONFIG2_CKE_LSB                                          7
+#define DDR_CONFIG2_CKE_MASK                                         0x00000080
+#define DDR_CONFIG2_CKE_GET(x)                                       (((x) & DDR_CONFIG2_CKE_MASK) >> DDR_CONFIG2_CKE_LSB)
+#define DDR_CONFIG2_CKE_SET(x)                                       (((x) << DDR_CONFIG2_CKE_LSB) & DDR_CONFIG2_CKE_MASK)
+//#define DDR_CONFIG2_CKE_RESET                                        1'd0
+#define DDR_CONFIG2_PHASE_SELECT_MSB                                 6
+#define DDR_CONFIG2_PHASE_SELECT_LSB                                 6
+#define DDR_CONFIG2_PHASE_SELECT_MASK                                0x00000040
+#define DDR_CONFIG2_PHASE_SELECT_GET(x)                              (((x) & DDR_CONFIG2_PHASE_SELECT_MASK) >> DDR_CONFIG2_PHASE_SELECT_LSB)
+#define DDR_CONFIG2_PHASE_SELECT_SET(x)                              (((x) << DDR_CONFIG2_PHASE_SELECT_LSB) & DDR_CONFIG2_PHASE_SELECT_MASK)
+//#define DDR_CONFIG2_PHASE_SELECT_RESET                               1'd0
+#define DDR_CONFIG2_CNTL_OE_EN_MSB                                   5
+#define DDR_CONFIG2_CNTL_OE_EN_LSB                                   5
+#define DDR_CONFIG2_CNTL_OE_EN_MASK                                  0x00000020
+#define DDR_CONFIG2_CNTL_OE_EN_GET(x)                                (((x) & DDR_CONFIG2_CNTL_OE_EN_MASK) >> DDR_CONFIG2_CNTL_OE_EN_LSB)
+#define DDR_CONFIG2_CNTL_OE_EN_SET(x)                                (((x) << DDR_CONFIG2_CNTL_OE_EN_LSB) & DDR_CONFIG2_CNTL_OE_EN_MASK)
+//#define DDR_CONFIG2_CNTL_OE_EN_RESET                                 1'd1
+#define DDR_CONFIG2_BURST_TYPE_MSB                                   4
+#define DDR_CONFIG2_BURST_TYPE_LSB                                   4
+#define DDR_CONFIG2_BURST_TYPE_MASK                                  0x00000010
+#define DDR_CONFIG2_BURST_TYPE_GET(x)                                (((x) & DDR_CONFIG2_BURST_TYPE_MASK) >> DDR_CONFIG2_BURST_TYPE_LSB)
+#define DDR_CONFIG2_BURST_TYPE_SET(x)                                (((x) << DDR_CONFIG2_BURST_TYPE_LSB) & DDR_CONFIG2_BURST_TYPE_MASK)
+//#define DDR_CONFIG2_BURST_TYPE_RESET                                 1'd0
+#define DDR_CONFIG2_BURST_LENGTH_MSB                                 3
+#define DDR_CONFIG2_BURST_LENGTH_LSB                                 0
+#define DDR_CONFIG2_BURST_LENGTH_MASK                                0x0000000f
+#define DDR_CONFIG2_BURST_LENGTH_GET(x)                              (((x) & DDR_CONFIG2_BURST_LENGTH_MASK) >> DDR_CONFIG2_BURST_LENGTH_LSB)
+#define DDR_CONFIG2_BURST_LENGTH_SET(x)                              (((x) << DDR_CONFIG2_BURST_LENGTH_LSB) & DDR_CONFIG2_BURST_LENGTH_MASK)
+//#define DDR_CONFIG2_BURST_LENGTH_RESET                               4'd8
+#define DDR_CONFIG2_ADDRESS                                          0x18000004
+
+
+#define DDR2_CONFIG_DDR2_TWL_MSB                                     13
+#define DDR2_CONFIG_DDR2_TWL_LSB                                     10
+#define DDR2_CONFIG_DDR2_TWL_MASK                                    0x00003c00
+#define DDR2_CONFIG_DDR2_TWL_GET(x)                                  (((x) & DDR2_CONFIG_DDR2_TWL_MASK) >> DDR2_CONFIG_DDR2_TWL_LSB)
+#define DDR2_CONFIG_DDR2_TWL_SET(x)                                  (((x) << DDR2_CONFIG_DDR2_TWL_LSB) & DDR2_CONFIG_DDR2_TWL_MASK)
+//#define DDR2_CONFIG_DDR2_TWL_RESET                                   4'd1
+#define DDR2_CONFIG_DDR2_ODT_MSB                                     9
+#define DDR2_CONFIG_DDR2_ODT_LSB                                     9
+#define DDR2_CONFIG_DDR2_ODT_MASK                                    0x00000200
+#define DDR2_CONFIG_DDR2_ODT_GET(x)                                  (((x) & DDR2_CONFIG_DDR2_ODT_MASK) >> DDR2_CONFIG_DDR2_ODT_LSB)
+#define DDR2_CONFIG_DDR2_ODT_SET(x)                                  (((x) << DDR2_CONFIG_DDR2_ODT_LSB) & DDR2_CONFIG_DDR2_ODT_MASK)
+//#define DDR2_CONFIG_DDR2_ODT_RESET                                   1'd1
+#define DDR2_CONFIG_TFAW_MSB                                         7
+#define DDR2_CONFIG_TFAW_LSB                                         2
+#define DDR2_CONFIG_TFAW_MASK                                        0x000000fc
+#define DDR2_CONFIG_TFAW_GET(x)                                      (((x) & DDR2_CONFIG_TFAW_MASK) >> DDR2_CONFIG_TFAW_LSB)
+#define DDR2_CONFIG_TFAW_SET(x)                                      (((x) << DDR2_CONFIG_TFAW_LSB) & DDR2_CONFIG_TFAW_MASK)
+//#define DDR2_CONFIG_TFAW_RESET                                       6'd22
+#define DDR2_CONFIG_ENABLE_DDR2_MSB                                  0
+#define DDR2_CONFIG_ENABLE_DDR2_LSB                                  0
+#define DDR2_CONFIG_ENABLE_DDR2_MASK                                 0x00000001
+#define DDR2_CONFIG_ENABLE_DDR2_GET(x)                               (((x) & DDR2_CONFIG_ENABLE_DDR2_MASK) >> DDR2_CONFIG_ENABLE_DDR2_LSB)
+#define DDR2_CONFIG_ENABLE_DDR2_SET(x)                               (((x) << DDR2_CONFIG_ENABLE_DDR2_LSB) & DDR2_CONFIG_ENABLE_DDR2_MASK)
+//#define DDR2_CONFIG_ENABLE_DDR2_RESET                                1'd0
+#define DDR2_CONFIG_ADDRESS                                          0x180000b8
+
+#define DDR_CTL_CONFIG_SRAM_TSEL_MSB                                 31
+#define DDR_CTL_CONFIG_SRAM_TSEL_LSB                                 30
+#define DDR_CTL_CONFIG_SRAM_TSEL_MASK                                0xc0000000
+#define DDR_CTL_CONFIG_SRAM_TSEL_GET(x)                              (((x) & DDR_CTL_CONFIG_SRAM_TSEL_MASK) >> DDR_CTL_CONFIG_SRAM_TSEL_LSB)
+#define DDR_CTL_CONFIG_SRAM_TSEL_SET(x)                              (((x) << DDR_CTL_CONFIG_SRAM_TSEL_LSB) & DDR_CTL_CONFIG_SRAM_TSEL_MASK)
+#define DDR_CTL_CONFIG_SRAM_TSEL_RESET                               0x1 // 1
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MSB                           29
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB                           21
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK                          0x3fe00000
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_GET(x)                        (((x) & DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK) >> DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB)
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_SET(x)                        (((x) << DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB) & DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK)
+#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_RESET                         0x0 // 0
+#define DDR_CTL_CONFIG_SPARE_MSB                                     20
+#define DDR_CTL_CONFIG_SPARE_LSB                                     6
+#define DDR_CTL_CONFIG_SPARE_MASK                                    0x001fffc0
+#define DDR_CTL_CONFIG_SPARE_GET(x)                                  (((x) & DDR_CTL_CONFIG_SPARE_MASK) >> DDR_CTL_CONFIG_SPARE_LSB)
+#define DDR_CTL_CONFIG_SPARE_SET(x)                                  (((x) << DDR_CTL_CONFIG_SPARE_LSB) & DDR_CTL_CONFIG_SPARE_MASK)
+#define DDR_CTL_CONFIG_SPARE_RESET                                   0x4 // 4
+#define DDR_CTL_CONFIG_PREFETCH_CNT_MSB                              5
+#define DDR_CTL_CONFIG_PREFETCH_CNT_LSB                              2
+#define DDR_CTL_CONFIG_PREFETCH_CNT_MASK                             0x0000003c
+#define DDR_CTL_CONFIG_PREFETCH_CNT_GET(x)                           (((x) & DDR_CTL_CONFIG_PREFETCH_CNT_MASK) >> DDR_CTL_CONFIG_PREFETCH_CNT_LSB)
+#define DDR_CTL_CONFIG_PREFETCH_CNT_SET(x)                           (((x) << DDR_CTL_CONFIG_PREFETCH_CNT_LSB) & DDR_CTL_CONFIG_PREFETCH_CNT_MASK)
+#define DDR_CTL_CONFIG_PREFETCH_CNT_RESET                            0x3 // 3
+#define DDR_CTL_CONFIG_HALF_WIDTH_MSB                                1
+#define DDR_CTL_CONFIG_HALF_WIDTH_LSB                                1
+#define DDR_CTL_CONFIG_HALF_WIDTH_MASK                               0x00000002
+#define DDR_CTL_CONFIG_HALF_WIDTH_GET(x)                             (((x) & DDR_CTL_CONFIG_HALF_WIDTH_MASK) >> DDR_CTL_CONFIG_HALF_WIDTH_LSB)
+#define DDR_CTL_CONFIG_HALF_WIDTH_SET(x)                             (((x) << DDR_CTL_CONFIG_HALF_WIDTH_LSB) & DDR_CTL_CONFIG_HALF_WIDTH_MASK)
+#define DDR_CTL_CONFIG_HALF_WIDTH_RESET                              0x1 // 1
+#define DDR_CTL_CONFIG_SRAM_MODE_EN_MSB                              0
+#define DDR_CTL_CONFIG_SRAM_MODE_EN_LSB                              0
+#define DDR_CTL_CONFIG_SRAM_MODE_EN_MASK                             0x00000001
+#define DDR_CTL_CONFIG_SRAM_MODE_EN_GET(x)                           (((x) & DDR_CTL_CONFIG_SRAM_MODE_EN_MASK) >> DDR_CTL_CONFIG_SRAM_MODE_EN_LSB)
+#define DDR_CTL_CONFIG_SRAM_MODE_EN_SET(x)                           (((x) << DDR_CTL_CONFIG_SRAM_MODE_EN_LSB) & DDR_CTL_CONFIG_SRAM_MODE_EN_MASK)
+#define DDR_CTL_CONFIG_SRAM_MODE_EN_RESET                            0x0 // 0
+#define DDR_CTL_CONFIG_ADDRESS                                       0x18000108
+
+
+#define CPU_DPLL3_MEAS_AT_TXON_MSB		31
+#define CPU_DPLL3_MEAS_AT_TXON_LSB		31
+#define CPU_DPLL3_MEAS_AT_TXON_MASK		0x80000000
+#define CPU_DPLL3_MEAS_AT_TXON_GET(x)		(((x) & CPU_DPLL3_MEAS_AT_TXON_MASK) >> CPU_DPLL3_MEAS_AT_TXON_LSB)
+#define CPU_DPLL3_MEAS_AT_TXON_SET(x)		(((x) << CPU_DPLL3_MEAS_AT_TXON_LSB) & CPU_DPLL3_MEAS_AT_TXON_MASK)
+#define CPU_DPLL3_MEAS_AT_TXON_RESET		0x0 // 0
+#define CPU_DPLL3_DO_MEAS_MSB			30
+#define CPU_DPLL3_DO_MEAS_LSB			30
+#define CPU_DPLL3_DO_MEAS_MASK			0x40000000
+#define CPU_DPLL3_DO_MEAS_GET(x)		(((x) & CPU_DPLL3_DO_MEAS_MASK) >> CPU_DPLL3_DO_MEAS_LSB)
+#define CPU_DPLL3_DO_MEAS_SET(x)		(((x) << CPU_DPLL3_DO_MEAS_LSB) & CPU_DPLL3_DO_MEAS_MASK)
+#define CPU_DPLL3_DO_MEAS_RESET			0x0 // 0
+#define CPU_DPLL3_PHASE_SHIFT_MSB		29
+#define CPU_DPLL3_PHASE_SHIFT_LSB		23
+#define CPU_DPLL3_PHASE_SHIFT_MASK		0x3f800000
+#define CPU_DPLL3_PHASE_SHIFT_GET(x)		(((x) & CPU_DPLL3_PHASE_SHIFT_MASK) >> CPU_DPLL3_PHASE_SHIFT_LSB)
+#define CPU_DPLL3_PHASE_SHIFT_SET(x)		(((x) << CPU_DPLL3_PHASE_SHIFT_LSB) & CPU_DPLL3_PHASE_SHIFT_MASK)
+#define CPU_DPLL3_PHASE_SHIFT_RESET		0x0 // 0
+#define CPU_DPLL3_SQSUM_DVC_MSB			22
+#define CPU_DPLL3_SQSUM_DVC_LSB			3
+#define CPU_DPLL3_SQSUM_DVC_MASK		0x007ffff8
+#define CPU_DPLL3_SQSUM_DVC_GET(x)		(((x) & CPU_DPLL3_SQSUM_DVC_MASK) >> CPU_DPLL3_SQSUM_DVC_LSB)
+#define CPU_DPLL3_SQSUM_DVC_SET(x)		(((x) << CPU_DPLL3_SQSUM_DVC_LSB) & CPU_DPLL3_SQSUM_DVC_MASK)
+#define CPU_DPLL3_SQSUM_DVC_RESET		0x0 // 0
+#define CPU_DPLL3_SPARE_MSB			2
+#define CPU_DPLL3_SPARE_LSB			0
+#define CPU_DPLL3_SPARE_MASK			0x00000007
+#define CPU_DPLL3_SPARE_GET(x)			(((x) & CPU_DPLL3_SPARE_MASK) >> CPU_DPLL3_SPARE_LSB)
+#define CPU_DPLL3_SPARE_SET(x)			(((x) << CPU_DPLL3_SPARE_LSB) & CPU_DPLL3_SPARE_MASK)
+#define CPU_DPLL3_SPARE_RESET			0x0 // 0
+#define CPU_DPLL3_ADDRESS			0x181161c8
+#define CPU_DPLL4_MEAN_DVC_MSB			31
+#define CPU_DPLL4_MEAN_DVC_LSB			21
+#define CPU_DPLL4_MEAN_DVC_MASK			0xffe00000
+#define CPU_DPLL4_MEAN_DVC_GET(x)		(((x) & CPU_DPLL4_MEAN_DVC_MASK) >> CPU_DPLL4_MEAN_DVC_LSB)
+#define CPU_DPLL4_MEAN_DVC_SET(x)		(((x) << CPU_DPLL4_MEAN_DVC_LSB) & CPU_DPLL4_MEAN_DVC_MASK)
+#define CPU_DPLL4_MEAN_DVC_RESET		0x0 // 0
+#define CPU_DPLL4_VC_MEAS0_MSB			20
+#define CPU_DPLL4_VC_MEAS0_LSB			4
+#define CPU_DPLL4_VC_MEAS0_MASK			0x001ffff0
+#define CPU_DPLL4_VC_MEAS0_GET(x)		(((x) & CPU_DPLL4_VC_MEAS0_MASK) >> CPU_DPLL4_VC_MEAS0_LSB)
+#define CPU_DPLL4_VC_MEAS0_SET(x)		(((x) << CPU_DPLL4_VC_MEAS0_LSB) & CPU_DPLL4_VC_MEAS0_MASK)
+#define CPU_DPLL4_VC_MEAS0_RESET		0x0 // 0
+#define CPU_DPLL4_MEAS_DONE_MSB			3
+#define CPU_DPLL4_MEAS_DONE_LSB			3
+#define CPU_DPLL4_MEAS_DONE_MASK		0x00000008
+#define CPU_DPLL4_MEAS_DONE_GET(x)		(((x) & CPU_DPLL4_MEAS_DONE_MASK) >> CPU_DPLL4_MEAS_DONE_LSB)
+#define CPU_DPLL4_MEAS_DONE_SET(x)		(((x) << CPU_DPLL4_MEAS_DONE_LSB) & CPU_DPLL4_MEAS_DONE_MASK)
+#define CPU_DPLL4_MEAS_DONE_RESET		0x0 // 0
+#define CPU_DPLL4_SPARE_MSB			2
+#define CPU_DPLL4_SPARE_LSB			0
+#define CPU_DPLL4_SPARE_MASK			0x00000007
+#define CPU_DPLL4_SPARE_GET(x)			(((x) & CPU_DPLL4_SPARE_MASK) >> CPU_DPLL4_SPARE_LSB)
+#define CPU_DPLL4_SPARE_SET(x)			(((x) << CPU_DPLL4_SPARE_LSB) & CPU_DPLL4_SPARE_MASK)
+#define CPU_DPLL4_SPARE_RESET			0x0 // 0
+#define CPU_DPLL4_ADDRESS			0x181161cc
+
+#define DDR_DPLL3_MEAS_AT_TXON_MSB		31
+#define DDR_DPLL3_MEAS_AT_TXON_LSB		31
+#define DDR_DPLL3_MEAS_AT_TXON_MASK		0x80000000
+#define DDR_DPLL3_MEAS_AT_TXON_GET(x)		(((x) & DDR_DPLL3_MEAS_AT_TXON_MASK) >> DDR_DPLL3_MEAS_AT_TXON_LSB)
+#define DDR_DPLL3_MEAS_AT_TXON_SET(x)		(((x) << DDR_DPLL3_MEAS_AT_TXON_LSB) & DDR_DPLL3_MEAS_AT_TXON_MASK)
+#define DDR_DPLL3_MEAS_AT_TXON_RESET		0x0 // 0
+#define DDR_DPLL3_DO_MEAS_MSB			30
+#define DDR_DPLL3_DO_MEAS_LSB			30
+#define DDR_DPLL3_DO_MEAS_MASK			0x40000000
+#define DDR_DPLL3_DO_MEAS_GET(x)		(((x) & DDR_DPLL3_DO_MEAS_MASK) >> DDR_DPLL3_DO_MEAS_LSB)
+#define DDR_DPLL3_DO_MEAS_SET(x)		(((x) << DDR_DPLL3_DO_MEAS_LSB) & DDR_DPLL3_DO_MEAS_MASK)
+#define DDR_DPLL3_DO_MEAS_RESET			0x0 // 0
+#define DDR_DPLL3_PHASE_SHIFT_MSB		29
+#define DDR_DPLL3_PHASE_SHIFT_LSB		23
+#define DDR_DPLL3_PHASE_SHIFT_MASK		0x3f800000
+#define DDR_DPLL3_PHASE_SHIFT_GET(x)		(((x) & DDR_DPLL3_PHASE_SHIFT_MASK) >> DDR_DPLL3_PHASE_SHIFT_LSB)
+#define DDR_DPLL3_PHASE_SHIFT_SET(x)		(((x) << DDR_DPLL3_PHASE_SHIFT_LSB) & DDR_DPLL3_PHASE_SHIFT_MASK)
+#define DDR_DPLL3_PHASE_SHIFT_RESET		0x0 // 0
+#define DDR_DPLL3_SQSUM_DVC_MSB			22
+#define DDR_DPLL3_SQSUM_DVC_LSB			3
+#define DDR_DPLL3_SQSUM_DVC_MASK		0x007ffff8
+#define DDR_DPLL3_SQSUM_DVC_GET(x)		(((x) & DDR_DPLL3_SQSUM_DVC_MASK) >> DDR_DPLL3_SQSUM_DVC_LSB)
+#define DDR_DPLL3_SQSUM_DVC_SET(x)		(((x) << DDR_DPLL3_SQSUM_DVC_LSB) & DDR_DPLL3_SQSUM_DVC_MASK)
+#define DDR_DPLL3_SQSUM_DVC_RESET		0x0 // 0
+#define DDR_DPLL3_SPARE_MSB			2
+#define DDR_DPLL3_SPARE_LSB			0
+#define DDR_DPLL3_SPARE_MASK			0x00000007
+#define DDR_DPLL3_SPARE_GET(x)			(((x) & DDR_DPLL3_SPARE_MASK) >> DDR_DPLL3_SPARE_LSB)
+#define DDR_DPLL3_SPARE_SET(x)			(((x) << DDR_DPLL3_SPARE_LSB) & DDR_DPLL3_SPARE_MASK)
+#define DDR_DPLL3_SPARE_RESET			0x0 // 0
+#define DDR_DPLL3_ADDRESS			0x18116248
+
+// 32'h1811624c (DDR_DPLL4)
+#define DDR_DPLL4_MEAN_DVC_MSB			31
+#define DDR_DPLL4_MEAN_DVC_LSB			21
+#define DDR_DPLL4_MEAN_DVC_MASK			0xffe00000
+#define DDR_DPLL4_MEAN_DVC_GET(x)		(((x) & DDR_DPLL4_MEAN_DVC_MASK) >> DDR_DPLL4_MEAN_DVC_LSB)
+#define DDR_DPLL4_MEAN_DVC_SET(x)		(((x) << DDR_DPLL4_MEAN_DVC_LSB) & DDR_DPLL4_MEAN_DVC_MASK)
+#define DDR_DPLL4_MEAN_DVC_RESET		0x0 // 0
+#define DDR_DPLL4_VC_MEAS0_MSB			20
+#define DDR_DPLL4_VC_MEAS0_LSB			4
+#define DDR_DPLL4_VC_MEAS0_MASK			0x001ffff0
+#define DDR_DPLL4_VC_MEAS0_GET(x)		(((x) & DDR_DPLL4_VC_MEAS0_MASK) >> DDR_DPLL4_VC_MEAS0_LSB)
+#define DDR_DPLL4_VC_MEAS0_SET(x)		(((x) << DDR_DPLL4_VC_MEAS0_LSB) & DDR_DPLL4_VC_MEAS0_MASK)
+#define DDR_DPLL4_VC_MEAS0_RESET		0x0 // 0
+#define DDR_DPLL4_MEAS_DONE_MSB			3
+#define DDR_DPLL4_MEAS_DONE_LSB			3
+#define DDR_DPLL4_MEAS_DONE_MASK		0x00000008
+#define DDR_DPLL4_MEAS_DONE_GET(x)		(((x) & DDR_DPLL4_MEAS_DONE_MASK) >> DDR_DPLL4_MEAS_DONE_LSB)
+#define DDR_DPLL4_MEAS_DONE_SET(x)		(((x) << DDR_DPLL4_MEAS_DONE_LSB) & DDR_DPLL4_MEAS_DONE_MASK)
+#define DDR_DPLL4_MEAS_DONE_RESET		0x0 // 0
+#define DDR_DPLL4_SPARE_MSB			2
+#define DDR_DPLL4_SPARE_LSB			0
+#define DDR_DPLL4_SPARE_MASK			0x00000007
+#define DDR_DPLL4_SPARE_GET(x)			(((x) & DDR_DPLL4_SPARE_MASK) >> DDR_DPLL4_SPARE_LSB)
+#define DDR_DPLL4_SPARE_SET(x)			(((x) << DDR_DPLL4_SPARE_LSB) & DDR_DPLL4_SPARE_MASK)
+#define DDR_DPLL4_SPARE_RESET			0x0 // 0
+#define DDR_DPLL4_ADDRESS			0x1811624c
+
+#define DPLL2_ADDRESS_c4			0x181161c4
+#define DPLL3_ADDRESS_c8			CPU_DPLL3_ADDRESS
+#define DPLL2_ADDRESS_44			0x18116244
+#define DPLL3_ADDRESS_48			DDR_DPLL3_ADDRESS
+#define DPLL3_ADDRESS_88			0x18116188
+
+#define PCIe_DPLL_REFDIV_MSB			31
+#define PCIe_DPLL_REFDIV_LSB			27
+#define PCIe_DPLL_REFDIV_MASK			0xf8000000
+#define PCIe_DPLL_REFDIV_GET(x)			(((x) & PCIe_DPLL_REFDIV_MASK) >> PCIe_DPLL_REFDIV_LSB)
+#define PCIe_DPLL_REFDIV_SET(x)			(((x) << PCIe_DPLL_REFDIV_LSB) & PCIe_DPLL_REFDIV_MASK)
+#define PCIe_DPLL_REFDIV_RESET			0x1 // 1
+#define PCIe_DPLL_NINT_MSB			26
+#define PCIe_DPLL_NINT_LSB			18
+#define PCIe_DPLL_NINT_MASK			0x07fc0000
+#define PCIe_DPLL_NINT_GET(x)			(((x) & PCIe_DPLL_NINT_MASK) >> PCIe_DPLL_NINT_LSB)
+#define PCIe_DPLL_NINT_SET(x)			(((x) << PCIe_DPLL_NINT_LSB) & PCIe_DPLL_NINT_MASK)
+#define PCIe_DPLL_NINT_RESET			0x10 // 16
+#define PCIe_DPLL_NFRAC_MSB			17
+#define PCIe_DPLL_NFRAC_LSB			0
+#define PCIe_DPLL_NFRAC_MASK			0x0003ffff
+#define PCIe_DPLL_NFRAC_GET(x)			(((x) & PCIe_DPLL_NFRAC_MASK) >> PCIe_DPLL_NFRAC_LSB)
+#define PCIe_DPLL_NFRAC_SET(x)			(((x) << PCIe_DPLL_NFRAC_LSB) & PCIe_DPLL_NFRAC_MASK)
+#define PCIe_DPLL_NFRAC_RESET			0x0 // 0
+#define PCIe_DPLL_ADDRESS			0x18116c00
+
+// 32'h18116c04 (PCIe_DPLL2)
+#define PCIe_DPLL2_RANGE_MSB			31
+#define PCIe_DPLL2_RANGE_LSB			31
+#define PCIe_DPLL2_RANGE_MASK			0x80000000
+#define PCIe_DPLL2_RANGE_GET(x)			(((x) & PCIe_DPLL2_RANGE_MASK) >> PCIe_DPLL2_RANGE_LSB)
+#define PCIe_DPLL2_RANGE_SET(x)			(((x) << PCIe_DPLL2_RANGE_LSB) & PCIe_DPLL2_RANGE_MASK)
+#define PCIe_DPLL2_RANGE_RESET			0x0 // 0
+#define PCIe_DPLL2_LOCAL_PLL_MSB		30
+#define PCIe_DPLL2_LOCAL_PLL_LSB		30
+#define PCIe_DPLL2_LOCAL_PLL_MASK		0x40000000
+#define PCIe_DPLL2_LOCAL_PLL_GET(x)		(((x) & PCIe_DPLL2_LOCAL_PLL_MASK) >> PCIe_DPLL2_LOCAL_PLL_LSB)
+#define PCIe_DPLL2_LOCAL_PLL_SET(x)		(((x) << PCIe_DPLL2_LOCAL_PLL_LSB) & PCIe_DPLL2_LOCAL_PLL_MASK)
+#define PCIe_DPLL2_LOCAL_PLL_RESET		0x0 // 0
+#define PCIe_DPLL2_KI_MSB			29
+#define PCIe_DPLL2_KI_LSB			26
+#define PCIe_DPLL2_KI_MASK			0x3c000000
+#define PCIe_DPLL2_KI_GET(x)			(((x) & PCIe_DPLL2_KI_MASK) >> PCIe_DPLL2_KI_LSB)
+#define PCIe_DPLL2_KI_SET(x)			(((x) << PCIe_DPLL2_KI_LSB) & PCIe_DPLL2_KI_MASK)
+#define PCIe_DPLL2_KI_RESET			0x6 // 6
+#define PCIe_DPLL2_KD_MSB			25
+#define PCIe_DPLL2_KD_LSB			19
+#define PCIe_DPLL2_KD_MASK			0x03f80000
+#define PCIe_DPLL2_KD_GET(x)			(((x) & PCIe_DPLL2_KD_MASK) >> PCIe_DPLL2_KD_LSB)
+#define PCIe_DPLL2_KD_SET(x)			(((x) << PCIe_DPLL2_KD_LSB) & PCIe_DPLL2_KD_MASK)
+#define PCIe_DPLL2_KD_RESET			0x7f // 127
+#define PCIe_DPLL2_EN_NEGTRIG_MSB		18
+#define PCIe_DPLL2_EN_NEGTRIG_LSB		18
+#define PCIe_DPLL2_EN_NEGTRIG_MASK		0x00040000
+#define PCIe_DPLL2_EN_NEGTRIG_GET(x)		(((x) & PCIe_DPLL2_EN_NEGTRIG_MASK) >> PCIe_DPLL2_EN_NEGTRIG_LSB)
+#define PCIe_DPLL2_EN_NEGTRIG_SET(x)		(((x) << PCIe_DPLL2_EN_NEGTRIG_LSB) & PCIe_DPLL2_EN_NEGTRIG_MASK)
+#define PCIe_DPLL2_EN_NEGTRIG_RESET		0x0 // 0
+#define PCIe_DPLL2_SEL_1SDM_MSB			17
+#define PCIe_DPLL2_SEL_1SDM_LSB			17
+#define PCIe_DPLL2_SEL_1SDM_MASK		0x00020000
+#define PCIe_DPLL2_SEL_1SDM_GET(x)		(((x) & PCIe_DPLL2_SEL_1SDM_MASK) >> PCIe_DPLL2_SEL_1SDM_LSB)
+#define PCIe_DPLL2_SEL_1SDM_SET(x)		(((x) << PCIe_DPLL2_SEL_1SDM_LSB) & PCIe_DPLL2_SEL_1SDM_MASK)
+#define PCIe_DPLL2_SEL_1SDM_RESET		0x0 // 0
+#define PCIe_DPLL2_PLL_PWD_MSB			16
+#define PCIe_DPLL2_PLL_PWD_LSB			16
+#define PCIe_DPLL2_PLL_PWD_MASK			0x00010000
+#define PCIe_DPLL2_PLL_PWD_GET(x)		(((x) & PCIe_DPLL2_PLL_PWD_MASK) >> PCIe_DPLL2_PLL_PWD_LSB)
+#define PCIe_DPLL2_PLL_PWD_SET(x)		(((x) << PCIe_DPLL2_PLL_PWD_LSB) & PCIe_DPLL2_PLL_PWD_MASK)
+#define PCIe_DPLL2_PLL_PWD_RESET		0x1 // 1
+#define PCIe_DPLL2_OUTDIV_MSB			15
+#define PCIe_DPLL2_OUTDIV_LSB			13
+#define PCIe_DPLL2_OUTDIV_MASK			0x0000e000
+#define PCIe_DPLL2_OUTDIV_GET(x)		(((x) & PCIe_DPLL2_OUTDIV_MASK) >> PCIe_DPLL2_OUTDIV_LSB)
+#define PCIe_DPLL2_OUTDIV_SET(x)		(((x) << PCIe_DPLL2_OUTDIV_LSB) & PCIe_DPLL2_OUTDIV_MASK)
+#define PCIe_DPLL2_OUTDIV_RESET			0x0 // 0
+#define PCIe_DPLL2_DELTA_MSB			12
+#define PCIe_DPLL2_DELTA_LSB			7
+#define PCIe_DPLL2_DELTA_MASK			0x00001f80
+#define PCIe_DPLL2_DELTA_GET(x)			(((x) & PCIe_DPLL2_DELTA_MASK) >> PCIe_DPLL2_DELTA_LSB)
+#define PCIe_DPLL2_DELTA_SET(x)			(((x) << PCIe_DPLL2_DELTA_LSB) & PCIe_DPLL2_DELTA_MASK)
+#define PCIe_DPLL2_DELTA_RESET			0x1e // 30
+#define PCIe_DPLL2_SPARE_MSB			6
+#define PCIe_DPLL2_SPARE_LSB			0
+#define PCIe_DPLL2_SPARE_MASK			0x0000007f
+#define PCIe_DPLL2_SPARE_GET(x)			(((x) & PCIe_DPLL2_SPARE_MASK) >> PCIe_DPLL2_SPARE_LSB)
+#define PCIe_DPLL2_SPARE_SET(x)			(((x) << PCIe_DPLL2_SPARE_LSB) & PCIe_DPLL2_SPARE_MASK)
+#define PCIe_DPLL2_SPARE_RESET			0x0 // 0
+#define PCIe_DPLL2_ADDRESS			0x18116c04
+
+#define PCIe_DPLL3_MEAS_AT_TXON_MSB		31
+#define PCIe_DPLL3_MEAS_AT_TXON_LSB		31
+#define PCIe_DPLL3_MEAS_AT_TXON_MASK		0x80000000
+#define PCIe_DPLL3_MEAS_AT_TXON_GET(x)		(((x) & PCIe_DPLL3_MEAS_AT_TXON_MASK) >> PCIe_DPLL3_MEAS_AT_TXON_LSB)
+#define PCIe_DPLL3_MEAS_AT_TXON_SET(x)		(((x) << PCIe_DPLL3_MEAS_AT_TXON_LSB) & PCIe_DPLL3_MEAS_AT_TXON_MASK)
+#define PCIe_DPLL3_MEAS_AT_TXON_RESET		0x0 // 0
+#define PCIe_DPLL3_DO_MEAS_MSB			30
+#define PCIe_DPLL3_DO_MEAS_LSB			30
+#define PCIe_DPLL3_DO_MEAS_MASK			0x40000000
+#define PCIe_DPLL3_DO_MEAS_GET(x)		(((x) & PCIe_DPLL3_DO_MEAS_MASK) >> PCIe_DPLL3_DO_MEAS_LSB)
+#define PCIe_DPLL3_DO_MEAS_SET(x)		(((x) << PCIe_DPLL3_DO_MEAS_LSB) & PCIe_DPLL3_DO_MEAS_MASK)
+#define PCIe_DPLL3_DO_MEAS_RESET		0x0 // 0
+#define PCIe_DPLL3_PHASE_SHIFT_MSB		29
+#define PCIe_DPLL3_PHASE_SHIFT_LSB		23
+#define PCIe_DPLL3_PHASE_SHIFT_MASK		0x3f800000
+#define PCIe_DPLL3_PHASE_SHIFT_GET(x)		(((x) & PCIe_DPLL3_PHASE_SHIFT_MASK) >> PCIe_DPLL3_PHASE_SHIFT_LSB)
+#define PCIe_DPLL3_PHASE_SHIFT_SET(x)		(((x) << PCIe_DPLL3_PHASE_SHIFT_LSB) & PCIe_DPLL3_PHASE_SHIFT_MASK)
+#define PCIe_DPLL3_PHASE_SHIFT_RESET		0x0 // 0
+#define PCIe_DPLL3_SQSUM_DVC_MSB		22
+#define PCIe_DPLL3_SQSUM_DVC_LSB		3
+#define PCIe_DPLL3_SQSUM_DVC_MASK		0x007ffff8
+#define PCIe_DPLL3_SQSUM_DVC_GET(x)		(((x) & PCIe_DPLL3_SQSUM_DVC_MASK) >> PCIe_DPLL3_SQSUM_DVC_LSB)
+#define PCIe_DPLL3_SQSUM_DVC_SET(x)		(((x) << PCIe_DPLL3_SQSUM_DVC_LSB) & PCIe_DPLL3_SQSUM_DVC_MASK)
+#define PCIe_DPLL3_SQSUM_DVC_RESET		0x0 // 0
+#define PCIe_DPLL3_SPARE_MSB			2
+#define PCIe_DPLL3_SPARE_LSB			0
+#define PCIe_DPLL3_SPARE_MASK			0x00000007
+#define PCIe_DPLL3_SPARE_GET(x)			(((x) & PCIe_DPLL3_SPARE_MASK) >> PCIe_DPLL3_SPARE_LSB)
+#define PCIe_DPLL3_SPARE_SET(x)			(((x) << PCIe_DPLL3_SPARE_LSB) & PCIe_DPLL3_SPARE_MASK)
+#define PCIe_DPLL3_SPARE_RESET			0x0 // 0
+#define PCIe_DPLL3_ADDRESS			0x18116c08
+
+#define PCIe_DPLL4_MEAN_DVC_MSB			31
+#define PCIe_DPLL4_MEAN_DVC_LSB			21
+#define PCIe_DPLL4_MEAN_DVC_MASK		0xffe00000
+#define PCIe_DPLL4_MEAN_DVC_GET(x)		(((x) & PCIe_DPLL4_MEAN_DVC_MASK) >> PCIe_DPLL4_MEAN_DVC_LSB)
+#define PCIe_DPLL4_MEAN_DVC_SET(x)		(((x) << PCIe_DPLL4_MEAN_DVC_LSB) & PCIe_DPLL4_MEAN_DVC_MASK)
+#define PCIe_DPLL4_MEAN_DVC_RESET		0x0 // 0
+#define PCIe_DPLL4_VC_MEAS0_MSB			20
+#define PCIe_DPLL4_VC_MEAS0_LSB			4
+#define PCIe_DPLL4_VC_MEAS0_MASK		0x001ffff0
+#define PCIe_DPLL4_VC_MEAS0_GET(x)		(((x) & PCIe_DPLL4_VC_MEAS0_MASK) >> PCIe_DPLL4_VC_MEAS0_LSB)
+#define PCIe_DPLL4_VC_MEAS0_SET(x)		(((x) << PCIe_DPLL4_VC_MEAS0_LSB) & PCIe_DPLL4_VC_MEAS0_MASK)
+#define PCIe_DPLL4_VC_MEAS0_RESET		0x0 // 0
+#define PCIe_DPLL4_MEAS_DONE_MSB		3
+#define PCIe_DPLL4_MEAS_DONE_LSB		3
+#define PCIe_DPLL4_MEAS_DONE_MASK		0x00000008
+#define PCIe_DPLL4_MEAS_DONE_GET(x)		(((x) & PCIe_DPLL4_MEAS_DONE_MASK) >> PCIe_DPLL4_MEAS_DONE_LSB)
+#define PCIe_DPLL4_MEAS_DONE_SET(x)		(((x) << PCIe_DPLL4_MEAS_DONE_LSB) & PCIe_DPLL4_MEAS_DONE_MASK)
+#define PCIe_DPLL4_MEAS_DONE_RESET		0x0 // 0
+#define PCIe_DPLL4_SPARE_MSB			2
+#define PCIe_DPLL4_SPARE_LSB			0
+#define PCIe_DPLL4_SPARE_MASK			0x00000007
+#define PCIe_DPLL4_SPARE_GET(x)			(((x) & PCIe_DPLL4_SPARE_MASK) >> PCIe_DPLL4_SPARE_LSB)
+#define PCIe_DPLL4_SPARE_SET(x)			(((x) << PCIe_DPLL4_SPARE_LSB) & PCIe_DPLL4_SPARE_MASK)
+#define PCIe_DPLL4_SPARE_RESET			0x0 // 0
+#define PCIe_DPLL4_ADDRESS			0x18116c0c
+
+#define	ATH_DDR_COUNT_LOC	0xbd000000
+#define	ATH_CPU_COUNT_LOC	0xbd000004
+
+#define XTAL_ADDRESS                                                 0x18116290
+
+#define GPIO_OE_ADDRESS                                              0x18040000
+
+
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MSB                          31
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_LSB                          31
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MASK                         0x80000000
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_GET(x)                       (((x) & PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MASK) >> PCIE_PHY_REG_1_SERDES_DIS_RXIMP_LSB)
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_SET(x)                       (((x) << PCIE_PHY_REG_1_SERDES_DIS_RXIMP_LSB) & PCIE_PHY_REG_1_SERDES_DIS_RXIMP_MASK)
+#define PCIE_PHY_REG_1_SERDES_DIS_RXIMP_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MSB                          30
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_LSB                          29
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MASK                         0x60000000
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_GET(x)                       (((x) & PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MASK) >> PCIE_PHY_REG_1_SERDES_TXDR_CTRL_LSB)
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_SET(x)                       (((x) << PCIE_PHY_REG_1_SERDES_TXDR_CTRL_LSB) & PCIE_PHY_REG_1_SERDES_TXDR_CTRL_MASK)
+#define PCIE_PHY_REG_1_SERDES_TXDR_CTRL_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_PERSTDELAY_MSB                                28
+#define PCIE_PHY_REG_1_PERSTDELAY_LSB                                27
+#define PCIE_PHY_REG_1_PERSTDELAY_MASK                               0x18000000
+#define PCIE_PHY_REG_1_PERSTDELAY_GET(x)                             (((x) & PCIE_PHY_REG_1_PERSTDELAY_MASK) >> PCIE_PHY_REG_1_PERSTDELAY_LSB)
+#define PCIE_PHY_REG_1_PERSTDELAY_SET(x)                             (((x) << PCIE_PHY_REG_1_PERSTDELAY_LSB) & PCIE_PHY_REG_1_PERSTDELAY_MASK)
+#define PCIE_PHY_REG_1_PERSTDELAY_RESET                              0x2 // 2
+#define PCIE_PHY_REG_1_CLKOBSSEL_MSB                                 26
+#define PCIE_PHY_REG_1_CLKOBSSEL_LSB                                 25
+#define PCIE_PHY_REG_1_CLKOBSSEL_MASK                                0x06000000
+#define PCIE_PHY_REG_1_CLKOBSSEL_GET(x)                              (((x) & PCIE_PHY_REG_1_CLKOBSSEL_MASK) >> PCIE_PHY_REG_1_CLKOBSSEL_LSB)
+#define PCIE_PHY_REG_1_CLKOBSSEL_SET(x)                              (((x) << PCIE_PHY_REG_1_CLKOBSSEL_LSB) & PCIE_PHY_REG_1_CLKOBSSEL_MASK)
+#define PCIE_PHY_REG_1_CLKOBSSEL_RESET                               0x0 // 0
+#define PCIE_PHY_REG_1_DATAOBSEN_MSB                                 24
+#define PCIE_PHY_REG_1_DATAOBSEN_LSB                                 24
+#define PCIE_PHY_REG_1_DATAOBSEN_MASK                                0x01000000
+#define PCIE_PHY_REG_1_DATAOBSEN_GET(x)                              (((x) & PCIE_PHY_REG_1_DATAOBSEN_MASK) >> PCIE_PHY_REG_1_DATAOBSEN_LSB)
+#define PCIE_PHY_REG_1_DATAOBSEN_SET(x)                              (((x) << PCIE_PHY_REG_1_DATAOBSEN_LSB) & PCIE_PHY_REG_1_DATAOBSEN_MASK)
+#define PCIE_PHY_REG_1_DATAOBSEN_RESET                               0x0 // 0
+#define PCIE_PHY_REG_1_FUNCTESTEN_MSB                                23
+#define PCIE_PHY_REG_1_FUNCTESTEN_LSB                                23
+#define PCIE_PHY_REG_1_FUNCTESTEN_MASK                               0x00800000
+#define PCIE_PHY_REG_1_FUNCTESTEN_GET(x)                             (((x) & PCIE_PHY_REG_1_FUNCTESTEN_MASK) >> PCIE_PHY_REG_1_FUNCTESTEN_LSB)
+#define PCIE_PHY_REG_1_FUNCTESTEN_SET(x)                             (((x) << PCIE_PHY_REG_1_FUNCTESTEN_LSB) & PCIE_PHY_REG_1_FUNCTESTEN_MASK)
+#define PCIE_PHY_REG_1_FUNCTESTEN_RESET                              0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_DISABLE_MSB                            22
+#define PCIE_PHY_REG_1_SERDES_DISABLE_LSB                            22
+#define PCIE_PHY_REG_1_SERDES_DISABLE_MASK                           0x00400000
+#define PCIE_PHY_REG_1_SERDES_DISABLE_GET(x)                         (((x) & PCIE_PHY_REG_1_SERDES_DISABLE_MASK) >> PCIE_PHY_REG_1_SERDES_DISABLE_LSB)
+#define PCIE_PHY_REG_1_SERDES_DISABLE_SET(x)                         (((x) << PCIE_PHY_REG_1_SERDES_DISABLE_LSB) & PCIE_PHY_REG_1_SERDES_DISABLE_MASK)
+#define PCIE_PHY_REG_1_SERDES_DISABLE_RESET                          0x0 // 0
+#define PCIE_PHY_REG_1_RXCLKINV_MSB                                  21
+#define PCIE_PHY_REG_1_RXCLKINV_LSB                                  21
+#define PCIE_PHY_REG_1_RXCLKINV_MASK                                 0x00200000
+#define PCIE_PHY_REG_1_RXCLKINV_GET(x)                               (((x) & PCIE_PHY_REG_1_RXCLKINV_MASK) >> PCIE_PHY_REG_1_RXCLKINV_LSB)
+#define PCIE_PHY_REG_1_RXCLKINV_SET(x)                               (((x) << PCIE_PHY_REG_1_RXCLKINV_LSB) & PCIE_PHY_REG_1_RXCLKINV_MASK)
+#define PCIE_PHY_REG_1_RXCLKINV_RESET                                0x1 // 1
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MSB                          20
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_LSB                          20
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MASK                         0x00100000
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_GET(x)                       (((x) & PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MASK) >> PCIE_PHY_REG_1_FUNCTESTRXCLKINV_LSB)
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_SET(x)                       (((x) << PCIE_PHY_REG_1_FUNCTESTRXCLKINV_LSB) & PCIE_PHY_REG_1_FUNCTESTRXCLKINV_MASK)
+#define PCIE_PHY_REG_1_FUNCTESTRXCLKINV_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MSB                          19
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_LSB                          19
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MASK                         0x00080000
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_GET(x)                       (((x) & PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MASK) >> PCIE_PHY_REG_1_FUNCTESTTXCLKINV_LSB)
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_SET(x)                       (((x) << PCIE_PHY_REG_1_FUNCTESTTXCLKINV_LSB) & PCIE_PHY_REG_1_FUNCTESTTXCLKINV_MASK)
+#define PCIE_PHY_REG_1_FUNCTESTTXCLKINV_RESET                        0x0 // 0
+#define PCIE_PHY_REG_1_ENABLECLKREQ_MSB                              18
+#define PCIE_PHY_REG_1_ENABLECLKREQ_LSB                              18
+#define PCIE_PHY_REG_1_ENABLECLKREQ_MASK                             0x00040000
+#define PCIE_PHY_REG_1_ENABLECLKREQ_GET(x)                           (((x) & PCIE_PHY_REG_1_ENABLECLKREQ_MASK) >> PCIE_PHY_REG_1_ENABLECLKREQ_LSB)
+#define PCIE_PHY_REG_1_ENABLECLKREQ_SET(x)                           (((x) << PCIE_PHY_REG_1_ENABLECLKREQ_LSB) & PCIE_PHY_REG_1_ENABLECLKREQ_MASK)
+#define PCIE_PHY_REG_1_ENABLECLKREQ_RESET                            0x0 // 0
+#define PCIE_PHY_REG_1_FORCELOOPBACK_MSB                             17
+#define PCIE_PHY_REG_1_FORCELOOPBACK_LSB                             17
+#define PCIE_PHY_REG_1_FORCELOOPBACK_MASK                            0x00020000
+#define PCIE_PHY_REG_1_FORCELOOPBACK_GET(x)                          (((x) & PCIE_PHY_REG_1_FORCELOOPBACK_MASK) >> PCIE_PHY_REG_1_FORCELOOPBACK_LSB)
+#define PCIE_PHY_REG_1_FORCELOOPBACK_SET(x)                          (((x) << PCIE_PHY_REG_1_FORCELOOPBACK_LSB) & PCIE_PHY_REG_1_FORCELOOPBACK_MASK)
+#define PCIE_PHY_REG_1_FORCELOOPBACK_RESET                           0x0 // 0
+#define PCIE_PHY_REG_1_SEL_CLK_MSB                                   16
+#define PCIE_PHY_REG_1_SEL_CLK_LSB                                   15
+#define PCIE_PHY_REG_1_SEL_CLK_MASK                                  0x00018000
+#define PCIE_PHY_REG_1_SEL_CLK_GET(x)                                (((x) & PCIE_PHY_REG_1_SEL_CLK_MASK) >> PCIE_PHY_REG_1_SEL_CLK_LSB)
+#define PCIE_PHY_REG_1_SEL_CLK_SET(x)                                (((x) << PCIE_PHY_REG_1_SEL_CLK_LSB) & PCIE_PHY_REG_1_SEL_CLK_MASK)
+#define PCIE_PHY_REG_1_SEL_CLK_RESET                                 0x2 // 2
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_MSB                              14
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_LSB                              14
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_MASK                             0x00004000
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_GET(x)                           (((x) & PCIE_PHY_REG_1_SERDES_RX_EQ_MASK) >> PCIE_PHY_REG_1_SERDES_RX_EQ_LSB)
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_SET(x)                           (((x) << PCIE_PHY_REG_1_SERDES_RX_EQ_LSB) & PCIE_PHY_REG_1_SERDES_RX_EQ_MASK)
+#define PCIE_PHY_REG_1_SERDES_RX_EQ_RESET                            0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_MSB                           13
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_LSB                           13
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_MASK                          0x00002000
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_GET(x)                        (((x) & PCIE_PHY_REG_1_SERDES_EN_LCKDT_MASK) >> PCIE_PHY_REG_1_SERDES_EN_LCKDT_LSB)
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_SET(x)                        (((x) << PCIE_PHY_REG_1_SERDES_EN_LCKDT_LSB) & PCIE_PHY_REG_1_SERDES_EN_LCKDT_MASK)
+#define PCIE_PHY_REG_1_SERDES_EN_LCKDT_RESET                         0x1 // 1
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MSB                     12
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_LSB                     12
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MASK                    0x00001000
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_GET(x)                  (((x) & PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MASK) >> PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_LSB)
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_SET(x)                  (((x) << PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_LSB) & PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_MASK)
+#define PCIE_PHY_REG_1_SERDES_PLL_DISABLE_L1_RESET                   0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_MSB                         11
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_LSB                         11
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_MASK                        0x00000800
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_GET(x)                      (((x) & PCIE_PHY_REG_1_SERDES_POWER_SAVE_MASK) >> PCIE_PHY_REG_1_SERDES_POWER_SAVE_LSB)
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_SET(x)                      (((x) << PCIE_PHY_REG_1_SERDES_POWER_SAVE_LSB) & PCIE_PHY_REG_1_SERDES_POWER_SAVE_MASK)
+#define PCIE_PHY_REG_1_SERDES_POWER_SAVE_RESET                       0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_MSB                             10
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_LSB                             9
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_MASK                            0x00000600
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_GET(x)                          (((x) & PCIE_PHY_REG_1_SERDES_CDR_BW_MASK) >> PCIE_PHY_REG_1_SERDES_CDR_BW_LSB)
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_SET(x)                          (((x) << PCIE_PHY_REG_1_SERDES_CDR_BW_LSB) & PCIE_PHY_REG_1_SERDES_CDR_BW_MASK)
+#define PCIE_PHY_REG_1_SERDES_CDR_BW_RESET                           0x3 // 3
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_MSB                             8
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_LSB                             7
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_MASK                            0x00000180
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_GET(x)                          (((x) & PCIE_PHY_REG_1_SERDES_TH_LOS_MASK) >> PCIE_PHY_REG_1_SERDES_TH_LOS_LSB)
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_SET(x)                          (((x) << PCIE_PHY_REG_1_SERDES_TH_LOS_LSB) & PCIE_PHY_REG_1_SERDES_TH_LOS_MASK)
+#define PCIE_PHY_REG_1_SERDES_TH_LOS_RESET                           0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_MSB                           6
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_LSB                           6
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_MASK                          0x00000040
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_GET(x)                        (((x) & PCIE_PHY_REG_1_SERDES_EN_DEEMP_MASK) >> PCIE_PHY_REG_1_SERDES_EN_DEEMP_LSB)
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_SET(x)                        (((x) << PCIE_PHY_REG_1_SERDES_EN_DEEMP_LSB) & PCIE_PHY_REG_1_SERDES_EN_DEEMP_MASK)
+#define PCIE_PHY_REG_1_SERDES_EN_DEEMP_RESET                         0x1 // 1
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_MSB                           5
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_LSB                           5
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_MASK                          0x00000020
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_GET(x)                        (((x) & PCIE_PHY_REG_1_SERDES_HALFTXDR_MASK) >> PCIE_PHY_REG_1_SERDES_HALFTXDR_LSB)
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_SET(x)                        (((x) << PCIE_PHY_REG_1_SERDES_HALFTXDR_LSB) & PCIE_PHY_REG_1_SERDES_HALFTXDR_MASK)
+#define PCIE_PHY_REG_1_SERDES_HALFTXDR_RESET                         0x0 // 0
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_MSB                            4
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_LSB                            4
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_MASK                           0x00000010
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_GET(x)                         (((x) & PCIE_PHY_REG_1_SERDES_SEL_HSP_MASK) >> PCIE_PHY_REG_1_SERDES_SEL_HSP_LSB)
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_SET(x)                         (((x) << PCIE_PHY_REG_1_SERDES_SEL_HSP_LSB) & PCIE_PHY_REG_1_SERDES_SEL_HSP_MASK)
+#define PCIE_PHY_REG_1_SERDES_SEL_HSP_RESET                          0x1 // 1
+#define PCIE_PHY_REG_1_S_MSB                                         3
+#define PCIE_PHY_REG_1_S_LSB                                         0
+#define PCIE_PHY_REG_1_S_MASK                                        0x0000000f
+#define PCIE_PHY_REG_1_S_GET(x)                                      (((x) & PCIE_PHY_REG_1_S_MASK) >> PCIE_PHY_REG_1_S_LSB)
+#define PCIE_PHY_REG_1_S_SET(x)                                      (((x) << PCIE_PHY_REG_1_S_LSB) & PCIE_PHY_REG_1_S_MASK)
+#define PCIE_PHY_REG_1_S_RESET                                       0xe // 14
+#define PCIE_PHY_REG_1_ADDRESS                                       0x18116cc0
+
+
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MSB                         31
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB                         24
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK                        0xff000000
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_7_RESET                       0xb // 11
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MSB                         23
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB                         16
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK                        0x00ff0000
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_6_RESET                       0xa // 10
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MSB                         15
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB                         8
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK                        0x0000ff00
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_5_RESET                       0x9 // 9
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MSB                         7
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB                         0
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK                        0x000000ff
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_GET(x)                      (((x) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK) >> GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(x)                      (((x) << GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_LSB) & GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK)
+#define GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_RESET                       0x14 // 20
+#define GPIO_OUT_FUNCTION1_ADDRESS                                   0x18040030
+
+
+#if (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(32)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(1)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(32)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(1)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(2)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(2)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(1)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(24)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(48)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(1)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(48)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(1)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(40)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(44)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_332_166)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(26)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(16)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_332_200)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(26)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(16)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_266_133)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(21)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(16)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_266_200)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(21)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(16)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(2)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_566_550_275)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(22)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(13)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(40) | CPU_PLL_DITHER_NFRAC_MAX_SET(40)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(9) | CPU_PLL_DITHER_NFRAC_MAX_SET(9)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(768) | DDR_PLL_DITHER_NFRAC_MAX_SET(768)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_566_525_262)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(21)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(13)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(40) | CPU_PLL_DITHER_NFRAC_MAX_SET(40)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(9) | CPU_PLL_DITHER_NFRAC_MAX_SET(9)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(128) | DDR_PLL_DITHER_NFRAC_MAX_SET(128)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(12)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(40) | CPU_PLL_DITHER_NFRAC_MAX_SET(40)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(9) | CPU_PLL_DITHER_NFRAC_MAX_SET(9)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(512) | DDR_PLL_DITHER_NFRAC_MAX_SET(512)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(19)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(11)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(41) | CPU_PLL_DITHER_NFRAC_MAX_SET(41)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(9) | CPU_PLL_DITHER_NFRAC_MAX_SET(9)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(1023)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(895) | DDR_PLL_DITHER_NFRAC_MAX_SET(1023)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_566_450_225)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(36)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(22)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(40) | CPU_PLL_DITHER_NFRAC_MAX_SET(40)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(9) | CPU_PLL_DITHER_NFRAC_MAX_SET(9)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(512) | DDR_PLL_DITHER_NFRAC_MAX_SET(512)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_566_400_200)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(16)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(10)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(40) | CPU_PLL_DITHER_NFRAC_MAX_SET(40)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(9) | CPU_PLL_DITHER_NFRAC_MAX_SET(9)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(19)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(12)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(25) | CPU_PLL_DITHER_NFRAC_MAX_SET(25)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(204) | DDR_PLL_DITHER_NFRAC_MAX_SET(204)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_480_240)
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(32)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(1)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(19)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(12)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(204) | DDR_PLL_DITHER_NFRAC_MAX_SET(204)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+
+
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(26)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(24)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_600_300)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(24)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_275)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(22)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_650_325)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(26)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_525_262)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(21)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_575_287)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(23)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(14)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_450_200)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(18)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(21)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(13)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(21)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(13)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(12)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(28)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(24)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(15)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_300)
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(20)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(12)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(32) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(28)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(17)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(3)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(24)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(15)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(0)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(12)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_500_500_250)
+
+#define CPU_PLL_CONFIG_NINT_VAL			CPU_PLL_CONFIG_NINT_SET(20)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2		CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL			DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1		DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#else
+/*
+ * This is for old lowlevel init file that was used for wasp 1.0 to compile.
+ */
+
+#ifdef CONFIG_AP123			// CFG_PLL_535_400_200
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(21)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(13)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(32)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(20)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#elif defined(CONFIG_ATH_NAND_SUPPORT)	// NAND on DB120 CFG_PLL_560_400_200
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(16)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(10)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(0)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(25) | CPU_PLL_DITHER_NFRAC_MAX_SET(25)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#else					// CFG_PLL_560_450_225
+
+#define CPU_PLL_CONFIG_NINT_VAL_25		CPU_PLL_CONFIG_NINT_SET(22)
+#define CPU_PLL_CONFIG_NINT_VAL_40		CPU_PLL_CONFIG_NINT_SET(14)
+#define CPU_PLL_CONFIG_REF_DIV_VAL		CPU_PLL_CONFIG_REFDIV_SET(1)
+#define CPU_PLL_CONFIG_RANGE_VAL		CPU_PLL_CONFIG_RANGE_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL1		CPU_PLL_CONFIG_OUTDIV_SET(1)
+#define CPU_PLL_CONFIG_OUT_DIV_VAL2	        CPU_PLL_CONFIG_OUTDIV_SET(0)
+
+#define DDR_PLL_CONFIG_NINT_VAL_25		DDR_PLL_CONFIG_NINT_SET(36)
+#define DDR_PLL_CONFIG_NINT_VAL_40		DDR_PLL_CONFIG_NINT_SET(22)
+#define DDR_PLL_CONFIG_REF_DIV_VAL		DDR_PLL_CONFIG_REFDIV_SET(1)
+#define DDR_PLL_CONFIG_RANGE_VAL		DDR_PLL_CONFIG_RANGE_SET(0)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL1	        DDR_PLL_CONFIG_OUTDIV_SET(1)
+#define DDR_PLL_CONFIG_OUT_DIV_VAL2		DDR_PLL_CONFIG_OUTDIV_SET(1)
+
+#define CPU_PLL_NFRAC_MIN_SET			CPU_PLL_DITHER_NFRAC_MIN_SET(20) | CPU_PLL_DITHER_NFRAC_MAX_SET(20)
+
+#define CPU_PLL_NFRAC_25			CPU_PLL_DITHER_NFRAC_MIN_SET(25) | CPU_PLL_DITHER_NFRAC_MAX_SET(25)
+#define CPU_PLL_NFRAC_40			CPU_PLL_DITHER_NFRAC_MIN_SET(0) | CPU_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_25			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | DDR_PLL_DITHER_NFRAC_MAX_SET(0)
+#define DDR_PLL_NFRAC_40			DDR_PLL_DITHER_NFRAC_MIN_SET(512) | DDR_PLL_DITHER_NFRAC_MAX_SET(512)
+
+#define CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL	CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR	CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR	CPU_DDR_CLOCK_CONTROL_DDRCLK_FROM_DDRPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU	CPU_DDR_CLOCK_CONTROL_CPUCLK_FROM_CPUPLL_SET(1)
+#define CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV	CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_SET(0)
+#define CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV	CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_SET(0)
+
+#endif
+
+#endif
+
+#define DDR_DPLL_REFDIV_MSB                                              31
+#define DDR_DPLL_REFDIV_LSB                                              27
+#define DDR_DPLL_REFDIV_MASK                                             0xf8000000
+#define DDR_DPLL_REFDIV_GET(x)                                           (((x) & DDR_DPLL_REFDIV_MASK) >> DDR_DPLL_REFDIV_LSB)
+#define DDR_DPLL_REFDIV_SET(x)                                           (((x) << DDR_DPLL_REFDIV_LSB) & DDR_DPLL_REFDIV_MASK)
+#define DDR_DPLL_REFDIV_RESET                                            0x1 // 1
+#define DDR_DPLL_NINT_MSB                                                26
+#define DDR_DPLL_NINT_LSB                                                18
+#define DDR_DPLL_NINT_MASK                                               0x07fc0000
+#define DDR_DPLL_NINT_GET(x)                                             (((x) & DDR_DPLL_NINT_MASK) >> DDR_DPLL_NINT_LSB)
+#define DDR_DPLL_NINT_SET(x)                                             (((x) << DDR_DPLL_NINT_LSB) & DDR_DPLL_NINT_MASK)
+#define DDR_DPLL_NINT_RESET                                              0x10 // 16
+#define DDR_DPLL_NFRAC_MSB                                               17
+#define DDR_DPLL_NFRAC_LSB                                               0
+#define DDR_DPLL_NFRAC_MASK                                              0x0003ffff
+#define DDR_DPLL_NFRAC_GET(x)                                            (((x) & DDR_DPLL_NFRAC_MASK) >> DDR_DPLL_NFRAC_LSB)
+#define DDR_DPLL_NFRAC_SET(x)                                            (((x) << DDR_DPLL_NFRAC_LSB) & DDR_DPLL_NFRAC_MASK)
+#define DDR_DPLL_NFRAC_RESET                                             0x0 // 0
+#define DDR_DPLL_ADDRESS                                                 0x18116240
+
+#define DDR_DPLL2_RANGE_MSB                                              31
+#define DDR_DPLL2_RANGE_LSB                                              31
+#define DDR_DPLL2_RANGE_MASK                                             0x80000000
+#define DDR_DPLL2_RANGE_GET(x)                                           (((x) & DDR_DPLL2_RANGE_MASK) >> DDR_DPLL2_RANGE_LSB)
+#define DDR_DPLL2_RANGE_SET(x)                                           (((x) << DDR_DPLL2_RANGE_LSB) & DDR_DPLL2_RANGE_MASK)
+#define DDR_DPLL2_RANGE_RESET                                            0x0 // 0
+#define DDR_DPLL2_LOCAL_PLL_MSB                                          30
+#define DDR_DPLL2_LOCAL_PLL_LSB                                          30
+#define DDR_DPLL2_LOCAL_PLL_MASK                                         0x40000000
+#define DDR_DPLL2_LOCAL_PLL_GET(x)                                       (((x) & DDR_DPLL2_LOCAL_PLL_MASK) >> DDR_DPLL2_LOCAL_PLL_LSB)
+#define DDR_DPLL2_LOCAL_PLL_SET(x)                                       (((x) << DDR_DPLL2_LOCAL_PLL_LSB) & DDR_DPLL2_LOCAL_PLL_MASK)
+#define DDR_DPLL2_LOCAL_PLL_RESET                                        0x0 // 0
+#define DDR_DPLL2_KI_MSB                                                 29
+#define DDR_DPLL2_KI_LSB                                                 26
+#define DDR_DPLL2_KI_MASK                                                0x3c000000
+#define DDR_DPLL2_KI_GET(x)                                              (((x) & DDR_DPLL2_KI_MASK) >> DDR_DPLL2_KI_LSB)
+#define DDR_DPLL2_KI_SET(x)                                              (((x) << DDR_DPLL2_KI_LSB) & DDR_DPLL2_KI_MASK)
+#define DDR_DPLL2_KI_RESET                                               0x6 // 6
+#define DDR_DPLL2_KD_MSB                                                 25
+#define DDR_DPLL2_KD_LSB                                                 19
+#define DDR_DPLL2_KD_MASK                                                0x03f80000
+#define DDR_DPLL2_KD_GET(x)                                              (((x) & DDR_DPLL2_KD_MASK) >> DDR_DPLL2_KD_LSB)
+#define DDR_DPLL2_KD_SET(x)                                              (((x) << DDR_DPLL2_KD_LSB) & DDR_DPLL2_KD_MASK)
+#define DDR_DPLL2_KD_RESET                                               0x7f // 127
+#define DDR_DPLL2_EN_NEGTRIG_MSB                                         18
+#define DDR_DPLL2_EN_NEGTRIG_LSB                                         18
+#define DDR_DPLL2_EN_NEGTRIG_MASK                                        0x00040000
+#define DDR_DPLL2_EN_NEGTRIG_GET(x)                                      (((x) & DDR_DPLL2_EN_NEGTRIG_MASK) >> DDR_DPLL2_EN_NEGTRIG_LSB)
+#define DDR_DPLL2_EN_NEGTRIG_SET(x)                                      (((x) << DDR_DPLL2_EN_NEGTRIG_LSB) & DDR_DPLL2_EN_NEGTRIG_MASK)
+#define DDR_DPLL2_EN_NEGTRIG_RESET                                       0x0 // 0
+#define DDR_DPLL2_SEL_1SDM_MSB                                           17
+#define DDR_DPLL2_SEL_1SDM_LSB                                           17
+#define DDR_DPLL2_SEL_1SDM_MASK                                          0x00020000
+#define DDR_DPLL2_SEL_1SDM_GET(x)                                        (((x) & DDR_DPLL2_SEL_1SDM_MASK) >> DDR_DPLL2_SEL_1SDM_LSB)
+#define DDR_DPLL2_SEL_1SDM_SET(x)                                        (((x) << DDR_DPLL2_SEL_1SDM_LSB) & DDR_DPLL2_SEL_1SDM_MASK)
+#define DDR_DPLL2_SEL_1SDM_RESET                                         0x0 // 0
+#define DDR_DPLL2_PLL_PWD_MSB                                            16
+#define DDR_DPLL2_PLL_PWD_LSB                                            16
+#define DDR_DPLL2_PLL_PWD_MASK                                           0x00010000
+#define DDR_DPLL2_PLL_PWD_GET(x)                                         (((x) & DDR_DPLL2_PLL_PWD_MASK) >> DDR_DPLL2_PLL_PWD_LSB)
+#define DDR_DPLL2_PLL_PWD_SET(x)                                         (((x) << DDR_DPLL2_PLL_PWD_LSB) & DDR_DPLL2_PLL_PWD_MASK)
+#define DDR_DPLL2_PLL_PWD_RESET                                          0x1 // 1
+#define DDR_DPLL2_OUTDIV_MSB                                             15
+#define DDR_DPLL2_OUTDIV_LSB                                             13
+#define DDR_DPLL2_OUTDIV_MASK                                            0x0000e000
+#define DDR_DPLL2_OUTDIV_GET(x)                                          (((x) & DDR_DPLL2_OUTDIV_MASK) >> DDR_DPLL2_OUTDIV_LSB)
+#define DDR_DPLL2_OUTDIV_SET(x)                                          (((x) << DDR_DPLL2_OUTDIV_LSB) & DDR_DPLL2_OUTDIV_MASK)
+#define DDR_DPLL2_OUTDIV_RESET                                           0x0 // 0
+#define DDR_DPLL2_DELTA_MSB                                              12
+#define DDR_DPLL2_DELTA_LSB                                              7
+#define DDR_DPLL2_DELTA_MASK                                             0x00001f80
+#define DDR_DPLL2_DELTA_GET(x)                                           (((x) & DDR_DPLL2_DELTA_MASK) >> DDR_DPLL2_DELTA_LSB)
+#define DDR_DPLL2_DELTA_SET(x)                                           (((x) << DDR_DPLL2_DELTA_LSB) & DDR_DPLL2_DELTA_MASK)
+#define DDR_DPLL2_DELTA_RESET                                            0x1e // 30
+#define DDR_DPLL2_SPARE_MSB                                              6
+#define DDR_DPLL2_SPARE_LSB                                              0
+#define DDR_DPLL2_SPARE_MASK                                             0x0000007f
+#define DDR_DPLL2_SPARE_GET(x)                                           (((x) & DDR_DPLL2_SPARE_MASK) >> DDR_DPLL2_SPARE_LSB)
+#define DDR_DPLL2_SPARE_SET(x)                                           (((x) << DDR_DPLL2_SPARE_LSB) & DDR_DPLL2_SPARE_MASK)
+#define DDR_DPLL2_SPARE_RESET                                            0x0 // 0
+#define DDR_DPLL2_ADDRESS                                                0x18116244
+
+#define DDR_DPLL3_MEAS_AT_TXON_MSB                                       31
+#define DDR_DPLL3_MEAS_AT_TXON_LSB                                       31
+#define DDR_DPLL3_MEAS_AT_TXON_MASK                                      0x80000000
+#define DDR_DPLL3_MEAS_AT_TXON_GET(x)                                    (((x) & DDR_DPLL3_MEAS_AT_TXON_MASK) >> DDR_DPLL3_MEAS_AT_TXON_LSB)
+#define DDR_DPLL3_MEAS_AT_TXON_SET(x)                                    (((x) << DDR_DPLL3_MEAS_AT_TXON_LSB) & DDR_DPLL3_MEAS_AT_TXON_MASK)
+#define DDR_DPLL3_MEAS_AT_TXON_RESET                                     0x0 // 0
+#define DDR_DPLL3_DO_MEAS_MSB                                            30
+#define DDR_DPLL3_DO_MEAS_LSB                                            30
+#define DDR_DPLL3_DO_MEAS_MASK                                           0x40000000
+#define DDR_DPLL3_DO_MEAS_GET(x)                                         (((x) & DDR_DPLL3_DO_MEAS_MASK) >> DDR_DPLL3_DO_MEAS_LSB)
+#define DDR_DPLL3_DO_MEAS_SET(x)                                         (((x) << DDR_DPLL3_DO_MEAS_LSB) & DDR_DPLL3_DO_MEAS_MASK)
+#define DDR_DPLL3_DO_MEAS_RESET                                          0x0 // 0
+#define DDR_DPLL3_PHASE_SHIFT_MSB                                        29
+#define DDR_DPLL3_PHASE_SHIFT_LSB                                        23
+#define DDR_DPLL3_PHASE_SHIFT_MASK                                       0x3f800000
+#define DDR_DPLL3_PHASE_SHIFT_GET(x)                                     (((x) & DDR_DPLL3_PHASE_SHIFT_MASK) >> DDR_DPLL3_PHASE_SHIFT_LSB)
+#define DDR_DPLL3_PHASE_SHIFT_SET(x)                                     (((x) << DDR_DPLL3_PHASE_SHIFT_LSB) & DDR_DPLL3_PHASE_SHIFT_MASK)
+#define DDR_DPLL3_PHASE_SHIFT_RESET                                      0x0 // 0
+#define DDR_DPLL3_SQSUM_DVC_MSB                                          22
+#define DDR_DPLL3_SQSUM_DVC_LSB                                          3
+#define DDR_DPLL3_SQSUM_DVC_MASK                                         0x007ffff8
+#define DDR_DPLL3_SQSUM_DVC_GET(x)                                       (((x) & DDR_DPLL3_SQSUM_DVC_MASK) >> DDR_DPLL3_SQSUM_DVC_LSB)
+#define DDR_DPLL3_SQSUM_DVC_SET(x)                                       (((x) << DDR_DPLL3_SQSUM_DVC_LSB) & DDR_DPLL3_SQSUM_DVC_MASK)
+#define DDR_DPLL3_SQSUM_DVC_RESET                                        0x0 // 0
+#define DDR_DPLL3_SPARE_MSB                                              2
+#define DDR_DPLL3_SPARE_LSB                                              0
+#define DDR_DPLL3_SPARE_MASK                                             0x00000007
+#define DDR_DPLL3_SPARE_GET(x)                                           (((x) & DDR_DPLL3_SPARE_MASK) >> DDR_DPLL3_SPARE_LSB)
+#define DDR_DPLL3_SPARE_SET(x)                                           (((x) << DDR_DPLL3_SPARE_LSB) & DDR_DPLL3_SPARE_MASK)
+#define DDR_DPLL3_SPARE_RESET                                            0x0 // 0
+#define DDR_DPLL3_ADDRESS                                                0x18116248
+
+#define CPU_DPLL_REFDIV_MSB                                              31
+#define CPU_DPLL_REFDIV_LSB                                              27
+#define CPU_DPLL_REFDIV_MASK                                             0xf8000000
+#define CPU_DPLL_REFDIV_GET(x)                                           (((x) & CPU_DPLL_REFDIV_MASK) >> CPU_DPLL_REFDIV_LSB)
+#define CPU_DPLL_REFDIV_SET(x)                                           (((x) << CPU_DPLL_REFDIV_LSB) & CPU_DPLL_REFDIV_MASK)
+#define CPU_DPLL_REFDIV_RESET                                            0x1 // 1
+#define CPU_DPLL_NINT_MSB                                                26
+#define CPU_DPLL_NINT_LSB                                                18
+#define CPU_DPLL_NINT_MASK                                               0x07fc0000
+#define CPU_DPLL_NINT_GET(x)                                             (((x) & CPU_DPLL_NINT_MASK) >> CPU_DPLL_NINT_LSB)
+#define CPU_DPLL_NINT_SET(x)                                             (((x) << CPU_DPLL_NINT_LSB) & CPU_DPLL_NINT_MASK)
+#define CPU_DPLL_NINT_RESET                                              0x10 // 16
+#define CPU_DPLL_NFRAC_MSB                                               17
+#define CPU_DPLL_NFRAC_LSB                                               0
+#define CPU_DPLL_NFRAC_MASK                                              0x0003ffff
+#define CPU_DPLL_NFRAC_GET(x)                                            (((x) & CPU_DPLL_NFRAC_MASK) >> CPU_DPLL_NFRAC_LSB)
+#define CPU_DPLL_NFRAC_SET(x)                                            (((x) << CPU_DPLL_NFRAC_LSB) & CPU_DPLL_NFRAC_MASK)
+#define CPU_DPLL_NFRAC_RESET                                             0x0 // 0
+#define CPU_DPLL_ADDRESS                                                 0x181161c0
+
+#define CPU_DPLL2_RANGE_MSB                                              31
+#define CPU_DPLL2_RANGE_LSB                                              31
+#define CPU_DPLL2_RANGE_MASK                                             0x80000000
+#define CPU_DPLL2_RANGE_GET(x)                                           (((x) & CPU_DPLL2_RANGE_MASK) >> CPU_DPLL2_RANGE_LSB)
+#define CPU_DPLL2_RANGE_SET(x)                                           (((x) << CPU_DPLL2_RANGE_LSB) & CPU_DPLL2_RANGE_MASK)
+#define CPU_DPLL2_RANGE_RESET                                            0x0 // 0
+#define CPU_DPLL2_LOCAL_PLL_MSB                                          30
+#define CPU_DPLL2_LOCAL_PLL_LSB                                          30
+#define CPU_DPLL2_LOCAL_PLL_MASK                                         0x40000000
+#define CPU_DPLL2_LOCAL_PLL_GET(x)                                       (((x) & CPU_DPLL2_LOCAL_PLL_MASK) >> CPU_DPLL2_LOCAL_PLL_LSB)
+#define CPU_DPLL2_LOCAL_PLL_SET(x)                                       (((x) << CPU_DPLL2_LOCAL_PLL_LSB) & CPU_DPLL2_LOCAL_PLL_MASK)
+#define CPU_DPLL2_LOCAL_PLL_RESET                                        0x0 // 0
+#define CPU_DPLL2_KI_MSB                                                 29
+#define CPU_DPLL2_KI_LSB                                                 26
+#define CPU_DPLL2_KI_MASK                                                0x3c000000
+#define CPU_DPLL2_KI_GET(x)                                              (((x) & CPU_DPLL2_KI_MASK) >> CPU_DPLL2_KI_LSB)
+#define CPU_DPLL2_KI_SET(x)                                              (((x) << CPU_DPLL2_KI_LSB) & CPU_DPLL2_KI_MASK)
+#define CPU_DPLL2_KI_RESET                                               0x6 // 6
+#define CPU_DPLL2_KD_MSB                                                 25
+#define CPU_DPLL2_KD_LSB                                                 19
+#define CPU_DPLL2_KD_MASK                                                0x03f80000
+#define CPU_DPLL2_KD_GET(x)                                              (((x) & CPU_DPLL2_KD_MASK) >> CPU_DPLL2_KD_LSB)
+#define CPU_DPLL2_KD_SET(x)                                              (((x) << CPU_DPLL2_KD_LSB) & CPU_DPLL2_KD_MASK)
+#define CPU_DPLL2_KD_RESET                                               0x7f // 127
+#define CPU_DPLL2_EN_NEGTRIG_MSB                                         18
+#define CPU_DPLL2_EN_NEGTRIG_LSB                                         18
+#define CPU_DPLL2_EN_NEGTRIG_MASK                                        0x00040000
+#define CPU_DPLL2_EN_NEGTRIG_GET(x)                                      (((x) & CPU_DPLL2_EN_NEGTRIG_MASK) >> CPU_DPLL2_EN_NEGTRIG_LSB)
+#define CPU_DPLL2_EN_NEGTRIG_SET(x)                                      (((x) << CPU_DPLL2_EN_NEGTRIG_LSB) & CPU_DPLL2_EN_NEGTRIG_MASK)
+#define CPU_DPLL2_EN_NEGTRIG_RESET                                       0x0 // 0
+#define CPU_DPLL2_SEL_1SDM_MSB                                           17
+#define CPU_DPLL2_SEL_1SDM_LSB                                           17
+#define CPU_DPLL2_SEL_1SDM_MASK                                          0x00020000
+#define CPU_DPLL2_SEL_1SDM_GET(x)                                        (((x) & CPU_DPLL2_SEL_1SDM_MASK) >> CPU_DPLL2_SEL_1SDM_LSB)
+#define CPU_DPLL2_SEL_1SDM_SET(x)                                        (((x) << CPU_DPLL2_SEL_1SDM_LSB) & CPU_DPLL2_SEL_1SDM_MASK)
+#define CPU_DPLL2_SEL_1SDM_RESET                                         0x0 // 0
+#define CPU_DPLL2_PLL_PWD_MSB                                            16
+#define CPU_DPLL2_PLL_PWD_LSB                                            16
+#define CPU_DPLL2_PLL_PWD_MASK                                           0x00010000
+#define CPU_DPLL2_PLL_PWD_GET(x)                                         (((x) & CPU_DPLL2_PLL_PWD_MASK) >> CPU_DPLL2_PLL_PWD_LSB)
+#define CPU_DPLL2_PLL_PWD_SET(x)                                         (((x) << CPU_DPLL2_PLL_PWD_LSB) & CPU_DPLL2_PLL_PWD_MASK)
+#define CPU_DPLL2_PLL_PWD_RESET                                          0x1 // 1
+#define CPU_DPLL2_OUTDIV_MSB                                             15
+#define CPU_DPLL2_OUTDIV_LSB                                             13
+#define CPU_DPLL2_OUTDIV_MASK                                            0x0000e000
+#define CPU_DPLL2_OUTDIV_GET(x)                                          (((x) & CPU_DPLL2_OUTDIV_MASK) >> CPU_DPLL2_OUTDIV_LSB)
+#define CPU_DPLL2_OUTDIV_SET(x)                                          (((x) << CPU_DPLL2_OUTDIV_LSB) & CPU_DPLL2_OUTDIV_MASK)
+#define CPU_DPLL2_OUTDIV_RESET                                           0x0 // 0
+#define CPU_DPLL2_DELTA_MSB                                              12
+#define CPU_DPLL2_DELTA_LSB                                              7
+#define CPU_DPLL2_DELTA_MASK                                             0x00001f80
+#define CPU_DPLL2_DELTA_GET(x)                                           (((x) & CPU_DPLL2_DELTA_MASK) >> CPU_DPLL2_DELTA_LSB)
+#define CPU_DPLL2_DELTA_SET(x)                                           (((x) << CPU_DPLL2_DELTA_LSB) & CPU_DPLL2_DELTA_MASK)
+#define CPU_DPLL2_DELTA_RESET                                            0x1e // 30
+#define CPU_DPLL2_SPARE_MSB                                              6
+#define CPU_DPLL2_SPARE_LSB                                              0
+#define CPU_DPLL2_SPARE_MASK                                             0x0000007f
+#define CPU_DPLL2_SPARE_GET(x)                                           (((x) & CPU_DPLL2_SPARE_MASK) >> CPU_DPLL2_SPARE_LSB)
+#define CPU_DPLL2_SPARE_SET(x)                                           (((x) << CPU_DPLL2_SPARE_LSB) & CPU_DPLL2_SPARE_MASK)
+#define CPU_DPLL2_SPARE_RESET                                            0x0 // 0
+#define CPU_DPLL2_ADDRESS                                                0x181161c4
+
+// 32'h181161c8 (CPU_DPLL3)
+#define CPU_DPLL3_MEAS_AT_TXON_MSB                                       31
+#define CPU_DPLL3_MEAS_AT_TXON_LSB                                       31
+#define CPU_DPLL3_MEAS_AT_TXON_MASK                                      0x80000000
+#define CPU_DPLL3_MEAS_AT_TXON_GET(x)                                    (((x) & CPU_DPLL3_MEAS_AT_TXON_MASK) >> CPU_DPLL3_MEAS_AT_TXON_LSB)
+#define CPU_DPLL3_MEAS_AT_TXON_SET(x)                                    (((x) << CPU_DPLL3_MEAS_AT_TXON_LSB) & CPU_DPLL3_MEAS_AT_TXON_MASK)
+#define CPU_DPLL3_MEAS_AT_TXON_RESET                                     0x0 // 0
+#define CPU_DPLL3_DO_MEAS_MSB                                            30
+#define CPU_DPLL3_DO_MEAS_LSB                                            30
+#define CPU_DPLL3_DO_MEAS_MASK                                           0x40000000
+#define CPU_DPLL3_DO_MEAS_GET(x)                                         (((x) & CPU_DPLL3_DO_MEAS_MASK) >> CPU_DPLL3_DO_MEAS_LSB)
+#define CPU_DPLL3_DO_MEAS_SET(x)                                         (((x) << CPU_DPLL3_DO_MEAS_LSB) & CPU_DPLL3_DO_MEAS_MASK)
+#define CPU_DPLL3_DO_MEAS_RESET                                          0x0 // 0
+#define CPU_DPLL3_PHASE_SHIFT_MSB                                        29
+#define CPU_DPLL3_PHASE_SHIFT_LSB                                        23
+#define CPU_DPLL3_PHASE_SHIFT_MASK                                       0x3f800000
+#define CPU_DPLL3_PHASE_SHIFT_GET(x)                                     (((x) & CPU_DPLL3_PHASE_SHIFT_MASK) >> CPU_DPLL3_PHASE_SHIFT_LSB)
+#define CPU_DPLL3_PHASE_SHIFT_SET(x)                                     (((x) << CPU_DPLL3_PHASE_SHIFT_LSB) & CPU_DPLL3_PHASE_SHIFT_MASK)
+#define CPU_DPLL3_PHASE_SHIFT_RESET                                      0x0 // 0
+#define CPU_DPLL3_SQSUM_DVC_MSB                                          22
+#define CPU_DPLL3_SQSUM_DVC_LSB                                          3
+#define CPU_DPLL3_SQSUM_DVC_MASK                                         0x007ffff8
+#define CPU_DPLL3_SQSUM_DVC_GET(x)                                       (((x) & CPU_DPLL3_SQSUM_DVC_MASK) >> CPU_DPLL3_SQSUM_DVC_LSB)
+#define CPU_DPLL3_SQSUM_DVC_SET(x)                                       (((x) << CPU_DPLL3_SQSUM_DVC_LSB) & CPU_DPLL3_SQSUM_DVC_MASK)
+#define CPU_DPLL3_SQSUM_DVC_RESET                                        0x0 // 0
+#define CPU_DPLL3_SPARE_MSB                                              2
+#define CPU_DPLL3_SPARE_LSB                                              0
+#define CPU_DPLL3_SPARE_MASK                                             0x00000007
+#define CPU_DPLL3_SPARE_GET(x)                                           (((x) & CPU_DPLL3_SPARE_MASK) >> CPU_DPLL3_SPARE_LSB)
+#define CPU_DPLL3_SPARE_SET(x)                                           (((x) << CPU_DPLL3_SPARE_LSB) & CPU_DPLL3_SPARE_MASK)
+#define CPU_DPLL3_SPARE_RESET                                            0x0 // 0
+#define CPU_DPLL3_ADDRESS                                                0x181161c8
+
+/*
+ * Range:
+ *	0: frequency range of (530 ~ 830 MHz)/2^outdiv
+ *	1: frequency range of (350 ~ 750 MHz)/2^outdiv
+ */
+
+#if (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+#	define CPU_DPLL_40		CPU_DPLL_REFDIV_SET(0x8) | CPU_DPLL_NINT_SET(160)
+#	define CPU_DPLL_25		CPU_DPLL_REFDIV_SET(0x5) | CPU_DPLL_NINT_SET(160)
+#	define __CPU_DPLL2_VAL		CPU_DPLL2_RANGE_SET(0) | \
+					CPU_DPLL2_KI_SET(0x4) | \
+					CPU_DPLL2_KD_SET(0x10) | \
+					CPU_DPLL2_OUTDIV_SET(1) | \
+					CPU_DPLL2_DELTA_SET(0x1e)
+
+#	define DDR_DPLL_40		DDR_DPLL_REFDIV_SET(0x8) | DDR_DPLL_NINT_SET(160)
+#	define DDR_DPLL_25		DDR_DPLL_REFDIV_SET(0x5) | DDR_DPLL_NINT_SET(160)
+#	define __DDR_DPLL2_VAL		DDR_DPLL2_RANGE_SET(0) | \
+					DDR_DPLL2_KI_SET(0x4) | \
+					DDR_DPLL2_KD_SET(0x10) | \
+					DDR_DPLL2_OUTDIV_SET(1) | \
+					DDR_DPLL2_DELTA_SET(0x1e)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_535_400_200)
+#	define CPU_DPLL_40		CPU_DPLL_REFDIV_SET(0x8) | CPU_DPLL_NINT_SET(107)
+#	define CPU_DPLL_25		CPU_DPLL_REFDIV_SET(0x5) | CPU_DPLL_NINT_SET(107)
+#	define __CPU_DPLL2_VAL		CPU_DPLL2_RANGE_SET(1) | \
+					CPU_DPLL2_KI_SET(0x4) | \
+					CPU_DPLL2_KD_SET(0x10) | \
+					CPU_DPLL2_OUTDIV_SET(0) | \
+					CPU_DPLL2_DELTA_SET(0x1e)
+
+#	define DDR_DPLL_40		DDR_DPLL_REFDIV_SET(0x8) | DDR_DPLL_NINT_SET(160)
+#	define DDR_DPLL_25		DDR_DPLL_REFDIV_SET(0x5) | DDR_DPLL_NINT_SET(160)
+#	define __DDR_DPLL2_VAL		DDR_DPLL2_RANGE_SET(0) | \
+					DDR_DPLL2_KI_SET(0x4) | \
+					DDR_DPLL2_KD_SET(0x10) | \
+					DDR_DPLL2_OUTDIV_SET(1) | \
+					DDR_DPLL2_DELTA_SET(0x1e)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#	define CPU_DPLL_40		CPU_DPLL_REFDIV_SET(0x8) | CPU_DPLL_NINT_SET(112)
+#	define CPU_DPLL_25		CPU_DPLL_REFDIV_SET(0x5) | CPU_DPLL_NINT_SET(112)
+
+#	define __CPU_DPLL2_VAL		CPU_DPLL2_RANGE_SET(1) | \
+					CPU_DPLL2_KI_SET(0x4) | \
+					CPU_DPLL2_KD_SET(0x10) | \
+					CPU_DPLL2_OUTDIV_SET(0) | \
+					CPU_DPLL2_DELTA_SET(0x1e)
+
+#	define DDR_DPLL_40		DDR_DPLL_REFDIV_SET(0x8) | DDR_DPLL_NINT_SET(96)
+#	define DDR_DPLL_25		DDR_DPLL_REFDIV_SET(0x5) | DDR_DPLL_NINT_SET(96)
+#	define __DDR_DPLL2_VAL		DDR_DPLL2_RANGE_SET(1) | \
+					DDR_DPLL2_KI_SET(0x4) | \
+					DDR_DPLL2_KD_SET(0x10) | \
+					DDR_DPLL2_OUTDIV_SET(0) | \
+					DDR_DPLL2_DELTA_SET(0x1e)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_480_240)
+#	define CPU_DPLL_40		CPU_DPLL_REFDIV_SET(0x8) | CPU_DPLL_NINT_SET(160)
+#	define CPU_DPLL_25		CPU_DPLL_REFDIV_SET(0x5) | CPU_DPLL_NINT_SET(160)
+
+#	define __CPU_DPLL2_VAL		CPU_DPLL2_RANGE_SET(0) | \
+					CPU_DPLL2_KI_SET(0x4) | \
+					CPU_DPLL2_KD_SET(0x10) | \
+					CPU_DPLL2_OUTDIV_SET(1) | \
+					CPU_DPLL2_DELTA_SET(0x1e)
+
+#	define DDR_DPLL_40		DDR_DPLL_REFDIV_SET(0x8) | DDR_DPLL_NINT_SET(96)
+#	define DDR_DPLL_25		DDR_DPLL_REFDIV_SET(0x5) | DDR_DPLL_NINT_SET(96)
+#	define __DDR_DPLL2_VAL		DDR_DPLL2_RANGE_SET(1) | \
+					DDR_DPLL2_KI_SET(0x4) | \
+					DDR_DPLL2_KD_SET(0x10) | \
+					DDR_DPLL2_OUTDIV_SET(0) | \
+					DDR_DPLL2_DELTA_SET(0x1e)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_400_450_240)
+#	define CPU_DPLL_40		CPU_DPLL_REFDIV_SET(0x8) | CPU_DPLL_NINT_SET(160)
+#	define CPU_DPLL_25		CPU_DPLL_REFDIV_SET(0x5) | CPU_DPLL_NINT_SET(160)
+
+#	define __CPU_DPLL2_VAL		CPU_DPLL2_RANGE_SET(0) | \
+					CPU_DPLL2_KI_SET(0x4) | \
+					CPU_DPLL2_KD_SET(0x10) | \
+					CPU_DPLL2_OUTDIV_SET(1) | \
+					CPU_DPLL2_DELTA_SET(0x1e)
+
+#	define DDR_DPLL_40		DDR_DPLL_REFDIV_SET(0x8) | DDR_DPLL_NINT_SET(90)
+#	define DDR_DPLL_25		DDR_DPLL_REFDIV_SET(0x5) | DDR_DPLL_NINT_SET(90)
+#	define __DDR_DPLL2_VAL		DDR_DPLL2_RANGE_SET(1) | \
+					DDR_DPLL2_KI_SET(0x4) | \
+					DDR_DPLL2_KD_SET(0x10) | \
+					DDR_DPLL2_OUTDIV_SET(0) | \
+					DDR_DPLL2_DELTA_SET(0x1e)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_560_450_225)
+#	define CPU_DPLL_40		CPU_DPLL_REFDIV_SET(0x8) | CPU_DPLL_NINT_SET(112)
+#	define CPU_DPLL_25		CPU_DPLL_REFDIV_SET(0x5) | CPU_DPLL_NINT_SET(112)
+#	define __CPU_DPLL2_VAL		CPU_DPLL2_RANGE_SET(1) | \
+					CPU_DPLL2_KI_SET(0x4) | \
+					CPU_DPLL2_KD_SET(0x10) | \
+					CPU_DPLL2_OUTDIV_SET(0) | \
+					CPU_DPLL2_DELTA_SET(0x1e)
+
+#	define DDR_DPLL_40		DDR_DPLL_REFDIV_SET(0x8) | DDR_DPLL_NINT_SET(90)
+#	define DDR_DPLL_25		DDR_DPLL_REFDIV_SET(0x5) | DDR_DPLL_NINT_SET(90)
+#	define __DDR_DPLL2_VAL		DDR_DPLL2_RANGE_SET(1) | \
+					DDR_DPLL2_KI_SET(0x4) | \
+					DDR_DPLL2_KD_SET(0x10) | \
+					DDR_DPLL2_OUTDIV_SET(0) | \
+					DDR_DPLL2_DELTA_SET(0x1e)
+
+#elif (CFG_PLL_FREQ == CFG_PLL_560_400_200)
+#	define CPU_DPLL_40		CPU_DPLL_REFDIV_SET(0x8) | CPU_DPLL_NINT_SET(112)
+#	define CPU_DPLL_25		CPU_DPLL_REFDIV_SET(0x5) | CPU_DPLL_NINT_SET(112)
+#	define __CPU_DPLL2_VAL		CPU_DPLL2_RANGE_SET(1) | \
+					CPU_DPLL2_KI_SET(0x4) | \
+					CPU_DPLL2_KD_SET(0x10) | \
+					CPU_DPLL2_OUTDIV_SET(0) | \
+					CPU_DPLL2_DELTA_SET(0x1e)
+
+#	define DDR_DPLL_40		DDR_DPLL_REFDIV_SET(0x8) | DDR_DPLL_NINT_SET(160)
+#	define DDR_DPLL_25		DDR_DPLL_REFDIV_SET(0x5) | DDR_DPLL_NINT_SET(160)
+#	define __DDR_DPLL2_VAL		DDR_DPLL2_RANGE_SET(0) | \
+					DDR_DPLL2_KI_SET(0x4) | \
+					DDR_DPLL2_KD_SET(0x10) | \
+					DDR_DPLL2_OUTDIV_SET(1) | \
+					DDR_DPLL2_DELTA_SET(0x1e)
+#endif
+
+#define CPU_DPLL2_INIT			__CPU_DPLL2_VAL | CPU_DPLL2_PLL_PWD_SET(1)
+#define CPU_DPLL2_VAL			__CPU_DPLL2_VAL | CPU_DPLL2_LOCAL_PLL_SET(1)
+#define CPU_DPLL2_VAL_PWD		CPU_DPLL2_VAL | CPU_DPLL2_PLL_PWD_SET(1)
+
+#define DDR_DPLL2_INIT			__DDR_DPLL2_VAL | DDR_DPLL2_PLL_PWD_SET(1)
+#define DDR_DPLL2_VAL			__DDR_DPLL2_VAL | DDR_DPLL2_LOCAL_PLL_SET(1)
+#define DDR_DPLL2_VAL_PWD		DDR_DPLL2_VAL | DDR_DPLL2_PLL_PWD_SET(1)
+
+#endif /* _AR934X_SOC_H */
diff --git a/include/asm-mips/addrspace.h b/include/asm-mips/addrspace.h
index b8214b1c85..9fcc6bc527 100644
--- a/include/asm-mips/addrspace.h
+++ b/include/asm-mips/addrspace.h
@@ -48,7 +48,9 @@
 /* We use a 36 bit physical address map here and
    cannot access physical memory directly from core */
 #define UNCACHED_SDRAM(a) (((unsigned long)(a)) | 0x20000000)
-#else	/* !CONFIG_AU1X00 */
+#elif defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
+#define UNCACHED_SDRAM(a)   KSEG1ADDR((a))
+#else	/* !CONFIG_AR7100 */
 #define UNCACHED_SDRAM(a) PHYSADDR(a)
 #endif	/* CONFIG_AU1X00 */
 #endif	/* __ASSEMBLY__ */
diff --git a/include/asm-mips/bitops.h b/include/asm-mips/bitops.h
index 56d7225bb7..ae2693ae92 100644
--- a/include/asm-mips/bitops.h
+++ b/include/asm-mips/bitops.h
@@ -794,7 +794,7 @@ extern int find_first_zero_bit (void *addr, unsigned size);
 #endif /* (__MIPSEB__) */
 
 /* Now for the ext2 filesystem bit operations and helper routines. */
-
+#if (CONFIG_COMMANDS & CFG_CMD_EXT2)
 #ifdef __MIPSEB__
 extern __inline__ int ext2_set_bit(int nr, void * addr)
 {
@@ -908,5 +908,6 @@ found_middle:
 #define minix_test_and_clear_bit(nr,addr) test_and_clear_bit(nr,addr)
 #define minix_test_bit(nr,addr) test_bit(nr,addr)
 #define minix_find_first_zero_bit(addr,size) find_first_zero_bit(addr,size)
+#endif /* (CONFIG_COMMANDS & CFG_CMD_EXT2) */
 
 #endif /* _ASM_BITOPS_H */
diff --git a/include/atheros.h b/include/atheros.h
new file mode 100644
index 0000000000..fa258e2191
--- /dev/null
+++ b/include/atheros.h
@@ -0,0 +1,325 @@
+/*
+ * vim: tabstop=8 : noexpandtab
+ */
+#ifndef _ATHEROS_H
+#define _ATHEROS_H
+
+/*
+ * Set everything to zero. The corresponding header will
+ * undef and re-define the appropriate ones
+ */
+#define is_ar7100()	(0)
+
+#define is_ar7240()	(0)
+#define is_ar7241()	(0)
+#define is_ar7242()	(0)
+
+#define is_ar9330()	(0)
+#define is_ar933x()	(0)
+#define is_hornet()	(0)
+
+#define is_ar934x()	(0)
+#define is_wasp()	(0)
+
+#define is_qca955x()	(0)
+#define is_sco()	(0)
+
+#define is_qca953x()	(0)
+#define is_hb()		(0)
+
+#define ATH_CONSOLE_BAUD	115200
+
+#define AR7240_REV_1_2		0xc2
+
+#ifdef CONFIG_ATH_EMULATION
+#define is_emu()	(1)
+#else
+#define is_emu()	(0)
+#endif
+
+#ifdef CONFIG_F1E_PHY
+#define is_f1e()	1
+#else
+#define is_f1e()	0
+#endif
+#ifdef CONFIG_F2E_PHY
+#define is_f2e()	1
+#else
+#define is_f2e()	0
+#endif
+#ifdef CONFIG_ATHRS16_PHY
+#define is_s16()	1
+#else
+#define is_s16()	0
+#endif
+
+#ifdef CONFIG_ATHRS17_PHY
+#define is_s17()        1
+#else
+#define is_s17()        0
+#endif
+
+#ifdef CONFIG_ATHR_8033_PHY
+#define is_ar8033() 1
+#else
+#define is_ar8033() 0
+#endif
+
+#ifdef CONFIG_VIR_PHY
+#define is_vir_phy()	1
+#else
+#define is_vir_phy() 	0
+#endif
+
+
+#define ath_arch_init_irq() /* nothing */
+
+#ifndef __ASSEMBLY__
+
+int ath_uart_freq(void);
+
+typedef unsigned int ath_reg_t;
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+#endif /* __ASSEMBLY__ */
+
+#define ath_reg_rd(_phys)	(*(volatile ath_reg_t *)KSEG1ADDR(_phys))
+
+#define ath_reg_wr_nf(_phys, _val) \
+	((*(volatile ath_reg_t *)KSEG1ADDR(_phys)) = (_val))
+
+#define ath_reg_wr(_phys, _val) do {	\
+	ath_reg_wr_nf(_phys, _val);	\
+	ath_reg_rd(_phys);		\
+} while(0)
+
+#define ath_reg_rmw_set(_reg, _mask)	do {			\
+	ath_reg_wr((_reg), (ath_reg_rd((_reg)) | (_mask)));	\
+	ath_reg_rd((_reg));					\
+} while(0)
+
+#define ath_reg_rmw_clear(_reg, _mask) do {			\
+	ath_reg_wr((_reg), (ath_reg_rd((_reg)) & ~(_mask)));	\
+	ath_reg_rd((_reg));					\
+} while(0)
+
+#define ath_uart_rd(y)		ath_reg_rd((ATH_UART_BASE+y))
+#define ath_uart_wr(x, z)	ath_reg_wr((ATH_UART_BASE+x), z)
+
+#define REG_OFFSET		4
+
+#define OFS_RCV_BUFFER		(0 * REG_OFFSET)
+#define OFS_TRANS_HOLD		(0 * REG_OFFSET)
+#define OFS_SEND_BUFFER		(0 * REG_OFFSET)
+#define OFS_INTR_ENABLE		(1 * REG_OFFSET)
+#define OFS_INTR_ID		(2 * REG_OFFSET)
+#define OFS_DATA_FORMAT		(3 * REG_OFFSET)
+#define OFS_LINE_CONTROL	(3 * REG_OFFSET)
+#define OFS_MODEM_CONTROL	(4 * REG_OFFSET)
+#define OFS_RS232_OUTPUT	(4 * REG_OFFSET)
+#define OFS_LINE_STATUS		(5 * REG_OFFSET)
+#define OFS_MODEM_STATUS	(6 * REG_OFFSET)
+#define OFS_RS232_INPUT		(6 * REG_OFFSET)
+#define OFS_SCRATCH_PAD		(7 * REG_OFFSET)
+
+#define OFS_DIVISOR_LSB		(0 * REG_OFFSET)
+#define OFS_DIVISOR_MSB		(1 * REG_OFFSET)
+
+/*
+ * PLL Config for different CPU/DDR/AHB frequencies
+ */
+#define CFG_PLL_720_600_200	0x01
+#define CFG_PLL_720_680_240	0x02
+#define CFG_PLL_720_600_240	0x03
+#define CFG_PLL_680_680_226	0x04
+#define CFG_PLL_720_600_300	0x05
+#define CFG_PLL_400_400_200	0x06
+#define CFG_PLL_560_450_220	0x07
+#define CFG_PLL_550_400_200	0x08
+#define CFG_PLL_550_600_200	0x09
+#define CFG_PLL_600_600_200	0x0a
+
+#define UBOOT_SIZE                      (256 * 1024)
+#define PLL_FLASH_ADDR                  (CFG_FLASH_BASE + UBOOT_SIZE)
+#define PLL_CONFIG_VAL_F                (PLL_FLASH_ADDR + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define PLL_MAGIC                        0xaabbccdd
+#define SRIF_PLL_CONFIG_VAL_F           (PLL_CONFIG_VAL_F - 12)
+#define SRIF_PLL_MAGIC                  0x73726966 /* srif */
+
+#include <config.h>
+
+#if defined(CONFIG_MACH_AR724x)
+#	include <724x.h>
+#elif defined(CONFIG_MACH_AR933x)
+#	include <933x.h>
+#elif defined(CONFIG_MACH_AR934x)
+#	include <934x.h>
+#elif defined(CONFIG_MACH_QCA955x)
+#	include <955x.h>
+#elif defined(CONFIG_MACH_QCA953x)
+#	include <953x.h>
+#else
+#	error "Building U-Boot for unknown device"
+#endif
+
+#ifndef __ASSEMBLY__
+
+#define ATH_MEM_SDRAM		1
+#define ATH_MEM_DDR1		2
+#define ATH_MEM_DDR2		3
+/*
+ * GPIO Access & Control
+ */
+void ath_gpio_init(void);
+void ath_gpio_down(void);
+void ath_gpio_up(void);
+
+void ath_gpio_irq_init(int);
+/*
+ * GPIO Helper Functions
+ */
+void ath_gpio_enable_slic(void);
+
+/* enable UART block, takes away GPIO 10 and 9 */
+void ath_gpio_enable_uart(void);
+
+/* enable STEREO block, takes away GPIO 11,8,7, and 6 */
+void ath_gpio_enable_stereo(void);
+
+/* allow CS0/CS1 to be controlled via SPI register, takes away GPIO0/GPIO1 */
+void ath_gpio_enable_spi_cs1_cs0(void);
+
+/* allow GPIO0/GPIO1 to be used as SCL/SDA for software based i2c */
+void ath_gpio_enable_i2c_on_gpio_0_1(void);
+
+/*
+ * GPIO General Functions
+ */
+void ath_gpio_drive_low(unsigned int mask);
+void ath_gpio_drive_high(unsigned int mask);
+
+unsigned int ath_gpio_float_high_test(unsigned int mask);
+
+/* Functions to access SPI through software. Example:
+ *
+ * ath_spi_down(); ---------------------- disable others from accessing SPI bus taking semaphore
+ * ath_spi_enable_soft_access(); -------- disable HW control of SPI
+ *
+ * <board specific chip select routine>
+ *
+ * <read/write SPI using using custom routine or general purposeflash routines
+ * Custom routine may use:
+ *
+ *	ath_spi_raw_output_u8(unsigned char)
+ *	ath_spi_raw_output_u32(unsigned int)
+ *	ath_spi_raw_input_u32()
+ *
+ * General purpose flash routines:
+ *	ath_spi_flash_read_page(unsigned int addr, unsigned char *data, int len);
+ *	ath_spi_flash_write_page(unsigned int addr, unsigned char *data, int len);
+ *	ath_spi_flash_sector_erase(unsigned int addr);
+ * >
+ *
+ * <board specific chip deselect routine>
+ *
+ * ath_spi_disable_soft_acess(); ------- enable HW control of SPI bus
+ * ath_spi_up(); ----------------------- enable others to access SPI bus releasing semaphore
+ */
+void ath_spi_init(void);
+void ath_spi_down(void);
+void ath_spi_up(void);
+
+static inline void
+ath_spi_enable_soft_access(void)
+{
+	ath_reg_wr_nf(ATH_SPI_FS, 1);
+}
+
+static inline void
+ath_spi_disable_soft_access(void)
+{
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_DIS);
+	ath_reg_wr_nf(ATH_SPI_FS, 0);
+}
+
+void ath_spi_raw_output_u8(unsigned char val);
+void ath_spi_raw_output_u32(unsigned int val);
+unsigned int ath_spi_raw_input_u8(void);
+unsigned int ath_spi_raw_input_u32(void);
+
+void ath_spi_flash_read_page(unsigned int addr, unsigned char *data, int len);
+void ath_spi_flash_write_page(unsigned int addr, unsigned char *data, int len);
+void ath_spi_flash_sector_erase(unsigned int addr);
+
+/*
+ * Allow access to cs0-2 when GPIO Function enables cs0-2 through SPI register.
+ */
+static inline void
+ath_spi_enable_cs0(void)
+{
+	unsigned int cs;
+	ath_spi_down();
+	ath_spi_enable_soft_access();
+	cs = ath_reg_rd(ATH_SPI_WRITE) & ~ATH_SPI_CS_DIS;
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_ENABLE_0 | cs);
+}
+
+static inline void
+ath_spi_enable_cs1(void)
+{
+	unsigned int cs;
+#if defined(CONFIG_MACH_AR934x)	|| \
+    defined(CONFIG_MACH_QCA955x)
+	ath_spi_down();
+	ath_spi_init();
+	ath_spi_enable_soft_access();
+	cs = ath_reg_rd(ATH_SPI_WRITE) & ATH_SPI_CS_DIS;
+	ath_reg_wr_nf(ATH_SPI_WRITE, cs | ATH_SPI_CLK_HIGH);
+	cs = ath_reg_rd(ATH_SPI_WRITE) & ~ATH_SPI_CS_DIS;
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_ENABLE_1 | cs | ATH_SPI_CLK_HIGH);
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_ENABLE_1 | cs);
+#else
+	ath_spi_down();
+	ath_spi_enable_soft_access();
+	cs = ath_reg_rd(ATH_SPI_WRITE) & ~ATH_SPI_CS_DIS;
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_ENABLE_1 | cs);
+#endif
+}
+
+static inline void
+ath_spi_disable_cs(void)
+{
+	unsigned int cs = ath_reg_rd(ATH_SPI_WRITE) | ATH_SPI_CS_DIS;
+	ath_reg_wr_nf(ATH_SPI_WRITE, cs);
+	ath_spi_disable_soft_access();
+	ath_spi_up();
+}
+
+/*
+ * Example usage to access BOOT flash
+ */
+static inline void
+ath_spi_flash_cs0_sector_erase(unsigned int addr)
+{
+	ath_spi_enable_cs0();
+	ath_spi_flash_sector_erase(addr);
+	ath_spi_disable_cs();
+}
+
+static inline void
+ath_spi_flash_cs0_write_page(unsigned int addr, unsigned char *data, int len)
+{
+	ath_spi_enable_cs0();
+	ath_spi_flash_write_page(addr, data, len);
+	ath_spi_disable_cs();
+}
+
+#endif /* __ASSEMBLY__ */
+
+
+#endif /* _ATHEROS_H */
diff --git a/include/athversion.h b/include/athversion.h
new file mode 100644
index 0000000000..22e6005d22
--- /dev/null
+++ b/include/athversion.h
@@ -0,0 +1,8 @@
+#ifndef __ATHVERSION_H_
+#define __ATHVERSION_H_
+
+#define ATH_AP83_UBOOT_VERSION "0.0.12"
+#define ATH_PB45_UBOOT_VERSION "0.0.1"
+#define ATH_AP96_UBOOT_VERSION "0.0.1"
+
+#endif /* __ATHVERSION_H_ */
diff --git a/include/cmd_confdefs.h b/include/cmd_confdefs.h
index cf36583108..b98699f1e4 100644
--- a/include/cmd_confdefs.h
+++ b/include/cmd_confdefs.h
@@ -76,7 +76,8 @@
 #define CFG_CMD_HWFLOW	0x0000020000000000ULL	/* RTS/CTS hw flow control	*/
 #define CFG_CMD_SAVES	0x0000040000000000ULL	/* save S record dump		*/
 #define CFG_CMD_SPI	0x0000100000000000ULL	/* SPI utility			*/
-#define CFG_CMD_FDOS	0x0000200000000000ULL	/* Floppy DOS support		*/
+//#define CFG_CMD_FDOS	0x0000200000000000ULL	/* Floppy DOS support		*/
+#define CFG_CMD_PLL     0x0000200000000000ULL   /* Change CPU clock speeds      */
 #define CFG_CMD_VFD	0x0000400000000000ULL	/* VFD support (TRAB)		*/
 #define CFG_CMD_NAND	0x0000800000000000ULL	/* NAND support			*/
 #define CFG_CMD_BMP	0x0001000000000000ULL	/* BMP support			*/
@@ -94,12 +95,16 @@
 #define CFG_CMD_EXT2	0x1000000000000000ULL	/* EXT2 Support			*/
 #define CFG_CMD_SNTP	0x2000000000000000ULL	/* SNTP support			*/
 #define CFG_CMD_DISPLAY	0x4000000000000000ULL	/* Display support		*/
+#define CFG_CMD_ETHREG	0x8000000000000000ULL	/* S26 Reg RD/WR utility	*/
+
 
 #define CFG_CMD_ALL	0xFFFFFFFFFFFFFFFFULL	/* ALL commands			*/
 
-/* Commands that are considered "non-standard" for some reason
+/* 
+ *  Commands that are considered "non-standard" for some reason
  * (memory hogs, requires special hardware, not fully tested, etc.)
  */
+#ifndef COMPRESSED_UBOOT
 #define CFG_CMD_NONSTD (CFG_CMD_ASKENV	| \
 			CFG_CMD_BEDBUG	| \
 			CFG_CMD_BMP	| \
@@ -117,7 +122,6 @@
 			CFG_CMD_EXT2	| \
 			CFG_CMD_FDC	| \
 			CFG_CMD_FAT	| \
-			CFG_CMD_FDOS	| \
 			CFG_CMD_HWFLOW	| \
 			CFG_CMD_I2C	| \
 			CFG_CMD_IDE	| \
@@ -141,8 +145,70 @@
 			CFG_CMD_SPI	| \
 			CFG_CMD_UNIVERSE | \
 			CFG_CMD_USB	| \
+			CFG_CMD_ETHREG  | \
+			CFG_CMD_PLL     | \
+			CFG_CMD_LOADB	| \
+			CFG_CMD_LOADS	| \
+			CFG_CMD_VFD	)
+#else
+#define CFG_CMD_NONSTD (CFG_CMD_ASKENV	| \
+			CFG_CMD_BEDBUG	| \
+			CFG_CMD_BDI	| \
+			CFG_CMD_BMP	| \
+			CFG_CMD_BSP	| \
+			CFG_CMD_CACHE	| \
+			CFG_CMD_CDP	| \
+			CFG_CMD_CONSOLE	| \
+			CFG_CMD_DATE	| \
+			CFG_CMD_DHCP	| \
+			CFG_CMD_DIAG	| \
+			CFG_CMD_DISPLAY	| \
+			CFG_CMD_DOC	| \
+			CFG_CMD_DTT	| \
+			CFG_CMD_ECHO	| \
+			CFG_CMD_EEPROM	| \
+			CFG_CMD_ELF	| \
+			CFG_CMD_ENV	| \
+			CFG_CMD_EXT2	| \
+			CFG_CMD_FDC	| \
+			CFG_CMD_FAT	| \
+			CFG_CMD_FPGA	| \
+			CFG_CMD_HWFLOW	| \
+			CFG_CMD_I2C	| \
+			CFG_CMD_IDE	| \
+			CFG_CMD_IMI	| \
+			CFG_CMD_IMLS	| \
+			CFG_CMD_IMMAP	| \
+			CFG_CMD_IRQ	| \
+			CFG_CMD_ITEST	| \
+			CFG_CMD_JFFS2	| \
+			CFG_CMD_KGDB	| \
+			CFG_CMD_LOADB	| \
+			CFG_CMD_LOADS	| \
+			CFG_CMD_MISC	| \
+			CFG_CMD_MMC	| \
+			CFG_CMD_NAND	| \
+			CFG_CMD_NFS	| \
+			CFG_CMD_PCI	| \
+			CFG_CMD_PCMCIA	| \
+			CFG_CMD_PING	| \
+			CFG_CMD_PORTIO	| \
+			CFG_CMD_REGINFO	| \
+			CFG_CMD_REISER	| \
+			CFG_CMD_SAVES	| \
+			CFG_CMD_SCSI	| \
+			CFG_CMD_SETGETDCR	|\
+			CFG_CMD_SDRAM	| \
+			CFG_CMD_SNTP	| \
+			CFG_CMD_SPI	| \
+			CFG_CMD_UNIVERSE	 | \
+			CFG_CMD_USB	| \
+			CFG_CMD_XIMG	| \
+			CFG_CMD_ETHREG	| \
+			CFG_CMD_PLL     | \
 			CFG_CMD_VFD	)
 
+#endif
 /* Default configuration
  */
 #define CONFIG_CMD_DFL	(CFG_CMD_ALL & ~CFG_CMD_NONSTD)
diff --git a/include/common.h b/include/common.h
index 5d8b15628b..edcac77fbb 100644
--- a/include/common.h
+++ b/include/common.h
@@ -187,7 +187,11 @@ void	reset_cmd_timeout(void);
 /* lib_$(ARCH)/board.c */
 void	board_init_f  (ulong);
 void	board_init_r  (gd_t *, ulong);
+#ifdef COMPRESSED_UBOOT
+int	checkboard    (char *);
+#else
 int	checkboard    (void);
+#endif
 int	checkflash    (void);
 int	checkdram     (void);
 char *	strmhz(char *buf, long hz);
@@ -230,7 +234,11 @@ int env_complete(char *var, int maxv, char *cmdv[], int maxsz, char *buf);
 #endif
 
 void	pci_init      (void);
+#ifdef  COMPRESSED_UBOOT
+int	pci_init_board(void);
+#else
 void	pci_init_board(void);
+#endif /* #ifdef COMPRESSED_UBOOT */
 void	pciinfo	      (int, int);
 
 #if defined(CONFIG_PCI) && defined(CONFIG_440)
@@ -356,6 +364,7 @@ int	dcache_status (void);
 void	dcache_enable (void);
 void	dcache_disable(void);
 void	relocate_code (ulong, gd_t *, ulong);
+void 	ar7240_ddr_tap_init(void);
 ulong	get_endaddr   (void);
 void	trap_init     (ulong);
 #if defined (CONFIG_4xx)	|| \
diff --git a/include/configs/ap101-2.6.31.h b/include/configs/ap101-2.6.31.h
new file mode 100644
index 0000000000..bdfb6dd4a3
--- /dev/null
+++ b/include/configs/ap101-2.6.31.h
@@ -0,0 +1,243 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+
+#define ENABLE_DYNAMIC_CONF 1
+#define CONFIG_SUPPORT_AR7241 1
+
+#define CONFIG_AR7242_S16_PHY
+#define CONFIG_AG7240_GE0_IS_CONNECTED
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#ifndef ROOTFS
+#define ROOTFS 1
+#endif
+
+#if (ROOTFS == 2) /* make squashfs as rootfs type */
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+#else
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+
+#endif /* #if (ROOTFS == 2) */
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_200_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR values to support AR7241 */
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+//#define CFG_7241_DDR1_CONFIG_VAL      0x6fbc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+//#define CFG_7241_DDR1_MODE_VAL        0x23
+#define CFG_7241_DDR1_CONFIG2_VAL	0x9dd0e6a8
+
+
+#define CFG_7241_DDR2_CONFIG_VAL	0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT	0x133
+#define CFG_7241_DDR2_EXT_MODE_VAL	0x402
+#define CFG_7241_DDR2_MODE_VAL		0x33
+#define CFG_7241_DDR2_CONFIG2_VAL	0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR settings for AR7240 */
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#       define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#       define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL      0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada  
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.27
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9f7f1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap101-small.h b/include/configs/ap101-small.h
new file mode 100644
index 0000000000..a2e4e261a3
--- /dev/null
+++ b/include/configs/ap101-small.h
@@ -0,0 +1,243 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+
+#define ENABLE_DYNAMIC_CONF 1
+#define CONFIG_SUPPORT_AR7241 1
+
+#define CONFIG_AR7242_S16_PHY
+#define CONFIG_AG7240_GE0_IS_CONNECTED
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#ifndef ROOTFS
+#define ROOTFS 1
+#endif
+
+#if (ROOTFS == 2) /* make squashfs as rootfs type */
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+#else
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+
+#endif /* #if (ROOTFS == 2) */
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_200_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR values to support AR7241 */
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+//#define CFG_7241_DDR1_CONFIG_VAL      0x6fbc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+//#define CFG_7241_DDR1_MODE_VAL        0x23
+#define CFG_7241_DDR1_CONFIG2_VAL	0x9dd0e6a8
+
+
+#define CFG_7241_DDR2_CONFIG_VAL	0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT	0x133
+#define CFG_7241_DDR2_EXT_MODE_VAL	0x402
+#define CFG_7241_DDR2_MODE_VAL		0x33
+#define CFG_7241_DDR2_CONFIG2_VAL	0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR settings for AR7240 */
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#       define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#       define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL      0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada  
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+
+
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.1
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9f7f1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap101.h b/include/configs/ap101.h
new file mode 100644
index 0000000000..a2e4e261a3
--- /dev/null
+++ b/include/configs/ap101.h
@@ -0,0 +1,243 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+
+#define ENABLE_DYNAMIC_CONF 1
+#define CONFIG_SUPPORT_AR7241 1
+
+#define CONFIG_AR7242_S16_PHY
+#define CONFIG_AG7240_GE0_IS_CONNECTED
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#ifndef ROOTFS
+#define ROOTFS 1
+#endif
+
+#if (ROOTFS == 2) /* make squashfs as rootfs type */
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+#else
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+
+#endif /* #if (ROOTFS == 2) */
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_200_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR values to support AR7241 */
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+//#define CFG_7241_DDR1_CONFIG_VAL      0x6fbc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+//#define CFG_7241_DDR1_MODE_VAL        0x23
+#define CFG_7241_DDR1_CONFIG2_VAL	0x9dd0e6a8
+
+
+#define CFG_7241_DDR2_CONFIG_VAL	0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT	0x133
+#define CFG_7241_DDR2_EXT_MODE_VAL	0x402
+#define CFG_7241_DDR2_MODE_VAL		0x33
+#define CFG_7241_DDR2_CONFIG2_VAL	0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR settings for AR7240 */
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#       define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#       define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL      0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada  
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+
+
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.1
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9f7f1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap111-2.6.31.h b/include/configs/ap111-2.6.31.h
new file mode 100644
index 0000000000..b49d96b805
--- /dev/null
+++ b/include/configs/ap111-2.6.31.h
@@ -0,0 +1,244 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+
+#define ENABLE_DYNAMIC_CONF 1
+#define CONFIG_SUPPORT_AR7241 1
+
+#define CONFIG_AR7242_S16_PHY
+#define CONFIG_AG7240_GE0_IS_CONNECTED
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#ifndef ROOTFS
+#define ROOTFS 1
+#endif
+
+#if (ROOTFS == 2) /* make squashfs as rootfs type */
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+#else
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+
+#endif /* #if (ROOTFS == 2) */
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_200_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+
+#define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR values to support AR7241 */
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+//#define CFG_7241_DDR1_CONFIG_VAL      0x6fbc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+//#define CFG_7241_DDR1_MODE_VAL        0x23
+#define CFG_7241_DDR1_CONFIG2_VAL	0x9dd0e6a8
+
+
+#define CFG_7241_DDR2_CONFIG_VAL	0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT	0x133
+#define CFG_7241_DDR2_EXT_MODE_VAL	0x402
+#define CFG_7241_DDR2_MODE_VAL		0x33
+#define CFG_7241_DDR2_CONFIG2_VAL	0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR settings for AR7240 */
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#       define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#       define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL      0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada  
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+#define CONFIG_PCI_CONFIG_DATA_IN_OTP
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+
+
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.1
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9f7f0000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        3
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap111.h b/include/configs/ap111.h
new file mode 100644
index 0000000000..6a277418b2
--- /dev/null
+++ b/include/configs/ap111.h
@@ -0,0 +1,243 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+
+#define ENABLE_DYNAMIC_CONF 1
+#define CONFIG_SUPPORT_AR7241 1
+
+#define CONFIG_AR7242_S16_PHY
+#define CONFIG_AG7240_GE0_IS_CONNECTED
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#ifndef ROOTFS
+#define ROOTFS 1
+#endif
+
+#if (ROOTFS == 2) /* make squashfs as rootfs type */
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+#else
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+
+#endif /* #if (ROOTFS == 2) */
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_200_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR values to support AR7241 */
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+//#define CFG_7241_DDR1_CONFIG_VAL      0x6fbc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+//#define CFG_7241_DDR1_MODE_VAL        0x23
+#define CFG_7241_DDR1_CONFIG2_VAL	0x9dd0e6a8
+
+
+#define CFG_7241_DDR2_CONFIG_VAL	0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT	0x133
+#define CFG_7241_DDR2_EXT_MODE_VAL	0x402
+#define CFG_7241_DDR2_MODE_VAL		0x33
+#define CFG_7241_DDR2_CONFIG2_VAL	0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR settings for AR7240 */
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#       define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#       define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL      0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada  
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+
+
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.1
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9f3f0000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        3
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap120.h b/include/configs/ap120.h
new file mode 100644
index 0000000000..b7ae77df77
--- /dev/null
+++ b/include/configs/ap120.h
@@ -0,0 +1,476 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE		16
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if CONFIG_MI124
+#define BC "bc=mi124_f1e\0"
+#endif
+#if CONFIG_AP123
+#define BC "bc=ap123\0"
+#endif
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else	//dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, u-boot.bin)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nor0:320k(u-boot-and-env),6336k(free);ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:05"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		db12x${bc}-nand-jffs2
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#elif defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#	ifdef COMPRESSED_UBOOT
+#		define ATH_U_FILE	tuboot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f010000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+		/*
+		 * For compressed uboot, environment sector is not used.
+		 * Hence the mtd partition indices get reduced by 1.
+		 * This conflicts with
+		 *	- minor no. for /dev/caldata in
+		 *		build/scripts/{board}/dev.txt
+		 *	- root=<rooot dev> kernel cmdline parameter
+		 * Hence, doing a dummy split of the u-boot partition
+		 * to maintain the same minor no. as in the normal u-boot.
+		 */
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:32k(u-boot1),32k(u-boot2),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	else /* COMPRESSED_UBOOT */
+#		define ATH_U_FILE	u-boot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f050000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	endif /* COMPRESSED_UBOOT */
+#elif defined(CONFIG_DB12X_P2P)
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x-p2p${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		ap120-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#if (FLASH_SIZE == 16) 
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k@0xff0000(ART)"
+#else/* 8M */
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif /*CONFIG_MI124*/
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef CONFIG_ATH_NAND_SUPPORT
+#	define CFG_ENV_ADDR		0x9f040000
+#	if (FLASH_SIZE == 16)
+#		define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#	else  /* FLASH_SIZE == 16 */
+#		ifdef COMPRESSED_UBOOT
+#			if (FLASH_SIZE == 4)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else  /* FLASH_SIZE == 4 */
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#			endif  /* FLASH_SIZE == 4 */
+#		else /* COMPRESSED_UBOOT */
+#			if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#			endif
+#		endif  /* COMPRESSED_UBOOT */
+#	endif  /* FLASH_SIZE == 16 */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#define ATH_CFG_COMMANDS	(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define BOARDCAL                         (CFG_FLASH_BASE + CFG_FLASH_SIZE -0x10000)
+#define WLANCAL                         (BOARDCAL +0x1000)
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap121.h b/include/configs/ap121.h
new file mode 100644
index 0000000000..1401e30551
--- /dev/null
+++ b/include/configs/ap121.h
@@ -0,0 +1,335 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+#include <config.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ *-----------------------------------------------------------------------
+ */
+ 
+#if (FLASH_SIZE == 4)
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+
+#define ENABLE_DYNAMIC_CONF 1
+
+#else
+/* For 2 MB flash */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      32     /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00200000 /* Total flash size */
+#endif
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+
+#if (FLASH_SIZE == 4)
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),1216k(rootfs),640k(uImage),64k(NVRAM),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),1152k(rootfs),704k(uImage),64k(NVRAM),64k(ART)"
+#endif
+
+#if (BOARD_STRING == 1)
+#undef CONFIG_BOOTARGS
+#undef MTDPARTS_DEFAULT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),3008k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#endif
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_HORNET_EMU
+    #ifdef CONFIG_HORNET_EMU_HARDI_WLAN
+    #define CFG_PLL_FREQ	CFG_PLL_48_48_24
+    #else
+    #define CFG_PLL_FREQ	CFG_PLL_80_80_40
+    #endif
+#else
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+#endif
+
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#define CPU_PLL_DITHER_FRAC_VAL 0x001003e8
+#define CPU_CLK_CONTROL_VAL2 0x00008000
+
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (300000000/2)
+    #if CONFIG_40MHZ_XTAL_SUPPORT
+        #define CPU_PLL_CONFIG_VAL1 0x40813C00
+        #define CPU_PLL_CONFIG_VAL2 0x00813C00    
+    #else
+        #define CPU_PLL_CONFIG_VAL1 0x40816000
+        #define CPU_PLL_CONFIG_VAL2 0x00816000
+    #endif
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#	define CFG_HZ          (350000000/2)
+    #if CONFIG_40MHZ_XTAL_SUPPORT
+        #undef CPU_PLL_DITHER_FRAC_VAL
+        #define CPU_PLL_DITHER_FRAC_VAL 0x001803E8
+        #define CPU_PLL_CONFIG_VAL1 0x40814600
+        #define CPU_PLL_CONFIG_VAL2 0x00814600    
+    #else
+        #define CPU_PLL_CONFIG_VAL1 0x40817000
+        #define CPU_PLL_CONFIG_VAL2 0x00817000
+    #endif
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+    #if CONFIG_40MHZ_XTAL_SUPPORT
+        #define CPU_PLL_CONFIG_VAL1 0x40815000
+        #define CPU_PLL_CONFIG_VAL2 0x00815000    
+    #else
+        #define CPU_PLL_CONFIG_VAL1 0x40818000
+        #define CPU_PLL_CONFIG_VAL2 0x00818000
+    #endif
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#	define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#	define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#	define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_362_362_181)
+#	define CFG_HZ          (326500000/2)
+    #define CPU_PLL_CONFIG_VAL1 0x40817400
+    #define CPU_PLL_CONFIG_VAL2 0x00817400
+#elif (CFG_PLL_FREQ == CFG_PLL_80_80_40)
+#	define CFG_HZ          (80000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_64_64_32)
+#	define CFG_HZ          (64000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_48_48_24)
+#	define CFG_HZ          (48000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_32_32_16)
+#	define CFG_HZ          (32000000/2)
+#endif
+
+#if CONFIG_40MHZ_XTAL_SUPPORT
+    #define CPU_PLL_SETTLE_TIME_VAL    0x00000550
+#else
+    #define CPU_PLL_SETTLE_TIME_VAL    0x00000352
+#endif
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		0x10000
+
+#if (FLASH_SIZE == 4)
+    #define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else
+    #ifdef VXWORKS_UBOOT
+       #define CONFIG_BOOTCOMMAND "bootm 0x9f050000"
+    #else
+       #define CONFIG_BOOTCOMMAND "bootm 0x9f140000"
+    #endif
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#if CONFIG_40MHZ_XTAL_SUPPORT
+#define CFG_DDR_REFRESH_VAL     0x4270
+#else
+#define CFG_DDR_REFRESH_VAL     0x4186
+#endif
+#define CFG_DDR_CONFIG_VAL      0x7fbc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#	define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#	define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+//#define CFG_DDR_CONFIG2_VAL	 0x99d0e6a8     // HORNET 1.0
+#define CFG_DDR_CONFIG2_VAL	 0x9dd0e6a8         // HORNET 1.1
+
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+#ifndef CONFIG_HORNET_EMU
+#define CFG_DDR_TAP0_VAL        0x8
+#define CFG_DDR_TAP1_VAL        0x9
+#else
+#define CFG_DDR_TAP0_VAL        0x8
+#define CFG_DDR_TAP1_VAL        0x9
+#endif
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+/* DDR value from Flash */
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#ifndef COMPRESSED_UBOOT
+#	ifndef CONFIG_MACH_HORNET
+#		define CONFIG_PCI 1
+#	endif
+#else
+#	define ATH_NO_PCI_INIT
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV |	\
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_ETHREG ))
+#elif defined(VXWORKS_UBOOT)
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_MII | CFG_CMD_ELF))
+#else
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_MII))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CFG_ATHRS26_PHY  1
+
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+
+#ifdef CONFIG_HORNET_EMU
+#define CFG_AG7240_NMACS 1
+#else
+#define CFG_AG7240_NMACS 2
+#endif
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#if (FLASH_SIZE == 4)
+#define WLANCAL                        0xbf3f1000
+#define BOARDCAL                       0xbf3f0000
+#else
+#define WLANCAL                        0xbf1f1000
+#define BOARDCAL                       0xbf1f0000
+#endif
+
+#define ATHEROS_PRODUCT_ID             138
+#define CAL_SECTOR                     (CFG_MAX_FLASH_SECT - 1)
+
+/* For Kite, only PCI-e interface is valid */
+#define AR7240_ART_PCICFG_OFFSET        3
+
+
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap123.h b/include/configs/ap123.h
new file mode 100644
index 0000000000..49d187f230
--- /dev/null
+++ b/include/configs/ap123.h
@@ -0,0 +1,474 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE		8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if CONFIG_MI124
+#define BC "bc=mi124_f1e\0"
+#endif
+#if CONFIG_AP123
+#define BC "bc=ap123\0"
+#endif
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else	//dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, u-boot.bin)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nor0:320k(u-boot-and-env),6336k(free);ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:05"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		db12x${bc}-nand-jffs2
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#elif defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#	ifdef COMPRESSED_UBOOT
+#		define ATH_U_FILE	tuboot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f010000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+		/*
+		 * For compressed uboot, environment sector is not used.
+		 * Hence the mtd partition indices get reduced by 1.
+		 * This conflicts with
+		 *	- minor no. for /dev/caldata in
+		 *		build/scripts/{board}/dev.txt
+		 *	- root=<rooot dev> kernel cmdline parameter
+		 * Hence, doing a dummy split of the u-boot partition
+		 * to maintain the same minor no. as in the normal u-boot.
+		 */
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:32k(u-boot1),32k(u-boot2),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	else /* COMPRESSED_UBOOT */
+#		define ATH_U_FILE	u-boot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f050000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	endif /* COMPRESSED_UBOOT */
+#elif defined(CONFIG_DB12X_P2P)
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x-p2p${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=squashfs init=/sbin/init " MTDPARTS_DEFAULT
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef CONFIG_ATH_NAND_SUPPORT
+#	define CFG_ENV_ADDR		0x9f040000
+#	if (FLASH_SIZE == 16)
+#		define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#	else  /* FLASH_SIZE == 16 */
+#		ifdef COMPRESSED_UBOOT
+#			if (FLASH_SIZE == 4)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else  /* FLASH_SIZE == 4 */
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#			endif  /* FLASH_SIZE == 4 */
+#		else /* COMPRESSED_UBOOT */
+#			if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#			endif
+#		endif  /* COMPRESSED_UBOOT */
+#	endif  /* FLASH_SIZE == 16 */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#define ATH_CFG_COMMANDS	(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap81.h b/include/configs/ap81.h
new file mode 100644
index 0000000000..b0e1e2c410
--- /dev/null
+++ b/include/configs/ap81.h
@@ -0,0 +1,191 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7100.h>
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+
+#ifndef BUILD_CONFIG_OVERRIDE
+#	define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+#ifdef CFG_HOWL_1_2
+#define AR9100_FLASH_CONFIG  0xb80f0004
+#endif
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0xbf000000
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#ifndef BUILD_CONFIG_OVERRIDE
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7100-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7100-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#endif
+
+#undef CFG_PLL_FREQ
+#ifdef CONFIG_AP81_CUS109
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+#else
+#define CFG_PLL_FREQ	CFG_PLL_400_400_100
+#endif
+
+/* Atheros Header configuration */
+
+#ifdef CONFIG_AP81_CUS109
+#define CFG_ATHRF1_PHY  1
+#define CFG_DUAL_F1E_PHY 1
+#else
+#define CFG_ATHRS26_PHY  1
+#define CFG_ATHRHDR_REG 1
+#endif
+
+#ifdef CFG_ATHRHDR_REG
+#undef CFG_SWITCH_FREQ
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ    CFG_PLL_400_400_200
+#define CFG_ATHRHDR_EN 1
+#define ATHRHDR_LEN   2
+#define ATHRHDR_MAX_DATA  10
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0xbf040000
+#define CFG_ENV_SIZE		0x10000
+
+#ifndef BUILD_CONFIG_OVERRIDE
+#	define CONFIG_BOOTCOMMAND "bootm 0xbf550000"
+#endif
+//#define CONFIG_FLASH_16BIT
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#define CFG_DDR_REFRESH_VAL     0x4c00
+#define CFG_DDR_CONFIG_VAL      0x67bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x161
+#define CFG_DDR_EXT_MODE_VAL    0x2
+#define CFG_DDR_MODE_VAL        0x61
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#define CFG_DDR_REFRESH_VAL     0x5f00
+#define CFG_DDR_CONFIG_VAL      0x77bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x131
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x31
+#endif
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL			    0x83d1f6a2
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0xffff
+
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | \
+            CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET |\
+   CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB \
+   | CFG_CMD_ELF ))
+
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.27
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#ifdef CONFIG_AP81_CUS109
+#define CFG_PHY_ADDR            0
+#define CFG_AG7100_NMACS        2
+#define CFG_GMII                0
+#define CFG_MII0_RMII           0
+#define CFG_MII0_RGMII          1
+#define CFG_AG7100_GE0_RGMII    1
+#define CFG_AG7100_GE1_RGMII    1
+#else
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7100_NMACS 1
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+#endif
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap83.h b/include/configs/ap83.h
new file mode 100644
index 0000000000..87fe4ff5bb
--- /dev/null
+++ b/include/configs/ap83.h
@@ -0,0 +1,190 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7100.h>
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+//#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+#define CFG_FLASH_ADDR0         (0x5555)  		
+#define CFG_FLASH_ADDR1         (0x2AAA)
+
+#define CFG_HOWL_1_2 1
+
+#ifdef CFG_HOWL_1_2
+#define AR9100_FLASH_CONFIG  0xb80f0004
+#endif
+
+
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0xbf000000
+
+#undef CONFIG_ROOTFS_RD
+#undef CONFIG_ROOTFS_FLASH
+#undef CONFIG_BOOTARGS_FL
+#undef CONFIG_BOOTARGS_RD
+#undef CONFIG_BOOTARGS
+#undef  MTDPARTS_DEFAULT
+#undef  MTDIDS_DEFAULT
+
+#define CONFIG_ROOTFS_FLASH
+#define CONFIG_BOOTARGS CONFIG_BOOTARGS_FL
+
+#define CONFIG_BOOTARGS_RD     "console=ttyS0,115200 root=01:00 rd_start=0x80600000 rd_size=5242880 init=/sbin/init mtdparts=ar9100-nor0:256k(u-boot),64k(u-boot-env),4096k(rootfs),2048k(uImage)"
+
+/* XXX - putting rootfs in last partition results in jffs errors */
+
+#ifndef CFG_HOWL_1_2
+#define CONFIG_BOOTARGS_FL     "console=ttyS0,115200 root=31:00 rootfstype=jffs2 init=/sbin/init mtdparts=ar9100-nor0:4096k(rootfs),256k(u-boot),128k(u-boot-env),1024k(uImage)"
+#else
+#define CONFIG_BOOTARGS_FL     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar9100-nor0:256k(u-boot),128k(u-boot-env),4096k(rootfs),1024k(uImage)"
+#endif
+
+#define MTDPARTS_DEFAULT    "mtdparts=ar9100-nor0:4096k(rootfs),256k(u-boot),128k(u-boot-env),1024k(uImage)"
+#define MTDIDS_DEFAULT      "nor0=ar9100-nor0"
+
+
+//#define CFG_FLASH_BASE		    0xbfc00000 /* Temp WAR as remap is not on by default */
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+#	define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_360_360_180)
+#	define CFG_HZ          (360000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0xbf040000
+#define CFG_ENV_SIZE		0x20000
+
+#define CONFIG_BOOTCOMMAND "bootm 0xbf460000"
+//#define CONFIG_FLASH_16BIT
+
+/* define default CFG_PLL_FREQ for ap83 */
+#define CFG_PLL_FREQ CFG_PLL_400_400_200
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#define CFG_DDR_REFRESH_VAL     0x4c00
+#define CFG_DDR_CONFIG_VAL      0x67bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x161
+#define CFG_DDR_EXT_MODE_VAL    0x2
+#define CFG_DDR_MODE_VAL        0x61
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_360_360_180)
+#define CFG_DDR_REFRESH_VAL     0x5f00
+#define CFG_DDR_CONFIG_VAL      0x77bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x131
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x31
+#endif
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL			    0x83d1f6a2
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0xffff
+
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | \
+            CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET |\
+   CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB \
+   | CFG_CMD_ELF ))
+
+
+#define CONFIG_IPADDR		192.168.1.10
+#define CONFIG_SERVERIP		192.168.1.11
+#define CONFIG_ETHADDR		00:00:00:00:00:00
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+#define CONFIG_PHY_GIGE       1              /* GbE speed/duplex detect */
+
+//#define CFG_VSC8601_PHY
+#define CFG_VITESSE_8601_7395_PHY 1
+#define CFG_AG7100_NMACS 2
+#define CONFIG_AR9100 1
+
+/*
+ * Uncomment the #define given below for building u-boot
+ * for DNI AP83 board with vitesse switch with no phy
+ */
+// #define CFG_VITESSE_73XX_NOPHY 1
+
+//#define CFG_PHY_ADDR 0x14  /* Port 4 */
+#define CFG_PHY_ADDR 0  /* Port 4 */
+#define CFG_GMII     0
+#define CFG_MII0_RGMII             1
+#define CFG_AG7100_GE0_RGMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap91-2MB.h b/include/configs/ap91-2MB.h
new file mode 100644
index 0000000000..c0e208c603
--- /dev/null
+++ b/include/configs/ap91-2MB.h
@@ -0,0 +1,214 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ *-----------------------------------------------------------------------
+ */
+#ifndef COMPRESSED_UBOOT
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#else
+/* For 2 MB flash */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      32     /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00200000 /* Total flash size */
+#endif  /* #ifndef COMPRESSED_UBOOT */
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),1280k(rootfs),576k(uImage),64k(NVRAM),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),1280k(rootfs),576k(uImage),64k(NVRAM),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ	CFG_PLL_350_350_175
+
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#	define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#	define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#	define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#	define CFG_HZ          (420000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		0x10000
+
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else 
+#define CONFIG_BOOTCOMMAND "bootm 0x9f150000"
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#	define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#	define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_PCI 1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV |	\
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_ETHREG ))
+#else
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CFG_ATHRS26_PHY  1
+
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.1
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                        0xbfff1000
+#define BOARDCAL                       0xbfff0000
+#define ATHEROS_PRODUCT_ID             138
+#define CAL_SECTOR                     (CFG_MAX_FLASH_SECT - 1)
+
+/* For Kite, only PCI-e interface is valid */
+#define AR7240_ART_PCICFG_OFFSET        3
+
+
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap91-2x8.h b/include/configs/ap91-2x8.h
new file mode 100644
index 0000000000..0d48d387ef
--- /dev/null
+++ b/include/configs/ap91-2x8.h
@@ -0,0 +1,214 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ *-----------------------------------------------------------------------
+ */
+#ifndef COMPRESSED_UBOOT
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#else
+/* For 2 MB flash */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      32     /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00200000 /* Total flash size */
+#endif  /* #ifndef COMPRESSED_UBOOT */
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),1088k(rootfs),704k(uImage),64k(NVRAM),64k(ART) mem=8M"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),1088k(rootfs),704k(uImage),64k(NVRAM),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ	CFG_PLL_350_350_175
+
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#	define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#	define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#	define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#	define CFG_HZ          (420000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		0x10000
+
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else 
+#define CONFIG_BOOTCOMMAND "bootm 0x9f120000"
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#	define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#	define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_PCI 1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV |	\
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_ETHREG ))
+#else
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CFG_ATHRS26_PHY  1
+
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.1
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                        0xbfff1000
+#define BOARDCAL                       0xbfff0000
+#define ATHEROS_PRODUCT_ID             138
+#define CAL_SECTOR                     (CFG_MAX_FLASH_SECT - 1)
+
+/* For Kite, only PCI-e interface is valid */
+#define AR7240_ART_PCICFG_OFFSET        3
+
+
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap91-router.h b/include/configs/ap91-router.h
new file mode 100644
index 0000000000..19a03abb30
--- /dev/null
+++ b/include/configs/ap91-router.h
@@ -0,0 +1,195 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ *-----------------------------------------------------------------------
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),3136k(rootfs),768k(uImage),64k(mib0),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),2944k(rootfs),1024k(uImage),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2880k(rootfs),768k(uImage),64k(mib0),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ	CFG_PLL_350_350_175
+
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#	define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#	define CFG_HZ          (400000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		0x10000
+
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else 
+#define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_PCI 1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV |	\
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_ETHREG ))
+#else
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CFG_ATHRS26_PHY  1
+
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.1
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                        0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              138
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Kite, only PCI-e interface is valid */
+#define AR7240_ART_PCICFG_OFFSET        3
+
+
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap91.h b/include/configs/ap91.h
new file mode 100644
index 0000000000..1fb8fe65f2
--- /dev/null
+++ b/include/configs/ap91.h
@@ -0,0 +1,240 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#ifndef COMPRESSED_UBOOT
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+
+#define ENABLE_DYNAMIC_CONF 1
+#else
+/* For 2 MB flash */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      32     /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00200000 /* Total flash size */
+#endif  /* #ifndef COMPRESSED_UBOOT */
+
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),1344k(rootfs),576k(uImage),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),1344k(rootfs),576k(uImage),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ	CFG_PLL_350_350_175
+
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#	define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#	define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#	define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#	define CFG_HZ          (420000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		0x10000
+
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else 
+#define CONFIG_BOOTCOMMAND "bootm 0x9f160000"
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#	define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#	define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+/* DDR value from Flash */
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada  
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_PCI 1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV |	\
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_ETHREG ))
+#else
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CFG_ATHRS26_PHY  1
+
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.1
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                        0xbfff1000
+#define BOARDCAL                       0xbfff0000
+#define ATHEROS_PRODUCT_ID             138
+#define CAL_SECTOR                     (CFG_MAX_FLASH_SECT - 1)
+
+/* For Kite, only PCI-e interface is valid */
+#define AR7240_ART_PCICFG_OFFSET        3
+
+
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap93-hgw.h b/include/configs/ap93-hgw.h
new file mode 100644
index 0000000000..147c6d3ff7
--- /dev/null
+++ b/include/configs/ap93-hgw.h
@@ -0,0 +1,172 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+
+#ifdef S25FL128P
+	#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+	#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#else
+	#define CFG_FLASH_SECTOR_SIZE   (256*1024)
+	#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_ENV_SECT_SIZE       CFG_FLASH_SECTOR_SIZE
+#define CFG_FLASH_SIZE          0x1000000 /* Total flash size */
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0xbf000000
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#ifdef S25FL128P
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),256k(u-boot-env),3072k(rootfs),1024k(uImage),3072k(spare-rootfs),1024k(spare-uImage),64k(mib0),64k(mib1),4096k(ct),3392k(var),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),256k(u-boot-env),3072k(rootfs),1024k(uImage),3072k(spare-rootfs),1024k(spare-uImage),256k(mib0),256k(mib1),4096k(ct),2816k(var),256k(ART)"
+#endif
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#	define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0xbf040000
+#define CFG_ENV_SIZE		0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0xbf300000"
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x2
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV |	\
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_ETHREG ))
+
+#define CFG_ATHRS26_PHY  1
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.1
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                        0xbfff1000
+#define BOARDCAL                       0xbfff0000
+#define ATHEROS_PRODUCT_ID             137
+#define CAL_SECTOR                     (CFG_MAX_FLASH_SECT - 1)
+
+/* For Kite, only PCI-e interface is valid */
+#define AR7240_ART_PCICFG_OFFSET       12
+
+
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap93.h b/include/configs/ap93.h
new file mode 100644
index 0000000000..4cd295ef85
--- /dev/null
+++ b/include/configs/ap93.h
@@ -0,0 +1,166 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#	define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#	define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#	define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV |	\
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_ETHREG ))
+
+#define CFG_ATHRS26_PHY  1
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.1
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                        0xbfff1000
+#define BOARDCAL                       0xbfff0000
+#define ATHEROS_PRODUCT_ID             137
+#define CAL_SECTOR                     (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap94.h b/include/configs/ap94.h
new file mode 100644
index 0000000000..610d4ff490
--- /dev/null
+++ b/include/configs/ap94.h
@@ -0,0 +1,182 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7100.h>
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1       /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+#define CFG_FLASH_ADDR0         (0x5555)        
+#define CFG_FLASH_ADDR1         (0x2AAA)
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE          0xbf000000
+
+#undef CONFIG_ROOTFS_RD
+#undef CONFIG_ROOTFS_FLASH
+#undef CONFIG_BOOTARGS_FL
+#undef CONFIG_BOOTARGS_RD
+#undef CONFIG_BOOTARGS
+#undef  MTDPARTS_DEFAULT
+#undef  MTDIDS_DEFAULT
+
+#define CONFIG_ROOTFS_FLASH
+#define CONFIG_BOOTARGS CONFIG_BOOTARGS_FL
+
+//#define CONFIG_BOOTARGS_RD     "console=ttyS0,115200 root=01:00 rd_start=0x80600000 rd_size=5242880 init=/sbin/init mtdparts=ar9100-nor0:256k(u-boot),64k(u-boot-env),4096k(rootfs),2048k(uImage)"
+
+/* XXX - putting rootfs in last partition results in jffs errors */
+
+#define CONFIG_BOOTARGS_FL     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7100-nor0:192k(uboot),64k(env),6144k(rootfs),1728k(uImage),64k(caldata)"
+
+#define MTDPARTS_DEFAULT    "mtdparts=ar7100-nor0:192k(u-boot),64k(env),6144k(rootfs),1728k(uImage),64k(caldata)"
+#define MTDIDS_DEFAULT      "nor0=ar7100-nor0"
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define CFG_MONITOR_BASE    TEXT_BASE
+#define CFG_MONITOR_LEN     (192 << 10)
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+
+#define CFG_HZ	(680000000/2)
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT    (2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT    (2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET  0x1000
+
+#define CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        0xbf030000
+#define CFG_ENV_SIZE        0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0xbf640000"
+
+/*
+** Extra environmental variables useful for loading the board
+*/
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+"loadUboot=tftpboot 0x80010000 u-boot.bin;erase 0xbf000000 +0x30000;cp.b 0x80010000 0xbf000000 0x30000\0" \
+"loadLinux=tftpboot 0x80010000 vmlinux.gz.uImage;erase 0xbf640000 +0x120000;cp.b 0x80010000 0xbf640000 0x120000\0" \
+"loadFiles=tftpboot 0x80010000 ap94-jffs2;erase 0xbf040000 +0x600000;cp.b 0x80010000 0xbf040000 0x600000\0" \
+"loadAll=run loadUboot;run loadLinux;run loadFiles\0"
+
+#define CONFIG_NR_DRAM_BANKS    		2
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define MERLIN24CAL                     0xbfff1000
+#define MERLIN50CAL                     0xbfff5000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              136
+#define CAL_SECTOR                      127
+
+/*
+** Configure the CPU clock settings
+*/
+
+#define CFG_PLL_FREQ	CFG_PLL_680_340_170
+/*
+** These values for DDR configuration came from the
+** BDM configuration script
+*/
+
+#define CFG_DDR_REFRESH_VAL     		0x461b
+#define CFG_DDR_CONFIG_VAL      		0xefbc8cd0
+#define CFG_DDR_CONFIG2_VAL             0x8e7156a2
+#define CFG_DDR_MODE_VAL_INIT   		0x131
+#define CFG_DDR_EXT_MODE_VAL    		0x0
+#define CFG_DDR_MODE_VAL        		0x61
+#define CFG_DDR_TRTW_VAL        		0x1f
+#define CFG_DDR_TWTR_VAL        		0x1e
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0xffff
+
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL        | CFG_CMD_MII   | CFG_CMD_PING  \
+   | CFG_CMD_NET | CFG_CMD_PCI     | CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS \
+   | CFG_CMD_RUN | CFG_CMD_LOADB   | CFG_CMD_ELF | CFG_CMD_BSP ))
+
+/*
+** Ethernet Configuration
+** Set default values, and select the PHY to use
+*/
+
+#define CONFIG_IPADDR       		192.168.1.2
+#define CONFIG_SERVERIP     		192.168.1.1
+//#define CONFIG_ETHADDR      		00:03:7f:ff:ff:fe
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+#define CONFIG_PHY_GIGE       		0              /* GbE speed/duplex detect */
+
+#define CFG_ATHRS26_PHY  			1
+#define CFG_AG7100_NMACS 			2
+//#define CFG_ATHRHDR_REG 			1
+//#define CFG_SWITCH_FREQ				1
+
+//#define CFG_ATHRHDR_EN 				1
+//#define ATHRHDR_LEN   				2
+//#define ATHRHDR_MAX_DATA  			10
+
+#define CFG_PHY_ADDR				0  /* Port 4 */
+#define CFG_GMII     				0
+#define CFG_MII0_RMII				1
+#define CFG_MII1_RMII				1
+#define CFG_AG7100_GE0_RMII			1
+#define CFG_AG7100_GE1_RMII			1
+
+/*
+** Configure Parser
+*/
+
+#define CFG_BOOTM_LEN   (16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+#include <cmd_confdefs.h>
+
+#endif  /* __CONFIG_H */
diff --git a/include/configs/ap94min.h b/include/configs/ap94min.h
new file mode 100644
index 0000000000..cafed2e64b
--- /dev/null
+++ b/include/configs/ap94min.h
@@ -0,0 +1,167 @@
+/*
+ * This file contains the configuration parameters for a minimum
+ * configuration AP 94 image.  This assumes a 4 meg flash part
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7100.h>
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1       /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+#define CFG_FLASH_ADDR0         (0x5555)        
+#define CFG_FLASH_ADDR1         (0x2AAA)
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE          0xbf000000
+
+#undef CONFIG_ROOTFS_RD
+#undef CONFIG_ROOTFS_FLASH
+#undef CONFIG_BOOTARGS_FL
+#undef CONFIG_BOOTARGS_RD
+#undef CONFIG_BOOTARGS
+#undef  MTDPARTS_DEFAULT
+#undef  MTDIDS_DEFAULT
+
+#define CONFIG_ROOTFS_FLASH
+#define CONFIG_BOOTARGS CONFIG_BOOTARGS_FL
+
+//#define CONFIG_BOOTARGS_RD     "console=ttyS0,115200 root=01:00 rd_start=0x80600000 rd_size=5242880 init=/sbin/init mtdparts=ar9100-nor0:256k(u-boot),64k(u-boot-env),4096k(rootfs),2048k(uImage)"
+
+/* XXX - putting rootfs in last partition results in jffs errors */
+
+#define CONFIG_BOOTARGS_FL     "console=ttyS0,115200 root=31:01 rootfstype=jffs2 init=/sbin/init mtdparts=ar7100-nor0:256k(u-boot),2880k(rootfs),896k(uImage),64k(caldata)"
+
+#define MTDPARTS_DEFAULT    "mtdparts=ar7100-nor0:256k(u-boot),2880k(rootfs),896k(uImage),64k(caldata)"
+#define MTDIDS_DEFAULT      "nor0=ar7100-nor0"
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define CFG_MONITOR_BASE    TEXT_BASE
+#define CFG_MONITOR_LEN     (192 << 10)
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+
+#define CFG_HZ	(680000000/2)
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT    (2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT    (2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET  0x1000
+
+#define CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        0xbf030000
+#define CFG_ENV_SIZE        0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0xbf310000"
+
+#define CONFIG_NR_DRAM_BANKS    		2
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define MERLIN24CAL			0xbf3f1000
+#define MERLIN50CAL			0xbf3f5000
+#define BOARDCAL			0xbf3f0000
+#define ATHEROS_PRODUCT_ID	136
+#define CAL_SECTOR			63
+
+/*
+** Configure the CPU clock settings
+*/
+
+#define CFG_PLL_FREQ	CFG_PLL_680_340_170
+/*
+** These values for DDR configuration came from the
+** BDM configuration script
+*/
+
+#define CFG_DDR_REFRESH_VAL     		0x461b
+#define CFG_DDR_CONFIG_VAL      		0xefbc8cd0
+#define CFG_DDR_CONFIG2_VAL             0x8e7156a2
+#define CFG_DDR_MODE_VAL_INIT   		0x131
+#define CFG_DDR_EXT_MODE_VAL    		0x0
+#define CFG_DDR_MODE_VAL        		0x61
+#define CFG_DDR_TRTW_VAL        		0x1f
+#define CFG_DDR_TWTR_VAL        		0x1e
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0xffff
+
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL        | CFG_CMD_MII   | CFG_CMD_PING  \
+   | CFG_CMD_NET | CFG_CMD_PCI     | CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS \
+   | CFG_CMD_RUN | CFG_CMD_LOADB   | CFG_CMD_ELF | CFG_CMD_BSP ))
+
+/*
+** Ethernet Configuration
+** Set default values, and select the PHY to use
+*/
+
+#define CONFIG_IPADDR       		192.168.1.2
+#define CONFIG_SERVERIP     		192.168.1.1
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+#define CONFIG_PHY_GIGE       		0              /* GbE speed/duplex detect */
+
+#define CFG_ATHRS26_PHY  			1
+#define CFG_AG7100_NMACS 			2
+
+#define CFG_PHY_ADDR				0  /* Port 4 */
+#define CFG_GMII     				0
+#define CFG_MII0_RMII				1
+#define CFG_MII1_RMII				1
+#define CFG_AG7100_GE0_RMII			1
+#define CFG_AG7100_GE1_RMII			1
+
+
+/*
+** Configure Parser
+*/
+
+#define CFG_BOOTM_LEN   (16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+#include <cmd_confdefs.h>
+
+#endif  /* __CONFIG_H */
diff --git a/include/configs/ap96.h b/include/configs/ap96.h
new file mode 100644
index 0000000000..8e4e26ae68
--- /dev/null
+++ b/include/configs/ap96.h
@@ -0,0 +1,177 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7100.h>
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1       /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+#define CFG_FLASH_ADDR0         (0x5555)        
+#define CFG_FLASH_ADDR1         (0x2AAA)
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE          0xbf000000
+
+#undef CONFIG_ROOTFS_RD
+#undef CONFIG_ROOTFS_FLASH
+#undef CONFIG_BOOTARGS_FL
+#undef CONFIG_BOOTARGS_RD
+#undef CONFIG_BOOTARGS
+#undef  MTDPARTS_DEFAULT
+#undef  MTDIDS_DEFAULT
+
+#define CONFIG_ROOTFS_FLASH
+#define CONFIG_BOOTARGS CONFIG_BOOTARGS_FL
+
+//#define CONFIG_BOOTARGS_RD     "console=ttyS0,115200 root=01:00 rd_start=0x80600000 rd_size=5242880 init=/sbin/init mtdparts=ar9100-nor0:256k(u-boot),64k(u-boot-env),4096k(rootfs),2048k(uImage)"
+
+/* XXX - putting rootfs in last partition results in jffs errors */
+
+#define CONFIG_BOOTARGS_FL     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7100-nor0:192k(uboot),64k(env),6144k(rootfs),1728k(uImage),64k(caldata) mem=64M"
+
+#define MTDPARTS_DEFAULT    "mtdparts=ar7100-nor0:192k(u-boot),64k(env),6144k(rootfs),1728k(uImage),64k(caldata) mem=64M"
+#define MTDIDS_DEFAULT      "nor0=ar7100-nor0"
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define CFG_MONITOR_BASE    TEXT_BASE
+#define CFG_MONITOR_LEN     (192 << 10)
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+
+#define CFG_HZ	(680000000/2)
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT    (2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT    (2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET  0x1000
+
+#define CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        0xbf030000
+#define CFG_ENV_SIZE        0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0xbf640000"
+
+/*
+** Extra environmental variables useful for loading the board
+*/
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+"loadUboot=tftpboot 0x80010000 u-boot.bin;erase 0xbf000000 +0x30000;cp.b 0x80010000 0xbf000000 0x30000\0" \
+"loadLinux=tftpboot 0x80010000 vmlinux.gz.uImage;erase 0xbf640000 +0x120000;cp.b 0x80010000 0xbf640000 0x120000\0" \
+"loadFiles=tftpboot 0x80010000 ap96-jffs2;erase 0xbf040000 +0x600000;cp.b 0x80010000 0xbf040000 0x600000\0" \
+"loadAll=run loadUboot;run loadLinux;run loadFiles\0"
+
+#define CONFIG_NR_DRAM_BANKS    		2
+
+#define CFG_BOARD_AP96 1
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define MERLIN24CAL                     0xbfff1000
+#define MERLIN50CAL                     0xbfff5000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              145
+#define CAL_SECTOR                      127
+
+/*
+** Configure the CPU clock settings
+*/
+
+#define CFG_PLL_FREQ	CFG_PLL_680_340_170
+/*
+** These values for DDR configuration came from the
+** BDM configuration script
+*/
+
+#define CFG_DDR_REFRESH_VAL     		0x461b
+#define CFG_DDR_CONFIG_VAL      		0x77b8884e
+#define CFG_DDR_CONFIG2_VAL             0x812cd6a8
+#define CFG_DDR_MODE_VAL_INIT   		0x131
+#define CFG_DDR_EXT_MODE_VAL    		0x0
+#define CFG_DDR_MODE_VAL        		0x33
+#define CFG_DDR_TRTW_VAL        		0x1f
+#define CFG_DDR_TWTR_VAL        		0x1e
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  	0xff
+
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL        | CFG_CMD_MII   | CFG_CMD_PING  \
+   | CFG_CMD_NET | CFG_CMD_PCI     | CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS \
+   | CFG_CMD_RUN | CFG_CMD_LOADB   | CFG_CMD_ELF | CFG_CMD_BSP ))
+
+/*
+** Ethernet Configuration
+** Set default values, and select the PHY to use
+*/
+
+#define CONFIG_IPADDR       		192.168.1.2
+#define CONFIG_SERVERIP     		192.168.1.1
+//#define CONFIG_ETHADDR      		00:03:7f:ff:ff:fe
+//#define CFG_FAULT_ECHO_LINK_DOWN    1
+#define CONFIG_PHY_GIGE       		1              /* GbE speed/duplex detect */
+
+#define CFG_ATHRS16_PHY  			1
+#define CFG_AG7100_NMACS 			2
+
+#define CFG_PHY_ADDR				0  /* Port 4 */
+#define CFG_GMII 1
+#define CFG_MII0_RGMII 0
+#define CFG_AG7100_GE0_RGMII 1
+#define CFG_AG7100_GE1_RGMII 1
+
+/*
+** Configure Parser
+*/
+
+#define CFG_BOOTM_LEN   (16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+#include <cmd_confdefs.h>
+
+#endif  /* __CONFIG_H */
diff --git a/include/configs/ap98.h b/include/configs/ap98.h
new file mode 100644
index 0000000000..ade507cf32
--- /dev/null
+++ b/include/configs/ap98.h
@@ -0,0 +1,278 @@
+/*
+ * This file contains the configuration parameters for the ap98 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if (FLASH_SIZE == 16)
+#undef COMPRESSED_UBOOT
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_SUPPORT_AR7241 1
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),256k(u-boot-env),3072k(rootfs),1024k(uImage),3072k(spare-rootfs),1024k(spare-uImage),64k(mib0),64k(mib1),4096k(ct),3392k(var),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=4M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),3136k(rootfs),768k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),3136k(rootfs),768k(uImage),64k(mib0),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_200_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else
+#ifdef COMPRESSED_UBOOT
+#define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#endif
+#endif
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR values to support AR7241 */
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+//#define CFG_7241_DDR1_CONFIG_VAL      0x6fbc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+//#define CFG_7241_DDR1_MODE_VAL        0x23
+#define CFG_7241_DDR1_CONFIG2_VAL	0x9dd0e6a8
+
+
+#define CFG_7241_DDR2_CONFIG_VAL	0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT	0x133
+#define CFG_7241_DDR2_EXT_MODE_VAL	0x402
+#define CFG_7241_DDR2_MODE_VAL		0x33
+#define CFG_7241_DDR2_CONFIG2_VAL	0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR settings for AR7240 */
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL      0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada  
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CFG_ATHRS26_PHY  1
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+#define SUPPORT_PLC                     1
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap99-2.6.31.h b/include/configs/ap99-2.6.31.h
new file mode 100644
index 0000000000..283aeebcc5
--- /dev/null
+++ b/include/configs/ap99-2.6.31.h
@@ -0,0 +1,259 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#define ENABLE_DYNAMIC_CONF 1
+#define CONFIG_SUPPORT_AR7241 1
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+#undef MTDPARTS_DEFAULT
+
+#ifdef COMPRESSED_UBOOT
+#	if (FLASH_SIZE == 8)
+#		define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),5376k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#		define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT " REVISIONID"
+#	else
+#		define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),3008k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#		define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT " REVISIONID"
+#	endif
+#else
+#	if (FLASH_SIZE == 8)
+#		define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#		define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT " REVISIONID"
+#	else
+#		define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#		define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT " REVISIONID"
+#	endif
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241
+#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_200_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR values to support AR7241 */
+
+#ifdef CONFIG_SUPPORT_AR7241
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+//#define CFG_7241_DDR1_CONFIG_VAL      0x6fbc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+//#define CFG_7241_DDR1_MODE_VAL        0x23
+#define CFG_7241_DDR1_CONFIG2_VAL	0x9dd0e6a8
+
+
+#define CFG_7241_DDR2_CONFIG_VAL	0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT	0x133
+#define CFG_7241_DDR2_EXT_MODE_VAL	0x402
+#define CFG_7241_DDR2_MODE_VAL		0x33
+#define CFG_7241_DDR2_CONFIG2_VAL	0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR settings for AR7240 */
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#       define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#       define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL      0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada  
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+
+#define CFG_ATHRS26_PHY  1
+
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.1
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+#define CFG_ATHRS26_PHY 1
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap99-hgw.h b/include/configs/ap99-hgw.h
new file mode 100644
index 0000000000..a0a71795cf
--- /dev/null
+++ b/include/configs/ap99-hgw.h
@@ -0,0 +1,274 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if (FLASH_SIZE == 16)
+#undef COMPRESSED_UBOOT
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_SUPPORT_AR7241 1
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),256k(u-boot-env),3072k(rootfs),1024k(uImage),3072k(spare-rootfs),1024k(spare-uImage),64k(mib0),64k(mib1),4096k(ct),3392k(var),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=4M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),3008k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),3008k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#endif
+#endif
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_200_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#endif
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR values to support AR7241 */
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+//#define CFG_7241_DDR1_CONFIG_VAL      0x6fbc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+//#define CFG_7241_DDR1_MODE_VAL        0x23
+#define CFG_7241_DDR1_CONFIG2_VAL	0x9dd0e6a8
+
+
+#define CFG_7241_DDR2_CONFIG_VAL	0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT	0x133
+#define CFG_7241_DDR2_EXT_MODE_VAL	0x402
+#define CFG_7241_DDR2_MODE_VAL		0x33
+#define CFG_7241_DDR2_CONFIG2_VAL	0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR settings for AR7240 */
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL      0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada  
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CFG_ATHRS26_PHY  1
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.20
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap99-ivi.h b/include/configs/ap99-ivi.h
new file mode 100644
index 0000000000..92176ab8d5
--- /dev/null
+++ b/include/configs/ap99-ivi.h
@@ -0,0 +1,272 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if (FLASH_SIZE == 16)
+#undef COMPRESSED_UBOOT
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_SUPPORT_AR7241 1
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),256k(u-boot-env),3072k(rootfs),1024k(uImage),3072k(spare-rootfs),1024k(spare-uImage),64k(mib0),64k(mib1),4096k(ct),3392k(var),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=4M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),3008k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),3008k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#endif
+#endif
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_200_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#endif
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR values to support AR7241 */
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+//#define CFG_7241_DDR1_CONFIG_VAL      0x6fbc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+//#define CFG_7241_DDR1_MODE_VAL        0x23
+#define CFG_7241_DDR1_CONFIG2_VAL	0x9dd0e6a8
+
+
+#define CFG_7241_DDR2_CONFIG_VAL	0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT	0x133
+#define CFG_7241_DDR2_EXT_MODE_VAL	0x402
+#define CFG_7241_DDR2_MODE_VAL		0x33
+#define CFG_7241_DDR2_CONFIG2_VAL	0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR settings for AR7240 */
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL      0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada  
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.20
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap99-small.h b/include/configs/ap99-small.h
new file mode 100644
index 0000000000..75c124e4e1
--- /dev/null
+++ b/include/configs/ap99-small.h
@@ -0,0 +1,247 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#define ENABLE_DYNAMIC_CONF 1
+#define CONFIG_SUPPORT_AR7241 1
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#if (FLASH_SIZE == 8)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),896k(uImage),64k(NVRAM),1792k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+#endif
+
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_200_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+
+#if (FLASH_SIZE == 8)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#endif
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR values to support AR7241 */
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+//#define CFG_7241_DDR1_CONFIG_VAL      0x6fbc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+//#define CFG_7241_DDR1_MODE_VAL        0x23
+#define CFG_7241_DDR1_CONFIG2_VAL	0x9dd0e6a8
+
+
+#define CFG_7241_DDR2_CONFIG_VAL	0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT	0x133
+#define CFG_7241_DDR2_EXT_MODE_VAL	0x402
+#define CFG_7241_DDR2_MODE_VAL		0x33
+#define CFG_7241_DDR2_CONFIG2_VAL	0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR settings for AR7240 */
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#       define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#       define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL      0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada  
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+
+#define CFG_ATHRS26_PHY  1
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.1
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ap99.h b/include/configs/ap99.h
new file mode 100644
index 0000000000..7663336c95
--- /dev/null
+++ b/include/configs/ap99.h
@@ -0,0 +1,278 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if (FLASH_SIZE == 16)
+#undef COMPRESSED_UBOOT
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_SUPPORT_AR7241 1
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),256k(u-boot-env),3072k(rootfs),1024k(uImage),3072k(spare-rootfs),1024k(spare-uImage),64k(mib0),64k(mib1),4096k(ct),3392k(var),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=4M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),3136k(rootfs),768k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),3136k(rootfs),768k(uImage),64k(mib0),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_200_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else
+#ifdef COMPRESSED_UBOOT
+#define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#endif
+#endif
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR values to support AR7241 */
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+//#define CFG_7241_DDR1_CONFIG_VAL      0x6fbc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+//#define CFG_7241_DDR1_MODE_VAL        0x23
+#define CFG_7241_DDR1_CONFIG2_VAL	0x9dd0e6a8
+
+
+#define CFG_7241_DDR2_CONFIG_VAL	0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT	0x133
+#define CFG_7241_DDR2_EXT_MODE_VAL	0x402
+#define CFG_7241_DDR2_MODE_VAL		0x33
+#define CFG_7241_DDR2_CONFIG2_VAL	0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR settings for AR7240 */
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL      0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada  
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CFG_ATHRS26_PHY  1
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/aph126.h b/include/configs/aph126.h
new file mode 100644
index 0000000000..e8382bb064
--- /dev/null
+++ b/include/configs/aph126.h
@@ -0,0 +1,421 @@
+/*
+ * This file contains the configuration parameters for the db120 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if !defined(CONFIG_ATH_NAND_BR)
+#define FLASH_SIZE 16
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* Assuming nand flash wouldn't use compressed u-boot */
+#ifdef CONFIG_ATH_NAND_BR
+#	define CFG_FLASH_BASE			0
+#else
+	/*
+	 * We boot from this flash
+	 */
+#	define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        (CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#define CFG_ENV_SIZE        CFG_FLASH_SECTOR_SIZE
+
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),8192k(reserve),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=8M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif
+
+#if (FLASH_SIZE == 16)
+#define CFG_KERNEL_ADDR 0x9f680000
+#else
+#define CFG_KERNEL_ADDR 0x9f680000
+#endif
+#define CFG_MIB0_ADDR		0x9ffe0000
+
+#define CONFIG_BOOTCOMMAND "bootm ${KERNELADDR}"
+
+#ifndef CFG_LOAD_ADDR
+#define CFG_LOAD_ADDR		0x80060000
+#endif
+#ifndef COMPRESSED_UBOOT
+#define CFG_FS_ADDR			0x9f050000//(CFG_ENV_ADDR+CFG_ENV_SIZE)
+#else
+#define CFG_FS_ADDR			0x9f010000//(CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#endif /* COMPRESSED_UBOOT */
+#define ENV_FS_ADDR			"FSADDR=" MK_STR(CFG_FS_ADDR) "\0"
+
+#define ENV_UBOOT_ADDR		"UBOOTADDR=" MK_STR(CFG_FLASH_BASE) "\0"
+#define ENV_KERNEL_ADDR		"KERNELADDR=" MK_STR(CFG_KERNEL_ADDR) "\0"
+#define ENV_MIB0_ADDR		"MIB0ADDR=" MK_STR(CFG_MIB0_ADDR) "\0"
+
+#define ENV_UPDATE \
+    "update=tftpboot " MK_STR(CFG_LOAD_ADDR) " ${filename} && "	\
+            "erase ${loadaddr} +${filesize} && "				\
+            "cp.b ${fileaddr} ${loadaddr} ${filesize}\0"
+
+#define ENV_UPDATE_KERNEL \
+    "updk=loadaddr=${KERNELADDR} && filename=zImage.uImage && " \
+    "run update\0"
+
+#define ENV_UPDATE_FS \
+    "updfs=loadaddr=${FSADDR} && filename=rootfs-jffs2 && " \
+    "run update\0"
+
+#ifdef COMPRESSED_UBOOT
+#define UBOOT_FILENAME "tuboot.bin"
+#else
+#define UBOOT_FILENAME "u-boot.bin"
+#endif
+
+#define ENV_UPDATE_UBOOT \
+    "updub=loadaddr=${UBOOTADDR} && filename=" UBOOT_FILENAME " && " \
+    "run update\0"
+
+#define ENV_UPDATE_ALL \
+	"updall=run updub && run updfs && run updk\0"
+
+#define ENV_ERASE_MIB0 \
+	"erasemib0=erase ${MIB0ADDR} +0x10000"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		ENV_UBOOT_ADDR \
+		ENV_FS_ADDR \
+		ENV_KERNEL_ADDR \
+		ENV_MIB0_ADDR \
+		ENV_UPDATE \
+		ENV_UPDATE_KERNEL \
+		ENV_UPDATE_FS \
+		ENV_UPDATE_UBOOT \
+		ENV_UPDATE_ALL \
+		ENV_ERASE_MIB0 \
+		""
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET 0xbd007000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+#if 0
+#ifdef CONFIG_ATH_NAND_BR
+#define CONFIG_BOOTCOMMAND "bootm 0x80000"
+#define CFG_ENV_ADDR		0x00040000
+#else  /* CONFIG_ATH_NAND_BR */
+#define CFG_ENV_ADDR		0x9f040000
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else  /* FLASH_SIZE == 16 */
+#ifdef COMPRESSED_UBOOT
+#if (FLASH_SIZE == 4)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else  /* FLASH_SIZE == 4 */
+#define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#endif  /* FLASH_SIZE == 4 */
+#else /* COMPRESSED_UBOOT */
+#if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#endif
+#endif  /* COMPRESSED_UBOOT */
+#endif  /* FLASH_SIZE == 16 */
+#endif  /* CONFIG_ATH_NAND_BR */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/aph128.h b/include/configs/aph128.h
new file mode 100644
index 0000000000..e8382bb064
--- /dev/null
+++ b/include/configs/aph128.h
@@ -0,0 +1,421 @@
+/*
+ * This file contains the configuration parameters for the db120 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if !defined(CONFIG_ATH_NAND_BR)
+#define FLASH_SIZE 16
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* Assuming nand flash wouldn't use compressed u-boot */
+#ifdef CONFIG_ATH_NAND_BR
+#	define CFG_FLASH_BASE			0
+#else
+	/*
+	 * We boot from this flash
+	 */
+#	define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        (CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#define CFG_ENV_SIZE        CFG_FLASH_SECTOR_SIZE
+
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),8192k(reserve),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=8M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif
+
+#if (FLASH_SIZE == 16)
+#define CFG_KERNEL_ADDR 0x9f680000
+#else
+#define CFG_KERNEL_ADDR 0x9f680000
+#endif
+#define CFG_MIB0_ADDR		0x9ffe0000
+
+#define CONFIG_BOOTCOMMAND "bootm ${KERNELADDR}"
+
+#ifndef CFG_LOAD_ADDR
+#define CFG_LOAD_ADDR		0x80060000
+#endif
+#ifndef COMPRESSED_UBOOT
+#define CFG_FS_ADDR			0x9f050000//(CFG_ENV_ADDR+CFG_ENV_SIZE)
+#else
+#define CFG_FS_ADDR			0x9f010000//(CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#endif /* COMPRESSED_UBOOT */
+#define ENV_FS_ADDR			"FSADDR=" MK_STR(CFG_FS_ADDR) "\0"
+
+#define ENV_UBOOT_ADDR		"UBOOTADDR=" MK_STR(CFG_FLASH_BASE) "\0"
+#define ENV_KERNEL_ADDR		"KERNELADDR=" MK_STR(CFG_KERNEL_ADDR) "\0"
+#define ENV_MIB0_ADDR		"MIB0ADDR=" MK_STR(CFG_MIB0_ADDR) "\0"
+
+#define ENV_UPDATE \
+    "update=tftpboot " MK_STR(CFG_LOAD_ADDR) " ${filename} && "	\
+            "erase ${loadaddr} +${filesize} && "				\
+            "cp.b ${fileaddr} ${loadaddr} ${filesize}\0"
+
+#define ENV_UPDATE_KERNEL \
+    "updk=loadaddr=${KERNELADDR} && filename=zImage.uImage && " \
+    "run update\0"
+
+#define ENV_UPDATE_FS \
+    "updfs=loadaddr=${FSADDR} && filename=rootfs-jffs2 && " \
+    "run update\0"
+
+#ifdef COMPRESSED_UBOOT
+#define UBOOT_FILENAME "tuboot.bin"
+#else
+#define UBOOT_FILENAME "u-boot.bin"
+#endif
+
+#define ENV_UPDATE_UBOOT \
+    "updub=loadaddr=${UBOOTADDR} && filename=" UBOOT_FILENAME " && " \
+    "run update\0"
+
+#define ENV_UPDATE_ALL \
+	"updall=run updub && run updfs && run updk\0"
+
+#define ENV_ERASE_MIB0 \
+	"erasemib0=erase ${MIB0ADDR} +0x10000"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		ENV_UBOOT_ADDR \
+		ENV_FS_ADDR \
+		ENV_KERNEL_ADDR \
+		ENV_MIB0_ADDR \
+		ENV_UPDATE \
+		ENV_UPDATE_KERNEL \
+		ENV_UPDATE_FS \
+		ENV_UPDATE_UBOOT \
+		ENV_UPDATE_ALL \
+		ENV_ERASE_MIB0 \
+		""
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET 0xbd007000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+#if 0
+#ifdef CONFIG_ATH_NAND_BR
+#define CONFIG_BOOTCOMMAND "bootm 0x80000"
+#define CFG_ENV_ADDR		0x00040000
+#else  /* CONFIG_ATH_NAND_BR */
+#define CFG_ENV_ADDR		0x9f040000
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else  /* FLASH_SIZE == 16 */
+#ifdef COMPRESSED_UBOOT
+#if (FLASH_SIZE == 4)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else  /* FLASH_SIZE == 4 */
+#define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#endif  /* FLASH_SIZE == 4 */
+#else /* COMPRESSED_UBOOT */
+#if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#endif
+#endif  /* COMPRESSED_UBOOT */
+#endif  /* FLASH_SIZE == 16 */
+#endif  /* CONFIG_ATH_NAND_BR */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/aph131.h b/include/configs/aph131.h
new file mode 100644
index 0000000000..347c4225fb
--- /dev/null
+++ b/include/configs/aph131.h
@@ -0,0 +1,321 @@
+#ifndef __BOARD_955X_H
+#define __BOARD_955X_H
+
+#include <config.h>
+
+#undef MTDPARTS_DEFAULT
+
+#undef CFG_HZ
+
+#include <atheros.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE 8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT	256	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"8256k(mib0)"
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT	128	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"64k(mib0)"
+#else
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"64k(mib0)"
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE	(64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE		0x01000000	/* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE		0x00800000	/* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE		0x00400000	/* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF	1
+#endif
+
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE	unsigned short
+
+#if defined(CONFIG_ATH_NAND_BR) && defined(COMPRESSED_UBOOT)
+#define CFG_FLASH_BASE			0xa0100000
+#else
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE		CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE	BOOTSTRAP_TEXT_BASE
+#endif
+
+#define CONFIG_PCI_CONFIG_DATA_IN_OTP
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE		(256 * 1024)
+#define UBOOT_ENV_SEC_START		(CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC			0xaabacada
+#define CFG_FLASH_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F		(CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F		CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F		CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+#define CFG_DDR_REFRESH_VAL		0x4138
+
+/*
+ * The following #defines are needed to get flash environment right
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#define __fs_name(x, y)		x ## y
+#define _fs_name(x, y)		__fs_name(x, y)
+#define fs_name(y)		_fs_name(__CONFIG_BOARD_NAME, y)
+
+#ifdef COMPRESSED_UBOOT
+#	define ATH_U_FILE	tuboot.bin
+#else
+#	define ATH_U_FILE	u-boot.bin
+#endif
+
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		if defined(COMPRESSED_UBOOT)
+#			define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x20000)
+#			define MTDPARTS_DEFAULT	"mtdparts=ath-nand:128k(u-boot),384k(free),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		else
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		endif
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else //dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nor0:320k(u-boot-and-env),6336k(free);ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:05"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		fs_name(${bc}-nand-jffs2)
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#else
+#	define ATH_F_FILE		rootfs-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage)," ATH_MTDPARTS_MIB0 ",64k(ART)"
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(updub, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(updfs, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(updk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define ENV_UPDATE_ALL \
+   "updall=run updub && run updfs && run updk\0"
+
+#define CFG_MIB0_ADDR       0x9f7e0000
+#define ENV_MIB0_ADDR       "MIB0ADDR=" MK_STR(CFG_MIB0_ADDR) "\0"
+#define ENV_ERASE_MIB0 \
+   "erasemib0=erase ${MIB0ADDR} +0x10000\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+    ENV_MIB0_ADDR \
+    ENV_ERASE_MIB0 \
+    ENV_UPDATE_ALL \
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT
+
+//#define CFG_PLL_FREQ    CFG_PLL_720_600_200
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET	0xbd007000
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#else
+#	define CFG_ENV_ADDR		0x9f040000
+#	define CONFIG_BOOTCOMMAND	"bootm 0x9f680000"
+#endif
+
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC		0xaabacada
+#define CFG_DDR_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#	ifdef CONFIG_ATH_NAND_BR
+#		define ATH_CFG_COMMANDS		((			\
+						CONFIG_CMD_DFL	|	\
+						CFG_CMD_PING	|	\
+						CFG_CMD_NET) & ~(	\
+						CFG_CMD_FLASH		\
+						))
+#	else
+#		define ATH_CFG_COMMANDS		(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#	endif
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL				0x9fff1000
+#define BOARDCAL			0x9fff0000
+#define ATHEROS_PRODUCT_ID		137
+#define CAL_SECTOR			(CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define ATH_ART_PCICFG_OFFSET		12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __BOARD_955X_H */
diff --git a/include/configs/ar7100.h b/include/configs/ar7100.h
new file mode 100644
index 0000000000..8f472d0030
--- /dev/null
+++ b/include/configs/ar7100.h
@@ -0,0 +1,100 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __AR7100_H
+#define __AR7100_H
+#include <config.h>
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core	*/
+
+#define CONFIG_BOOTDELAY	4	/* autoboot after 4 seconds	*/
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE  { 	115200}
+
+#define	CONFIG_TIMESTAMP		/* Print image info with timestamp */
+
+#define CONFIG_ROOTFS_RD
+
+#define	CONFIG_BOOTARGS_RD     "console=ttyS0,115200 root=01:00 rd_start=0x80600000 rd_size=5242880 init=/sbin/init mtdparts=ar7100-nor0:256k(u-boot),64k(u-boot-env),4096k(rootfs),2048k(uImage)"
+
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS_FL     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7100-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),2048k(uImage)"
+
+#ifndef BUILD_CONFIG_OVERRIDE
+#ifdef CONFIG_ROOTFS_FLASH
+#define CONFIG_BOOTARGS CONFIG_BOOTARGS_FL
+#else
+#define CONFIG_BOOTARGS ""
+#endif
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"ar7100> "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		512		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+//#define CFG_SDRAM_BASE		0xa0000000     /* Cached addr */
+
+#define	CFG_LOAD_ADDR		0x81000000     /* default load address	*/
+//#define	CFG_LOAD_ADDR		0xa1000000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#undef CFG_MEMTEST_START
+#define CFG_MEMTEST_START       0x80200000
+#define CFG_MEMTEST_END		0x83800000
+
+/*------------------------------------------------------------------------
+ * *  * JFFS2
+ */
+#define CFG_JFFS_CUSTOM_PART            /* board defined part   */
+#define CONFIG_JFFS2_CMDLINE
+#define MTDIDS_DEFAULT      "nor0=ar7100-nor0"
+
+#ifndef BUILD_CONFIG_OVERRIDE
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7100-nor0:256k(u-boot),"\
+                            "384k(experi-jffs2)"
+#endif
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#define CFG_HZ          40000000
+
+#define CFG_RX_ETH_BUFFER   16
+
+/*
+** PLL Config for different CPU/DDR/AHB frequencies
+*/
+
+#define CFG_PLL_200_200_100   0
+#define CFG_PLL_300_300_150   1
+#define CFG_PLL_333_333_166   2
+#define CFG_PLL_266_266_133   3
+#define CFG_PLL_266_266_66    4
+#define CFG_PLL_400_400_200   5
+#define CFG_PLL_360_360_180   6
+#define CFG_PLL_400_400_100   7
+#define CFG_PLL_680_340_170	  8
+#define CFG_PLL_600_300_150   9
+
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		32768
+#define CFG_ICACHE_SIZE		65536
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ar7240.h b/include/configs/ar7240.h
new file mode 100644
index 0000000000..d29cc33500
--- /dev/null
+++ b/include/configs/ar7240.h
@@ -0,0 +1,153 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __AR7240_H
+#define __AR7240_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core	*/
+
+#define CONFIG_BOOTDELAY	4	/* autoboot after 4 seconds	*/
+
+#define CONFIG_BAUDRATE		115200 
+#define CFG_BAUDRATE_TABLE  { 	115200}
+
+#define	CONFIG_TIMESTAMP		/* Print image info with timestamp */
+
+#define CONFIG_ROOTFS_RD
+
+#define	CONFIG_BOOTARGS_RD     "console=ttyS0,115200 root=01:00 rd_start=0x80600000 rd_size=5242880 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),4096k(rootfs),2048k(uImage)"
+
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS_FL     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),2048k(uImage)"
+
+#ifdef CONFIG_ROOTFS_FLASH
+#define CONFIG_BOOTARGS CONFIG_BOOTARGS_FL
+#else
+#define CONFIG_BOOTARGS ""
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"ar7240> "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		512		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+//#define CFG_SDRAM_BASE		0xa0000000     /* Cached addr */
+
+#define	CFG_LOAD_ADDR		0x81000000     /* default load address	*/
+//#define	CFG_LOAD_ADDR		0xa1000000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#undef CFG_MEMTEST_START
+#define CFG_MEMTEST_START       0x80200000
+#define CFG_MEMTEST_END		0x83800000
+
+/*------------------------------------------------------------------------
+ * *  * JFFS2
+ */
+#define CFG_JFFS_CUSTOM_PART            /* board defined part   */
+#define CONFIG_JFFS2_CMDLINE
+#define MTDIDS_DEFAULT      "nor0=ar7240-nor0"
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#ifdef CONFIG_HORNET_EMU_HARDI_WLAN
+#define CFG_HZ          24000000
+#else
+#define CFG_HZ          40000000
+#endif
+
+#define CFG_RX_ETH_BUFFER   16
+
+/*
+** PLL Config for different CPU/DDR/AHB frequencies
+*/
+
+#define CFG_PLL_200_200_100		0x00
+#define CFG_PLL_300_300_150		0x01
+#define CFG_PLL_320_320_160		0x02
+#define CFG_PLL_340_340_170		0x03
+#define CFG_PLL_350_350_175		0x04
+#define CFG_PLL_360_360_180		0x05
+#define CFG_PLL_400_400_200		0x06
+#define CFG_PLL_300_300_75		0x07
+#define CFG_PLL_400_400_100		0x08
+#define CFG_PLL_320_320_80		0x09
+#define CFG_PLL_410_400_200		0x0a
+#define CFG_PLL_420_400_200		0x0b
+#define CFG_PLL_80_80_40		0x0c
+#define CFG_PLL_64_64_32		0x0d
+#define CFG_PLL_48_48_24		0x0e
+#define CFG_PLL_32_32_16		0x0f
+#define CFG_PLL_333_333_166		0x10
+#define CFG_PLL_266_266_133		0x11
+#define CFG_PLL_266_266_66		0x12
+#define CFG_PLL_240_240_120		0x13
+#define CFG_PLL_160_160_80		0x14
+#define CFG_PLL_400_200_200		0x15
+#define CFG_PLL_500_400_200		0x16
+#define CFG_PLL_600_400_200		0x17
+#define CFG_PLL_600_500_250		0x18
+#define CFG_PLL_600_400_300		0x19
+#define CFG_PLL_500_500_250		0x1a
+#define CFG_PLL_600_350_175		0x1b
+#define CFG_PLL_600_300_150		0x1c
+#define CFG_PLL_600_550_1_1G_275	0x1d
+#define CFG_PLL_600_500_1G_250		0x1e
+#define CFG_PLL_533_400_200		0x1f
+#define CFG_PLL_600_450_200		0x20
+#define CFG_PLL_533_500_250		0x21
+#define CFG_PLL_700_400_200		0x22
+#define CFG_PLL_650_600_300		0x23
+#define CFG_PLL_600_600_300		0x24
+#define CFG_PLL_600_550_275		0x25
+#define CFG_PLL_566_475_237		0x26
+#define CFG_PLL_566_450_225		0x27
+#define CFG_PLL_600_332_166		0x28
+#define CFG_PLL_600_575_287		0x29
+#define CFG_PLL_600_525_262		0x2a
+#define CFG_PLL_566_550_275		0x2b
+#define CFG_PLL_566_525_262		0x2c
+#define CFG_PLL_600_332_200		0x2d
+#define CFG_PLL_600_266_133		0x2e
+#define CFG_PLL_600_266_200		0x2f
+#define CFG_PLL_600_650_325		0x30
+#define CFG_PLL_566_400_200		0x31
+#define CFG_PLL_566_500_250		0x32
+#define CFG_PLL_600_1_2G_400_200	0x33
+#define CFG_PLL_560_480_240		0x34
+#define CFG_PLL_333_166_166		0x35
+#define CFG_PLL_350_175_175		0x36
+#define CFG_PLL_360_180_180		0x37
+#define CFG_PLL_380_190_190		0x38
+#define CFG_PLL_262_262_131		0x39
+#define CFG_PLL_275_275_137		0x3a
+#define CFG_PLL_200_200_200		0x3b
+#define CFG_PLL_250_250_125		0x3c
+#define CFG_PLL_225_225_112		0x3d
+#define CFG_PLL_212_212_106		0x3e
+#define CFG_PLL_187_187_93		0x3f
+#define CFG_PLL_535_400_200		0x40
+#define CFG_PLL_560_400_200		0x41
+#define CFG_PLL_560_450_225		0x42
+#define CFG_PLL_400_480_240		0x43
+
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		32768
+#define CFG_ICACHE_SIZE		65536
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ar7240_emu.h b/include/configs/ar7240_emu.h
new file mode 100644
index 0000000000..e1fc2d940c
--- /dev/null
+++ b/include/configs/ar7240_emu.h
@@ -0,0 +1,177 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#define CONFIG_AR7240_EMU 1
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0xbf000000
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS     "console=ttyS0,9600 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ	CFG_PLL_400_400_100
+
+/* Atheros Header configuration */
+
+#define CFG_ATHRS26_PHY  1
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0xbf040000
+#define CFG_ENV_SIZE		0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0xbf550000"
+//#define CONFIG_FLASH_16BIT
+
+#define CONFIG_NR_DRAM_BANKS	2
+#if 0
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#define CFG_DDR_REFRESH_VAL     0x4c00
+#define CFG_DDR_CONFIG_VAL      0x67bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x161
+#define CFG_DDR_EXT_MODE_VAL    0x2
+#define CFG_DDR_MODE_VAL        0x61
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#define CFG_DDR_REFRESH_VAL     0x5f00
+#define CFG_DDR_CONFIG_VAL      0x77bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x131
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x31
+#endif
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL			    0x83d1f6a2
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0xffff
+
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0x6fbc8890
+#define CFG_DDR_MODE_VAL_INIT   0x123
+#define CFG_DDR_EXT_MODE_VAL    0x1
+#define CFG_DDR_MODE_VAL        0x23
+
+#define CFG_DDR_CONFIG2_VAL     0x91d0e6a8	
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | \
+            CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET |\
+   CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB \
+   | CFG_CMD_ELF ))
+
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.27
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              136
+#define CAL_SECTOR                      63
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/board953x.h b/include/configs/board953x.h
new file mode 100755
index 0000000000..d12e48a495
--- /dev/null
+++ b/include/configs/board953x.h
@@ -0,0 +1,359 @@
+#ifndef __BOARD_955X_H
+#define __BOARD_955X_H
+
+#include <config.h>
+
+#undef MTDPARTS_DEFAULT
+
+#undef CFG_HZ
+
+#include <atheros.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE 4
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT	256	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"8256k(mib0)"
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT	128	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"64k(mib0)"
+#else
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"64k(mib0)"
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE	(64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE		0x01000000	/* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE		0x00800000	/* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE		0x00400000	/* Total flash size */
+#endif
+
+/* Support 2MB flash */
+#ifdef TPWD_FOR_LINUX_CAL
+#if (FLASH_SIZE == 2)
+#define CFG_MAX_FLASH_SECT		32
+#define CFG_FLASH_SIZE			0x00200000
+#endif
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF	1
+#endif
+
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE	unsigned short
+
+#if defined(CONFIG_ATH_NAND_BR) && defined(COMPRESSED_UBOOT)
+#define CFG_FLASH_BASE			0xa0100000
+#else
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE		CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE	BOOTSTRAP_TEXT_BASE
+#endif
+
+#define CONFIG_PCI_CONFIG_DATA_IN_OTP
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE		(256 * 1024)
+#define UBOOT_ENV_SEC_START		(CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC			0xaabacada
+#define CFG_FLASH_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F		(CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F		CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F		CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+#define CFG_DDR_REFRESH_VAL		0x4138
+
+/*
+ * The following #defines are needed to get flash environment right
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#define __fs_name(x, y)		x ## y
+#define _fs_name(x, y)		__fs_name(x, y)
+#define fs_name(y)		_fs_name(__CONFIG_BOARD_NAME, y)
+
+//#ifdef COMPRESSED_UBOOT
+//#	define ATH_U_FILE	u-boot.bin
+//#else
+/* use u-boot.bin file name no matter compress uboot or not */
+#	define ATH_U_FILE	u-boot.bin/*  by huangwenzhong, 02May13 */
+//#endif
+
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		if defined(COMPRESSED_UBOOT)
+#			define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x20000)
+#			define MTDPARTS_DEFAULT	"mtdparts=ath-nand:128k(u-boot),384k(free),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		else
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		endif
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else //dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nor0:320k(u-boot-and-env),6336k(free);ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:05"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		fs_name(${bc}-nand-jffs2)
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#else
+#	if defined(COMPRESSED_UBOOT)
+#		define ATH_U_FILE	u-boot.bin
+#		define ATH_F_FILE	fs_name(${bc}-squashfs)
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f120000
+#		define ATH_K_FILE	vmlinux${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f020000
+		/*
+		 * For compressed uboot, environment sector is not used.
+		 * Hence the mtd partition indices get reduced by 1.
+		 * This conflicts with
+		 *	- minor no. for /dev/caldata in
+		 *		build/scripts/{board}/dev.txt
+		 *	- root=<rooot dev> kernel cmdline parameter
+		 * Hence, doing a dummy split of the u-boot partition
+		 * to maintain the same minor no. as in the normal u-boot.
+		 */
+//#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:32k(u-boot1),32k(u-boot2),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+	#if (FLASH_SIZE == 16)
+	#		define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:128k(u-boot),1024k(kernel),15104k(rootfs),64k(config),64k(art)"
+	#elif (FLASH_SIZE ==8)
+	#		define MTDPARTS_DEFAULT 	"mtdparts=ath-nor0:128k(u-boot),1024k(kernel),6912k(rootfs),64k(config),64k(art)"
+	#else
+	#		define MTDPARTS_DEFAULT 	"mtdparts=ath-nor0:128k(u-boot),1024k(kernel),2816k(rootfs),64k(config),64k(art)"
+	#endif
+
+#	else
+#		define ATH_F_FILE		fs_name(${bc}-jffs2)
+#		define ATH_F_LEN		0x630000
+#		define ATH_F_ADDR		0x9f050000
+#		define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#		define ATH_K_ADDR		0x9f680000
+#		define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage)," ATH_MTDPARTS_MIB0 ",64k(ART)"
+#	endif
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=squashfs init=/sbin/init " MTDPARTS_DEFAULT
+
+//#define CFG_PLL_FREQ    CFG_PLL_720_600_200
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET	0xbd001800
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#else
+#	define CFG_ENV_ADDR		0x9f040000
+#	ifdef COMPRESSED_UBOOT
+#		define CONFIG_BOOTCOMMAND	"bootm 0x9f020000"/*  by huangwenzhong, 02May13 */
+#	else
+#		define CONFIG_BOOTCOMMAND	"bootm 0x9f680000"
+#	endif
+#endif
+
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC		0xaabacada
+#define CFG_DDR_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_AG7240_SPEPHY /* choose eth1 first for tftpboot interface added by ZJin, 110328 */
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#	ifdef CONFIG_ATH_NAND_BR
+#		define ATH_CFG_COMMANDS		((			\
+						CONFIG_CMD_DFL	|	\
+						CFG_CMD_PING	|	\
+						CFG_CMD_NET) & ~(	\
+						CFG_CMD_FLASH		\
+						))
+#	else
+#		define ATH_CFG_COMMANDS		(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#	endif
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+//#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0xba:0xbe:0xfa:0xce:0x08:0x41
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+/* ZJin 110328
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+*/
+#undef DEBUG
+#undef CFG_HUSH_PARSER
+#undef CFG_PROMPT_HUSH_PS2
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL				0x9fff1000
+#define BOARDCAL			0x9fff0000
+#define ATHEROS_PRODUCT_ID		137
+#define CAL_SECTOR			(CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define ATH_ART_PCICFG_OFFSET		12
+
+#define CONFIG_LZMA 1
+
+#include <cmd_confdefs.h>
+
+#endif	/* __BOARD_955X_H */
diff --git a/include/configs/board955x.h b/include/configs/board955x.h
new file mode 100644
index 0000000000..354418584e
--- /dev/null
+++ b/include/configs/board955x.h
@@ -0,0 +1,310 @@
+#ifndef __BOARD_955X_H
+#define __BOARD_955X_H
+
+#include <config.h>
+
+#undef MTDPARTS_DEFAULT
+
+#undef CFG_HZ
+
+#include <atheros.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE 8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT	256	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"8256k(mib0)"
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT	128	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"64k(mib0)"
+#else
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0	"64k(mib0)"
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE	(64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE		0x01000000	/* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE		0x00800000	/* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE		0x00400000	/* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF	1
+#endif
+
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE	unsigned short
+
+#if defined(CONFIG_ATH_NAND_BR) && defined(COMPRESSED_UBOOT)
+#define CFG_FLASH_BASE			0xa0100000
+#else
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE		CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE	BOOTSTRAP_TEXT_BASE
+#endif
+
+#define CONFIG_PCI_CONFIG_DATA_IN_OTP
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE		(256 * 1024)
+#define UBOOT_ENV_SEC_START		(CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC			0xaabacada
+#define CFG_FLASH_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F		(CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F		CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F		CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+#define CFG_DDR_REFRESH_VAL		0x4138
+
+/*
+ * The following #defines are needed to get flash environment right
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#define __fs_name(x, y)		x ## y
+#define _fs_name(x, y)		__fs_name(x, y)
+#define fs_name(y)		_fs_name(__CONFIG_BOARD_NAME, y)
+
+#ifdef COMPRESSED_UBOOT
+#	define ATH_U_FILE	tuboot.bin
+#else
+#	define ATH_U_FILE	u-boot.bin
+#endif
+
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		if defined(COMPRESSED_UBOOT)
+#			define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x20000)
+#			define MTDPARTS_DEFAULT	"mtdparts=ath-nand:128k(u-boot),384k(free),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		else
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		endif
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else //dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nor0:320k(u-boot-and-env),6336k(free);ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:05"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		fs_name(${bc}-nand-jffs2)
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#else
+#	define ATH_F_FILE		fs_name(${bc}-jffs2)
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage)," ATH_MTDPARTS_MIB0 ",64k(ART)"
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT
+
+//#define CFG_PLL_FREQ    CFG_PLL_720_600_200
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET	0xbd007000
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#else
+#	define CFG_ENV_ADDR		0x9f040000
+#	define CONFIG_BOOTCOMMAND	"bootm 0x9f680000"
+#endif
+
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC		0xaabacada
+#define CFG_DDR_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#	ifdef CONFIG_ATH_NAND_BR
+#		define ATH_CFG_COMMANDS		((			\
+						CONFIG_CMD_DFL	|	\
+						CFG_CMD_PING	|	\
+						CFG_CMD_NET) & ~(	\
+						CFG_CMD_FLASH		\
+						))
+#	else
+#		define ATH_CFG_COMMANDS		(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#	endif
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL				0x9fff1000
+#define BOARDCAL			0x9fff0000
+#define ATHEROS_PRODUCT_ID		137
+#define CAL_SECTOR			(CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define ATH_ART_PCICFG_OFFSET		12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __BOARD_955X_H */
diff --git a/include/configs/cus136.h b/include/configs/cus136.h
new file mode 100644
index 0000000000..82dae3939b
--- /dev/null
+++ b/include/configs/cus136.h
@@ -0,0 +1,201 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+
+#ifdef S25FL128P
+	#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+	#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#else
+	#define CFG_FLASH_SECTOR_SIZE   (256*1024)
+	#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_ENV_SECT_SIZE       CFG_FLASH_SECTOR_SIZE
+#define CFG_FLASH_SIZE          0x1000000 /* Total flash size */
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),256k(u-boot-env),3072k(rootfs),1024k(uImage),3072k(spare-rootfs),1024k(spare-uImage),64k(mib0),64k(mib1),4096k(ct),3392k(var),64k(ART)"
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ	CFG_PLL_350_350_175
+
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#	define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#	define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#	define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#	define CFG_HZ          (420000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#	define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#	define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+/* DDR value from Flash */
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada  
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV |	\
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_ETHREG ))
+#define CFG_ATHRS26_PHY  1
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                        0xbfff1000
+#define BOARDCAL                       0xbfff0000
+#define ATHEROS_PRODUCT_ID             138
+#define CAL_SECTOR                     (CFG_MAX_FLASH_SECT - 1)
+
+/* For Kite, only PCI-e interface is valid */
+#define AR7240_ART_PCICFG_OFFSET        3
+
+
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/cus97.h b/include/configs/cus97.h
new file mode 100644
index 0000000000..ad2404f50f
--- /dev/null
+++ b/include/configs/cus97.h
@@ -0,0 +1,147 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7100.h>
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0xbf000000
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7100-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7100-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ	CFG_PLL_400_400_100
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0xbf040000
+#define CFG_ENV_SIZE		0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0xbf550000"
+//#define CONFIG_FLASH_16BIT
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#define CFG_DDR_REFRESH_VAL     0x4c00
+#define CFG_DDR_CONFIG_VAL      0x67bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x161
+#define CFG_DDR_EXT_MODE_VAL    0x2
+#define CFG_DDR_MODE_VAL        0x61
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+
+#define CFG_DDR_REFRESH_VAL     0x5f00
+#define CFG_DDR_CONFIG_VAL      0x77bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x131
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x31
+#endif
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL			    0x83d1f6a2
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0xffff
+
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | \
+            CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET |\
+   CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB \
+   | CFG_CMD_ELF ))
+
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.27
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+#define CFG_ATHRS26_PHY 
+#define CFG_PHY_ADDR 0 
+
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/db12x-extender.h b/include/configs/db12x-extender.h
new file mode 100644
index 0000000000..7290b6131f
--- /dev/null
+++ b/include/configs/db12x-extender.h
@@ -0,0 +1,419 @@
+/*
+ * This file contains the configuration parameters for the db120 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if !defined(CONFIG_ATH_NAND_BR)
+#define FLASH_SIZE 8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* Assuming nand flash wouldn't use compressed u-boot */
+#ifdef CONFIG_ATH_NAND_BR
+#	define CFG_FLASH_BASE			0
+#else
+	/*
+	 * We boot from this flash
+	 */
+#	define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        CFG_FLASH_BASE+UBOOT_FLASH_SIZE
+#define CFG_ENV_SIZE        CFG_FLASH_SECTOR_SIZE
+
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),3072k(rootfs),1024k(uImage),3072k(spare-rootfs),1024k(spare-uImage),64k(mib0),64k(mib1),4096k(ct),3392k(var),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=8M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif
+
+#if (FLASH_SIZE == 16)
+#define CFG_KERNEL_ADDR 0x9f550000
+#else
+#define CFG_KERNEL_ADDR 0x9f680000
+#endif
+#define CFG_MIB0_ADDR		0x9f7e0000
+
+#define CONFIG_BOOTCOMMAND "bootm ${KERNELADDR}"
+
+#ifndef CFG_LOAD_ADDR
+#define CFG_LOAD_ADDR		0x80060000
+#endif
+#ifndef COMPRESSED_UBOOT
+#define CFG_FS_ADDR			0x9f050000//(CFG_ENV_ADDR+CFG_ENV_SIZE)
+#else
+#define CFG_FS_ADDR			0x9f010000//(CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#endif /* COMPRESSED_UBOOT */
+#define ENV_FS_ADDR			"FSADDR=" MK_STR(CFG_FS_ADDR) "\0"
+
+#define ENV_UBOOT_ADDR		"UBOOTADDR=" MK_STR(CFG_FLASH_BASE) "\0"
+#define ENV_KERNEL_ADDR		"KERNELADDR=" MK_STR(CFG_KERNEL_ADDR) "\0"
+#define ENV_MIB0_ADDR		"MIB0ADDR=" MK_STR(CFG_MIB0_ADDR) "\0"
+
+#define ENV_UPDATE \
+    "update=tftpboot " MK_STR(CFG_LOAD_ADDR) " ${filename} && "	\
+            "erase ${loadaddr} +${filesize} && "				\
+            "cp.b ${fileaddr} ${loadaddr} ${filesize}\0"
+
+#define ENV_UPDATE_KERNEL \
+    "updk=loadaddr=${KERNELADDR} && filename=zImage.uImage && " \
+    "run update\0"
+
+#define ENV_UPDATE_FS \
+    "updfs=loadaddr=${FSADDR} && filename=rootfs-squashfs && " \
+    "run update\0"
+
+#ifdef COMPRESSED_UBOOT
+#define UBOOT_FILENAME "tuboot.bin"
+#else
+#define UBOOT_FILENAME "u-boot.bin"
+#endif
+
+#define ENV_UPDATE_UBOOT \
+    "updub=loadaddr=${UBOOTADDR} && filename=" UBOOT_FILENAME " && " \
+    "run update\0"
+
+#define ENV_UPDATE_ALL \
+	"updall=run updub && run updfs && run updk\0"
+
+#define ENV_ERASE_MIB0 \
+	"erasemib0=erase ${MIB0ADDR} +0x10000"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		ENV_UBOOT_ADDR \
+		ENV_FS_ADDR \
+		ENV_KERNEL_ADDR \
+		ENV_MIB0_ADDR \
+		ENV_UPDATE \
+		ENV_UPDATE_KERNEL \
+		ENV_UPDATE_FS \
+		ENV_UPDATE_UBOOT \
+		ENV_UPDATE_ALL \
+		ENV_ERASE_MIB0 \
+		""
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET 0xbd007000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+#if 0
+#ifdef CONFIG_ATH_NAND_BR
+#define CONFIG_BOOTCOMMAND "bootm 0x80000"
+#define CFG_ENV_ADDR		0x00040000
+#else  /* CONFIG_ATH_NAND_BR */
+#define CFG_ENV_ADDR		0x9f040000
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else  /* FLASH_SIZE == 16 */
+#ifdef COMPRESSED_UBOOT
+#if (FLASH_SIZE == 4)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else  /* FLASH_SIZE == 4 */
+#define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#endif  /* FLASH_SIZE == 4 */
+#else /* COMPRESSED_UBOOT */
+#if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#endif
+#endif  /* COMPRESSED_UBOOT */
+#endif  /* FLASH_SIZE == 16 */
+#endif  /* CONFIG_ATH_NAND_BR */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_JFFS2 | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/db12x-hybrid.h b/include/configs/db12x-hybrid.h
new file mode 100644
index 0000000000..b53aac3a09
--- /dev/null
+++ b/include/configs/db12x-hybrid.h
@@ -0,0 +1,495 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE		8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if CONFIG_MI124
+#define BC "bc=mi124_f1e\0"
+#endif
+#if CONFIG_AP123
+#define BC "bc=ap123\0"
+#endif
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#               ifdef CONFIG_DB12X_HGW
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:512k(u-boot),128k(u-boot-env),3m(uImage),15m(rootfs),128k(mib0),128k(caldata)"
+#		define CFG_ENV_ADDR	0x00080000
+#               endif
+#	else	//dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, u-boot.bin)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nor0:320k(u-boot-and-env),6336k(free);ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:05"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#       ifdef CONFIG_DB12X_HGW
+#	        define ATH_F_FILE		db12x-hgw-nand-jffs2
+#	        define ATH_F_LEN		0xf00000
+#	        define ATH_F_ADDR		0x3a0000
+#	        define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	        define ATH_K_ADDR		0xa0000
+#	        define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	        define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	        define ATH_EXTRA_ENV		"bootdevice=0\0"
+#	        define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0xa0000"
+#       else
+#	        define ATH_F_FILE		db12x${bc}-nand-jffs2
+#	        define ATH_F_LEN		0x700000
+#	        define ATH_F_ADDR		0x1c0000
+#	        define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	        define ATH_K_ADDR		0x80000
+#	        define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	        define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	        define ATH_EXTRA_ENV		"bootdevice=0\0"
+#	        define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#       endif
+#elif defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#	ifdef COMPRESSED_UBOOT
+#		define ATH_U_FILE	tuboot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f010000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+		/*
+		 * For compressed uboot, environment sector is not used.
+		 * Hence the mtd partition indices get reduced by 1.
+		 * This conflicts with
+		 *	- minor no. for /dev/caldata in
+		 *		build/scripts/{board}/dev.txt
+		 *	- root=<rooot dev> kernel cmdline parameter
+		 * Hence, doing a dummy split of the u-boot partition
+		 * to maintain the same minor no. as in the normal u-boot.
+		 */
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:32k(u-boot1),32k(u-boot2),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	else /* COMPRESSED_UBOOT */
+#		define ATH_U_FILE	u-boot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f050000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	endif /* COMPRESSED_UBOOT */
+#elif defined(CONFIG_DB12X_P2P)
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x-p2p${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET 0xbd007000
+
+#ifndef CONFIG_ATH_NAND_SUPPORT
+#	define CFG_ENV_ADDR		0x9f040000
+#	if (FLASH_SIZE == 16)
+#		define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#	else  /* FLASH_SIZE == 16 */
+#		ifdef COMPRESSED_UBOOT
+#			if (FLASH_SIZE == 4)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else  /* FLASH_SIZE == 4 */
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#			endif  /* FLASH_SIZE == 4 */
+#		else /* COMPRESSED_UBOOT */
+#			if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#			endif
+#		endif  /* COMPRESSED_UBOOT */
+#	endif  /* FLASH_SIZE == 16 */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#define ATH_CFG_COMMANDS	(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#               ifdef CONFIG_DB12X_HGW
+#		        define CFG_ENV_OFFSET		0x80000u
+#		        define CFG_ENV_SIZE		0x20000u
+#               endif          
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/db12x.h b/include/configs/db12x.h
new file mode 100644
index 0000000000..3c3de71f97
--- /dev/null
+++ b/include/configs/db12x.h
@@ -0,0 +1,484 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE		8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+#if defined(CONFIG_ATH_NAND_SUPPORT) && defined(COMPRESSED_UBOOT)
+#define CFG_FLASH_BASE			0xa0100000
+#else
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/*
+ * The following #defines are needed to get flash environment right
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if CONFIG_MI124
+#define BC "bc=mi124_f1e\0"
+#endif
+#if CONFIG_AP123
+#define BC "bc=ap123\0"
+#endif
+
+#ifndef BC
+#define BC
+#endif
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		if defined(COMPRESSED_UBOOT)
+#			define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x20000)
+#			define MTDPARTS_DEFAULT	"mtdparts=ath-nand:128k(u-boot),384k(free),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		else
+#			define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#			define MTDPARTS_DEFAULT	"mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		endif
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else	//dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, u-boot.bin)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nor0:320k(u-boot-and-env),6336k(free);ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:05"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		db12x${bc}-nand-jffs2${ns}
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#elif defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#	ifdef COMPRESSED_UBOOT
+#		define ATH_U_FILE	tuboot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f010000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+		/*
+		 * For compressed uboot, environment sector is not used.
+		 * Hence the mtd partition indices get reduced by 1.
+		 * This conflicts with
+		 *	- minor no. for /dev/caldata in
+		 *		build/scripts/{board}/dev.txt
+		 *	- root=<rooot dev> kernel cmdline parameter
+		 * Hence, doing a dummy split of the u-boot partition
+		 * to maintain the same minor no. as in the normal u-boot.
+		 */
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:32k(u-boot1),32k(u-boot2),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	else /* COMPRESSED_UBOOT */
+#		define ATH_U_FILE	u-boot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f050000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+#		define MTDPARTS_DEFAULT	"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#	endif /* COMPRESSED_UBOOT */
+#elif defined(CONFIG_DB12X_P2P)
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x-p2p${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_AP123
+#define CFG_PLL_FREQ	CFG_PLL_535_400_200
+#elif defined(CONFIG_ATH_NAND_SUPPORT)	// NAND on DB120
+#define CFG_PLL_FREQ	CFG_PLL_560_400_200
+#else					// DB120 and MI124
+#define CFG_PLL_FREQ	CFG_PLL_560_450_225
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200) || (CFG_PLL_FREQ == CFG_PLL_400_480_240)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_535_400_200)
+#   define CFG_HZ          (535000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240) || (CFG_PLL_FREQ == CFG_PLL_560_400_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_560_450_225)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET	0xbd007000
+
+#ifndef CONFIG_ATH_NAND_SUPPORT
+#	define CFG_ENV_ADDR		0x9f040000
+#	if (FLASH_SIZE == 16)
+#		define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#	else  /* FLASH_SIZE == 16 */
+#		ifdef COMPRESSED_UBOOT
+#			if (FLASH_SIZE == 4)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else  /* FLASH_SIZE == 4 */
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#			endif  /* FLASH_SIZE == 4 */
+#		else /* COMPRESSED_UBOOT */
+#			if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#			endif
+#		endif  /* COMPRESSED_UBOOT */
+#	endif  /* FLASH_SIZE == 16 */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#	ifdef CONFIG_ATH_NAND_BR
+#		define ATH_CFG_COMMANDS		((			\
+						CONFIG_CMD_DFL	|	\
+						CFG_CMD_PING	|	\
+						CFG_CMD_NET) & ~(	\
+						CFG_CMD_FLASH		\
+						))
+#	else
+#		define ATH_CFG_COMMANDS		(CONFIG_CMD_DFL	|	\
+						CFG_CMD_PING	|	\
+						CFG_CMD_NET)
+#	endif
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/dhp1565.h b/include/configs/dhp1565.h
new file mode 100644
index 0000000000..262ed07c6e
--- /dev/null
+++ b/include/configs/dhp1565.h
@@ -0,0 +1,420 @@
+/*
+ * This file contains the configuration parameters for the db120 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if !defined(CONFIG_ATH_NAND_BR)
+#define FLASH_SIZE 8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* Assuming nand flash wouldn't use compressed u-boot */
+#ifdef CONFIG_ATH_NAND_BR
+#	define CFG_FLASH_BASE			0
+#else
+	/*
+	 * We boot from this flash
+	 */
+#	define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        (CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#define CFG_ENV_SIZE        CFG_FLASH_SECTOR_SIZE
+
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),3072k(rootfs),1024k(uImage),3072k(spare-rootfs),1024k(spare-uImage),64k(mib0),64k(mib1),4096k(ct),3392k(var),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=8M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif
+
+#if (FLASH_SIZE == 16)
+#define CFG_KERNEL_ADDR 0x9f550000
+#else
+#define CFG_KERNEL_ADDR 0x9f680000
+#endif
+#define CFG_MIB0_ADDR		0x9f7e0000
+
+#define CONFIG_BOOTCOMMAND "bootm ${KERNELADDR}"
+
+#ifndef CFG_LOAD_ADDR
+#define CFG_LOAD_ADDR		0x80060000
+#endif
+#ifndef COMPRESSED_UBOOT
+#define CFG_FS_ADDR			0x9f050000//(CFG_ENV_ADDR+CFG_ENV_SIZE)
+#else
+#define CFG_FS_ADDR			0x9f010000//(CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#endif /* COMPRESSED_UBOOT */
+#define ENV_FS_ADDR			"FSADDR=" MK_STR(CFG_FS_ADDR) "\0"
+
+#define ENV_UBOOT_ADDR		"UBOOTADDR=" MK_STR(CFG_FLASH_BASE) "\0"
+#define ENV_KERNEL_ADDR		"KERNELADDR=" MK_STR(CFG_KERNEL_ADDR) "\0"
+#define ENV_MIB0_ADDR		"MIB0ADDR=" MK_STR(CFG_MIB0_ADDR) "\0"
+
+#define ENV_UPDATE \
+    "update=tftpboot " MK_STR(CFG_LOAD_ADDR) " ${filename} && "	\
+            "erase ${loadaddr} +${filesize} && "				\
+            "cp.b ${fileaddr} ${loadaddr} ${filesize}\0"
+
+#define ENV_UPDATE_KERNEL \
+    "updk=loadaddr=${KERNELADDR} && filename=zImage.uImage && " \
+    "run update\0"
+
+#define ENV_UPDATE_FS \
+    "updfs=loadaddr=${FSADDR} && filename=rootfs-squashfs && " \
+    "run update\0"
+
+#ifdef COMPRESSED_UBOOT
+#define UBOOT_FILENAME "tuboot.bin"
+#else
+#define UBOOT_FILENAME "u-boot.bin"
+#endif
+
+#define ENV_UPDATE_UBOOT \
+    "updub=loadaddr=${UBOOTADDR} && filename=" UBOOT_FILENAME " && " \
+    "run update\0"
+
+#define ENV_UPDATE_ALL \
+	"updall=run updub && run updfs && run updk\0"
+
+#define ENV_ERASE_MIB0 \
+	"erasemib0=erase ${MIB0ADDR} +0x10000"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		ENV_UBOOT_ADDR \
+		ENV_FS_ADDR \
+		ENV_KERNEL_ADDR \
+		ENV_MIB0_ADDR \
+		ENV_UPDATE \
+		ENV_UPDATE_KERNEL \
+		ENV_UPDATE_FS \
+		ENV_UPDATE_UBOOT \
+		ENV_UPDATE_ALL \
+		ENV_ERASE_MIB0 \
+		""
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+#if 0
+#ifdef CONFIG_ATH_NAND_BR
+#define CONFIG_BOOTCOMMAND "bootm 0x80000"
+#define CFG_ENV_ADDR		0x00040000
+#else  /* CONFIG_ATH_NAND_BR */
+#define CFG_ENV_ADDR		0x9f040000
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else  /* FLASH_SIZE == 16 */
+#ifdef COMPRESSED_UBOOT
+#if (FLASH_SIZE == 4)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else  /* FLASH_SIZE == 4 */
+#define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#endif  /* FLASH_SIZE == 4 */
+#else /* COMPRESSED_UBOOT */
+#if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#endif
+#endif  /* COMPRESSED_UBOOT */
+#endif  /* FLASH_SIZE == 16 */
+#endif  /* CONFIG_ATH_NAND_BR */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/hornet_emu.h b/include/configs/hornet_emu.h
new file mode 100644
index 0000000000..5c43f458b3
--- /dev/null
+++ b/include/configs/hornet_emu.h
@@ -0,0 +1,255 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+
+#define ENABLE_DYNAMIC_CONF 1
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short
+
+/*
+ * We boot from this flash
+ */
+ /*
+  * This section needs change for compressed u-boot
+  * support.
+  */
+#define CFG_FLASH_BASE		    0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#endif
+
+
+/*
+ * The following #defines are needed to get flash environment right
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+/* #define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)" */
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),1344k(rootfs),576k(uImage),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),1344k(rootfs),576k(uImage),64k(ART)"
+#else
+
+/*
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:128k(u-boot),1280k(rootfs),576k(uImage),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:128k(u-boot),1280k(rootfs),576k(uImage),64k(ART)"
+*/
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#endif /* #ifdef COMPRESSED_UBOOT */
+#undef CFG_PLL_FREQ
+#ifdef CONFIG_HORNET_EMU
+    #ifdef CONFIG_HORNET_EMU_HARDI_WLAN
+    #define CFG_PLL_FREQ	CFG_PLL_48_48_24
+    #else
+    #define CFG_PLL_FREQ	CFG_PLL_80_80_40
+    #endif
+#else
+#define CFG_PLL_FREQ	CFG_PLL_350_350_175
+#endif
+
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#	define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#	define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#	define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#	define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_80_80_40)
+#	define CFG_HZ          (80000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_64_64_32)
+#	define CFG_HZ          (64000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_48_48_24)
+#	define CFG_HZ          (48000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_32_32_16)
+#	define CFG_HZ          (32000000/2)
+#endif
+
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		0x10000
+
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else 
+#define CONFIG_BOOTCOMMAND "bootm 0x9f160000"
+#endif
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#	define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#	define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+/* DDR value from Flash */
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#ifndef CONFIG_HORNET_EMU
+#define CONFIG_PCI
+#endif
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET) | CFG_CMD_MII)
+
+/*
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_JFFS2 | CFG_CMD_ENV |	\
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_ETHREG ))
+*/
+
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.1
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0
+#ifdef CONFIG_HORNET_EMU
+#define CFG_AG7240_NMACS 1
+#else
+#define CFG_AG7240_NMACS 2
+#endif
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+//#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                        0xbfff1000
+#define BOARDCAL                       0xbfff0000
+#define ATHEROS_PRODUCT_ID             138
+#define CAL_SECTOR                     (CFG_MAX_FLASH_SECT - 1)
+
+/* For Kite, only PCI-e interface is valid */
+#define AR7240_ART_PCICFG_OFFSET        3
+
+
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mi93.h b/include/configs/mi93.h
new file mode 100644
index 0000000000..8ec1f2d734
--- /dev/null
+++ b/include/configs/mi93.h
@@ -0,0 +1,247 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#define ENABLE_DYNAMIC_CONF 1
+#define CONFIG_SUPPORT_AR7241 1
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#if (FLASH_SIZE == 8)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),896k(uImage),64k(NVRAM),1792k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+#endif
+
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_200_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+
+#if (FLASH_SIZE == 8)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#endif
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR values to support AR7241 */
+
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+//#define CFG_7241_DDR1_CONFIG_VAL      0x6fbc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+//#define CFG_7241_DDR1_MODE_VAL        0x23
+#define CFG_7241_DDR1_CONFIG2_VAL	0x9dd0e6a8
+
+
+#define CFG_7241_DDR2_CONFIG_VAL	0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT	0x133
+#define CFG_7241_DDR2_EXT_MODE_VAL	0x402
+#define CFG_7241_DDR2_MODE_VAL		0x33
+#define CFG_7241_DDR2_CONFIG2_VAL	0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR settings for AR7240 */
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#       define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#       define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL      0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada  
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_JFFS2 | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.27
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/pb42.h b/include/configs/pb42.h
new file mode 100644
index 0000000000..c6f5d606bb
--- /dev/null
+++ b/include/configs/pb42.h
@@ -0,0 +1,115 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7100.h>
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000    /* Flash size */
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0xbf000000
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CFG_HZ
+
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          200000000
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          200000000
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          222000000
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          266000000
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          266000000
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+#	define CFG_HZ          400000000
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0xbf040000
+#define CFG_ENV_SIZE		0x10000
+
+//#define CONFIG_FLASH_16BIT
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+#define CFG_DDR_REFRESH_VAL     0x461b
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | \
+            CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET |\
+   CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB \
+   | CFG_CMD_ELF ))
+
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.11
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+#define CONFIG_ADMTEK_PHY 
+#define CFG_PHY_ADDR 0x14  /* Port 4 */
+
+#define CFG_GMII     0
+#define CFG_MII0_MII             0
+
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+#include <cmd_confdefs.h>
+
+/* Ported from
+ * redboot/ecos/packages/hal/mips/pb42/current/cdl/hal_mips_pb42.cdl
+ */
+
+#define CFG_DDR_CONFIG_VAL			0xefbc8cd0
+#define CFG_DDR_CONFIG2_VAL			0x8e7156a2
+#define CFG_DDR_MODE_VAL			      0x61
+#define CFG_DDR_EXT_MODE_VAL			  0x0
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL		    0xffff
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/pb44.h b/include/configs/pb44.h
new file mode 100644
index 0000000000..43b2ecfa6b
--- /dev/null
+++ b/include/configs/pb44.h
@@ -0,0 +1,230 @@
+/*
+ * Copyright (c) 2009, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 
+ */
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7100.h>
+
+#define CFG_BOARD_PB44 1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#ifndef COMPRESSED_UBOOT
+#define CFG_MAX_FLASH_BANKS     1           /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128         /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000  /* Flash size */
+#else
+/* For 2 MB flash */
+#define CFG_MAX_FLASH_BANKS     1           /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128         /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000  /* 0x00200000 Total flash size */
+#endif  /* #ifndef COMPRESSED_UBOOT */
+
+/* 
+ * We boot from this flash
+ */
+#ifndef COMPRESSED_UBOOT
+#define CFG_FLASH_BASE          0xbf000000
+#else
+#define CFG_FLASH_BASE          0xbf000000
+#endif  /* #ifndef COMPRESSED_UBOOT */
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif  /* #ifdef COMPRESSED_UBOOT */
+
+
+#undef CONFIG_BOOTARGS_FL
+#undef CONFIG_BOOTARGS_RD
+#undef CONFIG_BOOTARGS
+#undef  MTDPARTS_DEFAULT
+#undef  MTDIDS_DEFAULT
+
+#define CONFIG_ROOTFS_FLASH
+#undef CONFIG_BOOTARGS
+
+/* XXX - putting rootfs in last partition results in jffs errors */
+
+#ifdef COMPRESSED_UBOOT
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=jffs2 init=/sbin/init mtdparts=ar7100-nor0:64k(u-boot),6144k(rootfs),1728k(uImage),64k(ART)"
+#else
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=jffs2 init=/sbin/init mtdparts=ar7100-nor0:64k(u-boot),6144k(rootfs),1728k(uImage),64k(ART)"
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+"loadUboot=tftp 0x80060000 tuboot.bin; erase 0xbf000000 +$filesize; cp.b $fileaddr 0xbf000000 $filesize\0" \
+"loadLinux=tftpboot 0x80010000 vmlinux.lzma.uImage;erase 0xbf640000 +$filesize; cp.b $fileaddr 0xbf640000 $filesize\0" \
+"loadFiles=tftpboot 0x80010000 pb44-small-jffs2;erase 0xbf040000 +$filesize; cp.b $fileaddr 0xbf040000 $filesize\0" \
+"loadAll=run loadUboot;run loadLinux;run loadFiles\0"
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define CFG_MONITOR_BASE    TEXT_BASE
+#define CFG_MONITOR_LEN     (192 << 10)
+
+#undef CFG_HZ
+#define CFG_PLL_FREQ    CFG_PLL_680_340_170
+
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          200000000
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          200000000
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          222000000
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          266000000
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          266000000
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+#	define CFG_HZ          400000000
+#elif (CFG_PLL_FREQ == CFG_PLL_680_340_170)
+#   define CFG_HZ  (680000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT    (2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT    (2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET  0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR		0xbf040000
+#define CFG_ENV_SIZE        0x10000
+
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_BOOTCOMMAND "bootm 0xbf640000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0xbf640000"
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+
+#define CONFIG_NR_DRAM_BANKS    		2
+
+#define ATHEROS_PRODUCT_ID	136
+/* The calibration sector is used to store MAC addresses and CPU PLL setting */
+#define BOARDCAL                        0xbfff0000
+#define CAL_SECTOR                      127
+
+/*
+** Configure the CPU clock settings
+*/
+
+#define CFG_PLL_FREQ	CFG_PLL_680_340_170
+/*
+** These values for DDR configuration came from the
+** BDM configuration script
+*/
+
+#define CFG_DDR_REFRESH_VAL     		0x461b
+#define CFG_DDR_CONFIG_VAL      		0x6fb8884e
+#define CFG_DDR_CONFIG2_VAL            	0x812cd6a8
+#define CFG_DDR_MODE_VAL_INIT   		0x131
+#define CFG_DDR_EXT_MODE_VAL    		0x0
+#define CFG_DDR_MODE_VAL        		0x63
+#define CFG_DDR_TRTW_VAL        		0x1f
+#define CFG_DDR_TWTR_VAL        		0x1e
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0xff
+
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_PCI
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL        | CFG_CMD_MII   | CFG_CMD_PING  \
+   | CFG_CMD_NET | CFG_CMD_PCI     | CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS \
+   | CFG_CMD_RUN | CFG_CMD_LOADB   | CFG_CMD_ELF | CFG_CMD_BSP ))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+
+/*
+** Ethernet Configuration
+** Set default values, and select the PHY to use
+*/
+
+#define CONFIG_IPADDR       		192.168.1.2
+#define CONFIG_SERVERIP     		192.168.1.200
+//#define CONFIG_ETHADDR      		00:03:7f:ff:ff:fe
+
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+#define CONFIG_PHY_GIGE       		1              /* GbE speed/duplex detect */
+
+#define CFG_VITESSE_8601_7395_PHY   1
+//#define CFG_ATHRF1_PHY              1
+#define CFG_AG7100_NMACS 			2
+
+#define CFG_PHY_ADDR				0 
+#define CFG_AG7100_GE0_RGMII 1 /* XXX: on pb44, GE0 can be RGMII or GMII depending magpie's interface */
+#define CFG_AG7100_GE1_RGMII 1
+
+/*
+** Configure Parser
+*/
+
+#define CFG_BOOTM_LEN   (16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+#include <cmd_confdefs.h>
+
+#endif  /* __CONFIG_H */
diff --git a/include/configs/pb45.h b/include/configs/pb45.h
new file mode 100644
index 0000000000..2a9249584d
--- /dev/null
+++ b/include/configs/pb45.h
@@ -0,0 +1,162 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7100.h>
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1       /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+#define CFG_FLASH_ADDR0         (0x5555)        
+#define CFG_FLASH_ADDR1         (0x2AAA)
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE          0xbf000000
+
+#undef CONFIG_ROOTFS_RD
+#undef CONFIG_ROOTFS_FLASH
+#undef CONFIG_BOOTARGS_FL
+#undef CONFIG_BOOTARGS_RD
+#undef CONFIG_BOOTARGS
+#undef  MTDPARTS_DEFAULT
+#undef  MTDIDS_DEFAULT
+
+#define CONFIG_ROOTFS_FLASH
+#define CONFIG_BOOTARGS CONFIG_BOOTARGS_FL
+
+//#define CONFIG_BOOTARGS_RD     "console=ttyS0,115200 root=01:00 rd_start=0x80600000 rd_size=5242880 init=/sbin/init mtdparts=ar9100-nor0:256k(u-boot),64k(u-boot-env),4096k(rootfs),2048k(uImage)"
+
+/* XXX - putting rootfs in last partition results in jffs errors */
+
+#define CONFIG_BOOTARGS_FL     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7100-nor0:256k(uboot),128k(env),6144k(rootfs),64k(mac),1600k(uImage)"
+
+#define MTDPARTS_DEFAULT    "mtdparts=ar7100-nor0:256k(u-boot),128k(env),6144k(rootfs),64k(mac),1600k(uImage)"
+#define MTDIDS_DEFAULT      "nor0=ar7100-nor0"
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define CFG_MONITOR_BASE    TEXT_BASE
+#define CFG_MONITOR_LEN     (192 << 10)
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+
+#define CFG_HZ	(680000000/2)
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT    (2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT    (2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET  0x1000
+
+#define CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        0xbf040000
+#define CFG_ENV_SIZE        0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0xbf670000"
+
+#define CONFIG_NR_DRAM_BANKS    		2
+
+#define ATHEROS_PRODUCT_ID	136
+#define CFG_BOARD_PB45 1
+
+/*
+** Configure the CPU clock settings
+*/
+
+#define CFG_PLL_FREQ	CFG_PLL_680_340_170
+/*
+** These values for DDR configuration came from the
+** BDM configuration script
+*/
+
+#define CFG_DDR_REFRESH_VAL     		0x461b
+#define CFG_DDR_CONFIG_VAL      		0x77b8884e
+#define CFG_DDR_CONFIG2_VAL             	0x812cd6a8
+#define CFG_DDR_MODE_VAL_INIT   		0x131
+#define CFG_DDR_EXT_MODE_VAL    		0x0
+#define CFG_DDR_MODE_VAL        		0x33
+#define CFG_DDR_TRTW_VAL        		0x1f
+#define CFG_DDR_TWTR_VAL        		0x1e
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  	0xff
+
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL        | CFG_CMD_MII   | CFG_CMD_PING  \
+   | CFG_CMD_NET | CFG_CMD_PCI     | CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS \
+   | CFG_CMD_RUN | CFG_CMD_LOADB   | CFG_CMD_ELF | CFG_CMD_BSP ))
+
+/*
+** Ethernet Configuration
+** Set default values, and select the PHY to use
+*/
+
+#define CONFIG_IPADDR       		192.168.1.2
+#define CONFIG_SERVERIP     		192.168.1.1
+//#define CONFIG_ETHADDR      		00:03:7f:ff:ff:fe
+//#define CFG_FAULT_ECHO_LINK_DOWN    1
+#define CONFIG_PHY_GIGE       		1              /* GbE speed/duplex detect */
+
+#define CFG_ATHRS16_PHY  			1
+#define CFG_AG7100_NMACS 			2
+//#define CFG_ATHRHDR_REG 			1
+//#define CFG_SWITCH_FREQ				1
+
+//#define CFG_ATHRHDR_EN 				1
+//#define ATHRHDR_LEN   				2
+//#define ATHRHDR_MAX_DATA  			10
+
+#define CFG_PHY_ADDR				0  /* Port 4 */
+#define CFG_GMII 1
+#define CFG_MII0_RGMII 0
+#define CFG_AG7100_GE0_RGMII 1
+#define CFG_AG7100_GE1_RGMII 1
+
+/*
+** Configure Parser
+*/
+
+#define CFG_BOOTM_LEN   (16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+#include <cmd_confdefs.h>
+
+#endif  /* __CONFIG_H */
diff --git a/include/configs/pb47.h b/include/configs/pb47.h
new file mode 100644
index 0000000000..ec1b2499ad
--- /dev/null
+++ b/include/configs/pb47.h
@@ -0,0 +1,160 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7100.h>
+
+#define CFG_BOARD_PB47 1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1       /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+#define CFG_FLASH_ADDR0         (0x5555)        
+#define CFG_FLASH_ADDR1         (0x2AAA)
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE          0xbf000000
+
+#undef CONFIG_ROOTFS_RD
+#undef CONFIG_ROOTFS_FLASH
+#undef CONFIG_BOOTARGS_FL
+#undef CONFIG_BOOTARGS_RD
+#undef CONFIG_BOOTARGS
+#undef  MTDPARTS_DEFAULT
+#undef  MTDIDS_DEFAULT
+
+#define CONFIG_ROOTFS_FLASH
+#define CONFIG_BOOTARGS CONFIG_BOOTARGS_FL
+
+/* XXX - putting rootfs in last partition results in jffs errors */
+
+#define CONFIG_BOOTARGS_FL     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mem=64M "MTDPARTS_DEFAULT
+
+#define MTDPARTS_DEFAULT    "mtdparts=ar7100-nor0:192k(u-boot),64k(env),6144k(rootfs),1728k(uImage),64k(caldata)"
+#define MTDIDS_DEFAULT      "nor0=ar7100-nor0"
+#define CONFIG_EXTRA_ENV_SETTINGS \
+"loadUboot=tftpboot 0x80010000 u-boot.bin;erase 0xbf000000 +0x30000;cp.b 0x80010000 0xbf000000 0x30000\0" \
+"loadLinux=tftpboot 0x80010000 vmlinux.gz.uImage;erase 0xbf640000 +0x120000;cp.b 0x80010000 0xbf640000 0x120000\0" \
+"loadFiles=tftpboot 0x80010000 pb47-jffs2;erase 0xbf040000 +0x600000;cp.b 0x80010000 0xbf040000 0x600000\0" \
+"loadAll=run loadUboot;run loadLinux;run loadFiles\0"
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define CFG_MONITOR_BASE    TEXT_BASE
+#define CFG_MONITOR_LEN     (192 << 10)
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+
+#define CFG_HZ	(680000000/2)
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT    (2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT    (2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET  0x1000
+
+#define CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        0xbf030000
+#define CFG_ENV_SIZE        0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0xbf640000"
+
+#define CONFIG_NR_DRAM_BANKS    		2
+
+#define ATHEROS_PRODUCT_ID	136
+/* The calibration sector is used to store MAC addresses and CPU PLL setting */
+#define BOARDCAL                        0xbfff0000
+#define CAL_SECTOR                      127
+
+/*
+** Configure the CPU clock settings
+*/
+
+#define CFG_PLL_FREQ	CFG_PLL_680_340_170
+/*
+** These values for DDR configuration came from the
+** BDM configuration script
+*/
+
+#define CFG_DDR_REFRESH_VAL     		0x461b
+#define CFG_DDR_CONFIG_VAL      		0x77b8884e
+#define CFG_DDR_CONFIG2_VAL             	0x812cd6a8
+#define CFG_DDR_MODE_VAL_INIT   		0x131
+#define CFG_DDR_EXT_MODE_VAL    		0x0
+#define CFG_DDR_MODE_VAL        		0x33
+#define CFG_DDR_TRTW_VAL        		0x1f
+#define CFG_DDR_TWTR_VAL        		0x1e
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  	0xff
+
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL        | CFG_CMD_MII   | CFG_CMD_PING  \
+   | CFG_CMD_NET | CFG_CMD_PCI     | CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS \
+   | CFG_CMD_RUN | CFG_CMD_LOADB   | CFG_CMD_ELF | CFG_CMD_BSP ))
+
+/*
+** Ethernet Configuration
+** Set default values, and select the PHY to use
+*/
+
+#define CONFIG_IPADDR       		192.168.1.2
+#define CONFIG_SERVERIP     		192.168.1.1
+//#define CONFIG_ETHADDR      		00:03:7f:ff:ff:fe
+#define CONFIG_PHY_GIGE       		1              /* GbE speed/duplex detect */
+
+#define CFG_ATHRF1_PHY  			1
+#define CFG_AG7100_NMACS 			2
+
+#define CFG_PHY_ADDR				0 
+#define CFG_AG7100_GE0_RGMII 1 /* XXX: on pb47, GE0 can be RGMII or GMII depending magpie's interface */
+#define CFG_AG7100_GE1_RGMII 1
+
+/*
+** Configure Parser
+*/
+
+#define CFG_BOOTM_LEN   (16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+#include <cmd_confdefs.h>
+
+#endif  /* __CONFIG_H */
diff --git a/include/configs/pb90.h b/include/configs/pb90.h
new file mode 100644
index 0000000000..9d1a2d00fd
--- /dev/null
+++ b/include/configs/pb90.h
@@ -0,0 +1,167 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ  CFG_PLL_350_350_175
+
+#undef CFG_HZ
+
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0x7fbc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x2
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 	0x99d0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV |	\
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF ))
+
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.27
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/pb92.h b/include/configs/pb92.h
new file mode 100644
index 0000000000..a3400384a1
--- /dev/null
+++ b/include/configs/pb92.h
@@ -0,0 +1,330 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if (FLASH_SIZE == 16)
+#undef COMPRESSED_UBOOT
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_SUPPORT_AR7241 1
+
+#define CONFIG_AR7242_S16_PHY
+#define CONFIG_AG7240_GE0_IS_CONNECTED
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define UBOOT_FLASH_SIZE          (64 * 1024)
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),256k(u-boot-env),3072k(rootfs),1024k(uImage),3072k(spare-rootfs),1024k(spare-uImage),64k(mib0),64k(mib1),4096k(ct),3392k(var),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=4M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),3136k(rootfs),768k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),3136k(rootfs),768k(uImage),64k(mib0),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241
+#define CFG_AR7241_PLL_FREQ     CFG_PLL_400_400_200
+//#define CFG_AR7241_PLL_FREQ	CFG_PLL_400_200_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		CFG_FLASH_BASE+UBOOT_FLASH_SIZE
+#define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+
+#if (FLASH_SIZE == 16)
+#define CFG_KERNEL_ADDR 0x9f550000
+#else
+#ifdef COMPRESSED_UBOOT
+#define CFG_KERNEL_ADDR 0x9f300000
+#else
+#define CFG_KERNEL_ADDR 0x9f320000
+#endif
+#endif
+#define CFG_MIB0_ADDR		0x9f3e0000
+
+#define CONFIG_BOOTCOMMAND "bootm ${KERNELADDR}"
+
+#ifndef CFG_LOAD_ADDR
+#define CFG_LOAD_ADDR		0x80060000
+#endif
+#ifndef COMPRESSED_UBOOT
+#define CFG_FS_ADDR			0x9f050000//(CFG_ENV_ADDR+CFG_ENV_SIZE)
+#else
+#define CFG_FS_ADDR			0x9f010000//(CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#endif /* COMPRESSED_UBOOT */
+#define ENV_FS_ADDR			"FSADDR=" MK_STR(CFG_FS_ADDR) "\0"
+
+#define ENV_UBOOT_ADDR		"UBOOTADDR=" MK_STR(CFG_FLASH_BASE) "\0"
+#define ENV_KERNEL_ADDR		"KERNELADDR=" MK_STR(CFG_KERNEL_ADDR) "\0"
+#define ENV_MIB0_ADDR		"MIB0ADDR=" MK_STR(CFG_MIB0_ADDR) "\0"
+
+#define ENV_UPDATE \
+    "update=tftpboot " MK_STR(CFG_LOAD_ADDR) " ${filename} && "	\
+            "erase ${loadaddr} +${filesize} && "				\
+            "cp.b ${fileaddr} ${loadaddr} ${filesize}\0"
+
+#define ENV_UPDATE_KERNEL \
+    "updk=loadaddr=${KERNELADDR} && filename=zImage.uImage && " \
+    "run update\0"
+
+#define ENV_UPDATE_FS \
+    "updfs=loadaddr=${FSADDR} && filename=rootfs-squashfs && " \
+    "run update\0"
+
+#ifdef COMPRESSED_UBOOT
+#define UBOOT_FILENAME "tuboot.bin"
+#else
+#define UBOOT_FILENAME "u-boot.bin"
+#endif
+
+#define ENV_UPDATE_UBOOT \
+    "updub=loadaddr=${UBOOTADDR} && filename=" UBOOT_FILENAME " && " \
+    "run update\0"
+
+#define ENV_UPDATE_ALL \
+	"updall=run updub && run updfs && run updk\0"
+
+#define ENV_ERASE_MIB0 \
+	"erasemib0=erase ${MIB0ADDR} +0x10000"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		ENV_UBOOT_ADDR \
+		ENV_FS_ADDR \
+		ENV_KERNEL_ADDR \
+		ENV_MIB0_ADDR \
+		ENV_UPDATE \
+		ENV_UPDATE_KERNEL \
+		ENV_UPDATE_FS \
+		ENV_UPDATE_UBOOT \
+		ENV_UPDATE_ALL \
+		ENV_ERASE_MIB0 \
+		""
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0x7fbc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x2
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 	0x99d0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR values to support AR7241 */
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+//#define CFG_7241_DDR1_CONFIG_VAL      0x6fbc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+//#define CFG_7241_DDR1_MODE_VAL        0x23
+#define CFG_7241_DDR1_CONFIG2_VAL	0x9dd0e6a8
+
+#define CFG_7241_DDR2_CONFIG_VAL        0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT     0x133 
+#define CFG_7241_DDR2_EXT_MODE_VAL      0x402
+#define CFG_7241_DDR2_MODE_VAL          0x33
+#define CFG_7241_DDR2_CONFIG2_VAL       0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_PCI 1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+#define CFG_ATHRS26_PHY  1
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                        0xbfff1000
+#define BOARDCAL                       0xbfff0000
+#define ATHEROS_PRODUCT_ID             137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/pb93.h b/include/configs/pb93.h
new file mode 100644
index 0000000000..6e8b3c20f4
--- /dev/null
+++ b/include/configs/pb93.h
@@ -0,0 +1,229 @@
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#define ENABLE_DYNAMIC_CONF 1
+#define CONFIG_SUPPORT_AR7241 1
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CONFIG_SUPPORT_AR7241 1
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#endif
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#if (FLASH_SIZE == 8)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),896k(uImage),64k(NVRAM),1792k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#endif
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241
+#define CFG_AR7241_PLL_FREQ     CFG_PLL_400_400_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE            CFG_FLASH_SECTOR_SIZE 
+
+#if (FLASH_SIZE == 8)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#endif
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0x7fbc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x2
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 	0x99d0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR values to support AR7241 */
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+#define CFG_7241_DDR1_CONFIG2_VAL       0x9dd0e6a8 
+
+#define CFG_7241_DDR2_CONFIG_VAL        0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT     0x133 
+#define CFG_7241_DDR2_EXT_MODE_VAL      0x402
+#define CFG_7241_DDR2_MODE_VAL          0x33
+#define CFG_7241_DDR2_CONFIG2_VAL       0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F   *(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL | \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.27
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/pb9x-2.6.31.h b/include/configs/pb9x-2.6.31.h
new file mode 100644
index 0000000000..47330f3e24
--- /dev/null
+++ b/include/configs/pb9x-2.6.31.h
@@ -0,0 +1,286 @@
+/*
+ * Copyright (c) 2009, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 
+ */
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#define ENABLE_DYNAMIC_CONF 1
+#define CONFIG_SUPPORT_AR7241 1
+
+#define CONFIG_AR7242_S16_PHY
+#define CONFIG_AG7240_GE0_IS_CONNECTED
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CONFIG_SUPPORT_AR7241 1
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#endif
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+
+#ifndef ROOTFS
+#define ROOTFS 1
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#if (FLASH_SIZE == 8)
+#if (ROOTFS == 2) /* make squashfs as rootfs type */
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),896k(uImage),64k(NVRAM),1792k(ART) REVISIONID"
+#else
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),896k(uImage),64k(NVRAM),1792k(ART) REVISIONID"
+#endif /* #if ROOTFS == 2 */
+#else /* #else of FLASH_SIZE == 8 */
+#if (FLASH_SIZE == 4)
+#if (ROOTFS == 2) /* make squashfs as rootfs type */
+#define CONFIG_BOOTARGS "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),3008k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+#else
+#define CONFIG_BOOTARGS "console=ttyS0,115200 root=31:01 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),3008k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+#endif /* #if ROOTFS == 2 */
+#else
+#if (ROOTFS == 2) /* make squashfs as rootfs type */
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+#endif /* #if ROOTFS == 2 */
+#endif /* FLASH_SIZE == 4 */
+#endif
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241
+#define CFG_AR7241_PLL_FREQ     CFG_PLL_400_400_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE            CFG_FLASH_SECTOR_SIZE 
+
+#if (FLASH_SIZE == 8)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#endif
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0x7fbc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x2
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 	0x99d0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR values to support AR7241 */
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+#define CFG_7241_DDR1_CONFIG2_VAL       0x9dd0e6a8 
+
+#define CFG_7241_DDR2_CONFIG_VAL        0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT     0x133 
+#define CFG_7241_DDR2_EXT_MODE_VAL      0x402
+#define CFG_7241_DDR2_MODE_VAL          0x33
+#define CFG_7241_DDR2_CONFIG2_VAL       0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F   *(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_PCI 1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL | \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.27
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/pb9x-2x8.h b/include/configs/pb9x-2x8.h
new file mode 100644
index 0000000000..31b2efb7b1
--- /dev/null
+++ b/include/configs/pb9x-2x8.h
@@ -0,0 +1,212 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ *-----------------------------------------------------------------------
+ */
+#ifndef COMPRESSED_UBOOT
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#else
+/* For 2 MB flash */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      32     /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00200000 /* Total flash size */
+#endif  /* #ifndef COMPRESSED_UBOOT */
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),1280k(rootfs),576k(uImage),64k(NVRAM),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:64k(u-boot),1280k(rootfs),576k(uImage),64k(NVRAM),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ	CFG_PLL_350_350_175
+
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#	define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#	define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#	define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#	define CFG_HZ          (420000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE		0x10000
+
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else 
+#define CONFIG_BOOTCOMMAND "bootm 0x9f150000"
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#ifdef LOW_DRIVE_STRENGTH
+#	define CFG_DDR_EXT_MODE_VAL    0x2
+#else
+#	define CFG_DDR_EXT_MODE_VAL    0x0
+#endif
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_PCI 1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV |	\
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_ETHREG ))
+#else
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.2
+#define CONFIG_SERVERIP 192.168.1.1
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                        0xbfff1000
+#define BOARDCAL                       0xbfff0000
+#define ATHEROS_PRODUCT_ID             138
+#define CAL_SECTOR                     (CFG_MAX_FLASH_SECT - 1)
+
+/* For Kite, only PCI-e interface is valid */
+#define AR7240_ART_PCICFG_OFFSET        3
+
+
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/pb9x.h b/include/configs/pb9x.h
new file mode 100644
index 0000000000..656e6af14d
--- /dev/null
+++ b/include/configs/pb9x.h
@@ -0,0 +1,282 @@
+/*
+ * Copyright (c) 2009, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * 
+ */
+/*
+ * This file contains the configuration parameters for the pb93 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#define ENABLE_DYNAMIC_CONF 1
+#define CONFIG_SUPPORT_AR7241 1
+
+#define CONFIG_AR7242_S16_PHY
+#define CONFIG_AG7240_GE0_IS_CONNECTED
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CONFIG_SUPPORT_AR7241 1
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#endif
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+
+#ifndef ROOTFS
+#define ROOTFS 1
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#if (FLASH_SIZE == 8)
+#if (ROOTFS == 2) /* make squashfs as rootfs type */
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),896k(uImage),64k(NVRAM),1792k(ART) REVISIONID"
+#else
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),896k(uImage),64k(NVRAM),1792k(ART) REVISIONID"
+#endif /* #if ROOTFS == 2 */
+#else /* #else of FLASH_SIZE == 8 */
+#if (FLASH_SIZE == 4)
+#define CONFIG_BOOTARGS "console=ttyS0,115200 root=31:01 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:64k(u-boot),3008k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+#else
+#if (ROOTFS == 2) /* make squashfs as rootfs type */
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=squashfs init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART) REVISIONID"
+#endif /* #if ROOTFS == 2 */
+#endif /* FLASH_SIZE == 4 */
+#endif
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+
+#undef CFG_PLL_FREQ
+
+#ifdef CONFIG_SUPPORT_AR7241
+#define CFG_AR7241_PLL_FREQ     CFG_PLL_400_400_200
+#endif
+
+#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+
+#undef CFG_HZ
+
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0x9f040000
+#define CFG_ENV_SIZE            CFG_FLASH_SECTOR_SIZE 
+
+#if (FLASH_SIZE == 8)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#endif
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0x7fbc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x2
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 	0x99d0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+/* DDR values to support AR7241 */
+#ifdef CONFIG_SUPPORT_AR7241 
+#define CFG_7241_DDR1_CONFIG_VAL      0xc7bc8cd0
+#define CFG_7241_DDR1_MODE_VAL_INIT   0x133
+#define CFG_7241_DDR1_EXT_MODE_VAL    0x0
+#define CFG_7241_DDR1_MODE_VAL        0x33
+#define CFG_7241_DDR1_CONFIG2_VAL       0x9dd0e6a8 
+
+#define CFG_7241_DDR2_CONFIG_VAL        0xc7bc8cd0
+#define CFG_7241_DDR2_MODE_VAL_INIT     0x133 
+#define CFG_7241_DDR2_EXT_MODE_VAL      0x402
+#define CFG_7241_DDR2_MODE_VAL          0x33
+#define CFG_7241_DDR2_CONFIG2_VAL       0x9dd0e6a8
+#endif /* _SUPPORT_AR7241 */
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F   *(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_PCI 1
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL | \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.27
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/reh132.h b/include/configs/reh132.h
new file mode 100644
index 0000000000..1f51c6f16f
--- /dev/null
+++ b/include/configs/reh132.h
@@ -0,0 +1,424 @@
+/*
+ * This file contains the configuration parameters for the db120 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if !defined(CONFIG_ATH_NAND_FL)
+#define FLASH_SIZE 16
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* Assuming nand flash wouldn't use compressed u-boot */
+#ifdef CONFIG_ATH_NAND_FL
+#	define CFG_FLASH_BASE			0
+#else
+	/*
+	 * We boot from this flash
+	 */
+#	define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        (CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#define CFG_ENV_SIZE        CFG_FLASH_SECTOR_SIZE
+
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),8192k(reserve),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=8M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif
+
+#if (FLASH_SIZE == 16)
+#define CFG_KERNEL_ADDR 0x9f680000
+#else
+#define CFG_KERNEL_ADDR 0x9f680000
+#endif
+#define CFG_MIB0_ADDR		0x9ffe0000
+
+#define CONFIG_BOOTCOMMAND "bootm ${KERNELADDR}"
+
+#ifndef CFG_LOAD_ADDR
+#define CFG_LOAD_ADDR		0x80060000
+#endif
+#ifndef COMPRESSED_UBOOT
+#define CFG_FS_ADDR			0x9f050000//(CFG_ENV_ADDR+CFG_ENV_SIZE)
+#else
+#define CFG_FS_ADDR			0x9f010000//(CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#endif /* COMPRESSED_UBOOT */
+#define ENV_FS_ADDR			"FSADDR=" MK_STR(CFG_FS_ADDR) "\0"
+
+#define ENV_UBOOT_ADDR		"UBOOTADDR=" MK_STR(CFG_FLASH_BASE) "\0"
+#define ENV_KERNEL_ADDR		"KERNELADDR=" MK_STR(CFG_KERNEL_ADDR) "\0"
+#define ENV_MIB0_ADDR		"MIB0ADDR=" MK_STR(CFG_MIB0_ADDR) "\0"
+
+#define ENV_UPDATE \
+    "update=tftpboot " MK_STR(CFG_LOAD_ADDR) " ${filename} && "	\
+            "erase ${loadaddr} +${filesize} && "				\
+            "cp.b ${fileaddr} ${loadaddr} ${filesize}\0"
+
+#define ENV_UPDATE_KERNEL \
+    "updk=loadaddr=${KERNELADDR} && filename=zImage.uImage && " \
+    "run update\0"
+
+#define ENV_UPDATE_FS \
+    "updfs=loadaddr=${FSADDR} && filename=rootfs-jffs2 && " \
+    "run update\0"
+
+#ifdef COMPRESSED_UBOOT
+#define UBOOT_FILENAME "tuboot.bin"
+#else
+#define UBOOT_FILENAME "u-boot.bin"
+#endif
+
+#define ENV_UPDATE_UBOOT \
+    "updub=loadaddr=${UBOOTADDR} && filename=" UBOOT_FILENAME " && " \
+    "run update\0"
+
+#define ENV_UPDATE_ALL \
+	"updall=run updub && run updfs && run updk\0"
+
+#define ENV_ERASE_MIB0 \
+	"erasemib0=erase ${MIB0ADDR} +0x10000"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		ENV_UBOOT_ADDR \
+		ENV_FS_ADDR \
+		ENV_KERNEL_ADDR \
+		ENV_MIB0_ADDR \
+		ENV_UPDATE \
+		ENV_UPDATE_KERNEL \
+		ENV_UPDATE_FS \
+		ENV_UPDATE_UBOOT \
+		ENV_UPDATE_ALL \
+		ENV_ERASE_MIB0 \
+		""
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+#define CFG_INIT_SRAM_SP_OFFSET 0xbd007000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+#if 0
+#ifdef CONFIG_ATH_NAND_FL
+#define CONFIG_BOOTCOMMAND "bootm 0x80000"
+#define CFG_ENV_ADDR		0x00040000
+#else  /* CONFIG_ATH_NAND_FL */
+#define CFG_ENV_ADDR		0x9f040000
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else  /* FLASH_SIZE == 16 */
+#ifdef COMPRESSED_UBOOT
+#if (FLASH_SIZE == 4)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else  /* FLASH_SIZE == 4 */
+#define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#endif  /* FLASH_SIZE == 4 */
+#else /* COMPRESSED_UBOOT */
+#if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#endif
+#endif  /* COMPRESSED_UBOOT */
+#endif  /* FLASH_SIZE == 16 */
+#endif  /* CONFIG_ATH_NAND_FL */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+#define CONFIG_SHUTDOWN_PCIE_USB 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_WAH132 1 
+
+#define CFG_PHY_ADDR 0 
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/scoemu.h b/include/configs/scoemu.h
new file mode 100644
index 0000000000..61597932a3
--- /dev/null
+++ b/include/configs/scoemu.h
@@ -0,0 +1,439 @@
+#ifndef __SCOEMU_H
+#define __SCOEMU_H
+
+#include <config.h>
+
+#undef MTDPARTS_DEFAULT
+
+#undef CFG_HZ
+
+#include <atheros.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE 8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT	256	/* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT	128	/* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE	(64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE		0x01000000	/* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE		0x00800000	/* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE		0x00400000	/* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF	1
+#endif
+
+//#define CONFIG_WASP_SUPPORT	1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE	unsigned short
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 		1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED	1
+
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE		CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE	BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE		(256 * 1024)
+#define UBOOT_ENV_SEC_START		(CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC			0xaabacada
+#define CFG_FLASH_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F		(CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F		CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F		CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/*
+ * The following #defines are needed to get flash environment right
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if CONFIG_MI124
+#define BC "bc=mi124_f1e\0"
+#endif
+#if CONFIG_AP123
+#define BC "bc=ap123\0"
+#endif
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else	//dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, u-boot.bin)
+#	define MTDPARTS_DEFAULT 	"mtdparts=ath-nor0:320k(u-boot-and-env),6336k(free);ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:05"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		db12x${bc}-nand-jffs2
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#elif defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#		ifdef COMPRESSED_UBOOT
+#		define ATH_U_FILE	tuboot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f010000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+			/*
+			 * For compressed uboot, environment sector is not used.
+			 * Hence the mtd partition indices get reduced by 1.
+			 * This conflicts with
+			 *	- minor no. for /dev/caldata in
+			 *		build/scripts/{board}/dev.txt
+			 *	- root=<rooot dev> kernel cmdline parameter
+			 * Hence, doing a dummy split of the u-boot partition
+			 * to maintain the same minor no. as in the normal u-boot.
+			 */
+#			define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:32k(u-boot1),32k(u-boot2),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#		else /* COMPRESSED_UBOOT */
+#		define ATH_U_FILE	u-boot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f050000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+#			define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#		endif /* COMPRESSED_UBOOT */
+#elif defined(CONFIG_DB12X_P2P)
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x-p2p${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		db12x${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline. The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#ifdef CONFIG_ATH_EMULATION
+#	define CFG_HZ	(80000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ	(200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ	(300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#	define CFG_HZ	(350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ	(333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ	(266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ	(400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#	define CFG_HZ	(320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#	define CFG_HZ	(410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#	define CFG_HZ	(420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#	define CFG_HZ	(240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#	define CFG_HZ	(160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#	define CFG_HZ	(500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#	define CFG_HZ	(600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#	define CFG_HZ	(533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#	define CFG_HZ	(700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#	define CFG_HZ	(650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#	define CFG_HZ	(560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+	(CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+	(CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#	define CFG_HZ	(566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef CONFIG_ATH_NAND_SUPPORT
+#	define CFG_ENV_ADDR		0x9f040000
+#	if (FLASH_SIZE == 16)
+#		define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#	else	/* FLASH_SIZE == 16 */
+#		ifdef COMPRESSED_UBOOT
+#			if (FLASH_SIZE == 4)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else	/* FLASH_SIZE == 4 */
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#			endif	/* FLASH_SIZE == 4 */
+#		else /* COMPRESSED_UBOOT */
+#			if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#			endif
+#		endif	/* COMPRESSED_UBOOT */
+#	endif	/* FLASH_SIZE == 16 */
+#endif
+
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC		0xaabacada
+#define CFG_DDR_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#define ATH_CFG_COMMANDS	(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL				0x9fff1000
+#define BOARDCAL			0x9fff0000
+#define ATHEROS_PRODUCT_ID		137
+#define CAL_SECTOR			(CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define ATH_ART_PCICFG_OFFSET		12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __SCOEMU_H */
diff --git a/include/configs/tb225.h b/include/configs/tb225.h
new file mode 100644
index 0000000000..816c8a0194
--- /dev/null
+++ b/include/configs/tb225.h
@@ -0,0 +1,84 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7100.h>
+
+/*
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	     1	     /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	    (128)	 /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+/* 
+ * We boot from this flash, selected with dip switch 
+ */
+#define CFG_FLASH_BASE		    0xbfc00000
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	    TEXT_BASE
+#define	CFG_MONITOR_LEN		    (192 << 10)
+
+/*
+ * cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	    0x1000
+
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+//#define	CFG_ENV_IS_IN_FLASH    1
+#define CFG_ENV_IS_NOWHERE  1
+
+/* Address and size of Primary Environment Sector	*/
+//#define CFG_ENV_ADDR		0xbfc30000
+#define CFG_ENV_SIZE		0x10000
+
+//#define CONFIG_FLASH_16BIT
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#define CFG_HZ          40000000
+
+#define CFG_DDR_REFRESH_VAL 0x4139
+#define CFG_DDR_TRTW_VAL    0x12
+#define CFG_DDR_TWTR_VAL    0x12
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | \
+            CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET |\
+   CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB \
+   | CFG_CMD_ELF ) & ~CFG_CMD_ENV)
+
+#define CFG_PHY_ADDR    0x18
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.11
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+//#define CFG_VSC8201_PHY             1
+#define CFG_IP175B_PHY             1
+
+#define CFG_MII0_RGMII             0
+
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/tb243.h b/include/configs/tb243.h
new file mode 100644
index 0000000000..ff19bc83a7
--- /dev/null
+++ b/include/configs/tb243.h
@@ -0,0 +1,124 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7100.h>
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#//define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+//#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+#define CFG_FLASH_ADDR0         (0x5555)  		
+#define CFG_FLASH_ADDR1         (0x2AAA)
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0xbf000000
+//#define CFG_FLASH_BASE		    0xbfc00000 /* Temp WAR as remap is not on by default */
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CFG_HZ
+
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          200000000
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          200000000
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          222000000
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          266000000
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          266000000
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+#	define CFG_HZ          400000000
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0xbf040000
+#define CFG_ENV_SIZE		0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0xbf550000"
+//#define CONFIG_FLASH_16BIT
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+#define CFG_DDR_REFRESH_VAL     0x4c00
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | \
+            CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET |\
+   CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB \
+   | CFG_CMD_ELF ))
+
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.11
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+#define CONFIG_ADMTEK_PHY 
+#define CFG_PHY_ADDR 0x14  /* Port 4 */
+
+#define CFG_GMII     0
+#define CFG_MII0_MII             0
+
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+#include <cmd_confdefs.h>
+
+/* Ported from
+ * redboot/ecos/packages/hal/mips/pb42/current/cdl/hal_mips_pb42.cdl
+ */
+
+#define CFG_DDR_CONFIG_VAL              0x67bc8cd0
+#define CFG_DDR_CONFIG2_VAL			    0x83d1f6a2
+#define CFG_DDR_MODE_VAL			    0x61
+#define CFG_DDR_MODE_VAL_INIT		    0x161
+#define CFG_DDR_EXT_MODE_VAL            0x2
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0xffff
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/tb327.h b/include/configs/tb327.h
new file mode 100644
index 0000000000..0e057cee27
--- /dev/null
+++ b/include/configs/tb327.h
@@ -0,0 +1,156 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00800000 /* Total flash size */
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0xbf000000
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2688k(rootfs),1024k(uImage)"
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+
+/* Atheros Header configuration */
+
+#define CFG_ATHRS26_PHY  1
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0xbf040000
+#define CFG_ENV_SIZE		0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0xbf2f0000"
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0x7fbc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x2
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 0x99d0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI |	\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV |	\
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF ))
+
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.27
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                        0xbfff1000
+#define BOARDCAL                       0xbfff0000
+#define ATHEROS_PRODUCT_ID             136
+#define CAL_SECTOR                     63
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/tb6xx.h b/include/configs/tb6xx.h
new file mode 100644
index 0000000000..430c1f1840
--- /dev/null
+++ b/include/configs/tb6xx.h
@@ -0,0 +1,342 @@
+#ifndef __TB6XX_H
+#define __TB6XX_H
+
+#include <config.h>
+
+#undef MTDPARTS_DEFAULT
+
+#undef CFG_HZ
+
+#include <atheros.h>
+
+#ifndef FLASH_SIZE
+#define FLASH_SIZE 8
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT	256	/* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT	128	/* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE	(64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE		0x01000000	/* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE		0x00800000	/* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE		0x00400000	/* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF	1
+#endif
+
+//#define CONFIG_WASP_SUPPORT	1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE	unsigned short
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 		1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED	1
+
+/* NOR Flash start address */
+#define CFG_FLASH_BASE			0x9f000000
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE		CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE	BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE		(256 * 1024)
+#define UBOOT_ENV_SEC_START		(CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC			0xaabacada
+#define CFG_FLASH_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F		*(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F		(CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F		CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F		CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+#define CFG_DDR_REFRESH_VAL			0x412c
+
+/*
+ * The following #defines are needed to get flash environment right
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+
+#if CONFIG_MI124
+#define BC "bc=mi124_f1e\0"
+#endif
+#if CONFIG_AP123
+#define BC "bc=ap123\0"
+#endif
+
+#define __gen_cmd(n, a, f, ec, cc, el)		\
+	#n "=tftp 0x80060000 ${dir}" #f "&&"	\
+	#ec " " #a " " #el "&&"			\
+	#cc " $fileaddr " #a " $filesize\0"
+
+#define gen_cmd(n, a, f)			\
+	__gen_cmd(n, a, f, erase, cp.b, +$filesize)
+
+#define gen_cmd_el(n, a, f, el)			\
+	__gen_cmd(n, a, f, erase, cp.b, +el)
+
+#define nand_gen_cmd(n, a, f, s)		\
+	__gen_cmd(n, a, f, nand erase, nand write, s)
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR	// nand boot rom
+#		define ATH_U_CMD	nand_gen_cmd(lu, 0x0, 2fw.bin, 0x40000)
+#		define MTDPARTS_DEFAULT "mtdparts=ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:03"
+#		define CFG_ENV_ADDR	0x00040000
+#	else	//dual flash
+#		define ATH_U_CMD	gen_cmd(lu, 0x9f000000, u-boot.bin)
+#	define MTDPARTS_DEFAULT 	"mtdparts=ath-nor0:320k(u-boot-and-env),6336k(free);ath-nand:256k(u-boot),256k(u-boot-env),1280k(uImage),7m(rootfs),128k(dummy),128k(caldata)"
+#		define ATH_ROOT_DEV	"31:05"
+#		define CFG_ENV_ADDR	0x9f040000
+#	endif
+#	define ATH_F_FILE		tb6xx${bc}-nand-jffs2
+#	define ATH_F_LEN		0x700000
+#	define ATH_F_ADDR		0x1c0000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x80000
+#	define ATH_F_CMD		nand_gen_cmd(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#	define ATH_K_CMD		nand_gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE, 0x140000)
+#	define ATH_EXTRA_ENV		"bootdevice=0\0"
+#	define CONFIG_BOOTCOMMAND	"nboot 0x81000000 0 0x80000"
+#elif defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#		ifdef COMPRESSED_UBOOT
+#		define ATH_U_FILE	tuboot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f010000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+			/*
+			 * For compressed uboot, environment sector is not used.
+			 * Hence the mtd partition indices get reduced by 1.
+			 * This conflicts with
+			 *	- minor no. for /dev/caldata in
+			 *		build/scripts/{board}/dev.txt
+			 *	- root=<rooot dev> kernel cmdline parameter
+			 * Hence, doing a dummy split of the u-boot partition
+			 * to maintain the same minor no. as in the normal u-boot.
+			 */
+#			define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:32k(u-boot1),32k(u-boot2),3008k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#		else /* COMPRESSED_UBOOT */
+#		define ATH_U_FILE	u-boot.bin
+#		define ATH_F_FILE	${bc}-jffs2
+#		define ATH_F_LEN	$filesize
+#		define ATH_F_ADDR	0x9f050000
+#		define ATH_K_FILE	vmlinux_${bc}.lzma.uImage
+#		define ATH_K_ADDR	0x9f300000
+#			define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(mib0),64k(ART)"
+#		endif /* COMPRESSED_UBOOT */
+#elif defined(CONFIG_TB6XX_P2P)
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		tb6xx-p2p${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#	define ATH_U_FILE		u-boot.bin
+#	define ATH_F_FILE		tb6xx${bc}-jffs2
+#	define ATH_F_LEN		0x630000
+#	define ATH_F_ADDR		0x9f050000
+#	define ATH_K_FILE		vmlinux${bc}.lzma.uImage
+#	define ATH_K_ADDR		0x9f680000
+#	define MTDPARTS_DEFAULT		"mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif /*CONFIG_MI124*/
+
+#ifndef ATH_ROOT_DEV
+#	define ATH_ROOT_DEV	"31:02"
+#endif
+
+#ifndef ATH_EXTRA_ENV
+#	define ATH_EXTRA_ENV
+#endif
+
+#ifndef ATH_U_CMD
+#	define ATH_U_CMD	gen_cmd(lu, 0x9f000000, ATH_U_FILE)
+#endif
+
+#ifndef ATH_F_CMD
+#	define ATH_F_CMD	gen_cmd_el(lf, ATH_F_ADDR, ATH_F_FILE, ATH_F_LEN)
+#endif
+
+#ifndef ATH_K_CMD
+#	define ATH_K_CMD	gen_cmd(lk, ATH_K_ADDR, ATH_K_FILE)
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"dir=\0" ATH_U_CMD ATH_F_CMD ATH_K_CMD ""
+
+#define	CONFIG_BOOTARGS		"console=ttyS0,115200 root=" ATH_ROOT_DEV " rootfstype=jffs2 init=/sbin/init " MTDPARTS_DEFAULT
+
+//#define CFG_PLL_FREQ    CFG_PLL_720_600_200
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef CONFIG_ATH_NAND_SUPPORT
+#	define CFG_ENV_ADDR		0x9f040000
+#	if (FLASH_SIZE == 16)
+#		define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#	else	/* FLASH_SIZE == 16 */
+#		ifdef COMPRESSED_UBOOT
+#			if (FLASH_SIZE == 4)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else	/* FLASH_SIZE == 4 */
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#			endif	/* FLASH_SIZE == 4 */
+#		else /* COMPRESSED_UBOOT */
+#			if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#			else
+#				define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#			endif
+#		endif	/* COMPRESSED_UBOOT */
+#	endif	/* FLASH_SIZE == 16 */
+#endif
+
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC		0xaabacada
+#define CFG_DDR_MAGIC_F		(UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define ATH_CFG_COMMANDS	((			\
+				CONFIG_CMD_DFL	|	\
+				CFG_CMD_DHCP	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_PCI	|	\
+				CFG_CMD_FLS	|	\
+				CFG_CMD_MII	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET	|	\
+				CFG_CMD_ENV	|	\
+				CFG_CMD_PLL	|	\
+				CFG_CMD_FLASH	|	\
+				CFG_CMD_RUN	|	\
+				CFG_CMD_ELF	|	\
+				CFG_CMD_DDR	|	\
+				CFG_CMD_ETHREG		\
+				) & ~(			\
+				CFG_CMD_IMLS	|	\
+				CFG_CMD_FLASH		\
+				))
+#else
+#define ATH_CFG_COMMANDS	(CONFIG_CMD_DFL	|	\
+				CFG_CMD_PING	|	\
+				CFG_CMD_NET)
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#ifdef CONFIG_ATH_NAND_SUPPORT
+#	ifdef CONFIG_ATH_NAND_BR
+#		define CFG_ENV_IS_IN_NAND	1
+#		define CFG_ENV_OFFSET		0x40000u
+#		define CFG_ENV_SIZE		0x40000u
+#		define ATH_EXTRA_CMD		CFG_CMD_NAND
+#	else
+#		define CFG_ENV_IS_IN_FLASH	1
+#		define CFG_ENV_SIZE		CFG_FLASH_SECTOR_SIZE
+#		define ATH_EXTRA_CMD		(CFG_CMD_NAND | CFG_CMD_FLASH)
+#	endif
+#	define NAND_MAX_CHIPS			1
+#	define CFG_MAX_NAND_DEVICE		1
+#else
+#	define ATH_EXTRA_CMD			CFG_CMD_FLASH
+#	define CFG_ENV_IS_IN_FLASH		1
+#	define CFG_ENV_SIZE			CFG_FLASH_SECTOR_SIZE
+#endif
+
+#define DEBUG
+
+#ifdef COMPRESSED_UBOOT
+#undef  CFG_ENV_IS_IN_FLASH
+#undef  CFG_ENV_IS_IN_NAND
+#define CFG_ENV_IS_NOWHERE		1
+#endif
+
+#define CONFIG_COMMANDS			(ATH_CFG_COMMANDS | ATH_EXTRA_CMD)
+
+#define CONFIG_IPADDR			192.168.1.1
+#define CONFIG_SERVERIP			192.168.1.10
+#define CONFIG_ETHADDR			0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN	1
+
+#define CFG_PHY_ADDR			0
+#define CFG_GMII			0
+#define CFG_MII0_RMII			1
+#define CFG_AG7100_GE0_RMII		1
+
+#define CFG_BOOTM_LEN			(16 << 20) /* 16 MB */
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2		"hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL				0x9fff1000
+#define BOARDCAL			0x9fff0000
+#define ATHEROS_PRODUCT_ID		137
+#define CAL_SECTOR			(CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define ATH_ART_PCICFG_OFFSET		12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __TB6XX_H */
diff --git a/include/configs/wah132.h b/include/configs/wah132.h
new file mode 100644
index 0000000000..7b744e3027
--- /dev/null
+++ b/include/configs/wah132.h
@@ -0,0 +1,422 @@
+/*
+ * This file contains the configuration parameters for the db120 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#if !defined(CONFIG_ATH_NAND_FL)
+#define FLASH_SIZE 16
+#endif
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256    /* max number of sectors on one chip */
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128    /* max number of sectors on one chip */
+#else
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000 /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000    /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF 1
+#endif
+
+#define CONFIG_WASP_SUPPORT 1
+#undef CFG_ATHRS26_PHY
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+// Set this to zero, for 16bit ddr2
+#define DDR2_32BIT_SUPPORT 	1
+
+/* S16 specific defines */
+
+#define CONFIG_AG7240_GE0_IS_CONNECTED 1
+
+/* Assuming nand flash wouldn't use compressed u-boot */
+#ifdef CONFIG_ATH_NAND_FL
+#	define CFG_FLASH_BASE			0
+#else
+	/*
+	 * We boot from this flash
+	 */
+#	define CFG_FLASH_BASE			0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE         CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE  BOOTSTRAP_TEXT_BASE
+#endif
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE          (256 * 1024)
+#define UBOOT_ENV_SEC_START        (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC           0xaabacada  
+#define CFG_FLASH_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F   *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F          *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#define CFG_MAX_FLASH_SECT_F      (CFG_FLASH_SIZE / CFG_FLASH_SECTOR_SIZE) /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE_F          CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F   CFG_FLASH_SECTOR_SIZE
+#endif
+
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+/* Address and size of Primary Environment Sector   */
+#define CFG_ENV_ADDR        (CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#define CFG_ENV_SIZE        CFG_FLASH_SECTOR_SIZE
+
+
+#undef CONFIG_BOOTARGS
+
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),8192k(reserve),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),256k(u-boot-env),5120k(rootfs),1024k(uImage)"
+#else /* FLASH_SIZE=8M */
+#ifdef COMPRESSED_UBOOT
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:01 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:64k(u-boot),6592k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#else
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT    "mtdparts=ath-nor0:256k(u-boot),64k(u-boot-env),6336k(rootfs),1408k(uImage),64k(mib0),64k(ART)"
+#endif
+#endif
+
+#if (FLASH_SIZE == 16)
+#define CFG_KERNEL_ADDR 0x9f680000
+#else
+#define CFG_KERNEL_ADDR 0x9f680000
+#endif
+#define CFG_MIB0_ADDR		0x9ffe0000
+
+#define CONFIG_BOOTCOMMAND "bootm ${KERNELADDR}"
+
+#ifndef CFG_LOAD_ADDR
+#define CFG_LOAD_ADDR		0x80060000
+#endif
+#ifndef COMPRESSED_UBOOT
+#define CFG_FS_ADDR			0x9f050000//(CFG_ENV_ADDR+CFG_ENV_SIZE)
+#else
+#define CFG_FS_ADDR			0x9f010000//(CFG_FLASH_BASE+UBOOT_FLASH_SIZE)
+#endif /* COMPRESSED_UBOOT */
+#define ENV_FS_ADDR			"FSADDR=" MK_STR(CFG_FS_ADDR) "\0"
+
+#define ENV_UBOOT_ADDR		"UBOOTADDR=" MK_STR(CFG_FLASH_BASE) "\0"
+#define ENV_KERNEL_ADDR		"KERNELADDR=" MK_STR(CFG_KERNEL_ADDR) "\0"
+#define ENV_MIB0_ADDR		"MIB0ADDR=" MK_STR(CFG_MIB0_ADDR) "\0"
+
+#define ENV_UPDATE \
+    "update=tftpboot " MK_STR(CFG_LOAD_ADDR) " ${filename} && "	\
+            "erase ${loadaddr} +${filesize} && "				\
+            "cp.b ${fileaddr} ${loadaddr} ${filesize}\0"
+
+#define ENV_UPDATE_KERNEL \
+    "updk=loadaddr=${KERNELADDR} && filename=zImage.uImage && " \
+    "run update\0"
+
+#define ENV_UPDATE_FS \
+    "updfs=loadaddr=${FSADDR} && filename=rootfs-jffs2 && " \
+    "run update\0"
+
+#ifdef COMPRESSED_UBOOT
+#define UBOOT_FILENAME "tuboot.bin"
+#else
+#define UBOOT_FILENAME "u-boot.bin"
+#endif
+
+#define ENV_UPDATE_UBOOT \
+    "updub=loadaddr=${UBOOTADDR} && filename=" UBOOT_FILENAME " && " \
+    "run update\0"
+
+#define ENV_UPDATE_ALL \
+	"updall=run updub && run updfs && run updk\0"
+
+#define ENV_ERASE_MIB0 \
+	"erasemib0=erase ${MIB0ADDR} +0x10000"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		ENV_UBOOT_ADDR \
+		ENV_FS_ADDR \
+		ENV_KERNEL_ADDR \
+		ENV_MIB0_ADDR \
+		ENV_UPDATE \
+		ENV_UPDATE_KERNEL \
+		ENV_UPDATE_FS \
+		ENV_UPDATE_UBOOT \
+		ENV_UPDATE_ALL \
+		ENV_ERASE_MIB0 \
+		""
+
+#undef CFG_PLL_FREQ
+
+//#define CFG_PLL_FREQ	CFG_PLL_600_266_133
+//#define CFG_PLL_FREQ	CFG_PLL_600_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_566_550_275
+//#define CFG_PLL_FREQ	CFG_PLL_566_525_262
+//#define CFG_PLL_FREQ	CFG_PLL_600_332_166
+//#define CFG_PLL_FREQ	CFG_PLL_566_475_237
+//#define CFG_PLL_FREQ	CFG_PLL_600_575_287
+//#define CFG_PLL_FREQ	CFG_PLL_400_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_533_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_450_200
+//#define CFG_PLL_FREQ	CFG_PLL_600_500_1G_250
+//#define CFG_PLL_FREQ	CFG_PLL_600_550_1_1G_275
+//#define CFG_PLL_FREQ	CFG_PLL_600_350_175
+//#define CFG_PLL_FREQ	CFG_PLL_600_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_600_1_2G_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_300_300_150
+//#define CFG_PLL_FREQ	CFG_PLL_500_400_200
+//#define CFG_PLL_FREQ	CFG_PLL_400_200_200
+#if !defined(CONFIG_AP123) && !defined(CONFIG_MI124)
+#define CFG_PLL_FREQ    CFG_PLL_560_480_240
+#else
+#define CFG_PLL_FREQ    CFG_PLL_533_400_200
+#endif
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#   define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#   define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#   define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#   define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#   define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#   define CFG_HZ          (320000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_410_400_200)
+#   define CFG_HZ          (410000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_420_400_200)
+#   define CFG_HZ          (420000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_240_240_120)
+#   define CFG_HZ          (240000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_160_160_80)
+#   define CFG_HZ          (160000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_200_200)
+#   define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_500_400_200)
+#   define CFG_HZ          (500000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_400_200) || (CFG_PLL_FREQ == CFG_PLL_600_450_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_600_300) || (CFG_PLL_FREQ == CFG_PLL_600_550_275) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_332_166) || (CFG_PLL_FREQ == CFG_PLL_600_575_287) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_525_262) || (CFG_PLL_FREQ == CFG_PLL_600_332_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_266_133) || (CFG_PLL_FREQ == CFG_PLL_600_266_200) || \
+      (CFG_PLL_FREQ == CFG_PLL_600_650_325) ||  (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_1_2G_400_200)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_1G_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_550_1_1G_275)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_500_250)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_350_175)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_600_300_150)
+#   define CFG_HZ          (600000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_533_400_200) || (CFG_PLL_FREQ == CFG_PLL_533_500_250)
+#   define CFG_HZ          (533000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_700_400_200)
+#   define CFG_HZ          (700000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_650_600_300)
+#   define CFG_HZ          (650000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_560_480_240)
+#   define CFG_HZ          (560000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_566_475_237) || (CFG_PLL_FREQ == CFG_PLL_566_450_225) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_550_275) || (CFG_PLL_FREQ == CFG_PLL_566_525_262) || \
+      (CFG_PLL_FREQ == CFG_PLL_566_400_200) || (CFG_PLL_FREQ == CFG_PLL_566_500_250)
+#   define CFG_HZ          (566000000/2)
+#endif
+
+/*
+ * timeout values are in ticks
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#ifndef COMPRESSED_UBOOT
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE
+#else
+#undef  CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_NOWHERE  1
+#endif
+
+#if 0
+#ifdef CONFIG_ATH_NAND_FL
+#define CONFIG_BOOTCOMMAND "bootm 0x80000"
+#define CFG_ENV_ADDR		0x00040000
+#else  /* CONFIG_ATH_NAND_FL */
+#define CFG_ENV_ADDR		0x9f040000
+#if (FLASH_SIZE == 16)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f550000"
+#else  /* FLASH_SIZE == 16 */
+#ifdef COMPRESSED_UBOOT
+#if (FLASH_SIZE == 4)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else  /* FLASH_SIZE == 4 */
+#define CONFIG_BOOTCOMMAND "bootm 0x9f320000"
+#endif  /* FLASH_SIZE == 4 */
+#else /* COMPRESSED_UBOOT */
+#if defined(CONFIG_MI124) || defined(CONFIG_AP123)
+#define CONFIG_BOOTCOMMAND "bootm 0x9f300000"
+#else
+#define CONFIG_BOOTCOMMAND "bootm 0x9f680000"
+#endif
+#endif  /* COMPRESSED_UBOOT */
+#endif  /* FLASH_SIZE == 16 */
+#endif  /* CONFIG_ATH_NAND_FL */
+#endif
+
+
+
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+/* DDR settings for WASP */
+
+#define CFG_DDR_REFRESH_VAL     0x4270
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL     0x9dd0e6a8
+
+
+
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+
+#if DDR2_32BIT_SUPPORT
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32
+#else
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL		CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16
+#endif
+
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL		0xffff
+#define CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL	0xffffffff
+
+/* DDR2 Init values */
+#define CFG_DDR2_EXT_MODE_VAL    0x402
+
+
+#ifdef ENABLE_DYNAMIC_CONF
+#define CFG_DDR_MAGIC           0xaabacada
+#define CFG_DDR_MAGIC_F         (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x30)
+#define CFG_DDR_CONFIG_VAL_F    *(volatile int *)(CFG_DDR_MAGIC_F + 4)
+#define CFG_DDR_CONFIG2_VAL_F	*(volatile int *)(CFG_DDR_MAGIC_F + 8)
+#define CFG_DDR_EXT_MODE_VAL_F  *(volatile int *)(CFG_DDR_MAGIC_F + 12)
+#endif
+
+#define CONFIG_NET_MULTI
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI 1
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#ifndef COMPRESSED_UBOOT
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | CFG_CMD_PCI | CFG_CMD_FLS |\
+	CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET | CFG_CMD_ENV | CFG_CMD_PLL| \
+	CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB | CFG_CMD_ELF | CFG_CMD_DDR | CFG_CMD_ETHREG))
+#else
+#define CONFIG_COMMANDS (( CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_NET))
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+#define CONFIG_IPADDR   192.168.1.1
+#define CONFIG_SERVERIP 192.168.1.10
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_WAH132 1 
+
+#define CFG_PHY_ADDR 0 
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0x9fff1000
+#define BOARDCAL                        0x9fff0000
+#define ATHEROS_PRODUCT_ID              137
+#define CAL_SECTOR                      (CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/wasp_emu.h b/include/configs/wasp_emu.h
new file mode 100644
index 0000000000..b443030972
--- /dev/null
+++ b/include/configs/wasp_emu.h
@@ -0,0 +1,179 @@
+/*
+ * This file contains the configuration parameters for the dbau1x00 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+
+#define CONFIG_AR7240_EMU 1
+#define CONFIG_WASP_EMU 1
+#define CONFIG_WASP_SUPPORT 1
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      64    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00400000 /* Total flash size */
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0xbf000000
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS     "console=ttyS0,9600 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ	CFG_PLL_400_400_100
+
+/* Atheros Header configuration */
+
+#define CFG_ATHRS27_PHY  1
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0xbf040000
+#define CFG_ENV_SIZE		0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0xbf550000"
+//#define CONFIG_FLASH_16BIT
+
+#define CONFIG_NR_DRAM_BANKS	2
+#if 0
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#define CFG_DDR_REFRESH_VAL     0x4c00
+#define CFG_DDR_CONFIG_VAL      0x67bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x161
+#define CFG_DDR_EXT_MODE_VAL    0x2
+#define CFG_DDR_MODE_VAL        0x61
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#define CFG_DDR_REFRESH_VAL     0x5f00
+#define CFG_DDR_CONFIG_VAL      0x77bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x131
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x31
+#endif
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL			    0x83d1f6a2
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0xffff
+
+#endif
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0x6fbc8890
+#define CFG_DDR_MODE_VAL_INIT   0x123
+#define CFG_DDR_EXT_MODE_VAL    0x1
+#define CFG_DDR_MODE_VAL        0x23
+
+#define CFG_DDR_CONFIG2_VAL     0x91d0e6a8	
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_DHCP | CFG_CMD_ELF | \
+            CFG_CMD_MII | CFG_CMD_PING | CFG_CMD_NET |\
+   CFG_CMD_ENV | CFG_CMD_FLASH | CFG_CMD_LOADS | CFG_CMD_RUN | CFG_CMD_LOADB \
+   | CFG_CMD_ELF ))
+
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.27
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL                         0xbfff1000
+#define BOARDCAL                        0xbfff0000
+#define ATHEROS_PRODUCT_ID              136
+#define CAL_SECTOR                      63
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define AR7240_ART_PCICFG_OFFSET        12
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/wrt54g.h b/include/configs/wrt54g.h
new file mode 100644
index 0000000000..82b73050ee
--- /dev/null
+++ b/include/configs/wrt54g.h
@@ -0,0 +1,173 @@
+/*****************************************************************************/
+/* \file wrt54g.h
+** \brief wrt54g configuration file
+**
+**  This file contains all of the specific definitions for the WRT54G project
+**  in u-boot.
+**
+**  Copyright (c) 2009 Atheros Communications Inc.  All rights reserved.
+** 
+**  This file is proprietary to Atheros Communications, Inc.'s and licensed only
+**  according to a Technology License Agreement approved and executed by Atheros,
+**  or sublicensed by an authorized sublicensor.
+*/
+
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/ar7240.h>
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS     1	    /* max number of memory banks */
+#define CFG_MAX_FLASH_SECT      32    /* max number of sectors on one chip */
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#define CFG_FLASH_SIZE          0x00200000 /* Total flash size */
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#	error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short 
+
+/* 
+ * We boot from this flash
+ */
+#define CFG_FLASH_BASE		    0xbf000000
+
+/* 
+ * The following #defines are needed to get flash environment right 
+ */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#undef CONFIG_BOOTARGS
+/* XXX - putting rootfs in last partition results in jffs errors */
+#define	CONFIG_BOOTARGS     "console=ttyS0,115200 root=31:02 rootfstype=jffs2 init=/sbin/init mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),2752k(rootfs),896k(uImage),64k(NVRAM),64k(ART)"
+
+/* default mtd partition table */
+#undef MTDPARTS_DEFAULT
+#define MTDPARTS_DEFAULT    "mtdparts=ar7240-nor0:256k(u-boot),64k(u-boot-env),5120k(rootfs),1024k(uImage)"
+
+#undef CFG_PLL_FREQ
+#define CFG_PLL_FREQ	CFG_PLL_350_350_175
+
+
+#undef CFG_HZ
+/*
+ * MIPS32 24K Processor Core Family Software User's Manual
+ *
+ * 6.2.9 Count Register (CP0 Register 9, Select 0)
+ * The Count register acts as a timer, incrementing at a constant
+ * rate, whether or not an instruction is executed, retired, or
+ * any forward progress is made through the pipeline.  The counter
+ * increments every other clock, if the DC bit in the Cause register
+ * is 0.
+ */
+/* Since the count is incremented every other tick, divide by 2 */
+/* XXX derive this from CFG_PLL_FREQ */
+#if (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+#	define CFG_HZ          (200000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+#	define CFG_HZ          (300000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_350_350_175)
+#	define CFG_HZ          (350000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+#	define CFG_HZ          (333000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+#	define CFG_HZ          (266000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200) || (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+#	define CFG_HZ          (400000000/2)
+#elif (CFG_PLL_FREQ == CFG_PLL_320_320_80) || (CFG_PLL_FREQ == CFG_PLL_320_320_160)
+#	define CFG_HZ          (400000000/2)
+#endif
+
+
+/* 
+ * timeout values are in ticks 
+ */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+/*
+ * Cache lock for stack
+ */
+#define CFG_INIT_SP_OFFSET	0x1000
+
+#define	CFG_ENV_IS_IN_FLASH    1
+#undef CFG_ENV_IS_NOWHERE  
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0xbf030000
+#define CFG_ENV_SIZE		0x10000
+
+#define CONFIG_BOOTCOMMAND "bootm 0x9f050000"
+//#define CONFIG_FLASH_16BIT
+
+/* DDR init values */
+
+#define CONFIG_NR_DRAM_BANKS	2
+#define CFG_DDR_REFRESH_VAL     0x4f10
+#define CFG_DDR_CONFIG_VAL      0xc7bc8cd0
+#define CFG_DDR_MODE_VAL_INIT   0x133
+#define CFG_DDR_EXT_MODE_VAL    0x0
+#define CFG_DDR_MODE_VAL        0x33
+
+#define CFG_DDR_TRTW_VAL        0x1f
+#define CFG_DDR_TWTR_VAL        0x1e
+
+#define CFG_DDR_CONFIG2_VAL	 0x9dd0e6a8
+#define CFG_DDR_RD_DATA_THIS_CYCLE_VAL  0x00ff
+
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_MEMSIZE_IN_BYTES
+#define CONFIG_PCI
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CONFIG_COMMANDS	(( CONFIG_CMD_DFL | CFG_CMD_PCI   | CFG_CMD_MII | CFG_CMD_PING | \
+			               CFG_CMD_NET    | CFG_CMD_ENV   |	CMD_FLASH   | CFG_CMD_ELF  | \
+			               CFG_CMD_RUN    | CFG_CMD_ETHREG ))
+
+
+#define CONFIG_IPADDR   192.168.1.10
+#define CONFIG_SERVERIP 192.168.1.27
+#define CONFIG_ETHADDR 0x00:0xaa:0xbb:0xcc:0xdd:0xee
+#define CFG_FAULT_ECHO_LINK_DOWN    1
+
+
+#define CFG_PHY_ADDR 0 
+#define CFG_AG7240_NMACS 2
+#define CFG_GMII     0
+#define CFG_MII0_RMII             1
+#define CFG_AG7100_GE0_RMII             1
+
+#define CFG_BOOTM_LEN	(16 << 20) /* 16 MB */
+#define DEBUG
+/*
+#define CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2 "hush>"
+*/
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the radio.
+*/
+
+#define WLANCAL                        0xbfff1000
+#define BOARDCAL                       0xbfff0000
+#define ATHEROS_PRODUCT_ID             140
+#define CAL_SECTOR                     (CFG_MAX_FLASH_SECT - 1)
+
+/* For Kite, only PCI-e interface is valid */
+#define AR7240_ART_PCICFG_OFFSET        3
+
+#include <cmd_confdefs.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/flash.h b/include/flash.h
index a84dc6872e..11285b4866 100644
--- a/include/flash.h
+++ b/include/flash.h
@@ -416,6 +416,8 @@ extern void flash_read_factory_serial(flash_info_t * info, void * buffer, int of
 #define FLASH_MT28S4M16LC 0x00E1	/* Micron MT28S4M16LC			*/
 #define FLASH_S29GL064M 0x00F0		/* Spansion S29GL064M-R6		*/
 
+#define FLASH_M25P64    0x00F2      
+
 #define FLASH_UNKNOWN	0xFFFF		/* unknown flash type			*/
 
 
diff --git a/include/hornet_soc.h b/include/hornet_soc.h
new file mode 100644
index 0000000000..b57e8203e3
--- /dev/null
+++ b/include/hornet_soc.h
@@ -0,0 +1,293 @@
+/*
+ * Atheror Hornet series processor SOC registers
+ *
+ * (C) Copyright 2010 Atheros Communications, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _HORNET_SOC_H
+#define _HORNET_SOC_H
+#include <ar7240_soc.h>
+#include <config.h>
+
+/*
+ * UART block
+ */
+// 0x0000 (UARTDATA)
+#define UARTDATA_UARTTXCSR_MSB                                       9
+#define UARTDATA_UARTTXCSR_LSB                                       9
+#define UARTDATA_UARTTXCSR_MASK                                      0x00000200
+#define UARTDATA_UARTTXCSR_GET(x)                                    (((x) & UARTDATA_UARTTXCSR_MASK) >> UARTDATA_UARTTXCSR_LSB)
+#define UARTDATA_UARTTXCSR_SET(x)                                    (((0 | (x)) << UARTDATA_UARTTXCSR_LSB) & UARTDATA_UARTTXCSR_MASK)
+#define UARTDATA_UARTTXCSR_RESET                                     0
+#define UARTDATA_UARTRXCSR_MSB                                       8
+#define UARTDATA_UARTRXCSR_LSB                                       8
+#define UARTDATA_UARTRXCSR_MASK                                      0x00000100
+#define UARTDATA_UARTRXCSR_GET(x)                                    (((x) & UARTDATA_UARTRXCSR_MASK) >> UARTDATA_UARTRXCSR_LSB)
+#define UARTDATA_UARTRXCSR_SET(x)                                    (((0 | (x)) << UARTDATA_UARTRXCSR_LSB) & UARTDATA_UARTRXCSR_MASK)
+#define UARTDATA_UARTRXCSR_RESET                                     0
+#define UARTDATA_UARTTXRXDATA_MSB                                    7
+#define UARTDATA_UARTTXRXDATA_LSB                                    0
+#define UARTDATA_UARTTXRXDATA_MASK                                   0x000000ff
+#define UARTDATA_UARTTXRXDATA_GET(x)                                 (((x) & UARTDATA_UARTTXRXDATA_MASK) >> UARTDATA_UARTTXRXDATA_LSB)
+#define UARTDATA_UARTTXRXDATA_SET(x)                                 (((0 | (x)) << UARTDATA_UARTTXRXDATA_LSB) & UARTDATA_UARTTXRXDATA_MASK)
+#define UARTDATA_UARTTXRXDATA_RESET                                  0
+#define UARTDATA_ADDRESS                                             0x0000
+#define UARTDATA_HW_MASK                                             0x000003ff
+#define UARTDATA_SW_MASK                                             0x000003ff
+#define UARTDATA_RSTMASK                                             0x000003ff
+#define UARTDATA_RESET                                               0x00000000
+
+// 0x0004 (UARTCS)
+#define UARTCS_UARTRXBUSY_MSB                                        15
+#define UARTCS_UARTRXBUSY_LSB                                        15
+#define UARTCS_UARTRXBUSY_MASK                                       0x00008000
+#define UARTCS_UARTRXBUSY_GET(x)                                     (((x) & UARTCS_UARTRXBUSY_MASK) >> UARTCS_UARTRXBUSY_LSB)
+#define UARTCS_UARTRXBUSY_SET(x)                                     (((0 | (x)) << UARTCS_UARTRXBUSY_LSB) & UARTCS_UARTRXBUSY_MASK)
+#define UARTCS_UARTRXBUSY_RESET                                      0
+#define UARTCS_UARTTXBUSY_MSB                                        14
+#define UARTCS_UARTTXBUSY_LSB                                        14
+#define UARTCS_UARTTXBUSY_MASK                                       0x00004000
+#define UARTCS_UARTTXBUSY_GET(x)                                     (((x) & UARTCS_UARTTXBUSY_MASK) >> UARTCS_UARTTXBUSY_LSB)
+#define UARTCS_UARTTXBUSY_SET(x)                                     (((0 | (x)) << UARTCS_UARTTXBUSY_LSB) & UARTCS_UARTTXBUSY_MASK)
+#define UARTCS_UARTTXBUSY_RESET                                      0
+#define UARTCS_UARTHOSTINTEN_MSB                                     13
+#define UARTCS_UARTHOSTINTEN_LSB                                     13
+#define UARTCS_UARTHOSTINTEN_MASK                                    0x00002000
+#define UARTCS_UARTHOSTINTEN_GET(x)                                  (((x) & UARTCS_UARTHOSTINTEN_MASK) >> UARTCS_UARTHOSTINTEN_LSB)
+#define UARTCS_UARTHOSTINTEN_SET(x)                                  (((0 | (x)) << UARTCS_UARTHOSTINTEN_LSB) & UARTCS_UARTHOSTINTEN_MASK)
+#define UARTCS_UARTHOSTINTEN_RESET                                   0
+#define UARTCS_UARTHOSTINT_MSB                                       12
+#define UARTCS_UARTHOSTINT_LSB                                       12
+#define UARTCS_UARTHOSTINT_MASK                                      0x00001000
+#define UARTCS_UARTHOSTINT_GET(x)                                    (((x) & UARTCS_UARTHOSTINT_MASK) >> UARTCS_UARTHOSTINT_LSB)
+#define UARTCS_UARTHOSTINT_SET(x)                                    (((0 | (x)) << UARTCS_UARTHOSTINT_LSB) & UARTCS_UARTHOSTINT_MASK)
+#define UARTCS_UARTHOSTINT_RESET                                     0
+#define UARTCS_UARTTXBREAK_MSB                                       11
+#define UARTCS_UARTTXBREAK_LSB                                       11
+#define UARTCS_UARTTXBREAK_MASK                                      0x00000800
+#define UARTCS_UARTTXBREAK_GET(x)                                    (((x) & UARTCS_UARTTXBREAK_MASK) >> UARTCS_UARTTXBREAK_LSB)
+#define UARTCS_UARTTXBREAK_SET(x)                                    (((0 | (x)) << UARTCS_UARTTXBREAK_LSB) & UARTCS_UARTTXBREAK_MASK)
+#define UARTCS_UARTTXBREAK_RESET                                     0
+#define UARTCS_UARTRXBREAK_MSB                                       10
+#define UARTCS_UARTRXBREAK_LSB                                       10
+#define UARTCS_UARTRXBREAK_MASK                                      0x00000400
+#define UARTCS_UARTRXBREAK_GET(x)                                    (((x) & UARTCS_UARTRXBREAK_MASK) >> UARTCS_UARTRXBREAK_LSB)
+#define UARTCS_UARTRXBREAK_SET(x)                                    (((0 | (x)) << UARTCS_UARTRXBREAK_LSB) & UARTCS_UARTRXBREAK_MASK)
+#define UARTCS_UARTRXBREAK_RESET                                     0
+#define UARTCS_UARTSERIATXREADY_MSB                                  9
+#define UARTCS_UARTSERIATXREADY_LSB                                  9
+#define UARTCS_UARTSERIATXREADY_MASK                                 0x00000200
+#define UARTCS_UARTSERIATXREADY_GET(x)                               (((x) & UARTCS_UARTSERIATXREADY_MASK) >> UARTCS_UARTSERIATXREADY_LSB)
+#define UARTCS_UARTSERIATXREADY_SET(x)                               (((0 | (x)) << UARTCS_UARTSERIATXREADY_LSB) & UARTCS_UARTSERIATXREADY_MASK)
+#define UARTCS_UARTSERIATXREADY_RESET                                0
+#define UARTCS_UARTTXREADYORIDE_MSB                                  8
+#define UARTCS_UARTTXREADYORIDE_LSB                                  8
+#define UARTCS_UARTTXREADYORIDE_MASK                                 0x00000100
+#define UARTCS_UARTTXREADYORIDE_GET(x)                               (((x) & UARTCS_UARTTXREADYORIDE_MASK) >> UARTCS_UARTTXREADYORIDE_LSB)
+#define UARTCS_UARTTXREADYORIDE_SET(x)                               (((0 | (x)) << UARTCS_UARTTXREADYORIDE_LSB) & UARTCS_UARTTXREADYORIDE_MASK)
+#define UARTCS_UARTTXREADYORIDE_RESET                                0
+#define UARTCS_UARTRXREADYORIDE_MSB                                  7
+#define UARTCS_UARTRXREADYORIDE_LSB                                  7
+#define UARTCS_UARTRXREADYORIDE_MASK                                 0x00000080
+#define UARTCS_UARTRXREADYORIDE_GET(x)                               (((x) & UARTCS_UARTRXREADYORIDE_MASK) >> UARTCS_UARTRXREADYORIDE_LSB)
+#define UARTCS_UARTRXREADYORIDE_SET(x)                               (((0 | (x)) << UARTCS_UARTRXREADYORIDE_LSB) & UARTCS_UARTRXREADYORIDE_MASK)
+#define UARTCS_UARTRXREADYORIDE_RESET                                0
+#define UARTCS_UARTDMAEN_MSB                                         6
+#define UARTCS_UARTDMAEN_LSB                                         6
+#define UARTCS_UARTDMAEN_MASK                                        0x00000040
+#define UARTCS_UARTDMAEN_GET(x)                                      (((x) & UARTCS_UARTDMAEN_MASK) >> UARTCS_UARTDMAEN_LSB)
+#define UARTCS_UARTDMAEN_SET(x)                                      (((0 | (x)) << UARTCS_UARTDMAEN_LSB) & UARTCS_UARTDMAEN_MASK)
+#define UARTCS_UARTDMAEN_RESET                                       0
+#define UARTCS_UARTFLOWCONTROLMODE_MSB                               5
+#define UARTCS_UARTFLOWCONTROLMODE_LSB                               4
+#define UARTCS_UARTFLOWCONTROLMODE_MASK                              0x00000030
+#define UARTCS_UARTFLOWCONTROLMODE_GET(x)                            (((x) & UARTCS_UARTFLOWCONTROLMODE_MASK) >> UARTCS_UARTFLOWCONTROLMODE_LSB)
+#define UARTCS_UARTFLOWCONTROLMODE_SET(x)                            (((0 | (x)) << UARTCS_UARTFLOWCONTROLMODE_LSB) & UARTCS_UARTFLOWCONTROLMODE_MASK)
+#define UARTCS_UARTFLOWCONTROLMODE_RESET                             0
+#define UARTCS_UARTINTERFACEMODE_MSB                                 3
+#define UARTCS_UARTINTERFACEMODE_LSB                                 2
+#define UARTCS_UARTINTERFACEMODE_MASK                                0x0000000c
+#define UARTCS_UARTINTERFACEMODE_GET(x)                              (((x) & UARTCS_UARTINTERFACEMODE_MASK) >> UARTCS_UARTINTERFACEMODE_LSB)
+#define UARTCS_UARTINTERFACEMODE_SET(x)                              (((0 | (x)) << UARTCS_UARTINTERFACEMODE_LSB) & UARTCS_UARTINTERFACEMODE_MASK)
+#define UARTCS_UARTINTERFACEMODE_RESET                               0
+#define UARTCS_UARTPARITYMODE_MSB                                    1
+#define UARTCS_UARTPARITYMODE_LSB                                    0
+#define UARTCS_UARTPARITYMODE_MASK                                   0x00000003
+#define UARTCS_UARTPARITYMODE_GET(x)                                 (((x) & UARTCS_UARTPARITYMODE_MASK) >> UARTCS_UARTPARITYMODE_LSB)
+#define UARTCS_UARTPARITYMODE_SET(x)                                 (((0 | (x)) << UARTCS_UARTPARITYMODE_LSB) & UARTCS_UARTPARITYMODE_MASK)
+#define UARTCS_UARTPARITYMODE_RESET                                  0
+#define UARTCS_ADDRESS                                               0x0004
+#define UARTCS_HW_MASK                                               0x0000ffff
+#define UARTCS_SW_MASK                                               0x0000ffff
+#define UARTCS_RSTMASK                                               0x000029ff
+#define UARTCS_RESET                                                 0x00000000
+
+// 0x0008 (UARTCLOCK)
+#define UARTCLOCK_UARTCLOCKSCALE_MSB                                 23
+#define UARTCLOCK_UARTCLOCKSCALE_LSB                                 16
+#define UARTCLOCK_UARTCLOCKSCALE_MASK                                0x00ff0000
+#define UARTCLOCK_UARTCLOCKSCALE_GET(x)                              (((x) & UARTCLOCK_UARTCLOCKSCALE_MASK) >> UARTCLOCK_UARTCLOCKSCALE_LSB)
+#define UARTCLOCK_UARTCLOCKSCALE_SET(x)                              (((0 | (x)) << UARTCLOCK_UARTCLOCKSCALE_LSB) & UARTCLOCK_UARTCLOCKSCALE_MASK)
+#define UARTCLOCK_UARTCLOCKSCALE_RESET                               0
+#define UARTCLOCK_UARTCLOCKSTEP_MSB                                  15
+#define UARTCLOCK_UARTCLOCKSTEP_LSB                                  0
+#define UARTCLOCK_UARTCLOCKSTEP_MASK                                 0x0000ffff
+#define UARTCLOCK_UARTCLOCKSTEP_GET(x)                               (((x) & UARTCLOCK_UARTCLOCKSTEP_MASK) >> UARTCLOCK_UARTCLOCKSTEP_LSB)
+#define UARTCLOCK_UARTCLOCKSTEP_SET(x)                               (((0 | (x)) << UARTCLOCK_UARTCLOCKSTEP_LSB) & UARTCLOCK_UARTCLOCKSTEP_MASK)
+#define UARTCLOCK_UARTCLOCKSTEP_RESET                                0
+#define UARTCLOCK_ADDRESS                                            0x0008
+#define UARTCLOCK_HW_MASK                                            0x00ffffff
+#define UARTCLOCK_SW_MASK                                            0x00ffffff
+#define UARTCLOCK_RSTMASK                                            0x00ffffff
+#define UARTCLOCK_RESET                                              0x00000000
+
+// 0x000c (UARTINT)
+#define UARTINT_UARTTXEMPTYINT_MSB                                   9
+#define UARTINT_UARTTXEMPTYINT_LSB                                   9
+#define UARTINT_UARTTXEMPTYINT_MASK                                  0x00000200
+#define UARTINT_UARTTXEMPTYINT_GET(x)                                (((x) & UARTINT_UARTTXEMPTYINT_MASK) >> UARTINT_UARTTXEMPTYINT_LSB)
+#define UARTINT_UARTTXEMPTYINT_SET(x)                                (((0 | (x)) << UARTINT_UARTTXEMPTYINT_LSB) & UARTINT_UARTTXEMPTYINT_MASK)
+#define UARTINT_UARTTXEMPTYINT_RESET                                 0
+#define UARTINT_UARTRXFULLINT_MSB                                    8
+#define UARTINT_UARTRXFULLINT_LSB                                    8
+#define UARTINT_UARTRXFULLINT_MASK                                   0x00000100
+#define UARTINT_UARTRXFULLINT_GET(x)                                 (((x) & UARTINT_UARTRXFULLINT_MASK) >> UARTINT_UARTRXFULLINT_LSB)
+#define UARTINT_UARTRXFULLINT_SET(x)                                 (((0 | (x)) << UARTINT_UARTRXFULLINT_LSB) & UARTINT_UARTRXFULLINT_MASK)
+#define UARTINT_UARTRXFULLINT_RESET                                  0
+#define UARTINT_UARTRXBREAKOFFINT_MSB                                7
+#define UARTINT_UARTRXBREAKOFFINT_LSB                                7
+#define UARTINT_UARTRXBREAKOFFINT_MASK                               0x00000080
+#define UARTINT_UARTRXBREAKOFFINT_GET(x)                             (((x) & UARTINT_UARTRXBREAKOFFINT_MASK) >> UARTINT_UARTRXBREAKOFFINT_LSB)
+#define UARTINT_UARTRXBREAKOFFINT_SET(x)                             (((0 | (x)) << UARTINT_UARTRXBREAKOFFINT_LSB) & UARTINT_UARTRXBREAKOFFINT_MASK)
+#define UARTINT_UARTRXBREAKOFFINT_RESET                              0
+#define UARTINT_UARTRXBREAKONINT_MSB                                 6
+#define UARTINT_UARTRXBREAKONINT_LSB                                 6
+#define UARTINT_UARTRXBREAKONINT_MASK                                0x00000040
+#define UARTINT_UARTRXBREAKONINT_GET(x)                              (((x) & UARTINT_UARTRXBREAKONINT_MASK) >> UARTINT_UARTRXBREAKONINT_LSB)
+#define UARTINT_UARTRXBREAKONINT_SET(x)                              (((0 | (x)) << UARTINT_UARTRXBREAKONINT_LSB) & UARTINT_UARTRXBREAKONINT_MASK)
+#define UARTINT_UARTRXBREAKONINT_RESET                               0
+#define UARTINT_UARTRXPARITYERRINT_MSB                               5
+#define UARTINT_UARTRXPARITYERRINT_LSB                               5
+#define UARTINT_UARTRXPARITYERRINT_MASK                              0x00000020
+#define UARTINT_UARTRXPARITYERRINT_GET(x)                            (((x) & UARTINT_UARTRXPARITYERRINT_MASK) >> UARTINT_UARTRXPARITYERRINT_LSB)
+#define UARTINT_UARTRXPARITYERRINT_SET(x)                            (((0 | (x)) << UARTINT_UARTRXPARITYERRINT_LSB) & UARTINT_UARTRXPARITYERRINT_MASK)
+#define UARTINT_UARTRXPARITYERRINT_RESET                             0
+#define UARTINT_UARTTXOFLOWERRINT_MSB                                4
+#define UARTINT_UARTTXOFLOWERRINT_LSB                                4
+#define UARTINT_UARTTXOFLOWERRINT_MASK                               0x00000010
+#define UARTINT_UARTTXOFLOWERRINT_GET(x)                             (((x) & UARTINT_UARTTXOFLOWERRINT_MASK) >> UARTINT_UARTTXOFLOWERRINT_LSB)
+#define UARTINT_UARTTXOFLOWERRINT_SET(x)                             (((0 | (x)) << UARTINT_UARTTXOFLOWERRINT_LSB) & UARTINT_UARTTXOFLOWERRINT_MASK)
+#define UARTINT_UARTTXOFLOWERRINT_RESET                              0
+#define UARTINT_UARTRXOFLOWERRINT_MSB                                3
+#define UARTINT_UARTRXOFLOWERRINT_LSB                                3
+#define UARTINT_UARTRXOFLOWERRINT_MASK                               0x00000008
+#define UARTINT_UARTRXOFLOWERRINT_GET(x)                             (((x) & UARTINT_UARTRXOFLOWERRINT_MASK) >> UARTINT_UARTRXOFLOWERRINT_LSB)
+#define UARTINT_UARTRXOFLOWERRINT_SET(x)                             (((0 | (x)) << UARTINT_UARTRXOFLOWERRINT_LSB) & UARTINT_UARTRXOFLOWERRINT_MASK)
+#define UARTINT_UARTRXOFLOWERRINT_RESET                              0
+#define UARTINT_UARTRXFRAMINGERRINT_MSB                              2
+#define UARTINT_UARTRXFRAMINGERRINT_LSB                              2
+#define UARTINT_UARTRXFRAMINGERRINT_MASK                             0x00000004
+#define UARTINT_UARTRXFRAMINGERRINT_GET(x)                           (((x) & UARTINT_UARTRXFRAMINGERRINT_MASK) >> UARTINT_UARTRXFRAMINGERRINT_LSB)
+#define UARTINT_UARTRXFRAMINGERRINT_SET(x)                           (((0 | (x)) << UARTINT_UARTRXFRAMINGERRINT_LSB) & UARTINT_UARTRXFRAMINGERRINT_MASK)
+#define UARTINT_UARTRXFRAMINGERRINT_RESET                            0
+#define UARTINT_UARTTXREADYINT_MSB                                   1
+#define UARTINT_UARTTXREADYINT_LSB                                   1
+#define UARTINT_UARTTXREADYINT_MASK                                  0x00000002
+#define UARTINT_UARTTXREADYINT_GET(x)                                (((x) & UARTINT_UARTTXREADYINT_MASK) >> UARTINT_UARTTXREADYINT_LSB)
+#define UARTINT_UARTTXREADYINT_SET(x)                                (((0 | (x)) << UARTINT_UARTTXREADYINT_LSB) & UARTINT_UARTTXREADYINT_MASK)
+#define UARTINT_UARTTXREADYINT_RESET                                 0
+#define UARTINT_UARTRXVALIDINT_MSB                                   0
+#define UARTINT_UARTRXVALIDINT_LSB                                   0
+#define UARTINT_UARTRXVALIDINT_MASK                                  0x00000001
+#define UARTINT_UARTRXVALIDINT_GET(x)                                (((x) & UARTINT_UARTRXVALIDINT_MASK) >> UARTINT_UARTRXVALIDINT_LSB)
+#define UARTINT_UARTRXVALIDINT_SET(x)                                (((0 | (x)) << UARTINT_UARTRXVALIDINT_LSB) & UARTINT_UARTRXVALIDINT_MASK)
+#define UARTINT_UARTRXVALIDINT_RESET                                 0
+#define UARTINT_ADDRESS                                              0x000c
+#define UARTINT_HW_MASK                                              0x000003ff
+#define UARTINT_SW_MASK                                              0x000003ff
+#define UARTINT_RSTMASK                                              0x000003ff
+#define UARTINT_RESET                                                0x00000000
+
+// 0x0010 (UARTINTEN)
+#define UARTINTEN_UARTTXEMPTYINTEN_MSB                               9
+#define UARTINTEN_UARTTXEMPTYINTEN_LSB                               9
+#define UARTINTEN_UARTTXEMPTYINTEN_MASK                              0x00000200
+#define UARTINTEN_UARTTXEMPTYINTEN_GET(x)                            (((x) & UARTINTEN_UARTTXEMPTYINTEN_MASK) >> UARTINTEN_UARTTXEMPTYINTEN_LSB)
+#define UARTINTEN_UARTTXEMPTYINTEN_SET(x)                            (((0 | (x)) << UARTINTEN_UARTTXEMPTYINTEN_LSB) & UARTINTEN_UARTTXEMPTYINTEN_MASK)
+#define UARTINTEN_UARTTXEMPTYINTEN_RESET                             0
+#define UARTINTEN_UARTRXFULLINTEN_MSB                                8
+#define UARTINTEN_UARTRXFULLINTEN_LSB                                8
+#define UARTINTEN_UARTRXFULLINTEN_MASK                               0x00000100
+#define UARTINTEN_UARTRXFULLINTEN_GET(x)                             (((x) & UARTINTEN_UARTRXFULLINTEN_MASK) >> UARTINTEN_UARTRXFULLINTEN_LSB)
+#define UARTINTEN_UARTRXFULLINTEN_SET(x)                             (((0 | (x)) << UARTINTEN_UARTRXFULLINTEN_LSB) & UARTINTEN_UARTRXFULLINTEN_MASK)
+#define UARTINTEN_UARTRXFULLINTEN_RESET                              0
+#define UARTINTEN_UARTRXBREAKOFFINTEN_MSB                            7
+#define UARTINTEN_UARTRXBREAKOFFINTEN_LSB                            7
+#define UARTINTEN_UARTRXBREAKOFFINTEN_MASK                           0x00000080
+#define UARTINTEN_UARTRXBREAKOFFINTEN_GET(x)                         (((x) & UARTINTEN_UARTRXBREAKOFFINTEN_MASK) >> UARTINTEN_UARTRXBREAKOFFINTEN_LSB)
+#define UARTINTEN_UARTRXBREAKOFFINTEN_SET(x)                         (((0 | (x)) << UARTINTEN_UARTRXBREAKOFFINTEN_LSB) & UARTINTEN_UARTRXBREAKOFFINTEN_MASK)
+#define UARTINTEN_UARTRXBREAKOFFINTEN_RESET                          0
+#define UARTINTEN_UARTRXBREAKONINTEN_MSB                             6
+#define UARTINTEN_UARTRXBREAKONINTEN_LSB                             6
+#define UARTINTEN_UARTRXBREAKONINTEN_MASK                            0x00000040
+#define UARTINTEN_UARTRXBREAKONINTEN_GET(x)                          (((x) & UARTINTEN_UARTRXBREAKONINTEN_MASK) >> UARTINTEN_UARTRXBREAKONINTEN_LSB)
+#define UARTINTEN_UARTRXBREAKONINTEN_SET(x)                          (((0 | (x)) << UARTINTEN_UARTRXBREAKONINTEN_LSB) & UARTINTEN_UARTRXBREAKONINTEN_MASK)
+#define UARTINTEN_UARTRXBREAKONINTEN_RESET                           0
+#define UARTINTEN_UARTRXPARITYERRINTEN_MSB                           5
+#define UARTINTEN_UARTRXPARITYERRINTEN_LSB                           5
+#define UARTINTEN_UARTRXPARITYERRINTEN_MASK                          0x00000020
+#define UARTINTEN_UARTRXPARITYERRINTEN_GET(x)                        (((x) & UARTINTEN_UARTRXPARITYERRINTEN_MASK) >> UARTINTEN_UARTRXPARITYERRINTEN_LSB)
+#define UARTINTEN_UARTRXPARITYERRINTEN_SET(x)                        (((0 | (x)) << UARTINTEN_UARTRXPARITYERRINTEN_LSB) & UARTINTEN_UARTRXPARITYERRINTEN_MASK)
+#define UARTINTEN_UARTRXPARITYERRINTEN_RESET                         0
+#define UARTINTEN_UARTTXOFLOWERRINTEN_MSB                            4
+#define UARTINTEN_UARTTXOFLOWERRINTEN_LSB                            4
+#define UARTINTEN_UARTTXOFLOWERRINTEN_MASK                           0x00000010
+#define UARTINTEN_UARTTXOFLOWERRINTEN_GET(x)                         (((x) & UARTINTEN_UARTTXOFLOWERRINTEN_MASK) >> UARTINTEN_UARTTXOFLOWERRINTEN_LSB)
+#define UARTINTEN_UARTTXOFLOWERRINTEN_SET(x)                         (((0 | (x)) << UARTINTEN_UARTTXOFLOWERRINTEN_LSB) & UARTINTEN_UARTTXOFLOWERRINTEN_MASK)
+#define UARTINTEN_UARTTXOFLOWERRINTEN_RESET                          0
+#define UARTINTEN_UARTRXOFLOWERRINTEN_MSB                            3
+#define UARTINTEN_UARTRXOFLOWERRINTEN_LSB                            3
+#define UARTINTEN_UARTRXOFLOWERRINTEN_MASK                           0x00000008
+#define UARTINTEN_UARTRXOFLOWERRINTEN_GET(x)                         (((x) & UARTINTEN_UARTRXOFLOWERRINTEN_MASK) >> UARTINTEN_UARTRXOFLOWERRINTEN_LSB)
+#define UARTINTEN_UARTRXOFLOWERRINTEN_SET(x)                         (((0 | (x)) << UARTINTEN_UARTRXOFLOWERRINTEN_LSB) & UARTINTEN_UARTRXOFLOWERRINTEN_MASK)
+#define UARTINTEN_UARTRXOFLOWERRINTEN_RESET                          0
+#define UARTINTEN_UARTRXFRAMINGERRINTEN_MSB                          2
+#define UARTINTEN_UARTRXFRAMINGERRINTEN_LSB                          2
+#define UARTINTEN_UARTRXFRAMINGERRINTEN_MASK                         0x00000004
+#define UARTINTEN_UARTRXFRAMINGERRINTEN_GET(x)                       (((x) & UARTINTEN_UARTRXFRAMINGERRINTEN_MASK) >> UARTINTEN_UARTRXFRAMINGERRINTEN_LSB)
+#define UARTINTEN_UARTRXFRAMINGERRINTEN_SET(x)                       (((0 | (x)) << UARTINTEN_UARTRXFRAMINGERRINTEN_LSB) & UARTINTEN_UARTRXFRAMINGERRINTEN_MASK)
+#define UARTINTEN_UARTRXFRAMINGERRINTEN_RESET                        0
+#define UARTINTEN_UARTTXREADYINTEN_MSB                               1
+#define UARTINTEN_UARTTXREADYINTEN_LSB                               1
+#define UARTINTEN_UARTTXREADYINTEN_MASK                              0x00000002
+#define UARTINTEN_UARTTXREADYINTEN_GET(x)                            (((x) & UARTINTEN_UARTTXREADYINTEN_MASK) >> UARTINTEN_UARTTXREADYINTEN_LSB)
+#define UARTINTEN_UARTTXREADYINTEN_SET(x)                            (((0 | (x)) << UARTINTEN_UARTTXREADYINTEN_LSB) & UARTINTEN_UARTTXREADYINTEN_MASK)
+#define UARTINTEN_UARTTXREADYINTEN_RESET                             0
+#define UARTINTEN_UARTRXVALIDINTEN_MSB                               0
+#define UARTINTEN_UARTRXVALIDINTEN_LSB                               0
+#define UARTINTEN_UARTRXVALIDINTEN_MASK                              0x00000001
+#define UARTINTEN_UARTRXVALIDINTEN_GET(x)                            (((x) & UARTINTEN_UARTRXVALIDINTEN_MASK) >> UARTINTEN_UARTRXVALIDINTEN_LSB)
+#define UARTINTEN_UARTRXVALIDINTEN_SET(x)                            (((0 | (x)) << UARTINTEN_UARTRXVALIDINTEN_LSB) & UARTINTEN_UARTRXVALIDINTEN_MASK)
+#define UARTINTEN_UARTRXVALIDINTEN_RESET                             0
+#define UARTINTEN_ADDRESS                                            0x0010
+#define UARTINTEN_HW_MASK                                            0x000003ff
+#define UARTINTEN_SW_MASK                                            0x000003ff
+#define UARTINTEN_RSTMASK                                            0x000003ff
+#define UARTINTEN_RESET                                              0x00000000
+
+#endif
diff --git a/include/image.h b/include/image.h
index 139df0b2d1..a33dca7067 100644
--- a/include/image.h
+++ b/include/image.h
@@ -131,6 +131,7 @@
 #define IH_COMP_NONE		0	/*  No	 Compression Used	*/
 #define IH_COMP_GZIP		1	/* gzip	 Compression Used	*/
 #define IH_COMP_BZIP2		2	/* bzip2 Compression Used	*/
+#define IH_COMP_LZMA		3	/* lzma  Compression Used	*/
 
 #define IH_MAGIC	0x27051956	/* Image Magic Number		*/
 #define IH_NMLEN		32	/* Image Name Length		*/
diff --git a/include/linux/mtd/mtd.h b/include/linux/mtd/mtd.h
index 13e90803a1..da273635df 100644
--- a/include/linux/mtd/mtd.h
+++ b/include/linux/mtd/mtd.h
@@ -1,5 +1,5 @@
 /*
- * $Id: mtd.h,v 1.56 2004/08/09 18:46:04 dmarlin Exp $
+ * $Id: //depot/sw/releases/9.5.3/boot/u-boot/include/linux/mtd/mtd.h#1 $
  *
  * Copyright (C) 1999-2003 David Woodhouse <dwmw2@infradead.org> et al.
  *
@@ -60,6 +60,10 @@ struct mtd_info {
 	u_int32_t ecctype;
 	u_int32_t eccsize;
 
+	u_int32_t erasesize_shift;
+	u_int32_t erasesize_mask;
+	u_int32_t writesize_shift;
+	u_int32_t writesize_mask;
 
 	/* Kernel-only stuff starts here. */
 	char *name;
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index a5227188d4..bd62edee00 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -5,7 +5,7 @@
  *                     Steven J. Hill <sjhill@realitydiluted.com>
  *		       Thomas Gleixner <tglx@linutronix.de>
  *
- * $Id: nand.h,v 1.68 2004/11/12 10:40:37 gleixner Exp $
+ * $Id: //depot/sw/releases/9.5.3/boot/u-boot/include/linux/mtd/nand.h#1 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -348,6 +348,10 @@ struct nand_chip {
 #define NAND_MFR_NATIONAL	0x8f
 #define NAND_MFR_RENESAS	0x07
 #define NAND_MFR_STMICRO	0x20
+#define NAND_MFR_HYNIX		0xad
+#define NAND_MFR_MICRON		0x2c
+#define NAND_MFR_AMD		0x01
+
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure
diff --git a/include/nand.h b/include/nand.h
index 905115b3da..185c699d3b 100644
--- a/include/nand.h
+++ b/include/nand.h
@@ -33,17 +33,17 @@ typedef struct mtd_info nand_info_t;
 extern int nand_curr_device;
 extern nand_info_t nand_info[];
 
-static inline int nand_read(nand_info_t *info, ulong ofs, ulong *len, u_char *buf)
+static inline int nand_read(nand_info_t *info, loff_t ofs, ulong *len, u_char *buf)
 {
 	return info->read(info, ofs, *len, (size_t *)len, buf);
 }
 
-static inline int nand_write(nand_info_t *info, ulong ofs, ulong *len, u_char *buf)
+static inline int nand_write(nand_info_t *info, loff_t ofs, ulong *len, u_char *buf)
 {
 	return info->write(info, ofs, *len, (size_t *)len, buf);
 }
 
-static inline int nand_block_isbad(nand_info_t *info, ulong ofs)
+static inline int nand_block_isbad(nand_info_t *info, loff_t ofs)
 {
 	return info->block_isbad(info, ofs);
 }
diff --git a/include/net.h b/include/net.h
index 461e038014..3abd56e3c8 100644
--- a/include/net.h
+++ b/include/net.h
@@ -268,7 +268,11 @@ typedef struct icmphdr {
  * maximum packet size =  1518
  * maximum packet size and multiple of 32 bytes =  1536
  */
+#ifdef CFG_ATHRHDR_EN
+#define PKTSIZE			1520
+#else
 #define PKTSIZE			1518
+#endif
 #define PKTSIZE_ALIGN		1536
 /*#define PKTSIZE		608*/
 
@@ -336,7 +340,11 @@ extern int		NetState;		/* Network loop state		*/
 extern int		NetRestartWrap;		/* Tried all network devices	*/
 #endif
 
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+typedef enum { BOOTP, RARP, ARP, TFTP, DHCP, PING, DNS, NFS, CDP, NETCONS, SNTP, ATHRHDR } proto_t;
+#else
 typedef enum { BOOTP, RARP, ARP, TFTP, DHCP, PING, DNS, NFS, CDP, NETCONS, SNTP } proto_t;
+#endif
 
 /* from net/net.c */
 extern char	BootFile[128];			/* Boot File name		*/
diff --git a/include/tpLinuxTag.h b/include/tpLinuxTag.h
new file mode 100755
index 0000000000..a027d165e8
--- /dev/null
+++ b/include/tpLinuxTag.h
@@ -0,0 +1,45 @@
+
+/**************************************************************************************
+* File Name  : tpLinuxTag.h
+*
+* Description: add tag with validation system to the firmware image file to be uploaded
+*              via http
+*
+* Created    : 16Sep07,	Liang Qiming
+**************************************************************************************/
+
+#ifndef _TP_LINUX_TAG_H_
+#define _TP_LINUX_TAG_H_
+
+
+#define TP_SIG_1   "TP-LINK Technologies"
+#define TP_SIG_2   "ver. 1.0"          // was "firmware version 2.0" now it is split 6 char out for chip id.
+
+#define TP_TAG_VER         "6"
+#define TP_TAG_VER_LAST    "26"
+
+// file tag (head) structure all is in clear text except validationTokens (crc, md5, sha1, etc). Total: 128 unsigned chars
+#define TAG_LEN         	512
+
+typedef unsigned int	Elf32_Addr;
+
+#define FILE_TAG_SIZE			512
+
+typedef struct _LINUX_FLASH_STRUCT
+{
+	unsigned long bootOffset;
+	unsigned long macAddrOffset;
+	unsigned long pinOffset;
+	unsigned long kernelOffset;
+	unsigned long rootfsOffset;
+	unsigned long configOffset;
+	unsigned long radioOffset;
+} LINUX_FLASH_STRUCT;
+
+unsigned long tp_htonl(unsigned long value);
+unsigned short tp_htons(unsigned short value);
+
+int getElfInfo(char *elfFile, Elf32_Addr *eEntry, Elf32_Addr *pVaddr);
+
+#endif // _TP_LINUX_TAG_H_
+
diff --git a/include/version.h b/include/version.h
index b56d2e9900..bc7d0b3b6b 100644
--- a/include/version.h
+++ b/include/version.h
@@ -25,5 +25,6 @@
 #define	__VERSION_H__
 
 #include "version_autogenerated.h"
+#include "athversion.h"
 
 #endif	/* __VERSION_H__ */
diff --git a/lib_bootstrap/LzmaDecode.c b/lib_bootstrap/LzmaDecode.c
new file mode 100644
index 0000000000..28263e64c0
--- /dev/null
+++ b/lib_bootstrap/LzmaDecode.c
@@ -0,0 +1,622 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder (optimized for Speed version)
+  
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifdef CONFIG_LZMA
+
+#include "LzmaDecode.h"
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
+
+#ifdef _LZMA_IN_CB
+
+
+#if 0
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return result; } \
+  BufferLim = Buffer + size; if (size == 0) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return LZMA_RESULT_DATA_ERROR; } }}
+#else
+
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) { return result; } \
+  BufferLim = Buffer + size; if (size == 0) { return LZMA_RESULT_DATA_ERROR; } }}
+#endif
+
+#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+
+#else
+
+#if 0
+#define RC_TEST { if (Buffer == BufferLim) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return LZMA_RESULT_DATA_ERROR; } }
+#else
+#define RC_TEST { if (Buffer == BufferLim) { return LZMA_RESULT_DATA_ERROR; } }
+#endif
+
+#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
+ 
+#endif
+
+#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi <<= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 << numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size < LZMA_PROPERTIES_SIZE)
+  {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  prop0 = propsData[0];
+  if (prop0 >= (9 * 5 * 5))
+  {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  {
+    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
+    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
+    propsRes->lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes->lc = prop0 % 9;
+    propsRes->pb = remainder / 5;
+    propsRes->lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes->DictionarySize = 0;
+    for (i = 0; i < 4; i++)
+      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
+    if (propsRes->DictionarySize == 0)
+      propsRes->DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs->Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+
+  #ifdef _LZMA_OUT_READ
+  
+  UInt32 Range = vs->Range;
+  UInt32 Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  const Byte *Buffer = vs->Buffer;
+  const Byte *BufferLim = vs->BufferLim;
+  #else
+  const Byte *Buffer = inStream;
+  const Byte *BufferLim = inStream + inSize;
+  #endif
+  int state = vs->State;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      #ifdef _LZMA_IN_CB
+      RC_INIT;
+      #else
+      RC_INIT(inStream, inSize);
+      #endif
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+    for (i = 0; i < numProbs; i++)
+      p[i] = kBitModelTotal >> 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  RC_INIT;
+  #else
+  RC_INIT(inStream, inSize);
+  #endif
+
+  #endif /* _LZMA_OUT_READ */
+
+  while(nowPos < outSize)
+  {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+
+    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        int matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol < 0x100);
+      }
+      while (symbol < 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (Byte)symbol;
+
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            UpdateBit0(prob);
+            
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+            {
+			  
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+              printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+              return LZMA_RESULT_DATA_ERROR;
+            }
+            
+            state = state < kNumLitStates ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            #endif
+
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 <<= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range >>= 1;
+              rep0 <<= 1;
+              if (Code >= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 <<= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i <<= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 > distanceLimit) 
+      #else
+      if (rep0 > nowPos)
+      #endif
+      {
+		
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+        printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+        return LZMA_RESULT_DATA_ERROR;
+      }
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+  }
+  RC_NORMALIZE;
+
+  #ifdef _LZMA_OUT_READ
+  vs->Range = Range;
+  vs->Code = Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + (UInt32)nowPos;
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs->Buffer = Buffer;
+  vs->BufferLim = BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
+
+#endif /* CONFIG_LZMA */
diff --git a/lib_bootstrap/LzmaDecode.h b/lib_bootstrap/LzmaDecode.h
new file mode 100644
index 0000000000..2870eeb9c9
--- /dev/null
+++ b/lib_bootstrap/LzmaDecode.h
@@ -0,0 +1,113 @@
+/* 
+  LzmaDecode.h
+  LZMA Decoder interface
+
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMADECODE_H
+#define __LZMADECODE_H
+
+#include "LzmaTypes.h"
+
+/* #define _LZMA_IN_CB */
+/* Use callback for input data */
+
+/* #define _LZMA_OUT_READ */
+/* Use read function for output data */
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_LOC_OPT */
+/* Enable local speed optimizations inside code */
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#ifdef _LZMA_IN_CB
+typedef struct _ILzmaInCallback
+{
+  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
+} ILzmaInCallback;
+#endif
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  #ifdef _LZMA_OUT_READ
+  UInt32 DictionarySize;
+  #endif
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((Properties)->lc + (Properties)->lp)))
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+
+  #ifdef _LZMA_IN_CB
+  const unsigned char *Buffer;
+  const unsigned char *BufferLim;
+  #endif
+
+  #ifdef _LZMA_OUT_READ
+  unsigned char *Dictionary;
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;
+  unsigned char TempDictionary[4];
+  #endif
+} CLzmaDecoderState;
+
+#ifdef _LZMA_OUT_READ
+#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; }
+#endif
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);
+
+#endif
diff --git a/lib_bootstrap/LzmaTypes.h b/lib_bootstrap/LzmaTypes.h
new file mode 100644
index 0000000000..288c5e45d7
--- /dev/null
+++ b/lib_bootstrap/LzmaTypes.h
@@ -0,0 +1,45 @@
+/* 
+LzmaTypes.h 
+
+Types for LZMA Decoder
+
+This file written and distributed to public domain by Igor Pavlov.
+This file is part of LZMA SDK 4.40 (2006-05-01)
+*/
+
+#ifndef __LZMATYPES_H
+#define __LZMATYPES_H
+
+#ifndef _7ZIP_BYTE_DEFINED
+#define _7ZIP_BYTE_DEFINED
+typedef unsigned char Byte;
+#endif 
+
+#ifndef _7ZIP_UINT16_DEFINED
+#define _7ZIP_UINT16_DEFINED
+typedef unsigned short UInt16;
+#endif 
+
+#ifndef _7ZIP_UINT32_DEFINED
+#define _7ZIP_UINT32_DEFINED
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef unsigned long UInt32;
+#else
+typedef unsigned int UInt32;
+#endif
+#endif 
+
+/* #define _LZMA_SYSTEM_SIZE_T */
+/* Use system's size_t. You can use it to enable 64-bit sizes supporting */
+
+#ifndef _7ZIP_SIZET_DEFINED
+#define _7ZIP_SIZET_DEFINED
+#ifdef _LZMA_SYSTEM_SIZE_T
+#include <stddef.h>
+typedef size_t SizeT;
+#else
+typedef UInt32 SizeT;
+#endif
+#endif
+
+#endif
diff --git a/lib_bootstrap/LzmaWrapper.c b/lib_bootstrap/LzmaWrapper.c
new file mode 100644
index 0000000000..955b911c91
--- /dev/null
+++ b/lib_bootstrap/LzmaWrapper.c
@@ -0,0 +1,223 @@
+/******************************************************************************
+**
+** FILE NAME    : LzmaWrapper.c
+** PROJECT      : bootloader
+** MODULES      : U-boot
+**
+** DATE         : 2 Nov 2006
+** AUTHOR       : Lin Mars
+** DESCRIPTION  : LZMA decoder support for U-boot 1.1.5
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 2 Nov 2006   Lin Mars        init version which derived from LzmaTest.c from
+**                              LZMA v4.43 SDK
+*******************************************************************************/
+#define LZMA_NO_STDIO
+#ifndef LZMA_NO_STDIO
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#endif
+
+#include <config.h>
+#include <common.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <malloc.h>
+
+#ifdef CONFIG_LZMA
+
+#include "LzmaDecode.h"
+#include "LzmaWrapper.h"
+
+static const char *kCantReadMessage = "Can not read from source buffer";
+static const char *kCantAllocateMessage = "Not enough buffer for decompression";
+
+static size_t rpos=0, dpos=0;
+
+static int MyReadFileAndCheck(unsigned char *src, void *dest, size_t size)
+{
+  if (size == 0)
+    return 0;
+  memcpy(dest, src + rpos, size);
+  rpos += size;
+  return 1;
+}
+
+int lzma_inflate(unsigned char *source, int s_len, unsigned char *dest, int *d_len)
+{
+  /* We use two 32-bit integers to construct 64-bit integer for file size.
+     You can remove outSizeHigh, if you don't need >= 4GB supporting,
+     or you can use UInt64 outSize, if your compiler supports 64-bit integers*/
+  UInt32 outSize = 0;
+  UInt32 outSizeHigh = 0;
+  SizeT outSizeFull;
+  unsigned char *outStream;
+  
+  int waitEOS = 1; 
+  /* waitEOS = 1, if there is no uncompressed size in headers, 
+   so decoder will wait EOS (End of Stream Marker) in compressed stream */
+
+  SizeT compressedSize;
+  unsigned char *inStream;
+
+  CLzmaDecoderState state;  /* it's about 24-80 bytes structure, if int is 32-bit */
+  unsigned char properties[LZMA_PROPERTIES_SIZE];
+
+  int res;
+
+  if (sizeof(UInt32) < 4)
+  {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("LZMA decoder needs correct UInt32\n");
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  {
+    long length=s_len;
+    if ((long)(SizeT)length != length)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("Too big compressed stream\n");
+#endif
+      return LZMA_RESULT_DATA_ERROR;
+    }
+    compressedSize = (SizeT)(length - (LZMA_PROPERTIES_SIZE + 8));
+  }
+
+  /* Read LZMA properties for compressed stream */
+
+  if (!MyReadFileAndCheck(source, properties, sizeof(properties)))
+  {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("%s\n", kCantReadMessage);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  /* Read uncompressed size */
+  {
+    int i;
+    for (i = 0; i < 8; i++)
+    {
+      unsigned char b;
+      if (!MyReadFileAndCheck(source, &b, 1))
+      {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+        printf("%s\n", kCantReadMessage);
+#endif
+        return LZMA_RESULT_DATA_ERROR;
+      }
+      if (b != 0xFF)
+        waitEOS = 0;
+      if (i < 4)
+        outSize += (UInt32)(b) << (i * 8);
+      else
+        outSizeHigh += (UInt32)(b) << ((i - 4) * 8);
+    }
+    
+    if (waitEOS)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("Stream with EOS marker is not supported");
+#endif
+      return LZMA_RESULT_DATA_ERROR;
+    }
+    outSizeFull = (SizeT)outSize;
+    if (sizeof(SizeT) >= 8)
+      outSizeFull |= (((SizeT)outSizeHigh << 16) << 16);
+    else if (outSizeHigh != 0 || (UInt32)(SizeT)outSize != outSize)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("Too big uncompressed stream");
+#endif
+      return LZMA_RESULT_DATA_ERROR;
+    }
+  }
+
+  /* Decode LZMA properties and allocate memory */
+  if (LzmaDecodeProperties(&state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK)
+  {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("Incorrect stream properties");
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  state.Probs = (CProb *)malloc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
+
+  if (outSizeFull == 0)
+    outStream = 0;
+  else
+  {
+    if (outSizeFull > d_len)
+      outStream = 0;
+    else
+      outStream = dest;
+  }
+
+  if (compressedSize == 0)
+    inStream = 0;
+  else
+  {
+    if ((compressedSize+rpos) > s_len )
+      inStream = 0;
+    else
+      inStream = source + rpos;
+  }
+
+  if (state.Probs == 0 
+    || (outStream == 0 && outSizeFull != 0)
+    || (inStream == 0 && compressedSize != 0)
+    )
+  {
+    free(state.Probs);
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("%s\n", kCantAllocateMessage);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  /* Decompress */
+  {
+    SizeT inProcessed;
+    SizeT outProcessed;
+    res = LzmaDecode(&state,
+      inStream, compressedSize, &inProcessed,
+      outStream, outSizeFull, &outProcessed);
+    if (res != 0)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("\nDecoding error = %d\n", res);
+#endif
+      res = 1;
+    }
+    else
+    {
+      *d_len = outProcessed;
+    }
+  }
+
+  free(state.Probs);
+  return res;
+}
+
+#endif /* CONFIG_LZMA */
diff --git a/lib_bootstrap/Makefile b/lib_bootstrap/Makefile
new file mode 100644
index 0000000000..ce46c80972
--- /dev/null
+++ b/lib_bootstrap/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= libbootstrap.a
+
+OBJS	= bootstrap_board.o LzmaDecode.o string.o crc32.o LzmaWrapper.o time.o
+#OBJS	= bootstrap_board.o LzmaDecode.o string.o crc32.o LzmaWrapper.o ctype.o display_options.o string.o vsprintf.o lists.o devices.o console.o time.o
+
+#BOOTSTRAP_PRINTF_STATUS = BOOTSTRAP_PRINTF_ENABLED
+
+ifeq ($(BOOTSTRAP_PRINTF_STATUS), BOOTSTRAP_PRINTF_ENABLED)
+#overwrite objs
+OBJS	= bootstrap_board.o time.o console.o LzmaWrapper.o LzmaDecode.o crc32.o ctype.o display_options.o string.o vsprintf.o lists.o devices.o
+CFLAGS += -DDEBUG_ENABLE_BOOTSTRAP_PRINTF
+endif
+
+CFLAGS += -DCONFIG_LZMA=1
+
+all:	.depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(OBJS:.o=.c)
+		echo "make libbootstrap.a with HEAD_SIZE $(HEAD_SIZE)"
+		$(CC) -M $(CFLAGS) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/lib_bootstrap/bootstrap_board.c b/lib_bootstrap/bootstrap_board.c
new file mode 100644
index 0000000000..1f6e3cbc46
--- /dev/null
+++ b/lib_bootstrap/bootstrap_board.c
@@ -0,0 +1,480 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <devices.h>
+#include <version.h>
+#include <net.h>
+#include <environment.h>
+#ifdef CONFIG_DANUBE
+#include <asm-mips/danube.h>
+#include <configs/danube.h>
+#endif
+#include "LzmaWrapper.h"
+
+//#define DEBUG_ENABLE_BOOTSTRAP_PRINTF
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if ( ((CFG_ENV_ADDR+CFG_ENV_SIZE) < BOOTSTRAP_CFG_MONITOR_BASE) || \
+      (CFG_ENV_ADDR >= (BOOTSTRAP_CFG_MONITOR_BASE + CFG_MONITOR_LEN)) ) || \
+    defined(CFG_ENV_IS_IN_NVRAM)
+#define	TOTAL_MALLOC_LEN	(CFG_MALLOC_LEN + CFG_ENV_SIZE)
+#else
+#define	TOTAL_MALLOC_LEN	CFG_MALLOC_LEN
+#endif
+
+#undef DEBUG
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+extern unsigned long nand_init(void);
+#endif
+
+#ifdef CONFIG_SERIAL_FLASH
+extern int serial_flash_init (void);
+#endif
+
+extern int timer_init(void);
+
+extern int incaip_set_cpuclk(void);
+
+extern ulong uboot_end_data_bootstrap;
+extern ulong uboot_end_bootstrap;
+
+ulong monitor_flash_len;
+
+const char version_string[] =
+	U_BOOT_VERSION" (" __DATE__ " - " __TIME__ ")";
+
+static char *failed = "*** failed ***\n";
+
+/*
+ * Begin and End of memory area for malloc(), and current "brk"
+ */
+static ulong mem_malloc_start;
+static ulong mem_malloc_end;
+static ulong mem_malloc_brk;
+
+
+/*
+ * The Malloc area is immediately below the monitor copy in DRAM
+ */
+static void mem_malloc_init (ulong dest_addr)
+{
+//	ulong dest_addr = BOOTSTRAP_CFG_MONITOR_BASE + gd->reloc_off;
+
+	mem_malloc_end = dest_addr;
+	mem_malloc_start = dest_addr - TOTAL_MALLOC_LEN;
+	mem_malloc_brk = mem_malloc_start;
+
+	memset ((void *) mem_malloc_start,
+		0,
+		mem_malloc_end - mem_malloc_start);
+}
+
+void *malloc(unsigned int size)
+{
+	if(size < (mem_malloc_end - mem_malloc_start))
+	{
+		mem_malloc_start += size;
+		return (void *)(mem_malloc_start - size);
+	}
+	return NULL;
+}
+
+void *realloc(void *src,unsigned int size)
+{
+	return NULL;
+}
+
+void free(void *src)
+{
+	return;
+}
+
+
+void *sbrk (ptrdiff_t increment)
+{
+	ulong old = mem_malloc_brk;
+	ulong new = old + increment;
+
+	if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
+		return (NULL);
+	}
+	mem_malloc_brk = new;
+	return ((void *) old);
+}
+
+
+static int init_func_ram (void)
+{
+#ifdef	CONFIG_BOARD_TYPES
+	int board_type = gd->board_type;
+#else
+	int board_type = 0;	/* use dummy arg */
+#endif
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	puts ("DRAM:  ");
+#endif
+
+	if ((gd->ram_size = initdram (board_type)) > 0) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		print_size (gd->ram_size, "\n");
+#endif
+		return (0);
+	}
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	puts (failed);
+#endif
+	return (1);
+}
+
+static int display_banner(void)
+{
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf ("\n\n%s\n\n", version_string);
+#endif
+	return (0);
+}
+
+static int init_baudrate (void)
+{
+#if 0
+	char tmp[64];	/* long enough for environment variables */
+	int i = getenv_r ("baudrate", tmp, sizeof (tmp));
+
+	gd->baudrate = (i > 0)
+			? (int) simple_strtoul (tmp, NULL, 10)
+			: CONFIG_BAUDRATE;
+#endif
+
+	gd->baudrate = CONFIG_BAUDRATE;
+
+	return (0);
+}
+#ifdef CONFIG_DANUBE
+static void init_led(void)
+{
+
+  *(unsigned long *)0xBE100B18 |=  0x70;
+  *(unsigned long *)0xBE100B1C |=  0x70;
+  *(unsigned long *)0xBE100B20 &= ~0x70;
+  *(unsigned long *)0xBE100B24 |=  0x70;
+#ifdef USE_REFERENCE_BOARD
+
+  *DANUBE_LED_CON1 = 0x00000003;
+  *DANUBE_LED_CPU0 = 0x0000010;
+  *DANUBE_LED_CPU1 = 0x00000000;
+  *DANUBE_LED_AR   = 0x00000000;
+  *DANUBE_LED_CON0 = 0x84000000;
+
+#else
+
+  *DANUBE_LED_CON1 = 0x00000007;
+  *DANUBE_LED_CPU0 = 0x00001000;
+  *DANUBE_LED_CPU1 = 0x00000000;
+  *DANUBE_LED_AR   = 0x00000000;
+  *DANUBE_LED_CON0 = 0x84000000;
+
+#endif
+
+}
+#endif
+/*
+ * Breath some life into the board...
+ *
+ * The first part of initialization is running from Flash memory;
+ * its main purpose is to initialize the RAM so that we
+ * can relocate the monitor code to RAM.
+ */
+
+/*
+ * All attempts to come up with a "common" initialization sequence
+ * that works for all boards and architectures failed: some of the
+ * requirements are just _too_ different. To get rid of the resulting
+ * mess of board dependend #ifdef'ed code we now make the whole
+ * initialization sequence configurable to the user.
+ *
+ * The requirements for any new initalization function is simple: it
+ * receives a pointer to the "global data" structure as it's only
+ * argument, and returns an integer return code, where 0 means
+ * "continue" and != 0 means "fatal error, hang the system".
+ */
+typedef int (init_fnc_t) (void);
+
+init_fnc_t *init_sequence[] = {
+	timer_init,
+	//env_init,		/* initialize environment */
+#ifdef CONFIG_INCA_IP
+	incaip_set_cpuclk,	/* set cpu clock according to environment variable */
+#endif
+	serial_init,		/* serial communications setup */
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	init_baudrate,		/* initialze baudrate settings */
+	console_init_f,
+	display_banner,		/* say that we are here */
+#endif
+	init_func_ram,
+#if !defined(ATH_NO_PCI_INIT) && !defined(CONFIG_WASP_SUPPORT)
+	pci_init_board,
+#endif
+	NULL,
+};
+
+
+void bootstrap_board_init_f(ulong bootflag)
+{
+	gd_t gd_data, *id;
+	bd_t *bd;
+	init_fnc_t **init_fnc_ptr;
+	ulong addr, addr_sp, len = (ulong)&uboot_end_bootstrap - BOOTSTRAP_CFG_MONITOR_BASE;
+	ulong *s;
+	ulong lzmaImageaddr  = 0;
+#ifdef CONFIG_PURPLE
+	void copy_code (ulong);
+#endif
+
+	/* Pointer is writable since we allocated a register for it.
+	 */
+	gd = &gd_data;
+	/* compiler optimization barrier needed for GCC >= 3.4 */
+	__asm__ __volatile__("": : :"memory");
+
+	memset ((void *)gd, 0, sizeof (gd_t));
+
+	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
+		if ((*init_fnc_ptr)() != 0) {
+			hang ();
+		}
+	}
+
+	/*
+	 * Now that we have DRAM mapped and working, we can
+	 * relocate the code and continue running from DRAM.
+	 */
+	addr = CFG_SDRAM_BASE + gd->ram_size;
+
+	/* We can reserve some RAM "on top" here.
+	 */
+
+	/* round down to next 4 kB limit.
+	 */
+	addr &= ~(4096 - 1);
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Top of RAM usable for U-Boot at: %08lx\n", addr);
+#endif
+	/* Reserve memory for U-Boot code, data & bss
+	 * round down to next 16 kB limit
+	 */
+	addr -= len;
+	addr &= ~(16 * 1024 - 1);
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Reserving %ldk for U-Boot at: %08lx\n", len >> 10, addr);
+#endif
+
+	 /* Reserve memory for malloc() arena.
+	 */
+	addr_sp = addr - TOTAL_MALLOC_LEN;
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Reserving %dk for malloc() at: %08lx\n",
+			TOTAL_MALLOC_LEN >> 10, addr_sp);
+#endif
+
+	/*
+	 * (permanently) allocate a Board Info struct
+	 * and a permanent copy of the "global" data
+	 */
+	addr_sp -= sizeof(bd_t);
+	bd = (bd_t *)addr_sp;
+	gd->bd = bd;
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Reserving %d Bytes for Board Info at: %08lx\n",
+			sizeof(bd_t), addr_sp);
+#endif
+
+	addr_sp -= sizeof(gd_t);
+	id = (gd_t *)addr_sp;
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Reserving %d Bytes for Global Data at: %08lx\n",
+			sizeof (gd_t), addr_sp);
+#endif
+ 	/* Reserve memory for boot params.
+	 */
+	addr_sp -= CFG_BOOTPARAMS_LEN;
+	bd->bi_boot_params = addr_sp;
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Reserving %dk for boot params() at: %08lx\n",
+			CFG_BOOTPARAMS_LEN >> 10, addr_sp);
+#endif
+	/*
+	 * Finally, we set up a new (bigger) stack.
+	 *
+	 * Leave some safety gap for SP, force alignment on 16 byte boundary
+	 * Clear initial stack frame
+	 */
+	addr_sp -= 16;
+	addr_sp &= ~0xF;
+	s = (ulong *)addr_sp;
+	*s-- = 0;
+	*s-- = 0;
+	addr_sp = (ulong)s;
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	debug ("Stack Pointer at: %08lx\n", addr_sp);
+#endif
+	/*
+	 * Save local variables to board info struct
+	 */
+	bd->bi_memstart	= CFG_SDRAM_BASE;	/* start of  DRAM memory */
+	bd->bi_memsize	= gd->ram_size;		/* size  of  DRAM memory in bytes */
+	bd->bi_baudrate	= gd->baudrate;		/* Console Baudrate */
+
+	memcpy (id, (void *)gd, sizeof (gd_t));
+
+	/* On the purple board we copy the code in a special way
+	 * in order to solve flash problems
+	 */
+#ifdef CONFIG_PURPLE
+	copy_code(addr);
+#endif
+
+	lzmaImageaddr = (ulong)&uboot_end_data_bootstrap;
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf ("\n relocating to address %08x ", addr);
+#endif
+
+	bootstrap_relocate_code (addr_sp, id, addr);
+
+	/* NOTREACHED - relocate_code() does not return */
+}
+/************************************************************************
+ *
+ * This is the next part if the initialization sequence: we are now
+ * running from RAM and have a "normal" C environment, i. e. global
+ * data can be written, BSS has been cleared, the stack size in not
+ * that critical any more, etc.
+ *
+ ************************************************************************
+ */
+
+void bootstrap_board_init_r (gd_t *id, ulong dest_addr)
+{
+	int i;
+
+	ulong	addr;
+	ulong	data, len, checksum;
+	ulong  *len_ptr;
+	image_header_t header;
+	image_header_t *hdr = &header;
+	unsigned int destLen;
+	int (*fn)(int);
+
+	/* initialize malloc() area */
+	mem_malloc_init(dest_addr);
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf("\n Compressed Image at %08x \n ", (BOOTSTRAP_CFG_MONITOR_BASE + ((ulong)&uboot_end_data_bootstrap - dest_addr)));
+#endif
+
+	addr = (char *)(BOOTSTRAP_CFG_MONITOR_BASE + ((ulong)&uboot_end_data_bootstrap - dest_addr));
+	memmove (&header, (char *)addr, sizeof(image_header_t));
+
+	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		printf ("Bad Magic Number at address 0x%08lx\n",addr);
+#endif
+		return;
+	}
+
+	data = (ulong)&header;
+	len  = sizeof(image_header_t);
+
+	checksum = ntohl(hdr->ih_hcrc);
+	hdr->ih_hcrc = 0;
+	if (crc32 (0, (char *)data, len) != checksum) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		printf ("Bad Header Checksum\n");
+#endif
+		return;
+	}
+
+	data = addr + sizeof(image_header_t);
+	len  = ntohl(hdr->ih_size);
+
+	len_ptr = (ulong *)data;
+
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf ("Disabling all the interrupts\n");
+#endif
+	disable_interrupts();
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf ("   Uncompressing UBoot Image ... \n" );
+#endif
+
+	/*
+	 * If we've got less than 4 MB of malloc() space,
+	 * use slower decompression algorithm which requires
+	 * at most 2300 KB of memory.
+	 */
+	destLen = 0x0;
+
+#ifdef CONFIG_LZMA 
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf ("U-Boot uncompress address %08x\n ",hdr->ih_load);
+#endif
+	i = lzma_inflate ((unsigned char *)data, len, (unsigned char*)ntohl(hdr->ih_load), &destLen);
+	if (i != LZMA_RESULT_OK) {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+		printf ("LZMA ERROR %d - must RESET board to recover\n", i);
+#endif
+		//do_reset (cmdtp, flag, argc, argv);
+		return;
+	}
+#endif
+	/* before jump to the u-boot in ddr, have better flush cache  */
+	mips_cache_flush();
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	printf ("Uncompression completed successfully with destLen %d\n ",destLen );
+	printf ("U-Boot Load address %08x\n ",hdr->ih_load);
+#endif
+
+        fn = ntohl(hdr->ih_load);
+
+	(*fn)(gd->ram_size);
+
+	hang ();
+}
+
+void hang (void)
+{
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+	puts ("### ERROR ### Please RESET the board ###\n");
+#endif
+	for (;;);
+}
diff --git a/lib_bootstrap/console.c b/lib_bootstrap/console.c
new file mode 100644
index 0000000000..a8fcd2a53f
--- /dev/null
+++ b/lib_bootstrap/console.c
@@ -0,0 +1,573 @@
+/*
+ * (C) Copyright 2000
+ * Paolo Scaffardi, AIRVENT SAM s.p.a - RIMINI(ITALY), arsenio@tin.it
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <stdarg.h>
+#include <malloc.h>
+#include <console.h>
+#include <exports.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_AMIGAONEG3SE
+int console_changed = 0;
+#endif
+
+#ifdef CFG_CONSOLE_IS_IN_ENV
+/*
+ * if overwrite_console returns 1, the stdin, stderr and stdout
+ * are switched to the serial port, else the settings in the
+ * environment are used
+ */
+#ifdef CFG_CONSOLE_OVERWRITE_ROUTINE
+extern int overwrite_console (void);
+#define OVERWRITE_CONSOLE overwrite_console ()
+#else
+#define OVERWRITE_CONSOLE 0
+#endif /* CFG_CONSOLE_OVERWRITE_ROUTINE */
+
+#endif /* CFG_CONSOLE_IS_IN_ENV */
+
+static int console_setfile (int file, device_t * dev)
+{
+	int error = 0;
+
+	if (dev == NULL)
+		return -1;
+
+	switch (file) {
+	case stdin:
+	case stdout:
+	case stderr:
+		/* Start new device */
+		if (dev->start) {
+			error = dev->start ();
+			/* If it's not started dont use it */
+			if (error < 0)
+				break;
+		}
+
+		/* Assign the new device (leaving the existing one started) */
+		stdio_devices[file] = dev;
+
+		/*
+		 * Update monitor functions
+		 * (to use the console stuff by other applications)
+		 */
+		switch (file) {
+		case stdin:
+			gd->jt[XF_getc] = dev->getc;
+			gd->jt[XF_tstc] = dev->tstc;
+			break;
+		case stdout:
+			gd->jt[XF_putc] = dev->putc;
+			gd->jt[XF_puts] = dev->puts;
+			gd->jt[XF_printf] = printf;
+			break;
+		}
+		break;
+
+	default:		/* Invalid file ID */
+		error = -1;
+	}
+	return error;
+}
+
+/** U-Boot INITIAL CONSOLE-NOT COMPATIBLE FUNCTIONS *************************/
+
+void serial_printf (const char *fmt, ...)
+{
+	va_list args;
+	uint i;
+	char printbuffer[CFG_PBSIZE];
+
+	va_start (args, fmt);
+
+	/* For this to work, printbuffer must be larger than
+	 * anything we ever want to print.
+	 */
+	i = vsprintf (printbuffer, fmt, args);
+	va_end (args);
+
+	serial_puts (printbuffer);
+}
+
+int fgetc (int file)
+{
+	if (file < MAX_FILES)
+		return stdio_devices[file]->getc ();
+
+	return -1;
+}
+
+int ftstc (int file)
+{
+	if (file < MAX_FILES)
+		return stdio_devices[file]->tstc ();
+
+	return -1;
+}
+
+void fputc (int file, const char c)
+{
+	if (file < MAX_FILES)
+		stdio_devices[file]->putc (c);
+}
+
+void fputs (int file, const char *s)
+{
+	if (file < MAX_FILES)
+		stdio_devices[file]->puts (s);
+}
+
+void fprintf (int file, const char *fmt, ...)
+{
+	va_list args;
+	uint i;
+	char printbuffer[CFG_PBSIZE];
+
+	va_start (args, fmt);
+
+	/* For this to work, printbuffer must be larger than
+	 * anything we ever want to print.
+	 */
+	i = vsprintf (printbuffer, fmt, args);
+	va_end (args);
+
+	/* Send to desired file */
+	fputs (file, printbuffer);
+}
+
+/** U-Boot INITIAL CONSOLE-COMPATIBLE FUNCTION *****************************/
+
+int getc (void)
+{
+	if (gd->flags & GD_FLG_DEVINIT) {
+		/* Get from the standard input */
+		return fgetc (stdin);
+	}
+
+	/* Send directly to the handler */
+	return serial_getc ();
+}
+
+int tstc (void)
+{
+	if (gd->flags & GD_FLG_DEVINIT) {
+		/* Test the standard input */
+		return ftstc (stdin);
+	}
+
+	/* Send directly to the handler */
+	return serial_tstc ();
+}
+
+void putc (const char c)
+{
+#ifdef CONFIG_SILENT_CONSOLE
+	if (gd->flags & GD_FLG_SILENT)
+		return;
+#endif
+
+	if (gd->flags & GD_FLG_DEVINIT) {
+		/* Send to the standard output */
+		fputc (stdout, c);
+	} else {
+		/* Send directly to the handler */
+		serial_putc (c);
+	}
+}
+
+void puts (const char *s)
+{
+#ifdef CONFIG_SILENT_CONSOLE
+	if (gd->flags & GD_FLG_SILENT)
+		return;
+#endif
+
+	if (gd->flags & GD_FLG_DEVINIT) {
+		/* Send to the standard output */
+		fputs (stdout, s);
+	} else {
+		/* Send directly to the handler */
+		serial_puts (s);
+	}
+}
+
+void printf (const char *fmt, ...)
+{
+	va_list args;
+	uint i;
+	char printbuffer[CFG_PBSIZE];
+
+	va_start (args, fmt);
+
+	/* For this to work, printbuffer must be larger than
+	 * anything we ever want to print.
+	 */
+	i = vsprintf (printbuffer, fmt, args);
+	va_end (args);
+
+	/* Print the string */
+	puts (printbuffer);
+}
+
+void vprintf (const char *fmt, va_list args)
+{
+	uint i;
+	char printbuffer[CFG_PBSIZE];
+
+	/* For this to work, printbuffer must be larger than
+	 * anything we ever want to print.
+	 */
+	i = vsprintf (printbuffer, fmt, args);
+
+	/* Print the string */
+	puts (printbuffer);
+}
+
+/* test if ctrl-c was pressed */
+static int ctrlc_disabled = 0;	/* see disable_ctrl() */
+static int ctrlc_was_pressed = 0;
+int ctrlc (void)
+{
+	if (!ctrlc_disabled && gd->have_console) {
+		if (tstc ()) {
+			switch (getc ()) {
+			case 0x03:		/* ^C - Control C */
+				ctrlc_was_pressed = 1;
+				return 1;
+			default:
+				break;
+			}
+		}
+	}
+	return 0;
+}
+
+/* pass 1 to disable ctrlc() checking, 0 to enable.
+ * returns previous state
+ */
+int disable_ctrlc (int disable)
+{
+	int prev = ctrlc_disabled;	/* save previous state */
+
+	ctrlc_disabled = disable;
+	return prev;
+}
+
+int had_ctrlc (void)
+{
+	return ctrlc_was_pressed;
+}
+
+void clear_ctrlc (void)
+{
+	ctrlc_was_pressed = 0;
+}
+
+#ifdef CONFIG_MODEM_SUPPORT_DEBUG
+char	screen[1024];
+char *cursor = screen;
+int once = 0;
+inline void dbg(const char *fmt, ...)
+{
+	va_list	args;
+	uint	i;
+	char	printbuffer[CFG_PBSIZE];
+
+	if (!once) {
+		memset(screen, 0, sizeof(screen));
+		once++;
+	}
+
+	va_start(args, fmt);
+
+	/* For this to work, printbuffer must be larger than
+	 * anything we ever want to print.
+	 */
+	i = vsprintf(printbuffer, fmt, args);
+	va_end(args);
+
+	if ((screen + sizeof(screen) - 1 - cursor) < strlen(printbuffer)+1) {
+		memset(screen, 0, sizeof(screen));
+		cursor = screen;
+	}
+	sprintf(cursor, printbuffer);
+	cursor += strlen(printbuffer);
+
+}
+#else
+inline void dbg(const char *fmt, ...)
+{
+}
+#endif
+
+/** U-Boot INIT FUNCTIONS *************************************************/
+
+int console_assign (int file, char *devname)
+{
+	int flag, i;
+
+	/* Check for valid file */
+	switch (file) {
+	case stdin:
+		flag = DEV_FLAGS_INPUT;
+		break;
+	case stdout:
+	case stderr:
+		flag = DEV_FLAGS_OUTPUT;
+		break;
+	default:
+		return -1;
+	}
+
+	/* Check for valid device name */
+
+	for (i = 1; i <= ListNumItems (devlist); i++) {
+		device_t *dev = ListGetPtrToItem (devlist, i);
+
+		if (strcmp (devname, dev->name) == 0) {
+			if (dev->flags & flag)
+				return console_setfile (file, dev);
+
+			return -1;
+		}
+	}
+
+	return -1;
+}
+
+/* Called before relocation - use serial functions */
+int console_init_f (void)
+{
+	gd->have_console = 1;
+
+#ifdef CONFIG_SILENT_CONSOLE
+	if (getenv("silent") != NULL)
+		gd->flags |= GD_FLG_SILENT;
+#endif
+
+	return (0);
+}
+
+#if defined(CFG_CONSOLE_IS_IN_ENV) || defined(CONFIG_SPLASH_SCREEN) || defined(CONFIG_SILENT_CONSOLE)
+/* search a device */
+device_t *search_device (int flags, char *name)
+{
+	int i, items;
+	device_t *dev = NULL;
+
+	items = ListNumItems (devlist);
+	if (name == NULL)
+		return dev;
+
+	for (i = 1; i <= items; i++) {
+		dev = ListGetPtrToItem (devlist, i);
+		if ((dev->flags & flags) && (strcmp (name, dev->name) == 0)) {
+			break;
+		}
+	}
+	return dev;
+}
+#endif /* CFG_CONSOLE_IS_IN_ENV || CONFIG_SPLASH_SCREEN */
+
+#ifdef CFG_CONSOLE_IS_IN_ENV
+/* Called after the relocation - use desired console functions */
+int console_init_r (void)
+{
+	char *stdinname, *stdoutname, *stderrname;
+	device_t *inputdev = NULL, *outputdev = NULL, *errdev = NULL;
+#ifdef CFG_CONSOLE_ENV_OVERWRITE
+	int i;
+#endif /* CFG_CONSOLE_ENV_OVERWRITE */
+
+	/* set default handlers at first */
+	gd->jt[XF_getc] = serial_getc;
+	gd->jt[XF_tstc] = serial_tstc;
+	gd->jt[XF_putc] = serial_putc;
+	gd->jt[XF_puts] = serial_puts;
+	gd->jt[XF_printf] = serial_printf;
+
+	/* stdin stdout and stderr are in environment */
+	/* scan for it */
+	stdinname  = getenv ("stdin");
+	stdoutname = getenv ("stdout");
+	stderrname = getenv ("stderr");
+
+	if (OVERWRITE_CONSOLE == 0) { 	/* if not overwritten by config switch */
+		inputdev  = search_device (DEV_FLAGS_INPUT,  stdinname);
+		outputdev = search_device (DEV_FLAGS_OUTPUT, stdoutname);
+		errdev    = search_device (DEV_FLAGS_OUTPUT, stderrname);
+	}
+	/* if the devices are overwritten or not found, use default device */
+	if (inputdev == NULL) {
+		inputdev  = search_device (DEV_FLAGS_INPUT,  "serial");
+	}
+	if (outputdev == NULL) {
+		outputdev = search_device (DEV_FLAGS_OUTPUT, "serial");
+	}
+	if (errdev == NULL) {
+		errdev    = search_device (DEV_FLAGS_OUTPUT, "serial");
+	}
+	/* Initializes output console first */
+	if (outputdev != NULL) {
+		console_setfile (stdout, outputdev);
+	}
+	if (errdev != NULL) {
+		console_setfile (stderr, errdev);
+	}
+	if (inputdev != NULL) {
+		console_setfile (stdin, inputdev);
+	}
+
+	gd->flags |= GD_FLG_DEVINIT;	/* device initialization completed */
+
+#ifndef CFG_CONSOLE_INFO_QUIET
+	/* Print information */
+	puts ("In:    ");
+	if (stdio_devices[stdin] == NULL) {
+		puts ("No input devices available!\n");
+	} else {
+		printf ("%s\n", stdio_devices[stdin]->name);
+	}
+
+	puts ("Out:   ");
+	if (stdio_devices[stdout] == NULL) {
+		puts ("No output devices available!\n");
+	} else {
+		printf ("%s\n", stdio_devices[stdout]->name);
+	}
+
+	puts ("Err:   ");
+	if (stdio_devices[stderr] == NULL) {
+		puts ("No error devices available!\n");
+	} else {
+		printf ("%s\n", stdio_devices[stderr]->name);
+	}
+#endif /* CFG_CONSOLE_INFO_QUIET */
+
+#ifdef CFG_CONSOLE_ENV_OVERWRITE
+	/* set the environment variables (will overwrite previous env settings) */
+	for (i = 0; i < 3; i++) {
+		setenv (stdio_names[i], stdio_devices[i]->name);
+	}
+#endif /* CFG_CONSOLE_ENV_OVERWRITE */
+
+#if 0
+	/* If nothing usable installed, use only the initial console */
+	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
+		return (0);
+#endif
+	return (0);
+}
+
+#else /* CFG_CONSOLE_IS_IN_ENV */
+#if 0
+/* Called after the relocation - use desired console functions */
+int console_init_r (void)
+{
+	device_t *inputdev = NULL, *outputdev = NULL;
+	int i, items = ListNumItems (devlist);
+
+#ifdef CONFIG_SPLASH_SCREEN
+	/* suppress all output if splash screen is enabled and we have
+	   a bmp to display                                            */
+	if (getenv("splashimage") != NULL)
+		outputdev = search_device (DEV_FLAGS_OUTPUT, "nulldev");
+#endif
+
+#ifdef CONFIG_SILENT_CONSOLE
+	/* Suppress all output if "silent" mode requested		*/
+	if (gd->flags & GD_FLG_SILENT)
+		outputdev = search_device (DEV_FLAGS_OUTPUT, "nulldev");
+#endif
+
+	/* Scan devices looking for input and output devices */
+	for (i = 1;
+	     (i <= items) && ((inputdev == NULL) || (outputdev == NULL));
+	     i++
+	    ) {
+		device_t *dev = ListGetPtrToItem (devlist, i);
+
+		if ((dev->flags & DEV_FLAGS_INPUT) && (inputdev == NULL)) {
+			inputdev = dev;
+		}
+		if ((dev->flags & DEV_FLAGS_OUTPUT) && (outputdev == NULL)) {
+			outputdev = dev;
+		}
+	}
+
+	/* Initializes output console first */
+	if (outputdev != NULL) {
+		console_setfile (stdout, outputdev);
+		console_setfile (stderr, outputdev);
+	}
+
+	/* Initializes input console */
+	if (inputdev != NULL) {
+		console_setfile (stdin, inputdev);
+	}
+
+	gd->flags |= GD_FLG_DEVINIT;	/* device initialization completed */
+
+#ifndef CFG_CONSOLE_INFO_QUIET
+	/* Print information */
+	puts ("In:    ");
+	if (stdio_devices[stdin] == NULL) {
+		puts ("No input devices available!\n");
+	} else {
+		printf ("%s\n", stdio_devices[stdin]->name);
+	}
+
+	puts ("Out:   ");
+	if (stdio_devices[stdout] == NULL) {
+		puts ("No output devices available!\n");
+	} else {
+		printf ("%s\n", stdio_devices[stdout]->name);
+	}
+
+	puts ("Err:   ");
+	if (stdio_devices[stderr] == NULL) {
+		puts ("No error devices available!\n");
+	} else {
+		printf ("%s\n", stdio_devices[stderr]->name);
+	}
+#endif /* CFG_CONSOLE_INFO_QUIET */
+
+	/* Setting environment variables */
+	for (i = 0; i < 3; i++) {
+		setenv (stdio_names[i], stdio_devices[i]->name);
+	}
+
+#if 0
+	/* If nothing usable installed, use only the initial console */
+	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
+		return (0);
+#endif
+
+	return (0);
+}
+#endif
+
+#endif /* CFG_CONSOLE_IS_IN_ENV */
diff --git a/lib_bootstrap/crc32.c b/lib_bootstrap/crc32.c
new file mode 100644
index 0000000000..50ca4ffd38
--- /dev/null
+++ b/lib_bootstrap/crc32.c
@@ -0,0 +1,197 @@
+/*
+ * This file is derived from crc32.c from the zlib-1.1.3 distribution
+ * by Jean-loup Gailly and Mark Adler.
+ */
+
+/* crc32.c -- compute the CRC-32 of a data stream
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+#ifndef USE_HOSTCC	/* Shut down "ANSI does not permit..." warnings */
+#include <common.h>	/* to get command definitions like CFG_CMD_JFFS2 */
+#endif
+
+#include "zlib.h"
+
+#define local static
+#define ZEXPORT	/* empty */
+unsigned long crc32 (unsigned long, const unsigned char *, unsigned int);
+
+#ifdef DYNAMIC_CRC_TABLE
+
+local int crc_table_empty = 1;
+local uLongf crc_table[256];
+local void make_crc_table OF((void));
+
+/*
+  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
+  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
+
+  Polynomials over GF(2) are represented in binary, one bit per coefficient,
+  with the lowest powers in the most significant bit.  Then adding polynomials
+  is just exclusive-or, and multiplying a polynomial by x is a right shift by
+  one.  If we call the above polynomial p, and represent a byte as the
+  polynomial q, also with the lowest power in the most significant bit (so the
+  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
+  where a mod b means the remainder after dividing a by b.
+
+  This calculation is done using the shift-register method of multiplying and
+  taking the remainder.  The register is initialized to zero, and for each
+  incoming bit, x^32 is added mod p to the register if the bit is a one (where
+  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
+  x (which is shifting right by one and adding x^32 mod p if the bit shifted
+  out is a one).  We start with the highest power (least significant bit) of
+  q and repeat for all eight bits of q.
+
+  The table is simply the CRC of all possible eight bit values.  This is all
+  the information needed to generate CRC's on data a byte at a time for all
+  combinations of CRC register values and incoming bytes.
+*/
+local void make_crc_table()
+{
+  uLong c;
+  int n, k;
+  uLong poly;            /* polynomial exclusive-or pattern */
+  /* terms of polynomial defining this crc (except x^32): */
+  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
+
+  /* make exclusive-or pattern from polynomial (0xedb88320L) */
+  poly = 0L;
+  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
+    poly |= 1L << (31 - p[n]);
+
+  for (n = 0; n < 256; n++)
+  {
+    c = (uLong)n;
+    for (k = 0; k < 8; k++)
+      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
+    crc_table[n] = c;
+  }
+  crc_table_empty = 0;
+}
+#else
+/* ========================================================================
+ * Table of CRC-32's of all single-byte values (made by make_crc_table)
+ */
+local const uLongf crc_table[256] = {
+  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+  0x2d02ef8dL
+};
+#endif
+
+#if 0
+/* =========================================================================
+ * This function can be used by asm versions of crc32()
+ */
+const uLongf * ZEXPORT get_crc_table()
+{
+#ifdef DYNAMIC_CRC_TABLE
+  if (crc_table_empty) make_crc_table();
+#endif
+  return (const uLongf *)crc_table;
+}
+#endif
+
+/* ========================================================================= */
+#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
+#define DO2(buf)  DO1(buf); DO1(buf);
+#define DO4(buf)  DO2(buf); DO2(buf);
+#define DO8(buf)  DO4(buf); DO4(buf);
+
+/* ========================================================================= */
+uLong ZEXPORT crc32(crc, buf, len)
+    uLong crc;
+    const Bytef *buf;
+    uInt len;
+{
+#ifdef DYNAMIC_CRC_TABLE
+    if (crc_table_empty)
+      make_crc_table();
+#endif
+    crc = crc ^ 0xffffffffL;
+    while (len >= 8)
+    {
+      DO8(buf);
+      len -= 8;
+    }
+    if (len) do {
+      DO1(buf);
+    } while (--len);
+    return crc ^ 0xffffffffL;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_JFFS2)
+
+/* No ones complement version. JFFS2 (and other things ?)
+ * don't use ones compliment in their CRC calculations.
+ */
+uLong ZEXPORT crc32_no_comp(uLong crc, const Bytef *buf, uInt len)
+{
+#ifdef DYNAMIC_CRC_TABLE
+    if (crc_table_empty)
+      make_crc_table();
+#endif
+    while (len >= 8)
+    {
+      DO8(buf);
+      len -= 8;
+    }
+    if (len) do {
+      DO1(buf);
+    } while (--len);
+
+    return crc;
+}
+
+#endif	/* CFG_CMD_JFFS2 */
diff --git a/lib_bootstrap/ctype.c b/lib_bootstrap/ctype.c
new file mode 100644
index 0000000000..6ed0468a21
--- /dev/null
+++ b/lib_bootstrap/ctype.c
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ *  linux/lib/ctype.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+#include <linux/ctype.h>
+
+unsigned char _ctype[] = {
+_C,_C,_C,_C,_C,_C,_C,_C,			/* 0-7 */
+_C,_C|_S,_C|_S,_C|_S,_C|_S,_C|_S,_C,_C,		/* 8-15 */
+_C,_C,_C,_C,_C,_C,_C,_C,			/* 16-23 */
+_C,_C,_C,_C,_C,_C,_C,_C,			/* 24-31 */
+_S|_SP,_P,_P,_P,_P,_P,_P,_P,			/* 32-39 */
+_P,_P,_P,_P,_P,_P,_P,_P,			/* 40-47 */
+_D,_D,_D,_D,_D,_D,_D,_D,			/* 48-55 */
+_D,_D,_P,_P,_P,_P,_P,_P,			/* 56-63 */
+_P,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U,	/* 64-71 */
+_U,_U,_U,_U,_U,_U,_U,_U,			/* 72-79 */
+_U,_U,_U,_U,_U,_U,_U,_U,			/* 80-87 */
+_U,_U,_U,_P,_P,_P,_P,_P,			/* 88-95 */
+_P,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L,	/* 96-103 */
+_L,_L,_L,_L,_L,_L,_L,_L,			/* 104-111 */
+_L,_L,_L,_L,_L,_L,_L,_L,			/* 112-119 */
+_L,_L,_L,_P,_P,_P,_P,_C,			/* 120-127 */
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		/* 128-143 */
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		/* 144-159 */
+_S|_SP,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,   /* 160-175 */
+_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,       /* 176-191 */
+_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,       /* 192-207 */
+_U,_U,_U,_U,_U,_U,_U,_P,_U,_U,_U,_U,_U,_U,_U,_L,       /* 208-223 */
+_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,       /* 224-239 */
+_L,_L,_L,_L,_L,_L,_L,_P,_L,_L,_L,_L,_L,_L,_L,_L};      /* 240-255 */
diff --git a/lib_bootstrap/devices.c b/lib_bootstrap/devices.c
new file mode 100644
index 0000000000..ddf8f8ee2d
--- /dev/null
+++ b/lib_bootstrap/devices.c
@@ -0,0 +1,216 @@
+/*
+ * (C) Copyright 2000
+ * Paolo Scaffardi, AIRVENT SAM s.p.a - RIMINI(ITALY), arsenio@tin.it
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <stdarg.h>
+#include <malloc.h>
+#include <devices.h>
+#include <serial.h>
+#ifdef CONFIG_LOGBUFFER
+#include <logbuff.h>
+#endif
+#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
+#include <i2c.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+list_t devlist = 0;
+device_t *stdio_devices[] = { NULL, NULL, NULL };
+char *stdio_names[MAX_FILES] = { "stdin", "stdout", "stderr" };
+
+#if defined(CONFIG_SPLASH_SCREEN) && !defined(CFG_DEVICE_NULLDEV)
+#define	CFG_DEVICE_NULLDEV	1
+#endif
+
+
+#ifdef CFG_DEVICE_NULLDEV
+void nulldev_putc(const char c)
+{
+  /* nulldev is empty! */
+}
+
+void nulldev_puts(const char *s)
+{
+  /* nulldev is empty! */
+}
+
+int nulldev_input(void)
+{
+  /* nulldev is empty! */
+  return 0;
+}
+#endif
+
+/**************************************************************************
+ * SYSTEM DRIVERS
+ **************************************************************************
+ */
+
+static void drv_system_init (void)
+{
+	device_t dev;
+
+	memset (&dev, 0, sizeof (dev));
+
+	strcpy (dev.name, "serial");
+	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
+#ifdef CONFIG_SERIAL_SOFTWARE_FIFO
+	dev.putc = serial_buffered_putc;
+	dev.puts = serial_buffered_puts;
+	dev.getc = serial_buffered_getc;
+	dev.tstc = serial_buffered_tstc;
+#else
+	dev.putc = serial_putc;
+	dev.puts = serial_puts;
+	dev.getc = serial_getc;
+	dev.tstc = serial_tstc;
+#endif
+
+	device_register (&dev);
+
+#ifdef CFG_DEVICE_NULLDEV
+	memset (&dev, 0, sizeof (dev));
+
+	strcpy (dev.name, "nulldev");
+	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
+	dev.putc = nulldev_putc;
+	dev.puts = nulldev_puts;
+	dev.getc = nulldev_input;
+	dev.tstc = nulldev_input;
+
+	device_register (&dev);
+#endif
+}
+
+/**************************************************************************
+ * DEVICES
+ **************************************************************************
+ */
+
+int device_register (device_t * dev)
+{
+	ListInsertItem (devlist, dev, LIST_END);
+	return 0;
+}
+
+/* deregister the device "devname".
+ * returns 0 if success, -1 if device is assigned and 1 if devname not found
+ */
+#ifdef	CFG_DEVICE_DEREGISTER
+int device_deregister(char *devname)
+{
+	int i,l,dev_index;
+	device_t *dev = NULL;
+	char temp_names[3][8];
+
+	dev_index=-1;
+	for (i=1; i<=ListNumItems(devlist); i++) {
+		dev = ListGetPtrToItem (devlist, i);
+		if(strcmp(dev->name,devname)==0) {
+			dev_index=i;
+			break;
+		}
+	}
+	if(dev_index<0) /* device not found */
+		return 0;
+	/* get stdio devices (ListRemoveItem changes the dev list) */
+	for (l=0 ; l< MAX_FILES; l++) {
+		if (stdio_devices[l] == dev) {
+			/* Device is assigned -> report error */
+			return -1;
+		}
+		memcpy (&temp_names[l][0],
+			stdio_devices[l]->name,
+			sizeof(stdio_devices[l]->name));
+	}
+	ListRemoveItem(devlist,NULL,dev_index);
+	/* reassign Device list */
+	for (i=1; i<=ListNumItems(devlist); i++) {
+		dev = ListGetPtrToItem (devlist, i);
+		for (l=0 ; l< MAX_FILES; l++) {
+			if(strcmp(dev->name,temp_names[l])==0) {
+				stdio_devices[l] = dev;
+			}
+		}
+	}
+	return 0;
+}
+#endif	/* CFG_DEVICE_DEREGISTER */
+
+int devices_init (void)
+{
+#ifndef CONFIG_ARM     /* already relocated for current ARM implementation */
+	ulong relocation_offset = gd->reloc_off;
+	int i;
+
+	/* relocate device name pointers */
+	for (i = 0; i < (sizeof (stdio_names) / sizeof (char *)); ++i) {
+		stdio_names[i] = (char *) (((ulong) stdio_names[i]) +
+						relocation_offset);
+	}
+#endif
+
+	/* Initialize the list */
+	devlist = ListCreate (sizeof (device_t));
+
+	if (devlist == NULL) {
+		eputs ("Cannot initialize the list of devices!\n");
+		return -1;
+	}
+#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
+	i2c_init (CFG_I2C_SPEED, CFG_I2C_SLAVE);
+#endif
+#ifdef CONFIG_LCD
+	drv_lcd_init ();
+#endif
+#if defined(CONFIG_VIDEO) || defined(CONFIG_CFB_CONSOLE)
+	drv_video_init ();
+#endif
+#ifdef CONFIG_KEYBOARD
+	drv_keyboard_init ();
+#endif
+#ifdef CONFIG_LOGBUFFER
+	drv_logbuff_init ();
+#endif
+	drv_system_init ();
+#ifdef CONFIG_SERIAL_MULTI
+	serial_devices_init ();
+#endif
+#ifdef CONFIG_USB_TTY
+	drv_usbtty_init ();
+#endif
+#ifdef CONFIG_NETCONSOLE
+	drv_nc_init ();
+#endif
+
+	return (0);
+}
+
+int devices_done (void)
+{
+	ListDispose (devlist);
+
+	return 0;
+}
diff --git a/lib_bootstrap/display_options.c b/lib_bootstrap/display_options.c
new file mode 100644
index 0000000000..512e8980d9
--- /dev/null
+++ b/lib_bootstrap/display_options.c
@@ -0,0 +1,67 @@
+/*
+ * (C) Copyright 2000-2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+int display_options (void)
+{
+	extern char version_string[];
+
+#if defined(BUILD_TAG)
+	printf ("\n\n%s, Build: %s\n\n", version_string, BUILD_TAG);
+#else
+	printf ("\n\n%s\n\n", version_string);
+#endif
+	return 0;
+}
+
+/*
+ * print sizes as "xxx kB", "xxx.y kB", "xxx MB" or "xxx.y MB" as needed;
+ * allow for optional trailing string (like "\n")
+ */
+void print_size (ulong size, const char *s)
+{
+	ulong m, n;
+	ulong d = 1 << 20;		/* 1 MB */
+	char  c = 'M';
+
+	if (size < d) {			/* print in kB */
+		c = 'k';
+		d = 1 << 10;
+	}
+
+	n = size / d;
+
+	m = (10 * (size - (n * d)) + (d / 2) ) / d;
+
+	if (m >= 10) {
+		m -= 10;
+		n += 1;
+	}
+
+	printf ("%2ld", n);
+	if (m) {
+		printf (".%ld", m);
+	}
+	printf (" %cB%s", c, s);
+}
diff --git a/lib_bootstrap/lists.c b/lib_bootstrap/lists.c
new file mode 100644
index 0000000000..3f117b568e
--- /dev/null
+++ b/lib_bootstrap/lists.c
@@ -0,0 +1,734 @@
+#include <common.h>
+#include <malloc.h>
+#include <lists.h>
+
+#define MAX(a,b) 	(((a)>(b)) ? (a) : (b))
+#define MIN(a,b) 	(((a)<(b)) ? (a) : (b))
+#define CAT4CHARS(a,b,c,d)	((a<<24) | (b<<16) | (c<<8) | d)
+
+/* increase list size by 10% every time it is full */
+#define kDefaultAllocationPercentIncrease	10
+
+/* always increase list size by 4 items when it is full */
+#define kDefaultAllocationminNumItemsIncrease	4
+
+/*
+ * how many items to expand the list by when it becomes full
+ * = current listSize (in items) + (hiword percent of list size) + loword
+ */
+#define NUMITEMSPERALLOC(list)	MAX(((*list)->listSize * \
+				    ((*list)->percentIncrease + 100)) / 100, \
+				    (*list)->minNumItemsIncrease )
+
+#define ITEMPTR(list,item)	&(((char *)&(*list)->itemList)[(*(list))->itemSize * (item)])
+
+#define LIST_SIGNATURE		CAT4CHARS('L', 'I', 'S', 'T');
+
+#define calloc(size,num)	malloc(size*num)
+
+/********************************************************************/
+
+Handle NewHandle (unsigned int numBytes)
+{
+	void *memPtr;
+	HandleRecord *hanPtr;
+
+	memPtr = calloc (numBytes, 1);
+	hanPtr = (HandleRecord *) calloc (sizeof (HandleRecord), 1);
+	if (hanPtr && (memPtr || numBytes == 0)) {
+		hanPtr->ptr = memPtr;
+		hanPtr->size = numBytes;
+		return (Handle) hanPtr;
+	} else {
+		free (memPtr);
+		free (hanPtr);
+		return NULL;
+	}
+}
+/********************************************************************/
+
+void DisposeHandle (Handle handle)
+{
+	if (handle) {
+		free (*handle);
+		free ((void *) handle);
+	}
+}
+/********************************************************************/
+
+unsigned int GetHandleSize (Handle handle)
+{
+	return ((HandleRecord *) handle)->size;
+}
+/********************************************************************/
+
+int SetHandleSize (Handle handle, unsigned int newSize)
+{
+	HandleRecord *hanRecPtr = (HandleRecord *) handle;
+	void *newPtr, *oldPtr;
+	unsigned int oldSize;
+
+
+	oldPtr = hanRecPtr->ptr;
+	oldSize = hanRecPtr->size;
+
+	if (oldSize == newSize)
+		return 1;
+
+	if (oldPtr == NULL) {
+		newPtr = malloc (newSize);
+	} else {
+		newPtr = realloc (oldPtr, newSize);
+	}
+	if (newPtr || (newSize == 0)) {
+		hanRecPtr->ptr = newPtr;
+		hanRecPtr->size = newSize;
+		if (newSize > oldSize)
+			memset ((char *) newPtr + oldSize, 0, newSize - oldSize);
+		return 1;
+	} else
+		return 0;
+}
+
+#ifdef	CFG_ALL_LIST_FUNCTIONS
+
+/*  Used to compare list elements by their raw data contents */
+static int ListMemBlockCmp (void *a, void *b, int size)
+{
+	return memcmp (a, b, size);
+}
+
+/***************************************************************************/
+
+/*
+ * Binary search numElements of size elementSize in array for a match
+ * to the. item. Return the index of the element that matches
+ * (0 - numElements - 1). If no match is found return the -i-1 where
+ * i is the index (0 - numElements) where the item should be placed.
+ * (*theCmp)(a,b) should return <0 if a<b, 0 if a==b, >0 if a>b.
+ *
+ * This function is like the C-Library function bsearch() except that
+ * this function returns the index where the item should be placed if
+ * it is not found.
+ */
+int BinSearch ( void *array, int numElements, int elementSize,
+		void *itemPtr, CompareFunction compareFunction)
+{
+	int low, high, mid, cmp;
+	void *arrayItemPtr;
+
+	for (low = 0, high = numElements - 1, mid = 0, cmp = -1; low <= high;) {
+		mid = (low + high) >> 1;
+
+		arrayItemPtr = (void *) (((char *) array) + (mid * elementSize));
+		cmp = compareFunction
+			? compareFunction (itemPtr, arrayItemPtr)
+			: ListMemBlockCmp (itemPtr, arrayItemPtr, elementSize);
+		if (cmp == 0) {
+			return mid;
+		} else if (cmp < 0) {
+			high = mid - 1;
+		} else {
+			low = mid + 1;
+		}
+	}
+	if (cmp > 0)
+		mid++;
+
+	return -mid - 1;
+}
+
+#endif	/* CFG_ALL_LIST_FUNCTIONS */
+
+/*******************************************************************************/
+
+/*
+ * If numNewItems == 0 then expand the list by the number of items
+ * indicated by its allocation policy.
+ * If numNewItems > 0 then expand the list by exactly the number of
+ * items indicated.
+ * If numNewItems < 0 then expand the list by the absolute value of
+ * numNewItems plus the number of items indicated by its allocation
+ * policy.
+ * Returns 1 for success, 0 if out of memory
+*/
+static int ExpandListSpace (list_t list, int numNewItems)
+{
+	if (numNewItems == 0) {
+		numNewItems = NUMITEMSPERALLOC (list);
+	} else if (numNewItems < 0) {
+		numNewItems = (-numNewItems) + NUMITEMSPERALLOC (list);
+	}
+
+	if (SetHandleSize ((Handle) list,
+			   sizeof (ListStruct) +
+			   ((*list)->listSize +
+			   numNewItems) * (*list)->itemSize)) {
+		(*list)->listSize += numNewItems;
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+/*******************************/
+
+#ifdef	CFG_ALL_LIST_FUNCTIONS
+
+/*
+ * This function reallocate the list, minus any currently unused
+ * portion of its allotted memory.
+ */
+void ListCompact (list_t list)
+{
+
+	if (!SetHandleSize ((Handle) list,
+			    sizeof (ListStruct) +
+			    (*list)->numItems * (*list)->itemSize)) {
+		return;
+	}
+
+	(*list)->listSize = (*list)->numItems;
+}
+
+#endif	/* CFG_ALL_LIST_FUNCTIONS */
+
+/*******************************/
+
+list_t ListCreate (int elementSize)
+{
+	list_t list;
+
+	list = (list_t) (NewHandle (sizeof (ListStruct)));  /* create empty list */
+	if (list) {
+		(*list)->signature = LIST_SIGNATURE;
+		(*list)->numItems = 0;
+		(*list)->listSize = 0;
+		(*list)->itemSize = elementSize;
+		(*list)->percentIncrease = kDefaultAllocationPercentIncrease;
+		(*list)->minNumItemsIncrease =
+				kDefaultAllocationminNumItemsIncrease;
+	}
+
+	return list;
+}
+
+/*******************************/
+
+void ListSetAllocationPolicy (list_t list, int minItemsPerAlloc,
+			      int percentIncreasePerAlloc)
+{
+	(*list)->percentIncrease = percentIncreasePerAlloc;
+	(*list)->minNumItemsIncrease = minItemsPerAlloc;
+}
+
+/*******************************/
+
+void ListDispose (list_t list)
+{
+	DisposeHandle ((Handle) list);
+}
+/*******************************/
+
+#ifdef	CFG_ALL_LIST_FUNCTIONS
+
+void ListDisposePtrList (list_t list)
+{
+	int index;
+	int numItems;
+
+	if (list) {
+		numItems = ListNumItems (list);
+
+		for (index = 1; index <= numItems; index++)
+			free (*(void **) ListGetPtrToItem (list, index));
+
+		ListDispose (list);
+	}
+}
+
+/*******************************/
+
+/*
+ * keeps memory, resets the number of items to 0
+ */
+void ListClear (list_t list)
+{
+	if (!list)
+		return;
+	(*list)->numItems = 0;
+}
+
+/*******************************/
+
+/*
+ * copy is only as large as necessary
+ */
+list_t ListCopy (list_t originalList)
+{
+	list_t tempList = NULL;
+	int numItems;
+
+	if (!originalList)
+		return NULL;
+
+	tempList = ListCreate ((*originalList)->itemSize);
+	if (tempList) {
+		numItems = ListNumItems (originalList);
+
+		if (!SetHandleSize ((Handle) tempList,
+				    sizeof (ListStruct) +
+				    numItems * (*tempList)->itemSize)) {
+			ListDispose (tempList);
+			return NULL;
+		}
+
+		(*tempList)->numItems = (*originalList)->numItems;
+		(*tempList)->listSize = (*originalList)->numItems;
+		(*tempList)->itemSize = (*originalList)->itemSize;
+		(*tempList)->percentIncrease = (*originalList)->percentIncrease;
+		(*tempList)->minNumItemsIncrease =
+				(*originalList)->minNumItemsIncrease;
+
+		memcpy (ITEMPTR (tempList, 0), ITEMPTR (originalList, 0),
+				numItems * (*tempList)->itemSize);
+	}
+
+	return tempList;
+}
+
+/********************************/
+
+/*
+ * list1 = list1 + list2
+ */
+int ListAppend (list_t list1, list_t list2)
+{
+	int numItemsL1, numItemsL2;
+
+	if (!list2)
+		return 1;
+
+	if (!list1)
+		return 0;
+	if ((*list1)->itemSize != (*list2)->itemSize)
+		return 0;
+
+	numItemsL1 = ListNumItems (list1);
+	numItemsL2 = ListNumItems (list2);
+
+	if (numItemsL2 == 0)
+		return 1;
+
+	if (!SetHandleSize ((Handle) list1,
+			    sizeof (ListStruct) + (numItemsL1 + numItemsL2) *
+					(*list1)->itemSize)) {
+		return 0;
+	}
+
+	(*list1)->numItems = numItemsL1 + numItemsL2;
+	(*list1)->listSize = numItemsL1 + numItemsL2;
+
+	memmove (ITEMPTR (list1, numItemsL1),
+		 ITEMPTR (list2, 0),
+		 numItemsL2 * (*list2)->itemSize);
+
+	return 1;
+}
+
+#endif	/* CFG_ALL_LIST_FUNCTIONS */
+
+/*******************************/
+
+/*
+ * returns 1 if the item is inserted, returns 0 if out of memory or
+ * bad arguments were passed.
+ */
+int ListInsertItem (list_t list, void *ptrToItem, int itemPosition)
+{
+	return ListInsertItems (list, ptrToItem, itemPosition, 1);
+}
+
+/*******************************/
+
+int ListInsertItems (list_t list, void *ptrToItems, int firstItemPosition,
+		     int numItemsToInsert)
+{
+	int numItems = (*list)->numItems;
+
+	if (firstItemPosition == numItems + 1)
+		firstItemPosition = LIST_END;
+	else if (firstItemPosition > numItems)
+		return 0;
+
+	if ((*list)->numItems >= (*list)->listSize) {
+		if (!ExpandListSpace (list, -numItemsToInsert))
+			return 0;
+	}
+
+	if (firstItemPosition == LIST_START) {
+		if (numItems == 0) {
+			/* special case for empty list */
+			firstItemPosition = LIST_END;
+		} else {
+			firstItemPosition = 1;
+		}
+	}
+
+	if (firstItemPosition == LIST_END) {	/* add at the end of the list */
+		if (ptrToItems)
+			memcpy (ITEMPTR (list, numItems), ptrToItems,
+					(*list)->itemSize * numItemsToInsert);
+		else
+			memset (ITEMPTR (list, numItems), 0,
+					(*list)->itemSize * numItemsToInsert);
+
+		(*list)->numItems += numItemsToInsert;
+	} else {					/* move part of list up to make room for new item */
+		memmove (ITEMPTR (list, firstItemPosition - 1 + numItemsToInsert),
+			 ITEMPTR (list, firstItemPosition - 1),
+			 (numItems + 1 - firstItemPosition) * (*list)->itemSize);
+
+		if (ptrToItems)
+			memmove (ITEMPTR (list, firstItemPosition - 1), ptrToItems,
+					 (*list)->itemSize * numItemsToInsert);
+		else
+			memset (ITEMPTR (list, firstItemPosition - 1), 0,
+					(*list)->itemSize * numItemsToInsert);
+
+		(*list)->numItems += numItemsToInsert;
+	}
+
+	return 1;
+}
+
+#ifdef CFG_ALL_LIST_FUNCTIONS
+
+/*******************************/
+
+int ListEqual (list_t list1, list_t list2)
+{
+	if (list1 == list2)
+		return 1;
+
+	if (list1 == NULL || list2 == NULL)
+		return 0;
+
+	if ((*list1)->itemSize == (*list1)->itemSize) {
+	    if ((*list1)->numItems == (*list2)->numItems) {
+		return (memcmp (ITEMPTR (list1, 0), ITEMPTR (list2, 0),
+				(*list1)->itemSize * (*list1)->numItems) == 0);
+	    }
+	}
+
+	return 0;
+}
+
+/*******************************/
+
+/*
+ * The item pointed to by ptrToItem is copied over the current item
+ * at itemPosition
+ */
+void ListReplaceItem (list_t list, void *ptrToItem, int itemPosition)
+{
+	ListReplaceItems (list, ptrToItem, itemPosition, 1);
+}
+
+/*******************************/
+
+/*
+ * The item pointed to by ptrToItems is copied over the current item
+ * at itemPosition
+ */
+void ListReplaceItems ( list_t list, void *ptrToItems,
+			int firstItemPosition, int numItemsToReplace)
+{
+
+	if (firstItemPosition == LIST_END)
+		firstItemPosition = (*list)->numItems;
+	else if (firstItemPosition == LIST_START)
+		firstItemPosition = 1;
+
+	memmove (ITEMPTR (list, firstItemPosition - 1), ptrToItems,
+			 (*list)->itemSize * numItemsToReplace);
+}
+
+/*******************************/
+
+void ListGetItem (list_t list, void *itemDestination, int itemPosition)
+{
+	ListGetItems (list, itemDestination, itemPosition, 1);
+}
+
+#endif	/* CFG_ALL_LIST_FUNCTIONS */
+
+/*******************************/
+
+#if defined(CFG_ALL_LIST_FUNCTIONS) || defined(CFG_DEVICE_DEREGISTER)
+
+void ListRemoveItem (list_t list, void *itemDestination, int itemPosition)
+{
+	ListRemoveItems (list, itemDestination, itemPosition, 1);
+}
+
+/*******************************/
+
+void ListRemoveItems (list_t list, void *itemsDestination,
+		      int firstItemPosition, int numItemsToRemove)
+{
+	int firstItemAfterChunk, numToMove;
+
+	if (firstItemPosition == LIST_START)
+		firstItemPosition = 1;
+	else if (firstItemPosition == LIST_END)
+		firstItemPosition = (*list)->numItems;
+
+	if (itemsDestination != NULL)
+		memcpy (itemsDestination, ITEMPTR (list, firstItemPosition - 1),
+				(*list)->itemSize * numItemsToRemove);
+
+	firstItemAfterChunk = firstItemPosition + numItemsToRemove;
+	numToMove = (*list)->numItems - (firstItemAfterChunk - 1);
+
+	if (numToMove > 0) {
+		/*
+		 * move part of list down to cover hole left by removed item
+		 */
+		memmove (ITEMPTR (list, firstItemPosition - 1),
+				 ITEMPTR (list, firstItemAfterChunk - 1),
+				 (*list)->itemSize * numToMove);
+	}
+
+	(*list)->numItems -= numItemsToRemove;
+}
+#endif	/* CFG_ALL_LIST_FUNCTIONS || CFG_DEVICE_DEREGISTER */
+
+/*******************************/
+
+void ListGetItems (list_t list, void *itemsDestination,
+		   int firstItemPosition, int numItemsToGet)
+{
+
+	if (firstItemPosition == LIST_START)
+		firstItemPosition = 1;
+	else if (firstItemPosition == LIST_END)
+		firstItemPosition = (*list)->numItems;
+
+	memcpy (itemsDestination,
+		ITEMPTR (list, firstItemPosition - 1),
+		(*list)->itemSize * numItemsToGet);
+}
+
+/*******************************/
+
+/*
+ * Returns a pointer to the item at itemPosition. returns null if an
+ * errors occurred.
+ */
+void *ListGetPtrToItem (list_t list, int itemPosition)
+{
+	if (itemPosition == LIST_START)
+		itemPosition = 1;
+	else if (itemPosition == LIST_END)
+		itemPosition = (*list)->numItems;
+
+	return ITEMPTR (list, itemPosition - 1);
+}
+
+/*******************************/
+
+/*
+ * returns a pointer the lists data (abstraction violation for
+ * optimization)
+ */
+void *ListGetDataPtr (list_t list)
+{
+	return &((*list)->itemList[0]);
+}
+
+/********************************/
+
+#ifdef	CFG_ALL_LIST_FUNCTIONS
+
+int ListApplyToEach (list_t list, int ascending,
+		     ListApplicationFunc funcToApply,
+		     void *callbackData)
+{
+	int result = 0, index;
+
+	if (!list || !funcToApply)
+		goto Error;
+
+	if (ascending) {
+		for (index = 1; index <= ListNumItems (list); index++) {
+			result = funcToApply (index,
+					      ListGetPtrToItem (list, index),
+					      callbackData);
+			if (result < 0)
+				goto Error;
+		}
+	} else {
+		for (index = ListNumItems (list);
+		     index > 0 && index <= ListNumItems (list);
+		     index--) {
+			result = funcToApply (index,
+					      ListGetPtrToItem (list, index),
+					      callbackData);
+			if (result < 0)
+				goto Error;
+		}
+	}
+
+Error:
+	return result;
+}
+
+#endif /* CFG_ALL_LIST_FUNCTIONS */
+
+/********************************/
+
+int ListGetItemSize (list_t list)
+{
+	return (*list)->itemSize;
+}
+
+/********************************/
+
+int ListNumItems (list_t list)
+{
+	return (*list)->numItems;
+}
+
+/*******************************/
+
+#ifdef	CFG_ALL_LIST_FUNCTIONS
+
+void ListRemoveDuplicates (list_t list, CompareFunction compareFunction)
+{
+	int numItems, index, startIndexForFind, duplicatesIndex;
+
+	numItems = ListNumItems (list);
+
+	for (index = 1; index < numItems; index++) {
+		startIndexForFind = index + 1;
+		while (startIndexForFind <= numItems) {
+			duplicatesIndex =
+				ListFindItem (list,
+					      ListGetPtrToItem (list, index),
+					      startIndexForFind,
+					      compareFunction);
+			if (duplicatesIndex > 0) {
+				ListRemoveItem (list, NULL, duplicatesIndex);
+				numItems--;
+				startIndexForFind = duplicatesIndex;
+			} else {
+				break;
+			}
+		}
+	}
+}
+
+/*******************************/
+
+
+/*******************************/
+
+int ListFindItem (list_t list, void *ptrToItem, int startingPosition,
+		  CompareFunction compareFunction)
+{
+	int numItems, size, index, cmp;
+	void *listItemPtr;
+
+	if ((numItems = (*list)->numItems) == 0)
+		return 0;
+
+	size = (*list)->itemSize;
+
+	if (startingPosition == LIST_START)
+		startingPosition = 1;
+	else if (startingPosition == LIST_END)
+		startingPosition = numItems;
+
+	for (index = startingPosition; index <= numItems; index++) {
+		listItemPtr = ITEMPTR (list, index - 1);
+		cmp = compareFunction
+			? compareFunction (ptrToItem, listItemPtr)
+			: ListMemBlockCmp (ptrToItem, listItemPtr, size);
+		if (cmp == 0)
+			return index;
+	}
+
+	return 0;
+}
+
+/*******************************/
+
+int ShortCompare (void *a, void *b)
+{
+	if (*(short *) a < *(short *) b)
+		return -1;
+	if (*(short *) a > *(short *) b)
+		return 1;
+	return 0;
+}
+
+/*******************************/
+
+int IntCompare (void *a, void *b)
+{
+	if (*(int *) a < *(int *) b)
+		return -1;
+	if (*(int *) a > *(int *) b)
+		return 1;
+	return 0;
+}
+
+/*******************************/
+
+int CStringCompare (void *a, void *b)
+{
+	return strcmp (*(char **) a, *(char **) b);
+}
+
+/*******************************/
+
+
+int ListBinSearch (list_t list, void *ptrToItem,
+		   CompareFunction compareFunction)
+{
+	int index;
+
+	index = BinSearch (ITEMPTR (list, 0),
+			   (int) (*list)->numItems,
+			   (int) (*list)->itemSize, ptrToItem,
+			   compareFunction);
+
+	if (index >= 0)
+		index++;			/* lists start from 1 */
+	else
+		index = 0;			/* item not found */
+
+	return index;
+}
+
+/**************************************************************************/
+
+/*
+ * Reserves memory for numItems in the list. If it succeeds then
+ * numItems items can be inserted without possibility of an out of
+ * memory error (useful to simplify error recovery in complex
+ * functions). Returns 1 if success, 0 if out of memory.
+ */
+int ListPreAllocate (list_t list, int numItems)
+{
+	if ((*list)->listSize - (*list)->numItems < numItems) {
+		return ExpandListSpace (list,
+					numItems - ((*list)->listSize -
+						(*list)->numItems));
+	} else {
+		return 1;	/* enough items are already pre-allocated */
+	}
+}
+
+#endif /* CFG_ALL_LIST_FUNCTIONS */
diff --git a/lib_bootstrap/string.c b/lib_bootstrap/string.c
new file mode 100644
index 0000000000..e0b793abbe
--- /dev/null
+++ b/lib_bootstrap/string.c
@@ -0,0 +1,578 @@
+/*
+ *  linux/lib/string.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+/*
+ * stupid library routines.. The optimized versions should generally be found
+ * as inline code in <asm-xx/string.h>
+ *
+ * These are buggy as well..
+ *
+ * * Fri Jun 25 1999, Ingo Oeser <ioe@informatik.tu-chemnitz.de>
+ * -  Added strsep() which will replace strtok() soon (because strsep() is
+ *    reentrant and should be faster). Use only strsep() in new code, please.
+ */
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <malloc.h>
+
+
+#if 0 /* not used - was: #ifndef __HAVE_ARCH_STRNICMP */
+/**
+ * strnicmp - Case insensitive, length-limited string comparison
+ * @s1: One string
+ * @s2: The other string
+ * @len: the maximum number of characters to compare
+ */
+int strnicmp(const char *s1, const char *s2, size_t len)
+{
+	/* Yes, Virginia, it had better be unsigned */
+	unsigned char c1, c2;
+
+	c1 = 0;	c2 = 0;
+	if (len) {
+		do {
+			c1 = *s1; c2 = *s2;
+			s1++; s2++;
+			if (!c1)
+				break;
+			if (!c2)
+				break;
+			if (c1 == c2)
+				continue;
+			c1 = tolower(c1);
+			c2 = tolower(c2);
+			if (c1 != c2)
+				break;
+		} while (--len);
+	}
+	return (int)c1 - (int)c2;
+}
+#endif
+
+char * ___strtok;
+
+#ifndef __HAVE_ARCH_STRCPY
+/**
+ * strcpy - Copy a %NUL terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ */
+char * strcpy(char * dest,const char *src)
+{
+	char *tmp = dest;
+
+	while ((*dest++ = *src++) != '\0')
+		/* nothing */;
+	return tmp;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRNCPY
+/**
+ * strncpy - Copy a length-limited, %NUL-terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ * @count: The maximum number of bytes to copy
+ *
+ * Note that unlike userspace strncpy, this does not %NUL-pad the buffer.
+ * However, the result is not %NUL-terminated if the source exceeds
+ * @count bytes.
+ */
+char * strncpy(char * dest,const char *src,size_t count)
+{
+	char *tmp = dest;
+
+	while (count-- && (*dest++ = *src++) != '\0')
+		/* nothing */;
+
+	return tmp;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRCAT
+/**
+ * strcat - Append one %NUL-terminated string to another
+ * @dest: The string to be appended to
+ * @src: The string to append to it
+ */
+char * strcat(char * dest, const char * src)
+{
+	char *tmp = dest;
+
+	while (*dest)
+		dest++;
+	while ((*dest++ = *src++) != '\0')
+		;
+
+	return tmp;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRNCAT
+/**
+ * strncat - Append a length-limited, %NUL-terminated string to another
+ * @dest: The string to be appended to
+ * @src: The string to append to it
+ * @count: The maximum numbers of bytes to copy
+ *
+ * Note that in contrast to strncpy, strncat ensures the result is
+ * terminated.
+ */
+char * strncat(char *dest, const char *src, size_t count)
+{
+	char *tmp = dest;
+
+	if (count) {
+		while (*dest)
+			dest++;
+		while ((*dest++ = *src++)) {
+			if (--count == 0) {
+				*dest = '\0';
+				break;
+			}
+		}
+	}
+
+	return tmp;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRCMP
+/**
+ * strcmp - Compare two strings
+ * @cs: One string
+ * @ct: Another string
+ */
+int strcmp(const char * cs,const char * ct)
+{
+	register signed char __res;
+
+	while (1) {
+		if ((__res = *cs - *ct++) != 0 || !*cs++)
+			break;
+	}
+
+	return __res;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRNCMP
+/**
+ * strncmp - Compare two length-limited strings
+ * @cs: One string
+ * @ct: Another string
+ * @count: The maximum number of bytes to compare
+ */
+int strncmp(const char * cs,const char * ct,size_t count)
+{
+	register signed char __res = 0;
+
+	while (count) {
+		if ((__res = *cs - *ct++) != 0 || !*cs++)
+			break;
+		count--;
+	}
+
+	return __res;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRCHR
+/**
+ * strchr - Find the first occurrence of a character in a string
+ * @s: The string to be searched
+ * @c: The character to search for
+ */
+char * strchr(const char * s, int c)
+{
+	for(; *s != (char) c; ++s)
+		if (*s == '\0')
+			return NULL;
+	return (char *) s;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRRCHR
+/**
+ * strrchr - Find the last occurrence of a character in a string
+ * @s: The string to be searched
+ * @c: The character to search for
+ */
+char * strrchr(const char * s, int c)
+{
+       const char *p = s + strlen(s);
+       do {
+	   if (*p == (char)c)
+	       return (char *)p;
+       } while (--p >= s);
+       return NULL;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRLEN
+/**
+ * strlen - Find the length of a string
+ * @s: The string to be sized
+ */
+size_t strlen(const char * s)
+{
+	const char *sc;
+
+	for (sc = s; *sc != '\0'; ++sc)
+		/* nothing */;
+	return sc - s;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRNLEN
+/**
+ * strnlen - Find the length of a length-limited string
+ * @s: The string to be sized
+ * @count: The maximum number of bytes to search
+ */
+size_t strnlen(const char * s, size_t count)
+{
+	const char *sc;
+
+	for (sc = s; count-- && *sc != '\0'; ++sc)
+		/* nothing */;
+	return sc - s;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRDUP
+char * strdup(const char *s)
+{
+	char *new;
+
+	if ((s == NULL)	||
+	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
+		return NULL;
+	}
+
+	strcpy (new, s);
+	return new;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRSPN
+/**
+ * strspn - Calculate the length of the initial substring of @s which only
+ * 	contain letters in @accept
+ * @s: The string to be searched
+ * @accept: The string to search for
+ */
+size_t strspn(const char *s, const char *accept)
+{
+	const char *p;
+	const char *a;
+	size_t count = 0;
+
+	for (p = s; *p != '\0'; ++p) {
+		for (a = accept; *a != '\0'; ++a) {
+			if (*p == *a)
+				break;
+		}
+		if (*a == '\0')
+			return count;
+		++count;
+	}
+
+	return count;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRPBRK
+/**
+ * strpbrk - Find the first occurrence of a set of characters
+ * @cs: The string to be searched
+ * @ct: The characters to search for
+ */
+char * strpbrk(const char * cs,const char * ct)
+{
+	const char *sc1,*sc2;
+
+	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
+		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
+			if (*sc1 == *sc2)
+				return (char *) sc1;
+		}
+	}
+	return NULL;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRTOK
+/**
+ * strtok - Split a string into tokens
+ * @s: The string to be searched
+ * @ct: The characters to search for
+ *
+ * WARNING: strtok is deprecated, use strsep instead.
+ */
+char * strtok(char * s,const char * ct)
+{
+	char *sbegin, *send;
+
+	sbegin  = s ? s : ___strtok;
+	if (!sbegin) {
+		return NULL;
+	}
+	sbegin += strspn(sbegin,ct);
+	if (*sbegin == '\0') {
+		___strtok = NULL;
+		return( NULL );
+	}
+	send = strpbrk( sbegin, ct);
+	if (send && *send != '\0')
+		*send++ = '\0';
+	___strtok = send;
+	return (sbegin);
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRSEP
+/**
+ * strsep - Split a string into tokens
+ * @s: The string to be searched
+ * @ct: The characters to search for
+ *
+ * strsep() updates @s to point after the token, ready for the next call.
+ *
+ * It returns empty tokens, too, behaving exactly like the libc function
+ * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
+ * Same semantics, slimmer shape. ;)
+ */
+char * strsep(char **s, const char *ct)
+{
+	char *sbegin = *s, *end;
+
+	if (sbegin == NULL)
+		return NULL;
+
+	end = strpbrk(sbegin, ct);
+	if (end)
+		*end++ = '\0';
+	*s = end;
+
+	return sbegin;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRSWAB
+/**
+ * strswab - swap adjacent even and odd bytes in %NUL-terminated string
+ * s: address of the string
+ *
+ * returns the address of the swapped string or NULL on error. If
+ * string length is odd, last byte is untouched.
+ */
+char *strswab(const char *s)
+{
+	char *p, *q;
+
+	if ((NULL == s) || ('\0' == *s)) {
+		return (NULL);
+	}
+
+	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
+		char  tmp;
+
+		tmp = *p;
+		*p  = *q;
+		*q  = tmp;
+	}
+
+	return (char *) s;
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMSET
+/**
+ * memset - Fill a region of memory with the given value
+ * @s: Pointer to the start of the area.
+ * @c: The byte to fill the area with
+ * @count: The size of the area.
+ *
+ * Do not use memset() to access IO space, use memset_io() instead.
+ */
+void * memset(void * s,int c,size_t count)
+{
+	char *xs = (char *) s;
+
+	while (count--)
+		*xs++ = c;
+
+	return s;
+}
+#endif
+
+#ifndef __HAVE_ARCH_BCOPY
+/**
+ * bcopy - Copy one area of memory to another
+ * @src: Where to copy from
+ * @dest: Where to copy to
+ * @count: The size of the area.
+ *
+ * Note that this is the same as memcpy(), with the arguments reversed.
+ * memcpy() is the standard, bcopy() is a legacy BSD function.
+ *
+ * You should not use this function to access IO space, use memcpy_toio()
+ * or memcpy_fromio() instead.
+ */
+char * bcopy(const char * src, char * dest, int count)
+{
+	char *tmp = dest;
+
+	while (count--)
+		*tmp++ = *src++;
+
+	return dest;
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMCPY
+/**
+ * memcpy - Copy one area of memory to another
+ * @dest: Where to copy to
+ * @src: Where to copy from
+ * @count: The size of the area.
+ *
+ * You should not use this function to access IO space, use memcpy_toio()
+ * or memcpy_fromio() instead.
+ */
+void * memcpy(void * dest,const void *src,size_t count)
+{
+	char *tmp = (char *) dest, *s = (char *) src;
+
+	while (count--)
+		*tmp++ = *s++;
+
+	return dest;
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMMOVE
+/**
+ * memmove - Copy one area of memory to another
+ * @dest: Where to copy to
+ * @src: Where to copy from
+ * @count: The size of the area.
+ *
+ * Unlike memcpy(), memmove() copes with overlapping areas.
+ */
+void * memmove(void * dest,const void *src,size_t count)
+{
+	char *tmp, *s;
+
+	if (dest <= src) {
+		tmp = (char *) dest;
+		s = (char *) src;
+		while (count--)
+			*tmp++ = *s++;
+		}
+	else {
+		tmp = (char *) dest + count;
+		s = (char *) src + count;
+		while (count--)
+			*--tmp = *--s;
+		}
+
+	return dest;
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMCMP
+/**
+ * memcmp - Compare two areas of memory
+ * @cs: One area of memory
+ * @ct: Another area of memory
+ * @count: The size of the area.
+ */
+int memcmp(const void * cs,const void * ct,size_t count)
+{
+	const unsigned char *su1, *su2;
+	int res = 0;
+
+	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
+		if ((res = *su1 - *su2) != 0)
+			break;
+	return res;
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMSCAN
+/**
+ * memscan - Find a character in an area of memory.
+ * @addr: The memory area
+ * @c: The byte to search for
+ * @size: The size of the area.
+ *
+ * returns the address of the first occurrence of @c, or 1 byte past
+ * the area if @c is not found
+ */
+void * memscan(void * addr, int c, size_t size)
+{
+	unsigned char * p = (unsigned char *) addr;
+
+	while (size) {
+		if (*p == c)
+			return (void *) p;
+		p++;
+		size--;
+	}
+	return (void *) p;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRSTR
+/**
+ * strstr - Find the first substring in a %NUL terminated string
+ * @s1: The string to be searched
+ * @s2: The string to search for
+ */
+char * strstr(const char * s1,const char * s2)
+{
+	int l1, l2;
+
+	l2 = strlen(s2);
+	if (!l2)
+		return (char *) s1;
+	l1 = strlen(s1);
+	while (l1 >= l2) {
+		l1--;
+		if (!memcmp(s1,s2,l2))
+			return (char *) s1;
+		s1++;
+	}
+	return NULL;
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMCHR
+/**
+ * memchr - Find a character in an area of memory.
+ * @s: The memory area
+ * @c: The byte to search for
+ * @n: The size of the area.
+ *
+ * returns the address of the first occurrence of @c, or %NULL
+ * if @c is not found
+ */
+void *memchr(const void *s, int c, size_t n)
+{
+	const unsigned char *p = s;
+	while (n-- != 0) {
+		if ((unsigned char)c == *p++) {
+			return (void *)(p-1);
+		}
+	}
+	return NULL;
+}
+
+#endif
diff --git a/lib_bootstrap/time.c b/lib_bootstrap/time.c
new file mode 100644
index 0000000000..cd8dc721e2
--- /dev/null
+++ b/lib_bootstrap/time.c
@@ -0,0 +1,99 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+
+static inline void mips_compare_set(u32 v)
+{
+	asm volatile ("mtc0 %0, $11" : : "r" (v));
+}
+
+static inline void mips_count_set(u32 v)
+{
+	asm volatile ("mtc0 %0, $9" : : "r" (v));
+}
+
+
+static inline u32 mips_count_get(void)
+{
+	u32 count;
+
+	asm volatile ("mfc0 %0, $9" : "=r" (count) :);
+	return count;
+}
+
+/*
+ * timer without interrupts
+ */
+
+int timer_init(void)
+{
+	mips_compare_set(0);
+	mips_count_set(0);
+
+	return 0;
+}
+
+void reset_timer(void)
+{
+	mips_count_set(0);
+}
+
+ulong get_timer(ulong base)
+{
+	return mips_count_get() - base;
+}
+
+void set_timer(ulong t)
+{
+	mips_count_set(t);
+}
+
+void udelay (unsigned long usec)
+{
+	ulong tmo;
+	ulong start = get_timer(0);
+
+	tmo = usec * (CFG_HZ / 1000000);
+	while ((ulong)((mips_count_get() - start)) < tmo)
+		/*NOP*/;
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On MIPS it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return mips_count_get();
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On MIPS it returns the number of timer ticks per second.
+ */
+ulong get_tbclk(void)
+{
+	return CFG_HZ;
+}
diff --git a/lib_bootstrap/vsprintf.c b/lib_bootstrap/vsprintf.c
new file mode 100644
index 0000000000..2740f2e769
--- /dev/null
+++ b/lib_bootstrap/vsprintf.c
@@ -0,0 +1,385 @@
+/*
+ *  linux/lib/vsprintf.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+/* vsprintf.c -- Lars Wirzenius & Linus Torvalds. */
+/*
+ * Wirzenius wrote this portably, Torvalds fucked it up :-)
+ */
+
+#include <stdarg.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+
+#include <common.h>
+#if !defined (CONFIG_PANIC_HANG)
+#include <command.h>
+/*cmd_boot.c*/
+extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+#endif
+
+unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
+{
+	unsigned long result = 0,value;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit(cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base) {
+			base = 8;
+		}
+	}
+	if (!base) {
+		base = 10;
+	}
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+	    ? toupper(*cp) : *cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *)cp;
+	return result;
+}
+
+long simple_strtol(const char *cp,char **endp,unsigned int base)
+{
+	if(*cp=='-')
+		return -simple_strtoul(cp+1,endp,base);
+	return simple_strtoul(cp,endp,base);
+}
+
+#ifdef CFG_64BIT_STRTOUL
+unsigned long long simple_strtoull (const char *cp, char **endp, unsigned int base)
+{
+	unsigned long long result = 0, value;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit (cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base) {
+			base = 8;
+		}
+	}
+	if (!base) {
+		base = 10;
+	}
+	while (isxdigit (*cp) && (value = isdigit (*cp)
+				? *cp - '0'
+				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
+		result = result * base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *) cp;
+	return result;
+}
+#endif /* CFG_64BIT_STRTOUL */
+
+/* we use this so that we can do without the ctype library */
+#define is_digit(c)	((c) >= '0' && (c) <= '9')
+
+static int skip_atoi(const char **s)
+{
+	int i=0;
+
+	while (is_digit(**s))
+		i = i*10 + *((*s)++) - '0';
+	return i;
+}
+
+#define ZEROPAD	1		/* pad with zero */
+#define SIGN	2		/* unsigned/signed long */
+#define PLUS	4		/* show plus */
+#define SPACE	8		/* space if plus */
+#define LEFT	16		/* left justified */
+#define SPECIAL	32		/* 0x */
+#define LARGE	64		/* use 'ABCDEF' instead of 'abcdef' */
+
+#define do_div(n,base) ({ \
+	int __res; \
+	__res = ((unsigned long) n) % (unsigned) base; \
+	n = ((unsigned long) n) / (unsigned) base; \
+	__res; \
+})
+
+#ifdef CFG_64BIT_VSPRINTF
+static char * number(char * str, long long num, int base, int size, int precision ,int type)
+#else
+static char * number(char * str, long num, int base, int size, int precision ,int type)
+#endif
+{
+	char c,sign,tmp[66];
+	const char *digits="0123456789abcdefghijklmnopqrstuvwxyz";
+	int i;
+
+	if (type & LARGE)
+		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
+	if (type & LEFT)
+		type &= ~ZEROPAD;
+	if (base < 2 || base > 36)
+		return 0;
+	c = (type & ZEROPAD) ? '0' : ' ';
+	sign = 0;
+	if (type & SIGN) {
+		if (num < 0) {
+			sign = '-';
+			num = -num;
+			size--;
+		} else if (type & PLUS) {
+			sign = '+';
+			size--;
+		} else if (type & SPACE) {
+			sign = ' ';
+			size--;
+		}
+	}
+	if (type & SPECIAL) {
+		if (base == 16)
+			size -= 2;
+		else if (base == 8)
+			size--;
+	}
+	i = 0;
+	if (num == 0)
+		tmp[i++]='0';
+	else while (num != 0)
+		tmp[i++] = digits[do_div(num,base)];
+	if (i > precision)
+		precision = i;
+	size -= precision;
+	if (!(type&(ZEROPAD+LEFT)))
+		while(size-->0)
+			*str++ = ' ';
+	if (sign)
+		*str++ = sign;
+	if (type & SPECIAL) {
+		if (base==8)
+			*str++ = '0';
+		else if (base==16) {
+			*str++ = '0';
+			*str++ = digits[33];
+		}
+	}
+	if (!(type & LEFT))
+		while (size-- > 0)
+			*str++ = c;
+	while (i < precision--)
+		*str++ = '0';
+	while (i-- > 0)
+		*str++ = tmp[i];
+	while (size-- > 0)
+		*str++ = ' ';
+	return str;
+}
+
+/* Forward decl. needed for IP address printing stuff... */
+int sprintf(char * buf, const char *fmt, ...);
+
+int vsprintf(char *buf, const char *fmt, va_list args)
+{
+	int len;
+#ifdef CFG_64BIT_VSPRINTF
+	unsigned long long num;
+#else
+	unsigned long num;
+#endif
+	int i, base;
+	char * str;
+	const char *s;
+
+	int flags;		/* flags to number() */
+
+	int field_width;	/* width of output field */
+	int precision;		/* min. # of digits for integers; max
+				   number of chars for from string */
+	int qualifier;		/* 'h', 'l', or 'q' for integer fields */
+
+	for (str=buf ; *fmt ; ++fmt) {
+		if (*fmt != '%') {
+			*str++ = *fmt;
+			continue;
+		}
+
+		/* process flags */
+		flags = 0;
+		repeat:
+			++fmt;		/* this also skips first '%' */
+			switch (*fmt) {
+				case '-': flags |= LEFT; goto repeat;
+				case '+': flags |= PLUS; goto repeat;
+				case ' ': flags |= SPACE; goto repeat;
+				case '#': flags |= SPECIAL; goto repeat;
+				case '0': flags |= ZEROPAD; goto repeat;
+				}
+
+		/* get field width */
+		field_width = -1;
+		if (is_digit(*fmt))
+			field_width = skip_atoi(&fmt);
+		else if (*fmt == '*') {
+			++fmt;
+			/* it's the next argument */
+			field_width = va_arg(args, int);
+			if (field_width < 0) {
+				field_width = -field_width;
+				flags |= LEFT;
+			}
+		}
+
+		/* get the precision */
+		precision = -1;
+		if (*fmt == '.') {
+			++fmt;
+			if (is_digit(*fmt))
+				precision = skip_atoi(&fmt);
+			else if (*fmt == '*') {
+				++fmt;
+				/* it's the next argument */
+				precision = va_arg(args, int);
+			}
+			if (precision < 0)
+				precision = 0;
+		}
+
+		/* get the conversion qualifier */
+		qualifier = -1;
+		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'q') {
+			qualifier = *fmt;
+			++fmt;
+		}
+
+		/* default base */
+		base = 10;
+
+		switch (*fmt) {
+		case 'c':
+			if (!(flags & LEFT))
+				while (--field_width > 0)
+					*str++ = ' ';
+			*str++ = (unsigned char) va_arg(args, int);
+			while (--field_width > 0)
+				*str++ = ' ';
+			continue;
+
+		case 's':
+			s = va_arg(args, char *);
+			if (!s)
+				s = "<NULL>";
+
+			len = strnlen(s, precision);
+
+			if (!(flags & LEFT))
+				while (len < field_width--)
+					*str++ = ' ';
+			for (i = 0; i < len; ++i)
+				*str++ = *s++;
+			while (len < field_width--)
+				*str++ = ' ';
+			continue;
+
+		case 'p':
+			if (field_width == -1) {
+				field_width = 2*sizeof(void *);
+				flags |= ZEROPAD;
+			}
+			str = number(str,
+				(unsigned long) va_arg(args, void *), 16,
+				field_width, precision, flags);
+			continue;
+
+
+		case 'n':
+			if (qualifier == 'l') {
+				long * ip = va_arg(args, long *);
+				*ip = (str - buf);
+			} else {
+				int * ip = va_arg(args, int *);
+				*ip = (str - buf);
+			}
+			continue;
+
+		case '%':
+			*str++ = '%';
+			continue;
+
+		/* integer number formats - set up the flags and "break" */
+		case 'o':
+			base = 8;
+			break;
+
+		case 'X':
+			flags |= LARGE;
+		case 'x':
+			base = 16;
+			break;
+
+		case 'd':
+		case 'i':
+			flags |= SIGN;
+		case 'u':
+			break;
+
+		default:
+			*str++ = '%';
+			if (*fmt)
+				*str++ = *fmt;
+			else
+				--fmt;
+			continue;
+		}
+#ifdef CFG_64BIT_VSPRINTF
+		if (qualifier == 'q')  /* "quad" for 64 bit variables */
+			num = va_arg(args, unsigned long long);
+		else
+#endif
+		if (qualifier == 'l')
+			num = va_arg(args, unsigned long);
+		else if (qualifier == 'h') {
+			num = (unsigned short) va_arg(args, int);
+			if (flags & SIGN)
+				num = (short) num;
+		} else if (flags & SIGN)
+			num = va_arg(args, int);
+		else
+			num = va_arg(args, unsigned int);
+		str = number(str, num, base, field_width, precision, flags);
+	}
+	*str = '\0';
+	return str-buf;
+}
+
+int sprintf(char * buf, const char *fmt, ...)
+{
+	va_list args;
+	int i;
+
+	va_start(args, fmt);
+	i=vsprintf(buf,fmt,args);
+	va_end(args);
+	return i;
+}
+
+void panic(const char *fmt, ...)
+{
+	va_list	args;
+	va_start(args, fmt);
+	vprintf(fmt, args);
+	putc('\n');
+	va_end(args);
+#if defined (CONFIG_PANIC_HANG)
+	hang();
+#else
+	udelay (100000);	/* allow messages to go out */
+	do_reset (NULL, 0, 0, NULL);
+#endif
+}
diff --git a/lib_generic/LzmaDecode.c b/lib_generic/LzmaDecode.c
new file mode 100644
index 0000000000..99d1117701
--- /dev/null
+++ b/lib_generic/LzmaDecode.c
@@ -0,0 +1,600 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder (optimized for Speed version)
+  
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifdef CONFIG_LZMA
+
+#include "LzmaDecode.h"
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
+
+#ifdef _LZMA_IN_CB
+
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return result; } \
+  BufferLim = Buffer + size; if (size == 0) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return LZMA_RESULT_DATA_ERROR; } }}
+
+#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+
+#else
+
+#define RC_TEST { if (Buffer == BufferLim) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return LZMA_RESULT_DATA_ERROR; } }
+
+#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
+ 
+#endif
+
+#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi <<= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 << numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size < LZMA_PROPERTIES_SIZE)
+  {
+    printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  prop0 = propsData[0];
+  if (prop0 >= (9 * 5 * 5))
+  {
+    printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  {
+    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
+    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
+    propsRes->lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes->lc = prop0 % 9;
+    propsRes->pb = remainder / 5;
+    propsRes->lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes->DictionarySize = 0;
+    for (i = 0; i < 4; i++)
+      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
+    if (propsRes->DictionarySize == 0)
+      propsRes->DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs->Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+
+  #ifdef _LZMA_OUT_READ
+  
+  UInt32 Range = vs->Range;
+  UInt32 Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  const Byte *Buffer = vs->Buffer;
+  const Byte *BufferLim = vs->BufferLim;
+  #else
+  const Byte *Buffer = inStream;
+  const Byte *BufferLim = inStream + inSize;
+  #endif
+  int state = vs->State;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      #ifdef _LZMA_IN_CB
+      RC_INIT;
+      #else
+      RC_INIT(inStream, inSize);
+      #endif
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+    for (i = 0; i < numProbs; i++)
+      p[i] = kBitModelTotal >> 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  RC_INIT;
+  #else
+  RC_INIT(inStream, inSize);
+  #endif
+
+  #endif /* _LZMA_OUT_READ */
+
+  while(nowPos < outSize)
+  {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+
+    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        int matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol < 0x100);
+      }
+      while (symbol < 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (Byte)symbol;
+
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            UpdateBit0(prob);
+            
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+            {
+              printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+              return LZMA_RESULT_DATA_ERROR;
+            }
+            
+            state = state < kNumLitStates ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            #endif
+
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 <<= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range >>= 1;
+              rep0 <<= 1;
+              if (Code >= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 <<= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i <<= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 > distanceLimit) 
+      #else
+      if (rep0 > nowPos)
+      #endif
+      {
+        printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+        return LZMA_RESULT_DATA_ERROR;
+      }
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+  }
+  RC_NORMALIZE;
+
+  #ifdef _LZMA_OUT_READ
+  vs->Range = Range;
+  vs->Code = Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + (UInt32)nowPos;
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs->Buffer = Buffer;
+  vs->BufferLim = BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
+
+#endif /* CONFIG_LZMA */
diff --git a/lib_generic/LzmaDecode.h b/lib_generic/LzmaDecode.h
new file mode 100644
index 0000000000..2870eeb9c9
--- /dev/null
+++ b/lib_generic/LzmaDecode.h
@@ -0,0 +1,113 @@
+/* 
+  LzmaDecode.h
+  LZMA Decoder interface
+
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMADECODE_H
+#define __LZMADECODE_H
+
+#include "LzmaTypes.h"
+
+/* #define _LZMA_IN_CB */
+/* Use callback for input data */
+
+/* #define _LZMA_OUT_READ */
+/* Use read function for output data */
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_LOC_OPT */
+/* Enable local speed optimizations inside code */
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#ifdef _LZMA_IN_CB
+typedef struct _ILzmaInCallback
+{
+  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
+} ILzmaInCallback;
+#endif
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  #ifdef _LZMA_OUT_READ
+  UInt32 DictionarySize;
+  #endif
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((Properties)->lc + (Properties)->lp)))
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+
+  #ifdef _LZMA_IN_CB
+  const unsigned char *Buffer;
+  const unsigned char *BufferLim;
+  #endif
+
+  #ifdef _LZMA_OUT_READ
+  unsigned char *Dictionary;
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;
+  unsigned char TempDictionary[4];
+  #endif
+} CLzmaDecoderState;
+
+#ifdef _LZMA_OUT_READ
+#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; }
+#endif
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);
+
+#endif
diff --git a/lib_generic/LzmaTypes.h b/lib_generic/LzmaTypes.h
new file mode 100644
index 0000000000..288c5e45d7
--- /dev/null
+++ b/lib_generic/LzmaTypes.h
@@ -0,0 +1,45 @@
+/* 
+LzmaTypes.h 
+
+Types for LZMA Decoder
+
+This file written and distributed to public domain by Igor Pavlov.
+This file is part of LZMA SDK 4.40 (2006-05-01)
+*/
+
+#ifndef __LZMATYPES_H
+#define __LZMATYPES_H
+
+#ifndef _7ZIP_BYTE_DEFINED
+#define _7ZIP_BYTE_DEFINED
+typedef unsigned char Byte;
+#endif 
+
+#ifndef _7ZIP_UINT16_DEFINED
+#define _7ZIP_UINT16_DEFINED
+typedef unsigned short UInt16;
+#endif 
+
+#ifndef _7ZIP_UINT32_DEFINED
+#define _7ZIP_UINT32_DEFINED
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef unsigned long UInt32;
+#else
+typedef unsigned int UInt32;
+#endif
+#endif 
+
+/* #define _LZMA_SYSTEM_SIZE_T */
+/* Use system's size_t. You can use it to enable 64-bit sizes supporting */
+
+#ifndef _7ZIP_SIZET_DEFINED
+#define _7ZIP_SIZET_DEFINED
+#ifdef _LZMA_SYSTEM_SIZE_T
+#include <stddef.h>
+typedef size_t SizeT;
+#else
+typedef UInt32 SizeT;
+#endif
+#endif
+
+#endif
diff --git a/lib_generic/LzmaWrapper.c b/lib_generic/LzmaWrapper.c
new file mode 100644
index 0000000000..6c3d702461
--- /dev/null
+++ b/lib_generic/LzmaWrapper.c
@@ -0,0 +1,197 @@
+/******************************************************************************
+**
+** FILE NAME    : LzmaWrapper.c
+** PROJECT      : bootloader
+** MODULES      : U-boot
+**
+** DATE         : 2 Nov 2006
+** AUTHOR       : Lin Mars
+** DESCRIPTION  : LZMA decoder support for U-boot 1.1.5
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 2 Nov 2006   Lin Mars        init version which derived from LzmaTest.c from
+**                              LZMA v4.43 SDK
+*******************************************************************************/
+#define LZMA_NO_STDIO
+#ifndef LZMA_NO_STDIO
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#endif
+
+#include <config.h>
+#include <common.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <malloc.h>
+
+#ifdef CONFIG_LZMA
+
+#include "LzmaDecode.h"
+#include "LzmaWrapper.h"
+
+static const char *kCantReadMessage = "Can not read from source buffer";
+static const char *kCantAllocateMessage = "Not enough buffer for decompression";
+
+static size_t rpos=0, dpos=0;
+
+static int MyReadFileAndCheck(unsigned char *src, void *dest, size_t size)
+{
+  if (size == 0)
+    return 0;
+  memcpy(dest, src + rpos, size);
+  rpos += size;
+  return 1;
+}
+
+int lzma_inflate(unsigned char *source, int s_len, unsigned char *dest, int *d_len)
+{
+  /* We use two 32-bit integers to construct 64-bit integer for file size.
+     You can remove outSizeHigh, if you don't need >= 4GB supporting,
+     or you can use UInt64 outSize, if your compiler supports 64-bit integers*/
+  UInt32 outSize = 0;
+  UInt32 outSizeHigh = 0;
+  SizeT outSizeFull;
+  unsigned char *outStream;
+  
+  int waitEOS = 1; 
+  /* waitEOS = 1, if there is no uncompressed size in headers, 
+   so decoder will wait EOS (End of Stream Marker) in compressed stream */
+
+  SizeT compressedSize;
+  unsigned char *inStream;
+
+  CLzmaDecoderState state;  /* it's about 24-80 bytes structure, if int is 32-bit */
+  unsigned char properties[LZMA_PROPERTIES_SIZE];
+
+  int res;
+
+  if (sizeof(UInt32) < 4)
+  {
+    printf("LZMA decoder needs correct UInt32\n");
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  {
+    long length=s_len;
+    if ((long)(SizeT)length != length)
+    {
+      printf("Too big compressed stream\n");
+      return LZMA_RESULT_DATA_ERROR;
+    }
+    compressedSize = (SizeT)(length - (LZMA_PROPERTIES_SIZE + 8));
+  }
+
+  /* Read LZMA properties for compressed stream */
+
+  if (!MyReadFileAndCheck(source, properties, sizeof(properties)))
+  {
+    printf("%s\n", kCantReadMessage);
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  /* Read uncompressed size */
+  {
+    int i;
+    for (i = 0; i < 8; i++)
+    {
+      unsigned char b;
+      if (!MyReadFileAndCheck(source, &b, 1))
+      {
+        printf("%s\n", kCantReadMessage);
+        return LZMA_RESULT_DATA_ERROR;
+      }
+      if (b != 0xFF)
+        waitEOS = 0;
+      if (i < 4)
+        outSize += (UInt32)(b) << (i * 8);
+      else
+        outSizeHigh += (UInt32)(b) << ((i - 4) * 8);
+    }
+    
+    if (waitEOS)
+    {
+      printf("Stream with EOS marker is not supported");
+      return LZMA_RESULT_DATA_ERROR;
+    }
+    outSizeFull = (SizeT)outSize;
+    if (sizeof(SizeT) >= 8)
+      outSizeFull |= (((SizeT)outSizeHigh << 16) << 16);
+    else if (outSizeHigh != 0 || (UInt32)(SizeT)outSize != outSize)
+    {
+      printf("Too big uncompressed stream");
+      return LZMA_RESULT_DATA_ERROR;
+    }
+  }
+
+  /* Decode LZMA properties and allocate memory */
+  if (LzmaDecodeProperties(&state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK)
+  {
+    printf("Incorrect stream properties");
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  state.Probs = (CProb *)malloc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
+
+  if (outSizeFull == 0)
+    outStream = 0;
+  else
+  {
+    if (outSizeFull > d_len)
+      outStream = 0;
+    else
+      outStream = dest;
+  }
+
+  if (compressedSize == 0)
+    inStream = 0;
+  else
+  {
+    if ((compressedSize+rpos) > s_len )
+      inStream = 0;
+    else
+      inStream = source + rpos;
+  }
+
+  if (state.Probs == 0 
+    || (outStream == 0 && outSizeFull != 0)
+    || (inStream == 0 && compressedSize != 0)
+    )
+  {
+    free(state.Probs);
+    printf("%s\n", kCantAllocateMessage);
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  /* Decompress */
+  {
+    SizeT inProcessed;
+    SizeT outProcessed;
+    res = LzmaDecode(&state,
+      inStream, compressedSize, &inProcessed,
+      outStream, outSizeFull, &outProcessed);
+    if (res != 0)
+    {
+      printf("\nDecoding error = %d\n", res);
+      res = 1;
+    }
+    else
+    {
+      *d_len = outProcessed;
+    }
+  }
+
+  free(state.Probs);
+  return res;
+}
+
+#endif /* CONFIG_LZMA */
diff --git a/lib_generic/Makefile b/lib_generic/Makefile
index 18c41b1bd9..b72f2c0ff2 100644
--- a/lib_generic/Makefile
+++ b/lib_generic/Makefile
@@ -25,10 +25,18 @@ include $(TOPDIR)/config.mk
 
 LIB	= libgeneric.a
 
+ifeq ($(COMPRESSED_UBOOT),1)
+OBJS    = crc32.o ctype.o display_options.o ldiv.o \
+			string.o vsprintf.o LzmaWrapper.o LzmaDecode.o
+else
 OBJS	= bzlib.o bzlib_crctable.o bzlib_decompress.o \
 	  bzlib_randtable.o bzlib_huffman.o \
 	  crc32.o ctype.o display_options.o ldiv.o \
-	  string.o vsprintf.o zlib.o
+	  string.o vsprintf.o zlib.o LzmaDecode.o LzmaWrapper.o
+endif
+
+CFLAGS += -DCONFIG_LZMA=1
+
 
 $(LIB):	.depend $(OBJS)
 	$(AR) crv $@ $(OBJS)
diff --git a/lib_generic/zlib.c b/lib_generic/zlib.c
index 668ac8f808..dfbc500db7 100644
--- a/lib_generic/zlib.c
+++ b/lib_generic/zlib.c
@@ -2101,7 +2101,9 @@ z_stream *z;
 
 /* From: zutil.c,v 1.8 1995/05/03 17:27:12 jloup Exp */
 
+#ifndef COMPRESSED_UBOOT
 char *zlib_version = ZLIB_VERSION;
+#endif
 
 char *z_errmsg[] = {
 "stream end",          /* Z_STREAM_END    1 */
diff --git a/lib_mips/board.c b/lib_mips/board.c
index b7d335641a..43d5f6a224 100644
--- a/lib_mips/board.c
+++ b/lib_mips/board.c
@@ -45,13 +45,25 @@ extern int timer_init(void);
 
 extern int incaip_set_cpuclk(void);
 
+#if defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x)
+void ath_set_tuning_caps(void);
+#else
+#define ath_set_tuning_caps()	/* nothing */
+#endif
+
+
 extern ulong uboot_end_data;
 extern ulong uboot_end;
 
 ulong monitor_flash_len;
 
+#ifdef BUILD_VERSION
+const char version_string[] =
+        U_BOOT_VERSION" (Build from LSDK-" BUILD_VERSION " at " __DATE__ " - " __TIME__ ")";
+#else
 const char version_string[] =
 	U_BOOT_VERSION" (" __DATE__ " - " __TIME__ ")";
+#endif        
 
 static char *failed = "*** failed ***\n";
 
@@ -113,6 +125,7 @@ static int display_banner(void)
 {
 
 	printf ("\n\n%s\n\n", version_string);
+
 	return (0);
 }
 
@@ -159,17 +172,23 @@ static int init_baudrate (void)
 typedef int (init_fnc_t) (void);
 
 init_fnc_t *init_sequence[] = {
+#ifndef COMPRESSED_UBOOT
 	timer_init,
+#endif
 	env_init,		/* initialize environment */
 #ifdef CONFIG_INCA_IP
 	incaip_set_cpuclk,	/* set cpu clock according to environment variable */
 #endif
 	init_baudrate,		/* initialze baudrate settings */
+#ifndef COMPRESSED_UBOOT
 	serial_init,		/* serial communications setup */
+#endif
 	console_init_f,
 	display_banner,		/* say that we are here */
+#ifndef COMPRESSED_UBOOT
 	checkboard,
-	init_func_ram,
+    init_func_ram,
+#endif
 	NULL,
 };
 
@@ -181,10 +200,14 @@ void board_init_f(ulong bootflag)
 	init_fnc_t **init_fnc_ptr;
 	ulong addr, addr_sp, len = (ulong)&uboot_end - CFG_MONITOR_BASE;
 	ulong *s;
+#ifdef COMPRESSED_UBOOT
+    char board_string[50];
+#endif
 #ifdef CONFIG_PURPLE
 	void copy_code (ulong);
 #endif
 
+
 	/* Pointer is writable since we allocated a register for it.
 	 */
 	gd = &gd_data;
@@ -199,6 +222,14 @@ void board_init_f(ulong bootflag)
 		}
 	}
 
+#ifdef COMPRESSED_UBOOT
+    checkboard(board_string);
+    printf("%s\n\n",board_string);
+    gd->ram_size = bootflag;
+	puts ("DRAM:	");
+	print_size (gd->ram_size, "\n");
+#endif
+
 	/*
 	 * Now that we have DRAM mapped and working, we can
 	 * relocate the code and continue running from DRAM.
@@ -300,6 +331,9 @@ void board_init_r (gd_t *id, ulong dest_addr)
 	extern void malloc_bin_reloc (void);
 #ifndef CFG_ENV_IS_NOWHERE
 	extern char * env_name_spec;
+#endif
+#ifdef CONFIG_ATH_NAND_SUPPORT
+	extern ulong ath_nand_init(void);
 #endif
 	char *s, *e;
 	bd_t *bd;
@@ -347,9 +381,11 @@ void board_init_r (gd_t *id, ulong dest_addr)
 	env_name_spec += gd->reloc_off;
 #endif
 
+#ifndef CONFIG_ATH_NAND_BR
 	/* configure available FLASH banks */
 	size = flash_init();
 	display_flash_config (size);
+#endif
 
 	bd = gd->bd;
 	bd->bi_flashstart = CFG_FLASH_BASE;
@@ -364,6 +400,10 @@ void board_init_r (gd_t *id, ulong dest_addr)
 	mem_malloc_init();
 	malloc_bin_reloc();
 
+#ifdef CONFIG_ATH_NAND_BR
+	ath_nand_init();
+#endif
+
 	/* relocate environment function pointers etc. */
 	env_relocate();
 
@@ -417,6 +457,12 @@ void board_init_r (gd_t *id, ulong dest_addr)
 	eth_initialize(gd->bd);
 #endif
 
+#if defined(CONFIG_ATH_NAND_SUPPORT) && !defined(CONFIG_ATH_NAND_BR)
+	ath_nand_init();
+#endif
+
+        ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */
+
 	/* main_loop() can return to retry autoboot, if so just run it again. */
 	for (;;) {
 		main_loop ();
diff --git a/lib_mips/mips_linux.c b/lib_mips/mips_linux.c
index 952d5a90ee..85f683e717 100644
--- a/lib_mips/mips_linux.c
+++ b/lib_mips/mips_linux.c
@@ -28,6 +28,9 @@
 #include <asm/byteorder.h>
 #include <asm/addrspace.h>
 
+#ifdef CONFIG_AR7240
+#include <ar7240_soc.h>
+#endif
 DECLARE_GLOBAL_DATA_PTR;
 
 #define	LINUX_MAX_ENVS		256
@@ -54,6 +57,18 @@ static int	linux_env_idx;
 static void linux_params_init (ulong start, char * commandline);
 static void linux_env_set (char * env_name, char * env_val);
 
+#ifdef CONFIG_WASP_SUPPORT
+void wasp_set_cca(void)
+{
+	/* set cache coherency attribute */
+	asm(	"mfc0	$t0,	$16\n"		/* CP0_CONFIG == 16 */
+		"li	$t1,	~7\n"
+		"and	$t0,	$t0,	$t1\n"
+		"ori	$t0,	3\n"		/* CONF_CM_CACHABLE_NONCOHERENT */
+		"mtc0	$t0,	$16\n"		/* CP0_CONFIG == 16 */
+		"nop\n": : );
+}
+#endif
 
 void do_bootm_linux (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[],
 		     ulong addr, ulong * len_ptr, int verify)
@@ -61,13 +76,25 @@ void do_bootm_linux (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[],
 	ulong len = 0, checksum;
 	ulong initrd_start, initrd_end;
 	ulong data;
+	ulong mem_size_to_kernel;
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
+	int flash_size_mbytes;
+	void (*theKernel) (int, char **, char **, int);
+#else
 	void (*theKernel) (int, char **, char **, int *);
+#endif
 	image_header_t *hdr = &header;
 	char *commandline = getenv ("bootargs");
 	char env_buf[12];
 
+
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
+	theKernel =
+		(void (*)(int, char **, char **, int)) ntohl (hdr->ih_ep);
+#else
 	theKernel =
 		(void (*)(int, char **, char **, int *)) ntohl (hdr->ih_ep);
+#endif
 
 	/*
 	 * Check if there is an initrd image
@@ -213,12 +240,28 @@ void do_bootm_linux (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[],
 	/* we assume that the kernel is in place */
 	printf ("\nStarting kernel ...\n\n");
 
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
+#ifdef CONFIG_WASP_SUPPORT
+	wasp_set_cca();
+#endif
+	/* Pass the flash size as expected by current Linux kernel for AR7100 */
+	flash_size_mbytes = gd->bd->bi_flashsize/(1024 * 1024);
+    /* as the same, we pass the Memsize to kernel
+     * uboot can auto search mem to set memsize,so this memsize is right
+     * ZJin, 2011.07.18
+     */
+    mem_size_to_kernel = gd->ram_size;
+	theKernel (linux_argc, linux_argv, mem_size_to_kernel, flash_size_mbytes);
+	/* theKernel (linux_argc, linux_argv, linux_env, flash_size_mbytes); */
+#else
 	theKernel (linux_argc, linux_argv, linux_env, 0);
+#endif
 }
 
 static void linux_params_init (ulong start, char *line)
 {
 	char *next, *quote, *argp;
+	char memstr[32];
 
 	linux_argc = 1;
 	linux_argv = (char **) start;
@@ -227,6 +270,12 @@ static void linux_params_init (ulong start, char *line)
 
 	next = line;
 
+	if (strstr(line, "mem=")) {
+		memstr[0] = 0;
+	} else {
+		memstr[0] = 1;
+	}
+
 	while (line && *line && linux_argc < LINUX_MAX_ARGS) {
 		quote = strchr (line, '"');
 		next = strchr (line, ' ');
@@ -249,6 +298,18 @@ static void linux_params_init (ulong start, char *line)
 		linux_argv[linux_argc] = argp;
 		memcpy (argp, line, next - line);
 		argp[next - line] = 0;
+#if defined(CONFIG_AR7240)
+#define REVSTR	"REVISIONID"
+#define PYTHON	"python"
+#define VIRIAN	"virian"
+		if (strcmp(argp, REVSTR) == 0) {
+			if (is_ar7241() || is_ar7242()) {
+				strcpy(argp, VIRIAN);
+			} else {
+				strcpy(argp, PYTHON);
+			}
+		}
+#endif
 
 		argp += next - line + 1;
 		linux_argc++;
@@ -259,6 +320,17 @@ static void linux_params_init (ulong start, char *line)
 		line = next;
 	}
 
+#if defined(CONFIG_AR9100) || defined(CONFIG_AR7240) || defined(CONFIG_ATHEROS)
+	/* Add mem size to command line */
+	if (memstr[0]) {
+		sprintf(memstr, "mem=%luM", gd->ram_size >> 20);
+		memcpy (argp, memstr, strlen(memstr)+1);
+		linux_argv[linux_argc] = argp;
+		linux_argc++;
+		argp += strlen(memstr) + 1;
+	}
+#endif
+
 	linux_env = (char **) (((ulong) argp + 15) & ~15);
 	linux_env[0] = 0;
 	linux_env_p = (char *) (linux_env + LINUX_MAX_ENVS);
diff --git a/mips_config.mk b/mips_config.mk
index d8aa5fa777..c7c407caaf 100644
--- a/mips_config.mk
+++ b/mips_config.mk
@@ -22,3 +22,7 @@
 #
 
 PLATFORM_CPPFLAGS += -DCONFIG_MIPS -D__MIPS__
+
+ifeq ($(FLASH_TYPE),S25FL128P)
+   PLATFORM_CPPFLAGS += -D$(FLASH_TYPE)
+endif
diff --git a/net/Makefile b/net/Makefile
index 7a704898c2..683686060f 100644
--- a/net/Makefile
+++ b/net/Makefile
@@ -26,8 +26,12 @@ include $(TOPDIR)/config.mk
 # CFLAGS += -DET_DEBUG -DDEBUG
 
 LIB	= libnet.a
-
+ifeq ($(COMPRESSED_UBOOT),1)
+OBJS	= net.o tftp.o rarp.o eth.o
+else
 OBJS	= net.o tftp.o bootp.o rarp.o eth.o nfs.o sntp.o
+endif
+
 all:	$(LIB)
 
 $(LIB):	$(START) $(OBJS)
diff --git a/net/eth.c b/net/eth.c
index 9341e20e95..4eebc6da88 100644
--- a/net/eth.c
+++ b/net/eth.c
@@ -231,6 +231,15 @@ int eth_initialize(bd_t *bis)
 #if defined(CONFIG_RTL8169)
 	rtl8169_initialize(bis);
 #endif
+#if defined(CONFIG_AR7100)
+	ag7100_enet_initialize(bis);
+#endif
+#if defined(CONFIG_AR7240)
+	ag7240_enet_initialize(bis);
+#endif
+#if defined(CONFIG_ATHEROS) && !defined(CONFIG_ATH_EMULATION)
+	ath_gmac_enet_initialize(bis);
+#endif
 
 	if (!eth_devices) {
 		puts ("No ethernet found.\n");
@@ -258,6 +267,7 @@ int eth_initialize(bd_t *bis)
 					tmp = (*end) ? end+1 : end;
 			}
 
+#if !defined(CONFIG_AR9100) && !defined(CONFIG_AR7240) && !defined(CONFIG_ATHEROS)
 			if (memcmp(env_enetaddr, "\0\0\0\0\0\0", 6)) {
 				if (memcmp(dev->enetaddr, "\0\0\0\0\0\0", 6) &&
 				    memcmp(dev->enetaddr, env_enetaddr, 6))
@@ -278,6 +288,7 @@ int eth_initialize(bd_t *bis)
 
 				memcpy(dev->enetaddr, env_enetaddr, 6);
 			}
+#endif
 
 			eth_number++;
 			dev = dev->next;
@@ -343,8 +354,9 @@ int eth_init(bd_t *bis)
 
 	old_current = eth_current;
 	do {
+#if !defined(CFG_ATHRS26_PHY) && !defined(CFG_ATHRHDR_EN)
 		debug ("Trying %s\n", eth_current->name);
-
+#endif
 		if (eth_current->init(eth_current, bis)) {
 			eth_current->state = ETH_STATE_ACTIVE;
 
diff --git a/net/net.c b/net/net.c
index 1d1c98f3c2..c495a2b3eb 100644
--- a/net/net.c
+++ b/net/net.c
@@ -155,6 +155,9 @@ IPaddr_t	NetPingIP;		/* the ip address to ping 		*/
 
 static void PingStart(void);
 #endif
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+extern void athr_hdr_func(void);
+#endif
 
 #if (CONFIG_COMMANDS & CFG_CMD_CDP)
 static void CDPStart(void);
@@ -269,6 +272,9 @@ int
 NetLoop(proto_t protocol)
 {
 	bd_t *bd = gd->bd;
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+	static int AthrHdr_Flag = 0;
+#endif
 
 #ifdef CONFIG_NET_MULTI
 	NetRestarted = 0;
@@ -300,15 +306,41 @@ NetLoop(proto_t protocol)
 		NetArpWaitTxPacket -= (ulong)NetArpWaitTxPacket % PKTALIGN;
 		NetArpWaitTxPacketSize = 0;
 	}
-
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+	if(!AthrHdr_Flag) {
+	        eth_halt();
+		if (eth_init(bd) < 0) {
+            	    eth_halt();
+               	 return(-1);
+        	}
+		AthrHdr_Flag = 1;
+	}
+#else
 	eth_halt();
 #ifdef CONFIG_NET_MULTI
+#if defined(CFG_VITESSE_73XX_NOPHY) || defined(CFG_REH132) || defined (CONFIG_AG7240_SPEPHY)
+	/*
+	 * There is no PHY in the DNI AP83 board with vitesse switch
+	 * VSC7395XYV, so set the eth1 interface to switch ports, so
+	 * that u-boot can route all the traffic through the switch
+	 * ports.
+	 */
+	 /*
+	 * ag7240 uses eth1 as LAN and eth0 as WAN in uboot
+	 * because GE0 is MIDO server which must initialize first
+	 * modified by tiger 07/20/09
+	 */
+	setenv("ethact", "eth1");
+#else
+        setenv("ethact", "eth0");
+#endif
 	eth_set_current();
 #endif
 	if (eth_init(bd) < 0) {
 		eth_halt();
 		return(-1);
 	}
+#endif
 
 restart:
 #ifdef CONFIG_NET_MULTI
@@ -380,9 +412,18 @@ restart:
 		NetOurVLAN = getenv_VLAN("vlan");	/* VLANs must be read */
 		NetOurNativeVLAN = getenv_VLAN("nvlan");
 		break;
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+	case ATHRHDR:
+		athr_hdr_func();
+		break;
+#endif
 	default:
 		break;
 	}
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+	if(protocol == ATHRHDR)
+		goto skip_netloop;
+#endif
 
 	switch (net_check_prereq (protocol)) {
 	case 1:
@@ -415,7 +456,7 @@ restart:
 			DhcpRequest();		/* Basically same as BOOTP */
 			break;
 #endif /* CFG_CMD_DHCP */
-
+#ifndef COMPRESSED_UBOOT
 		case BOOTP:
 			BootpTry = 0;
 			BootpRequest ();
@@ -425,11 +466,13 @@ restart:
 			RarpTry = 0;
 			RarpRequest ();
 			break;
+#endif
 #if (CONFIG_COMMANDS & CFG_CMD_PING)
 		case PING:
 			PingStart();
 			break;
 #endif
+
 #if (CONFIG_COMMANDS & CFG_CMD_NFS)
 		case NFS:
 			NfsStart();
@@ -475,6 +518,7 @@ restart:
 	 *	Main packet reception loop.  Loop receiving packets until
 	 *	someone sets `NetState' to a state that terminates.
 	 */
+skip_netloop:
 	for (;;) {
 		WATCHDOG_RESET();
 #ifdef CONFIG_SHOW_ACTIVITY
@@ -497,8 +541,12 @@ restart:
 			puts ("\nAbort\n");
 			return (-1);
 		}
-
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+                if(protocol != ATHRHDR)
+			ArpTimeoutCheck();
+#else
 		ArpTimeoutCheck();
+#endif
 
 		/*
 		 *	Check for a timeout, and run the timeout handler
@@ -506,7 +554,7 @@ restart:
 		 */
 		if (timeHandler && ((get_timer(0) - timeStart) > timeDelta)) {
 			thand_f *x;
-
+#if !defined(CFG_ATHRS26_PHY) && !defined(CFG_ATHRHDR_EN)
 #if defined(CONFIG_MII) || (CONFIG_COMMANDS & CFG_CMD_MII)
 #  if defined(CFG_FAULT_ECHO_LINK_DOWN) && \
       defined(CONFIG_STATUS_LED) &&	   \
@@ -521,12 +569,11 @@ restart:
 			}
 #  endif /* CFG_FAULT_ECHO_LINK_DOWN, ... */
 #endif /* CONFIG_MII, ... */
+#endif
 			x = timeHandler;
 			timeHandler = (thand_f *)0;
 			(*x)();
 		}
-
-
 		switch (NetState) {
 
 		case NETLOOP_RESTART:
@@ -536,11 +583,17 @@ restart:
 			goto restart;
 
 		case NETLOOP_SUCCESS:
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+			if(protocol == ATHRHDR)
+				return 1;
+#endif
+
 			if (NetBootFileXferSize > 0) {
 				char buf[10];
 				printf("Bytes transferred = %ld (%lx hex)\n",
 					NetBootFileXferSize,
 					NetBootFileXferSize);
+
 				sprintf(buf, "%lx", NetBootFileXferSize);
 				setenv("filesize", buf);
 
@@ -572,6 +625,13 @@ startAgainHandler(uchar * pkt, unsigned dest, unsigned src, unsigned len)
 
 void NetStartAgain (void)
 {
+#ifdef FW_RECOVERY
+	extern ushort fw_recovery;
+
+	if(fw_recovery != 0)
+		return;
+#endif
+	
 	char *nretry;
 	int noretry = 0, once = 0;
 
@@ -770,7 +830,14 @@ static void PingStart(void)
 #if defined(CONFIG_NET_MULTI)
 	printf ("Using %s device\n", eth_get_name());
 #endif	/* CONFIG_NET_MULTI */
+
+#ifndef TPWD_FOR_LINUX_CAL
 	NetSetTimeout (10 * CFG_HZ, PingTimeout);
+#else
+	/* shorten ping timeout.  by HouXB, 01Feb13 */
+	NetSetTimeout (CFG_HZ, PingTimeout);
+#endif
+
 	NetSetHandler (PingHandler);
 
 	PingSend();
@@ -1140,6 +1207,9 @@ NetReceive(volatile uchar * inpkt, int len)
 	IPaddr_t tmp;
 	int	x;
 	uchar *pkt;
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+        uint8_t type;
+#endif
 #if (CONFIG_COMMANDS & CFG_CMD_CDP)
 	int iscdp;
 #endif
@@ -1149,9 +1219,26 @@ NetReceive(volatile uchar * inpkt, int len)
 	printf("packet received\n");
 #endif
 
-	NetRxPkt = inpkt;
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+	type = (inpkt[1] & 0xf);
+	/* check for ack */
+       if(type == 0x6){
+               (*packetHandler)(inpkt,0,0,0);
+		return;
+	}
+	else if (type == 0x0) {
+	   inpkt = inpkt + ATHRHDR_LEN;  /* Remove ATHRHDR */
+	   len = len - ATHRHDR_LEN;
+	}
+	else{
+		printf("Packet dropped! Type invalid.\n");
+		return;
+	}
+#endif
+
+        NetRxPkt = inpkt;
 	NetRxPktLen = len;
-	et = (Ethernet_t *)inpkt;
+        et = (Ethernet_t *)inpkt;
 
 	/* too small packet? */
 	if (len < ETHER_HDR_SIZE)
diff --git a/net/tftp.c b/net/tftp.c
index eca21d294e..3b1b88a8f0 100644
--- a/net/tftp.c
+++ b/net/tftp.c
@@ -15,9 +15,9 @@
 #if (CONFIG_COMMANDS & CFG_CMD_NET)
 
 #define WELL_KNOWN_PORT	69		/* Well known TFTP port #		*/
-#define TIMEOUT		5		/* Seconds to timeout for a lost pkt	*/
+#define TIMEOUT		2		/* Seconds to timeout for a lost pkt	*/
 #ifndef	CONFIG_NET_RETRY_COUNT
-# define TIMEOUT_COUNT	10		/* # of timeouts before giving up  */
+# define TIMEOUT_COUNT	3		/* # of timeouts before giving up  */
 #else
 # define TIMEOUT_COUNT  (CONFIG_NET_RETRY_COUNT * 2)
 #endif
@@ -267,6 +267,8 @@ TftpHandler (uchar * pkt, unsigned dest, unsigned src, unsigned len)
 
 		TftpLastBlock = TftpBlock;
 		NetSetTimeout (TIMEOUT * CFG_HZ, TftpTimeout);
+		if(TftpTimeoutCount)
+			TftpTimeoutCount = 0;
 
 		store_block (TftpBlock - 1, pkt + 2, len);
 
@@ -295,12 +297,25 @@ TftpHandler (uchar * pkt, unsigned dest, unsigned src, unsigned len)
 	}
 }
 
+extern int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+
+#ifdef FW_RECOVERY
+extern ushort fw_recovery;
+#endif
 
 static void
 TftpTimeout (void)
 {
 	if (++TftpTimeoutCount > TIMEOUT_COUNT) {
 		puts ("\nRetry count exceeded; starting again\n");
+		
+#ifdef FW_RECOVERY
+		if(fw_recovery) {
+			load_addr = simple_strtoul("9f020000", NULL, 16);
+			do_bootm(NULL, 0, 0, NULL);
+		}
+#endif
+
 		NetStartAgain ();
 	} else {
 		puts ("T ");
diff --git a/tools/crc32.c b/tools/crc32.c
new file mode 120000
index 0000000000..be36f5c9b5
--- /dev/null
+++ b/tools/crc32.c
@@ -0,0 +1 @@
+../lib_generic/crc32.c
\ No newline at end of file
diff --git a/tools/environment.c b/tools/environment.c
new file mode 120000
index 0000000000..c67bdde764
--- /dev/null
+++ b/tools/environment.c
@@ -0,0 +1 @@
+../common/environment.c
\ No newline at end of file
diff --git a/tools/mkimage.c b/tools/mkimage.c
index 5222bb21a5..9d15a50018 100644
--- a/tools/mkimage.c
+++ b/tools/mkimage.c
@@ -137,6 +137,7 @@ table_entry_t comp_name[] = {
     {	IH_COMP_NONE,	"none",		"uncompressed",		},
     {	IH_COMP_BZIP2,	"bzip2",	"bzip2 compressed",	},
     {	IH_COMP_GZIP,	"gzip",		"gzip compressed",	},
+    {   IH_COMP_LZMA,   "lzma",         "lzma compressed",      },
     {	-1,		"",		"",			},
 };
 
-- 
2.43.0

